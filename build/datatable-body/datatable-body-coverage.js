if (typeof _yuitest_coverage == "undefined"){
    _yuitest_coverage = {};
    _yuitest_coverline = function(src, line){
        var coverage = _yuitest_coverage[src];
        if (!coverage.lines[line]){
            coverage.calledLines++;
        }
        coverage.lines[line]++;
    };
    _yuitest_coverfunc = function(src, name, line){
        var coverage = _yuitest_coverage[src],
            funcId = name + ":" + line;
        if (!coverage.functions[funcId]){
            coverage.calledFunctions++;
        }
        coverage.functions[funcId]++;
    };
}
_yuitest_coverage["build/datatable-body/datatable-body.js"] = {
    lines: {},
    functions: {},
    coveredLines: 0,
    calledLines: 0,
    coveredFunctions: 0,
    calledFunctions: 0,
    path: "build/datatable-body/datatable-body.js",
    code: []
};
_yuitest_coverage["build/datatable-body/datatable-body.js"].code=["YUI.add('datatable-body', function (Y, NAME) {","","/**","View class responsible for rendering the `<tbody>` section of a table. Used as","the default `bodyView` for `Y.DataTable.Base` and `Y.DataTable` classes.","","@module datatable","@submodule datatable-body","@since 3.5.0","**/","var Lang         = Y.Lang,","    isArray      = Lang.isArray,","    isNumber     = Lang.isNumber,","    isString     = Lang.isString,","    fromTemplate = Lang.sub,","    htmlEscape   = Y.Escape.html,","    toArray      = Y.Array,","    bind         = Y.bind,","    YObject      = Y.Object,","    valueRegExp  = /\\{value\\}/g;","","/**","View class responsible for rendering the `<tbody>` section of a table. Used as","the default `bodyView` for `Y.DataTable.Base` and `Y.DataTable` classes.","","Translates the provided `modelList` into a rendered `<tbody>` based on the data","in the constituent Models, altered or amended by any special column","configurations.","","The `columns` configuration, passed to the constructor, determines which","columns will be rendered.","","The rendering process involves constructing an HTML template for a complete row","of data, built by concatenating a customized copy of the instance's","`CELL_TEMPLATE` into the `ROW_TEMPLATE` once for each column.  This template is","then populated with values from each Model in the `modelList`, aggregating a","complete HTML string of all row and column data.  A `<tbody>` Node is then created from the markup and any column `nodeFormatter`s are applied.","","Supported properties of the column objects include:","","  * `key` - Used to link a column to an attribute in a Model.","  * `name` - Used for columns that don't relate to an attribute in the Model","    (`formatter` or `nodeFormatter` only) if the implementer wants a","    predictable name to refer to in their CSS.","  * `cellTemplate` - Overrides the instance's `CELL_TEMPLATE` for cells in this","    column only.","  * `formatter` - Used to customize or override the content value from the","    Model.  These do not have access to the cell or row Nodes and should","    return string (HTML) content.","  * `nodeFormatter` - Used to provide content for a cell as well as perform any","    custom modifications on the cell or row Node that could not be performed by","    `formatter`s.  Should be used sparingly for better performance.","  * `emptyCellValue` - String (HTML) value to use if the Model data for a","    column, or the content generated by a `formatter`, is the empty string,","    `null`, or `undefined`.","  * `allowHTML` - Set to `true` if a column value, `formatter`, or","    `emptyCellValue` can contain HTML.  This defaults to `false` to protect","    against XSS.","  * `className` - Space delimited CSS classes to add to all `<td>`s in a column.","","A column `formatter` can be:","","  * a function, as described below.","  * a string which can be:","      * the name of a pre-defined formatter function","        which can be located in the `Y.DataTable.BodyView.Formatters` hash using the","        value of the `formatter` property as the index.","      * A template that can use the `{value}` placeholder to include the value","        for the current cell or the name of any field in the underlaying model","        also enclosed in curly braces.  Any number and type of these placeholders","        can be used.","","Column `formatter`s are passed an object (`o`) with the following properties:","","  * `value` - The current value of the column's associated attribute, if any.","  * `data` - An object map of Model keys to their current values.","  * `record` - The Model instance.","  * `column` - The column configuration object for the current column.","  * `className` - Initially empty string to allow `formatter`s to add CSS","    classes to the cell's `<td>`.","  * `rowIndex` - The zero-based row number.","  * `rowClass` - Initially empty string to allow `formatter`s to add CSS","    classes to the cell's containing row `<tr>`.","","They may return a value or update `o.value` to assign specific HTML content.  A","returned value has higher precedence.","","Column `nodeFormatter`s are passed an object (`o`) with the following","properties:","","  * `value` - The current value of the column's associated attribute, if any.","  * `td` - The `<td>` Node instance.","  * `cell` - The `<div>` liner Node instance if present, otherwise, the `<td>`.","    When adding content to the cell, prefer appending into this property.","  * `data` - An object map of Model keys to their current values.","  * `record` - The Model instance.","  * `column` - The column configuration object for the current column.","  * `rowIndex` - The zero-based row number.","","They are expected to inject content into the cell's Node directly, including","any \"empty\" cell content.  Each `nodeFormatter` will have access through the","Node API to all cells and rows in the `<tbody>`, but not to the `<table>`, as","it will not be attached yet.","","If a `nodeFormatter` returns `false`, the `o.td` and `o.cell` Nodes will be","`destroy()`ed to remove them from the Node cache and free up memory.  The DOM","elements will remain as will any content added to them.  _It is highly","advisable to always return `false` from your `nodeFormatter`s_.","","@class BodyView","@namespace DataTable","@extends View","@since 3.5.0","**/","Y.namespace('DataTable').BodyView = Y.Base.create('tableBody', Y.View, [], {","    // -- Instance properties -------------------------------------------------","","    /**","    HTML template used to create table cells.","","    @property CELL_TEMPLATE","    @type {HTML}","    @default '<td {headers} class=\"{className}\">{content}</td>'","    @since 3.5.0","    **/","    CELL_TEMPLATE: '<td {headers} class=\"{className}\">{content}</td>',","","    /**","    CSS class applied to even rows.  This is assigned at instantiation.","","    For DataTable, this will be `yui3-datatable-even`.","","    @property CLASS_EVEN","    @type {String}","    @default 'yui3-table-even'","    @since 3.5.0","    **/","    //CLASS_EVEN: null","","    /**","    CSS class applied to odd rows.  This is assigned at instantiation.","","    When used by DataTable instances, this will be `yui3-datatable-odd`.","","    @property CLASS_ODD","    @type {String}","    @default 'yui3-table-odd'","    @since 3.5.0","    **/","    //CLASS_ODD: null","","    /**","    HTML template used to create table rows.","","    @property ROW_TEMPLATE","    @type {HTML}","    @default '<tr id=\"{rowId}\" data-yui3-record=\"{clientId}\" class=\"{rowClass}\">{content}</tr>'","    @since 3.5.0","    **/","    ROW_TEMPLATE : '<tr id=\"{rowId}\" data-yui3-record=\"{clientId}\" class=\"{rowClass}\">{content}</tr>',","","    /**","    The object that serves as the source of truth for column and row data.","    This property is assigned at instantiation from the `host` property of","    the configuration object passed to the constructor.","","    @property host","    @type {Object}","    @default (initially unset)","    @since 3.5.0","    **/","    //TODO: should this be protected?","    //host: null,","","    /**","    HTML templates used to create the `<tbody>` containing the table rows.","","    @property TBODY_TEMPLATE","    @type {HTML}","    @default '<tbody class=\"{className}\">{content}</tbody>'","    @since 3.6.0","    **/","    TBODY_TEMPLATE: '<tbody class=\"{className}\"></tbody>',","","    // -- Public methods ------------------------------------------------------","","    /**","    Returns the `<td>` Node from the given row and column index.  Alternately,","    the `seed` can be a Node.  If so, the nearest ancestor cell is returned.","    If the `seed` is a cell, it is returned.  If there is no cell at the given","    coordinates, `null` is returned.","","    Optionally, include an offset array or string to return a cell near the","    cell identified by the `seed`.  The offset can be an array containing the","    number of rows to shift followed by the number of columns to shift, or one","    of \"above\", \"below\", \"next\", or \"previous\".","","    <pre><code>// Previous cell in the previous row","    var cell = table.getCell(e.target, [-1, -1]);","","    // Next cell","    var cell = table.getCell(e.target, 'next');","    var cell = table.getCell(e.target, [0, 1];</pre></code>","","    @method getCell","    @param {Number[]|Node} seed Array of row and column indexes, or a Node that","        is either the cell itself or a descendant of one.","    @param {Number[]|String} [shift] Offset by which to identify the returned","        cell Node","    @return {Node}","    @since 3.5.0","    **/","    getCell: function (seed, shift) {","        var tbody = this.tbodyNode,","            row, cell, index, rowIndexOffset;","","        if (seed && tbody) {","            if (isArray(seed)) {","                row = tbody.get('children').item(seed[0]);","                cell = row && row.get('children').item(seed[1]);","            } else if (Y.instanceOf(seed, Y.Node)) {","                cell = seed.ancestor('.' + this.getClassName('cell'), true);","            }","","            if (cell && shift) {","                rowIndexOffset = tbody.get('firstChild.rowIndex');","                if (isString(shift)) {","                    // TODO this should be a static object map","                    switch (shift) {","                        case 'above'   : shift = [-1, 0]; break;","                        case 'below'   : shift = [1, 0]; break;","                        case 'next'    : shift = [0, 1]; break;","                        case 'previous': shift = [0, -1]; break;","                    }","                }","","                if (isArray(shift)) {","                    index = cell.get('parentNode.rowIndex') +","                                shift[0] - rowIndexOffset;","                    row   = tbody.get('children').item(index);","","                    index = cell.get('cellIndex') + shift[1];","                    cell  = row && row.get('children').item(index);","                }","            }","        }","","        return cell || null;","    },","","    /**","    Returns the generated CSS classname based on the input.  If the `host`","    attribute is configured, it will attempt to relay to its `getClassName`","    or use its static `NAME` property as a string base.","","    If `host` is absent or has neither method nor `NAME`, a CSS classname","    will be generated using this class's `NAME`.","","    @method getClassName","    @param {String} token* Any number of token strings to assemble the","        classname from.","    @return {String}","    @protected","    @since 3.5.0","    **/","    getClassName: function () {","        var host = this.host,","            args;","","        if (host && host.getClassName) {","            return host.getClassName.apply(host, arguments);","        } else {","            args = toArray(arguments);","            args.unshift(this.constructor.NAME);","            return Y.ClassNameManager.getClassName","                .apply(Y.ClassNameManager, args);","        }","    },","","    /**","    Returns the Model associated to the row Node or id provided. Passing the","    Node or id for a descendant of the row also works.","","    If no Model can be found, `null` is returned.","","    @method getRecord","    @param {String|Node} seed Row Node or `id`, or one for a descendant of a row","    @return {Model}","    @since 3.5.0","    **/","    getRecord: function (seed) {","        var modelList = this.get('modelList'),","            tbody     = this.tbodyNode,","            row       = null,","            record;","","        if (tbody) {","            if (isString(seed)) {","                seed = tbody.one('#' + seed);","            }","","            if (Y.instanceOf(seed, Y.Node)) {","                row = seed.ancestor(function (node) {","                    return node.get('parentNode').compareTo(tbody);","                }, true);","","                record = row &&","                    modelList.getByClientId(row.getData('yui3-record'));","            }","        }","","        return record || null;","    },","","    /**","    Returns the `<tr>` Node from the given row index, Model, or Model's","    `clientId`.  If the rows haven't been rendered yet, or if the row can't be","    found by the input, `null` is returned.","","    @method getRow","    @param {Number|String|Model} id Row index, Model instance, or clientId","    @return {Node}","    @since 3.5.0","    **/","    getRow: function (id) {","        var tbody = this.tbodyNode,","            row = null;","","        if (tbody) {","            if (id) {","                id = this._idMap[id.get ? id.get('clientId') : id] || id;","            }","","            row = isNumber(id) ?","                tbody.get('children').item(id) :","                tbody.one('#' + id);","        }","","        return row;","    },","","    /**","    Creates the table's `<tbody>` content by assembling markup generated by","    populating the `ROW\\_TEMPLATE`, and `CELL\\_TEMPLATE` templates with content","    from the `columns` and `modelList` attributes.","","    The rendering process happens in three stages:","","    1. A row template is assembled from the `columns` attribute (see","       `_createRowTemplate`)","","    2. An HTML string is built up by concatenating the application of the data in","       each Model in the `modelList` to the row template. For cells with","       `formatter`s, the function is called to generate cell content. Cells","       with `nodeFormatter`s are ignored. For all other cells, the data value","       from the Model attribute for the given column key is used.  The","       accumulated row markup is then inserted into the container.","","    3. If any column is configured with a `nodeFormatter`, the `modelList` is","       iterated again to apply the `nodeFormatter`s.","","    Supported properties of the column objects include:","","      * `key` - Used to link a column to an attribute in a Model.","      * `name` - Used for columns that don't relate to an attribute in the Model","        (`formatter` or `nodeFormatter` only) if the implementer wants a","        predictable name to refer to in their CSS.","      * `cellTemplate` - Overrides the instance's `CELL_TEMPLATE` for cells in","        this column only.","      * `formatter` - Used to customize or override the content value from the","        Model.  These do not have access to the cell or row Nodes and should","        return string (HTML) content.","      * `nodeFormatter` - Used to provide content for a cell as well as perform","        any custom modifications on the cell or row Node that could not be","        performed by `formatter`s.  Should be used sparingly for better","        performance.","      * `emptyCellValue` - String (HTML) value to use if the Model data for a","        column, or the content generated by a `formatter`, is the empty string,","        `null`, or `undefined`.","      * `allowHTML` - Set to `true` if a column value, `formatter`, or","        `emptyCellValue` can contain HTML.  This defaults to `false` to protect","        against XSS.","      * `className` - Space delimited CSS classes to add to all `<td>`s in a","        column.","","    Column `formatter`s are passed an object (`o`) with the following","    properties:","","      * `value` - The current value of the column's associated attribute, if","        any.","      * `data` - An object map of Model keys to their current values.","      * `record` - The Model instance.","      * `column` - The column configuration object for the current column.","      * `className` - Initially empty string to allow `formatter`s to add CSS","        classes to the cell's `<td>`.","      * `rowIndex` - The zero-based row number.","      * `rowClass` - Initially empty string to allow `formatter`s to add CSS","        classes to the cell's containing row `<tr>`.","","    They may return a value or update `o.value` to assign specific HTML","    content.  A returned value has higher precedence.","","    Column `nodeFormatter`s are passed an object (`o`) with the following","    properties:","","      * `value` - The current value of the column's associated attribute, if","        any.","      * `td` - The `<td>` Node instance.","      * `cell` - The `<div>` liner Node instance if present, otherwise, the","        `<td>`.  When adding content to the cell, prefer appending into this","        property.","      * `data` - An object map of Model keys to their current values.","      * `record` - The Model instance.","      * `column` - The column configuration object for the current column.","      * `rowIndex` - The zero-based row number.","","    They are expected to inject content into the cell's Node directly, including","    any \"empty\" cell content.  Each `nodeFormatter` will have access through the","    Node API to all cells and rows in the `<tbody>`, but not to the `<table>`,","    as it will not be attached yet.","","    If a `nodeFormatter` returns `false`, the `o.td` and `o.cell` Nodes will be","    `destroy()`ed to remove them from the Node cache and free up memory.  The","    DOM elements will remain as will any content added to them.  _It is highly","    advisable to always return `false` from your `nodeFormatter`s_.","","    @method render","    @return {BodyView} The instance","    @chainable","    @since 3.5.0","    **/","    render: function () {","        var table   = this.get('container'),","            data    = this.get('modelList'),","            columns = this.get('columns'),","            tbody   = this.tbodyNode ||","                      (this.tbodyNode = this._createTBodyNode());","","        // Needed for mutation","        this._createRowTemplate(columns);","","        if (data) {","            tbody.setHTML(this._createDataHTML(columns));","","            this._applyNodeFormatters(tbody, columns);","        }","","        if (tbody.get('parentNode') !== table) {","            table.appendChild(tbody);","        }","","        this.bindUI();","","        return this;","    },","","    /**","     Refreshes the provided row against the provided model and the Array of","     columns to be updated.","","     @method refreshRow","     @param {Y.Node} row","     @param {Y.Model} model Y.Model representation of the row","     @param {Object[]} columns Array of column configuration objects","","     @chainable","     */","    refreshRow: function (row, model, columns) {","        var key,","            cell,","            len = columns.length,","            i;","","        for (i = 0; i < len; i++) {","            key = columns[i];","            cell = row.one('.' + this.getClassName('col', key));","            this.refreshCell(cell, model);","        }","","        return this;","    },","","    /**","     Refreshes the given cell with the provided model data and the provided","     column configuration.","","     Uses the provided column formatter if aviable.","","     @method refreshCell","     @param {Y.Node} cell Y.Node pointer to the cell element to be updated","     @param {Y.Model} [model] Y.Model representation of the row","     @param {Object} [col] Column configuration object for the cell","","     @chainable","     */","    refreshCell: function (cell, model, col) {","        var content,","            formatterFn,","            formatterData,","            data = model.toJSON();","","        cell = this.getCell(cell);","        model || (model = this.getRecord(cell));","        col || (col = this.getColumn(cell));","","        if (col.nodeFormatter) {","            formatterData = {","                cell: cell.one('.' + this.getClassName('liner')) || cell,","                column: col,","                data: data,","                record: model,","                rowIndex: this._getRowIndex(cell.ancestor('tr')),","                td: cell,","                value: data[col.key]","            };","","            keep = col.nodeFormatter.call(host,formatterData);","","            if (keep === false) {","                // Remove from the Node cache to reduce","                // memory footprint.  This also purges events,","                // which you shouldn't be scoping to a cell","                // anyway.  You've been warned.  Incidentally,","                // you should always return false. Just sayin.","                cell.destroy(true);","            }","","        } else if (col.formatter) {","            if (!col._formatterFn) {","                col = this._setColumnsFormatterFn([col])[0];","            }","","            formatterFn = col._formatterFn || null;","","            if (formatterFn) {","                formatterData = {","                    value    : data[col.key],","                    data     : data,","                    column   : col,","                    record   : model,","                    className: '',","                    rowClass : '',","                    rowIndex : this._getRowIndex(cell.ancestor('tr'))","                };","","                // Formatters can either return a value ...","                content = formatterFn.call(this.get('host'), formatterData);","","                // ... or update the value property of the data obj passed","                if (content === undefined) {","                    content = formatterData.value;","                }","            }","","            if (content === undefined || content === null || content === '') {","                content = col.emptyCellValue || '';","            }","","        } else {","            content = data[col.key] || col.emptyCellValue || '';","        }","","        cell.setHTML(col.allowHTML ? content : Y.Escape.html(content));","","        return this;","    },","","    /**","     Returns column data from this.get('columns'). If a Y.Node is provided as","     the key, will try to determine the key from the classname","     @method getColumn","     @param {String|Y.Node} key","     @return {Object} Returns column configuration","     */","    getColumn: function (key) {","        if (Y.instanceOf(key, Y.Node)) {","            // get column name from node","            key = key.get('className').match(","                new RegExp( this.getClassName('col') +'-([^ ]*)' )","            )[1];","        }","","        var cols = this.get('columns'),","            col = null;","","        Y.Array.some(cols, function (_col) {","            if (_col.key === key) {","                col = _col;","                return true;","            }","        });","","        return col;","    },","","    // -- Protected and private methods ---------------------------------------","    /**","    Handles changes in the source's columns attribute.  Redraws the table data.","","    @method _afterColumnsChange","    @param {EventFacade} e The `columnsChange` event object","    @protected","    @since 3.5.0","    **/","    // TODO: Preserve existing DOM","    // This will involve parsing and comparing the old and new column configs","    // and reacting to four types of changes:","    // 1. formatter, nodeFormatter, emptyCellValue changes","    // 2. column deletions","    // 3. column additions","    // 4. column moves (preserve cells)","    _afterColumnsChange: function () {","        this.render();","    },","","    /**","    Handles modelList changes, including additions, deletions, and updates.","","    Modifies the existing table DOM accordingly.","","    @method _afterDataChange","    @param {EventFacade} e The `change` event from the ModelList","    @protected","    @since 3.5.0","    **/","    _afterDataChange: function (e) {","        var type = (e.type.match(/:(add|change|remove)$/) || [])[1],","            index = e.index,","            columns = this.get('columns'),","            col,","            changed = e.changed && Y.Object.keys(e.changed),","            key,","            row,","            i,","            len;","","        for (i = 0, len = columns.length; i < len; i++ ) {","            col = columns[i];","","            // since nodeFormatters typcially make changes outside of it's","            // cell, we need to see if there are any columns that have a","            // nodeFormatter and if so, we need to do a full render() of the","            // tbody","            if (col.hasOwnProperty('nodeFormatter')) {","                this.render();","                return;","            }","        }","","        // TODO: if multiple rows are being added/remove/swapped, can we avoid the restriping?","        switch (type) {","            case 'change':","                for (i = 0, len = columns.length; i < len; i++) {","                    key = col.key || col.name;","                    if (col.formatter && !e.changed[key]) {","                        changed.push(key);","                    }","                }","                this.refreshRow(this.getRow(e.target), e.target, changed);","                break;","            case 'add':","                // we need to make sure we don't have an index larger than the data we have","                index =  Math.min(index, this.get('modelList').size() - 1);","","                // updates the columns with formatter functions","                this._setColumnsFormatterFn(columns);","                row = Y.Node.create(this._createRowHTML(e.model, index, columns));","                this.tbodyNode.insert(row, index);","                this._restripe(index);","                break;","            case 'remove':","                this.getRow(index).remove(true);","                // we removed a row, so we need to back up our index to stripe","                this._restripe(index - 1);","                break;","            default:","                this.render();","        }","    },","","    /**","     Toggles the odd/even classname of the row after the given index. This method","     is used to update rows after a row is inserted into or removed from the table.","     Note this event is delayed so the table is only restriped once when multiple","     rows are updated at one time.","","     @protected","     @method _restripe","     @param {Number} [index] Index of row to start restriping after","     @since @SINCE@","     */","    _restripe: function (index) {","        var task = this._restripeTask,","            self;","","        // index|0 to force int, avoid NaN. Math.max() to avoid neg indexes.","        index = Math.max((index|0), 0);","","        if (!task) {","            self = this;","","            this._restripeTask = {","                timer: setTimeout(function () {","                    // Check for self existence before continuing","                    if (!self || self.get('destroy') || !self.tbodyNode || !self.tbodyNode.inDoc()) {","                        self._restripeTask = null;","                        return;","                    }","","                    var odd  = [self.CLASS_ODD, self.CLASS_EVEN],","                        even = [self.CLASS_EVEN, self.CLASS_ODD],","                        index = self._restripeTask.index;","","                    self.tbodyNode.get('childNodes')","                        .slice(index)","                        .each(function (row, i) { // TODO: each vs batch","                            row.replaceClass.apply(row, (index + i) % 2 ? even : odd);","                        });","","                    self._restripeTask = null;","                }, 0),","","                index: index","            };","        } else {","            task.index = Math.min(task.index, index);","        }","","    },","","    /**","    Handles replacement of the modelList.","","    Rerenders the `<tbody>` contents.","","    @method _afterModelListChange","    @param {EventFacade} e The `modelListChange` event","    @protected","    @since 3.6.0","    **/","    _afterModelListChange: function () {","        var handles = this._eventHandles;","","        if (handles.dataChange) {","            handles.dataChange.detach();","            delete handles.dataChange;","            this.bindUI();","        }","","        if (this.tbodyNode) {","            this.render();","        }","    },","","    /**","    Iterates the `modelList`, and calls any `nodeFormatter`s found in the","    `columns` param on the appropriate cell Nodes in the `tbody`.","","    @method _applyNodeFormatters","    @param {Node} tbody The `<tbody>` Node whose columns to update","    @param {Object[]} columns The column configurations","    @protected","    @since 3.5.0","    **/","    _applyNodeFormatters: function (tbody, columns) {","        var host = this.host || this,","            data = this.get('modelList'),","            formatters = [],","            linerQuery = '.' + this.getClassName('liner'),","            rows, i, len;","","        // Only iterate the ModelList again if there are nodeFormatters","        for (i = 0, len = columns.length; i < len; ++i) {","            if (columns[i].nodeFormatter) {","                formatters.push(i);","            }","        }","","        if (data && formatters.length) {","            rows = tbody.get('childNodes');","","            data.each(function (record, index) {","                var formatterData = {","                        data      : record.toJSON(),","                        record    : record,","                        rowIndex  : index","                    },","                    row = rows.item(index),","                    i, len, col, key, cells, cell, keep;","","","                if (row) {","                    cells = row.get('childNodes');","                    for (i = 0, len = formatters.length; i < len; ++i) {","                        cell = cells.item(formatters[i]);","","                        if (cell) {","                            col = formatterData.column = columns[formatters[i]];","                            key = col.key || col.id;","","                            formatterData.value = record.get(key);","                            formatterData.td    = cell;","                            formatterData.cell  = cell.one(linerQuery) || cell;","","                            keep = col.nodeFormatter.call(host,formatterData);","","                            if (keep === false) {","                                // Remove from the Node cache to reduce","                                // memory footprint.  This also purges events,","                                // which you shouldn't be scoping to a cell","                                // anyway.  You've been warned.  Incidentally,","                                // you should always return false. Just sayin.","                                cell.destroy(true);","                            }","                        }","                    }","                }","            });","        }","    },","","    /**","    Binds event subscriptions from the UI and the host (if assigned).","","    @method bindUI","    @protected","    @since 3.5.0","    **/","    bindUI: function () {","        var handles     = this._eventHandles,","            modelList   = this.get('modelList'),","            changeEvent = modelList.model.NAME + ':change';","","        if (!handles.columnsChange) {","            handles.columnsChange = this.after('columnsChange',","                bind('_afterColumnsChange', this));","        }","","        if (modelList && !handles.dataChange) {","            handles.dataChange = modelList.after(","                ['add', 'remove', 'reset', changeEvent],","                bind('_afterDataChange', this));","        }","    },","","    /**","    Iterates the `modelList` and applies each Model to the `_rowTemplate`,","    allowing any column `formatter` or `emptyCellValue` to override cell","    content for the appropriate column.  The aggregated HTML string is","    returned.","","    @method _createDataHTML","    @param {Object[]} columns The column configurations to customize the","                generated cell content or class names","    @return {HTML} The markup for all Models in the `modelList`, each applied","                to the `_rowTemplate`","    @protected","    @since 3.5.0","    **/","    _createDataHTML: function (columns) {","        var data = this.get('modelList'),","            html = '';","","        if (data) {","            data.each(function (model, index) {","                html += this._createRowHTML(model, index, columns);","            }, this);","        }","","        return html;","    },","","    /**","    Applies the data of a given Model, modified by any column formatters and","    supplemented by other template values to the instance's `_rowTemplate` (see","    `_createRowTemplate`).  The generated string is then returned.","","    The data from Model's attributes is fetched by `toJSON` and this data","    object is appended with other properties to supply values to {placeholders}","    in the template.  For a template generated from a Model with 'foo' and 'bar'","    attributes, the data object would end up with the following properties","    before being used to populate the `_rowTemplate`:","","      * `clientID` - From Model, used the assign the `<tr>`'s 'id' attribute.","      * `foo` - The value to populate the 'foo' column cell content.  This","        value will be the value stored in the Model's `foo` attribute, or the","        result of the column's `formatter` if assigned.  If the value is '',","        `null`, or `undefined`, and the column's `emptyCellValue` is assigned,","        that value will be used.","      * `bar` - Same for the 'bar' column cell content.","      * `foo-className` - String of CSS classes to apply to the `<td>`.","      * `bar-className` - Same.","      * `rowClass`      - String of CSS classes to apply to the `<tr>`. This","        will be the odd/even class per the specified index plus any additional","        classes assigned by column formatters (via `o.rowClass`).","","    Because this object is available to formatters, any additional properties","    can be added to fill in custom {placeholders} in the `_rowTemplate`.","","    @method _createRowHTML","    @param {Model} model The Model instance to apply to the row template","    @param {Number} index The index the row will be appearing","    @param {Object[]} columns The column configurations","    @return {HTML} The markup for the provided Model, less any `nodeFormatter`s","    @protected","    @since 3.5.0","    **/","    _createRowHTML: function (model, index, columns) {","        var data     = model.toJSON(),","            clientId = model.get('clientId'),","            values   = {","                rowId   : this._getRowId(clientId),","                clientId: clientId,","                rowClass: (index % 2) ? this.CLASS_ODD : this.CLASS_EVEN","            },","            host = this.host || this,","            i, len, col, token, value, formatterData;","","        for (i = 0, len = columns.length; i < len; ++i) {","            col   = columns[i];","            value = data[col.key];","            token = col._id || col.key;","","            values[token + '-className'] = '';","","            if (col._formatterFn) {","                formatterData = {","                    value    : value,","                    data     : data,","                    column   : col,","                    record   : model,","                    className: '',","                    rowClass : '',","                    rowIndex : index","                };","","                // Formatters can either return a value","                value = col._formatterFn.call(host, formatterData);","","                // or update the value property of the data obj passed","                if (value === undefined) {","                    value = formatterData.value;","                }","","                values[token + '-className'] = formatterData.className;","                values.rowClass += ' ' + formatterData.rowClass;","            }","","            if (value === undefined || value === null || value === '') {","                value = col.emptyCellValue || '';","            }","","            values[token] = col.allowHTML ? value : htmlEscape(value);","","            values.rowClass = values.rowClass.replace(/\\s+/g, ' ');","        }","","        return fromTemplate(this._rowTemplate, values);","    },","","    /**","     Locates the row within the tbodyNode and returns the found index, or Null","     if it is not found in the tbodyNode","     @param {Y.Node} row","     @return {Number} Index of row in tbodyNode","     */","    _getRowIndex: function (row) {","        var tbody = this.tbodyNode,","            index = 1;","","        if (tbody && row) {","","            //if row is not in the tbody, return","            if (row.ancestor('tbody') !== tbody) {","                return null;","            }","","            // increment until we no longer have a previous node","            while (row = row.previous()) { // NOTE: assignment","                index++;","            }","        }","","        return index;","    },","","    /**","    Creates a custom HTML template string for use in generating the markup for","    individual table rows with {placeholder}s to capture data from the Models","    in the `modelList` attribute or from column `formatter`s.","","    Assigns the `_rowTemplate` property.","","    @method _createRowTemplate","    @param {Object[]} columns Array of column configuration objects","    @protected","    @since 3.5.0","    **/","    _createRowTemplate: function (columns) {","        var html         = '',","            cellTemplate = this.CELL_TEMPLATE,","            i, len, col, key, token, headers, tokenValues, formatter;","","        this._setColumnsFormatterFn(columns);","","        for (i = 0, len = columns.length; i < len; ++i) {","            col     = columns[i];","            key     = col.key;","            token   = col._id || key;","            formatter = col._formatterFn;","            // Only include headers if there are more than one","            headers = (col._headers || []).length > 1 ?","                        'headers=\"' + col._headers.join(' ') + '\"' : '';","","            tokenValues = {","                content  : '{' + token + '}',","                headers  : headers,","                className: this.getClassName('col', token) + ' ' +","                           (col.className || '') + ' ' +","                           this.getClassName('cell') +","                           ' {' + token + '-className}'","            };","            if (!formatter && col.formatter) {","                tokenValues.content = col.formatter.replace(valueRegExp, tokenValues.content);","            }","","            if (col.nodeFormatter) {","                // Defer all node decoration to the formatter","                tokenValues.content = '';","            }","","            html += fromTemplate(col.cellTemplate || cellTemplate, tokenValues);","        }","","        this._rowTemplate = fromTemplate(this.ROW_TEMPLATE, {","            content: html","        });","    },","","    /**","     Parses the columns array and defines the column's _formatterFn if there","     is a formatter available on the column","     @protected","     @method _setColumnsFormatterFn","     @param {Object[]} columns Array of column configuration objects","","     @return {Object[]} Returns modified columns configuration Array","     */","    _setColumnsFormatterFn: function (columns) {","        var Formatters = Y.DataTable.BodyView.Formatters,","            formatter,","            col,","            i,","            len;","","        for (i = 0, len = columns.length; i < len; i++) {","            col = columns[i];","            formatter = col.formatter;","","            if (!col._formatterFn && formatter) {","                if (Lang.isFunction(formatter)) {","                    col._formatterFn = formatter;","                } else if (formatter in Formatters) {","                    col._formatterFn = Formatters[formatter].call(this.host || this, col);","                }","            }","        }","","        return columns;","    },","","    /**","    Creates the `<tbody>` node that will store the data rows.","","    @method _createTBodyNode","    @return {Node}","    @protected","    @since 3.6.0","    **/","    _createTBodyNode: function () {","        return Y.Node.create(fromTemplate(this.TBODY_TEMPLATE, {","            className: this.getClassName('data')","        }));","    },","","    /**","    Destroys the instance.","","    @method destructor","    @protected","    @since 3.5.0","    **/","    destructor: function () {","        (new Y.EventHandle(YObject.values(this._eventHandles))).detach();","    },","","    /**","    Holds the event subscriptions needing to be detached when the instance is","    `destroy()`ed.","","    @property _eventHandles","    @type {Object}","    @default undefined (initially unset)","    @protected","    @since 3.5.0","    **/","    //_eventHandles: null,","","    /**","    Returns the row ID associated with a Model's clientId.","","    @method _getRowId","    @param {String} clientId The Model clientId","    @return {String}","    @protected","    **/","    _getRowId: function (clientId) {","        return this._idMap[clientId] || (this._idMap[clientId] = Y.guid());","    },","","    /**","    Map of Model clientIds to row ids.","","    @property _idMap","    @type {Object}","    @protected","    **/","    //_idMap,","","    /**","    Initializes the instance. Reads the following configuration properties in","    addition to the instance attributes:","","      * `columns` - (REQUIRED) The initial column information","      * `host`    - The object to serve as source of truth for column info and","                    for generating class names","","    @method initializer","    @param {Object} config Configuration data","    @protected","    @since 3.5.0","    **/","    initializer: function (config) {","        this.host = config.host;","","        this._eventHandles = {","            modelListChange: this.after('modelListChange',","                bind('_afterModelListChange', this))","        };","        this._idMap = {};","","        this.CLASS_ODD  = this.getClassName('odd');","        this.CLASS_EVEN = this.getClassName('even');","","    }","","    /**","    The HTML template used to create a full row of markup for a single Model in","    the `modelList` plus any customizations defined in the column","    configurations.","","    @property _rowTemplate","    @type {HTML}","    @default (initially unset)","    @protected","    @since 3.5.0","    **/","    //_rowTemplate: null","},{","    /**","    Hash of formatting functions for cell contents.","","    This property can be populated with a hash of formatting functions by the developer","    or a set of pre-defined functions can be loaded via the `datatable-formatters` module.","","    See: [DataTable.BodyView.Formatters](./DataTable.BodyView.Formatters.html)","    @property Formatters","    @type Object","    @since 3.8.0","    @static","    **/","    Formatters: {}","});","","","}, '@VERSION@', {\"requires\": [\"datatable-core\", \"view\", \"classnamemanager\"]});"];
_yuitest_coverage["build/datatable-body/datatable-body.js"].lines = {"1":0,"11":0,"115":0,"214":0,"217":0,"218":0,"219":0,"220":0,"221":0,"222":0,"225":0,"226":0,"227":0,"229":0,"230":0,"231":0,"232":0,"233":0,"237":0,"238":0,"240":0,"242":0,"243":0,"248":0,"267":0,"270":0,"271":0,"273":0,"274":0,"275":0,"292":0,"297":0,"298":0,"299":0,"302":0,"303":0,"304":0,"307":0,"312":0,"326":0,"329":0,"330":0,"331":0,"334":0,"339":0,"433":0,"440":0,"442":0,"443":0,"445":0,"448":0,"449":0,"452":0,"454":0,"469":0,"474":0,"475":0,"476":0,"477":0,"480":0,"497":0,"502":0,"503":0,"504":0,"506":0,"507":0,"517":0,"519":0,"525":0,"528":0,"529":0,"530":0,"533":0,"535":0,"536":0,"547":0,"550":0,"551":0,"555":0,"556":0,"560":0,"563":0,"565":0,"576":0,"578":0,"583":0,"586":0,"587":0,"588":0,"589":0,"593":0,"613":0,"627":0,"637":0,"638":0,"644":0,"645":0,"646":0,"651":0,"653":0,"654":0,"655":0,"656":0,"659":0,"660":0,"663":0,"666":0,"667":0,"668":0,"669":0,"670":0,"672":0,"674":0,"675":0,"677":0,"693":0,"697":0,"699":0,"700":0,"702":0,"705":0,"706":0,"707":0,"710":0,"714":0,"717":0,"720":0,"726":0,"742":0,"744":0,"745":0,"746":0,"747":0,"750":0,"751":0,"766":0,"773":0,"774":0,"775":0,"779":0,"780":0,"782":0,"783":0,"792":0,"793":0,"794":0,"795":0,"797":0,"798":0,"799":0,"801":0,"802":0,"803":0,"805":0,"807":0,"813":0,"830":0,"834":0,"835":0,"839":0,"840":0,"861":0,"864":0,"865":0,"866":0,"870":0,"909":0,"919":0,"920":0,"921":0,"922":0,"924":0,"926":0,"927":0,"938":0,"941":0,"942":0,"945":0,"946":0,"949":0,"950":0,"953":0,"955":0,"958":0,"968":0,"971":0,"974":0,"975":0,"979":0,"980":0,"984":0,"1000":0,"1004":0,"1006":0,"1007":0,"1008":0,"1009":0,"1010":0,"1012":0,"1015":0,"1023":0,"1024":0,"1027":0,"1029":0,"1032":0,"1035":0,"1050":0,"1056":0,"1057":0,"1058":0,"1060":0,"1061":0,"1062":0,"1063":0,"1064":0,"1069":0,"1081":0,"1094":0,"1118":0,"1144":0,"1146":0,"1150":0,"1152":0,"1153":0};
_yuitest_coverage["build/datatable-body/datatable-body.js"].functions = {"getCell:213":0,"getClassName:266":0,"(anonymous 2):303":0,"getRecord:291":0,"getRow:325":0,"render:432":0,"refreshRow:468":0,"refreshCell:496":0,"(anonymous 3):586":0,"getColumn:575":0,"_afterColumnsChange:612":0,"_afterDataChange:626":0,"(anonymous 5):716":0,"(anonymous 4):703":0,"_restripe:692":0,"_afterModelListChange:741":0,"(anonymous 6):782":0,"_applyNodeFormatters:765":0,"bindUI:829":0,"(anonymous 7):865":0,"_createDataHTML:860":0,"_createRowHTML:908":0,"_getRowIndex:967":0,"_createRowTemplate:999":0,"_setColumnsFormatterFn:1049":0,"_createTBodyNode:1080":0,"destructor:1093":0,"_getRowId:1117":0,"initializer:1143":0,"(anonymous 1):1":0};
_yuitest_coverage["build/datatable-body/datatable-body.js"].coveredLines = 224;
_yuitest_coverage["build/datatable-body/datatable-body.js"].coveredFunctions = 30;
_yuitest_coverline("build/datatable-body/datatable-body.js", 1);
YUI.add('datatable-body', function (Y, NAME) {

/**
View class responsible for rendering the `<tbody>` section of a table. Used as
the default `bodyView` for `Y.DataTable.Base` and `Y.DataTable` classes.

@module datatable
@submodule datatable-body
@since 3.5.0
**/
_yuitest_coverfunc("build/datatable-body/datatable-body.js", "(anonymous 1)", 1);
_yuitest_coverline("build/datatable-body/datatable-body.js", 11);
var Lang         = Y.Lang,
    isArray      = Lang.isArray,
    isNumber     = Lang.isNumber,
    isString     = Lang.isString,
    fromTemplate = Lang.sub,
    htmlEscape   = Y.Escape.html,
    toArray      = Y.Array,
    bind         = Y.bind,
    YObject      = Y.Object,
    valueRegExp  = /\{value\}/g;

/**
View class responsible for rendering the `<tbody>` section of a table. Used as
the default `bodyView` for `Y.DataTable.Base` and `Y.DataTable` classes.

Translates the provided `modelList` into a rendered `<tbody>` based on the data
in the constituent Models, altered or amended by any special column
configurations.

The `columns` configuration, passed to the constructor, determines which
columns will be rendered.

The rendering process involves constructing an HTML template for a complete row
of data, built by concatenating a customized copy of the instance's
`CELL_TEMPLATE` into the `ROW_TEMPLATE` once for each column.  This template is
then populated with values from each Model in the `modelList`, aggregating a
complete HTML string of all row and column data.  A `<tbody>` Node is then created from the markup and any column `nodeFormatter`s are applied.

Supported properties of the column objects include:

  * `key` - Used to link a column to an attribute in a Model.
  * `name` - Used for columns that don't relate to an attribute in the Model
    (`formatter` or `nodeFormatter` only) if the implementer wants a
    predictable name to refer to in their CSS.
  * `cellTemplate` - Overrides the instance's `CELL_TEMPLATE` for cells in this
    column only.
  * `formatter` - Used to customize or override the content value from the
    Model.  These do not have access to the cell or row Nodes and should
    return string (HTML) content.
  * `nodeFormatter` - Used to provide content for a cell as well as perform any
    custom modifications on the cell or row Node that could not be performed by
    `formatter`s.  Should be used sparingly for better performance.
  * `emptyCellValue` - String (HTML) value to use if the Model data for a
    column, or the content generated by a `formatter`, is the empty string,
    `null`, or `undefined`.
  * `allowHTML` - Set to `true` if a column value, `formatter`, or
    `emptyCellValue` can contain HTML.  This defaults to `false` to protect
    against XSS.
  * `className` - Space delimited CSS classes to add to all `<td>`s in a column.

A column `formatter` can be:

  * a function, as described below.
  * a string which can be:
      * the name of a pre-defined formatter function
        which can be located in the `Y.DataTable.BodyView.Formatters` hash using the
        value of the `formatter` property as the index.
      * A template that can use the `{value}` placeholder to include the value
        for the current cell or the name of any field in the underlaying model
        also enclosed in curly braces.  Any number and type of these placeholders
        can be used.

Column `formatter`s are passed an object (`o`) with the following properties:

  * `value` - The current value of the column's associated attribute, if any.
  * `data` - An object map of Model keys to their current values.
  * `record` - The Model instance.
  * `column` - The column configuration object for the current column.
  * `className` - Initially empty string to allow `formatter`s to add CSS
    classes to the cell's `<td>`.
  * `rowIndex` - The zero-based row number.
  * `rowClass` - Initially empty string to allow `formatter`s to add CSS
    classes to the cell's containing row `<tr>`.

They may return a value or update `o.value` to assign specific HTML content.  A
returned value has higher precedence.

Column `nodeFormatter`s are passed an object (`o`) with the following
properties:

  * `value` - The current value of the column's associated attribute, if any.
  * `td` - The `<td>` Node instance.
  * `cell` - The `<div>` liner Node instance if present, otherwise, the `<td>`.
    When adding content to the cell, prefer appending into this property.
  * `data` - An object map of Model keys to their current values.
  * `record` - The Model instance.
  * `column` - The column configuration object for the current column.
  * `rowIndex` - The zero-based row number.

They are expected to inject content into the cell's Node directly, including
any "empty" cell content.  Each `nodeFormatter` will have access through the
Node API to all cells and rows in the `<tbody>`, but not to the `<table>`, as
it will not be attached yet.

If a `nodeFormatter` returns `false`, the `o.td` and `o.cell` Nodes will be
`destroy()`ed to remove them from the Node cache and free up memory.  The DOM
elements will remain as will any content added to them.  _It is highly
advisable to always return `false` from your `nodeFormatter`s_.

@class BodyView
@namespace DataTable
@extends View
@since 3.5.0
**/
_yuitest_coverline("build/datatable-body/datatable-body.js", 115);
Y.namespace('DataTable').BodyView = Y.Base.create('tableBody', Y.View, [], {
    // -- Instance properties -------------------------------------------------

    /**
    HTML template used to create table cells.

    @property CELL_TEMPLATE
    @type {HTML}
    @default '<td {headers} class="{className}">{content}</td>'
    @since 3.5.0
    **/
    CELL_TEMPLATE: '<td {headers} class="{className}">{content}</td>',

    /**
    CSS class applied to even rows.  This is assigned at instantiation.

    For DataTable, this will be `yui3-datatable-even`.

    @property CLASS_EVEN
    @type {String}
    @default 'yui3-table-even'
    @since 3.5.0
    **/
    //CLASS_EVEN: null

    /**
    CSS class applied to odd rows.  This is assigned at instantiation.

    When used by DataTable instances, this will be `yui3-datatable-odd`.

    @property CLASS_ODD
    @type {String}
    @default 'yui3-table-odd'
    @since 3.5.0
    **/
    //CLASS_ODD: null

    /**
    HTML template used to create table rows.

    @property ROW_TEMPLATE
    @type {HTML}
    @default '<tr id="{rowId}" data-yui3-record="{clientId}" class="{rowClass}">{content}</tr>'
    @since 3.5.0
    **/
    ROW_TEMPLATE : '<tr id="{rowId}" data-yui3-record="{clientId}" class="{rowClass}">{content}</tr>',

    /**
    The object that serves as the source of truth for column and row data.
    This property is assigned at instantiation from the `host` property of
    the configuration object passed to the constructor.

    @property host
    @type {Object}
    @default (initially unset)
    @since 3.5.0
    **/
    //TODO: should this be protected?
    //host: null,

    /**
    HTML templates used to create the `<tbody>` containing the table rows.

    @property TBODY_TEMPLATE
    @type {HTML}
    @default '<tbody class="{className}">{content}</tbody>'
    @since 3.6.0
    **/
    TBODY_TEMPLATE: '<tbody class="{className}"></tbody>',

    // -- Public methods ------------------------------------------------------

    /**
    Returns the `<td>` Node from the given row and column index.  Alternately,
    the `seed` can be a Node.  If so, the nearest ancestor cell is returned.
    If the `seed` is a cell, it is returned.  If there is no cell at the given
    coordinates, `null` is returned.

    Optionally, include an offset array or string to return a cell near the
    cell identified by the `seed`.  The offset can be an array containing the
    number of rows to shift followed by the number of columns to shift, or one
    of "above", "below", "next", or "previous".

    <pre><code>// Previous cell in the previous row
    var cell = table.getCell(e.target, [-1, -1]);

    // Next cell
    var cell = table.getCell(e.target, 'next');
    var cell = table.getCell(e.target, [0, 1];</pre></code>

    @method getCell
    @param {Number[]|Node} seed Array of row and column indexes, or a Node that
        is either the cell itself or a descendant of one.
    @param {Number[]|String} [shift] Offset by which to identify the returned
        cell Node
    @return {Node}
    @since 3.5.0
    **/
    getCell: function (seed, shift) {
        _yuitest_coverfunc("build/datatable-body/datatable-body.js", "getCell", 213);
_yuitest_coverline("build/datatable-body/datatable-body.js", 214);
var tbody = this.tbodyNode,
            row, cell, index, rowIndexOffset;

        _yuitest_coverline("build/datatable-body/datatable-body.js", 217);
if (seed && tbody) {
            _yuitest_coverline("build/datatable-body/datatable-body.js", 218);
if (isArray(seed)) {
                _yuitest_coverline("build/datatable-body/datatable-body.js", 219);
row = tbody.get('children').item(seed[0]);
                _yuitest_coverline("build/datatable-body/datatable-body.js", 220);
cell = row && row.get('children').item(seed[1]);
            } else {_yuitest_coverline("build/datatable-body/datatable-body.js", 221);
if (Y.instanceOf(seed, Y.Node)) {
                _yuitest_coverline("build/datatable-body/datatable-body.js", 222);
cell = seed.ancestor('.' + this.getClassName('cell'), true);
            }}

            _yuitest_coverline("build/datatable-body/datatable-body.js", 225);
if (cell && shift) {
                _yuitest_coverline("build/datatable-body/datatable-body.js", 226);
rowIndexOffset = tbody.get('firstChild.rowIndex');
                _yuitest_coverline("build/datatable-body/datatable-body.js", 227);
if (isString(shift)) {
                    // TODO this should be a static object map
                    _yuitest_coverline("build/datatable-body/datatable-body.js", 229);
switch (shift) {
                        case 'above'   : _yuitest_coverline("build/datatable-body/datatable-body.js", 230);
shift = [-1, 0]; break;
                        case 'below'   : _yuitest_coverline("build/datatable-body/datatable-body.js", 231);
shift = [1, 0]; break;
                        case 'next'    : _yuitest_coverline("build/datatable-body/datatable-body.js", 232);
shift = [0, 1]; break;
                        case 'previous': _yuitest_coverline("build/datatable-body/datatable-body.js", 233);
shift = [0, -1]; break;
                    }
                }

                _yuitest_coverline("build/datatable-body/datatable-body.js", 237);
if (isArray(shift)) {
                    _yuitest_coverline("build/datatable-body/datatable-body.js", 238);
index = cell.get('parentNode.rowIndex') +
                                shift[0] - rowIndexOffset;
                    _yuitest_coverline("build/datatable-body/datatable-body.js", 240);
row   = tbody.get('children').item(index);

                    _yuitest_coverline("build/datatable-body/datatable-body.js", 242);
index = cell.get('cellIndex') + shift[1];
                    _yuitest_coverline("build/datatable-body/datatable-body.js", 243);
cell  = row && row.get('children').item(index);
                }
            }
        }

        _yuitest_coverline("build/datatable-body/datatable-body.js", 248);
return cell || null;
    },

    /**
    Returns the generated CSS classname based on the input.  If the `host`
    attribute is configured, it will attempt to relay to its `getClassName`
    or use its static `NAME` property as a string base.

    If `host` is absent or has neither method nor `NAME`, a CSS classname
    will be generated using this class's `NAME`.

    @method getClassName
    @param {String} token* Any number of token strings to assemble the
        classname from.
    @return {String}
    @protected
    @since 3.5.0
    **/
    getClassName: function () {
        _yuitest_coverfunc("build/datatable-body/datatable-body.js", "getClassName", 266);
_yuitest_coverline("build/datatable-body/datatable-body.js", 267);
var host = this.host,
            args;

        _yuitest_coverline("build/datatable-body/datatable-body.js", 270);
if (host && host.getClassName) {
            _yuitest_coverline("build/datatable-body/datatable-body.js", 271);
return host.getClassName.apply(host, arguments);
        } else {
            _yuitest_coverline("build/datatable-body/datatable-body.js", 273);
args = toArray(arguments);
            _yuitest_coverline("build/datatable-body/datatable-body.js", 274);
args.unshift(this.constructor.NAME);
            _yuitest_coverline("build/datatable-body/datatable-body.js", 275);
return Y.ClassNameManager.getClassName
                .apply(Y.ClassNameManager, args);
        }
    },

    /**
    Returns the Model associated to the row Node or id provided. Passing the
    Node or id for a descendant of the row also works.

    If no Model can be found, `null` is returned.

    @method getRecord
    @param {String|Node} seed Row Node or `id`, or one for a descendant of a row
    @return {Model}
    @since 3.5.0
    **/
    getRecord: function (seed) {
        _yuitest_coverfunc("build/datatable-body/datatable-body.js", "getRecord", 291);
_yuitest_coverline("build/datatable-body/datatable-body.js", 292);
var modelList = this.get('modelList'),
            tbody     = this.tbodyNode,
            row       = null,
            record;

        _yuitest_coverline("build/datatable-body/datatable-body.js", 297);
if (tbody) {
            _yuitest_coverline("build/datatable-body/datatable-body.js", 298);
if (isString(seed)) {
                _yuitest_coverline("build/datatable-body/datatable-body.js", 299);
seed = tbody.one('#' + seed);
            }

            _yuitest_coverline("build/datatable-body/datatable-body.js", 302);
if (Y.instanceOf(seed, Y.Node)) {
                _yuitest_coverline("build/datatable-body/datatable-body.js", 303);
row = seed.ancestor(function (node) {
                    _yuitest_coverfunc("build/datatable-body/datatable-body.js", "(anonymous 2)", 303);
_yuitest_coverline("build/datatable-body/datatable-body.js", 304);
return node.get('parentNode').compareTo(tbody);
                }, true);

                _yuitest_coverline("build/datatable-body/datatable-body.js", 307);
record = row &&
                    modelList.getByClientId(row.getData('yui3-record'));
            }
        }

        _yuitest_coverline("build/datatable-body/datatable-body.js", 312);
return record || null;
    },

    /**
    Returns the `<tr>` Node from the given row index, Model, or Model's
    `clientId`.  If the rows haven't been rendered yet, or if the row can't be
    found by the input, `null` is returned.

    @method getRow
    @param {Number|String|Model} id Row index, Model instance, or clientId
    @return {Node}
    @since 3.5.0
    **/
    getRow: function (id) {
        _yuitest_coverfunc("build/datatable-body/datatable-body.js", "getRow", 325);
_yuitest_coverline("build/datatable-body/datatable-body.js", 326);
var tbody = this.tbodyNode,
            row = null;

        _yuitest_coverline("build/datatable-body/datatable-body.js", 329);
if (tbody) {
            _yuitest_coverline("build/datatable-body/datatable-body.js", 330);
if (id) {
                _yuitest_coverline("build/datatable-body/datatable-body.js", 331);
id = this._idMap[id.get ? id.get('clientId') : id] || id;
            }

            _yuitest_coverline("build/datatable-body/datatable-body.js", 334);
row = isNumber(id) ?
                tbody.get('children').item(id) :
                tbody.one('#' + id);
        }

        _yuitest_coverline("build/datatable-body/datatable-body.js", 339);
return row;
    },

    /**
    Creates the table's `<tbody>` content by assembling markup generated by
    populating the `ROW\_TEMPLATE`, and `CELL\_TEMPLATE` templates with content
    from the `columns` and `modelList` attributes.

    The rendering process happens in three stages:

    1. A row template is assembled from the `columns` attribute (see
       `_createRowTemplate`)

    2. An HTML string is built up by concatenating the application of the data in
       each Model in the `modelList` to the row template. For cells with
       `formatter`s, the function is called to generate cell content. Cells
       with `nodeFormatter`s are ignored. For all other cells, the data value
       from the Model attribute for the given column key is used.  The
       accumulated row markup is then inserted into the container.

    3. If any column is configured with a `nodeFormatter`, the `modelList` is
       iterated again to apply the `nodeFormatter`s.

    Supported properties of the column objects include:

      * `key` - Used to link a column to an attribute in a Model.
      * `name` - Used for columns that don't relate to an attribute in the Model
        (`formatter` or `nodeFormatter` only) if the implementer wants a
        predictable name to refer to in their CSS.
      * `cellTemplate` - Overrides the instance's `CELL_TEMPLATE` for cells in
        this column only.
      * `formatter` - Used to customize or override the content value from the
        Model.  These do not have access to the cell or row Nodes and should
        return string (HTML) content.
      * `nodeFormatter` - Used to provide content for a cell as well as perform
        any custom modifications on the cell or row Node that could not be
        performed by `formatter`s.  Should be used sparingly for better
        performance.
      * `emptyCellValue` - String (HTML) value to use if the Model data for a
        column, or the content generated by a `formatter`, is the empty string,
        `null`, or `undefined`.
      * `allowHTML` - Set to `true` if a column value, `formatter`, or
        `emptyCellValue` can contain HTML.  This defaults to `false` to protect
        against XSS.
      * `className` - Space delimited CSS classes to add to all `<td>`s in a
        column.

    Column `formatter`s are passed an object (`o`) with the following
    properties:

      * `value` - The current value of the column's associated attribute, if
        any.
      * `data` - An object map of Model keys to their current values.
      * `record` - The Model instance.
      * `column` - The column configuration object for the current column.
      * `className` - Initially empty string to allow `formatter`s to add CSS
        classes to the cell's `<td>`.
      * `rowIndex` - The zero-based row number.
      * `rowClass` - Initially empty string to allow `formatter`s to add CSS
        classes to the cell's containing row `<tr>`.

    They may return a value or update `o.value` to assign specific HTML
    content.  A returned value has higher precedence.

    Column `nodeFormatter`s are passed an object (`o`) with the following
    properties:

      * `value` - The current value of the column's associated attribute, if
        any.
      * `td` - The `<td>` Node instance.
      * `cell` - The `<div>` liner Node instance if present, otherwise, the
        `<td>`.  When adding content to the cell, prefer appending into this
        property.
      * `data` - An object map of Model keys to their current values.
      * `record` - The Model instance.
      * `column` - The column configuration object for the current column.
      * `rowIndex` - The zero-based row number.

    They are expected to inject content into the cell's Node directly, including
    any "empty" cell content.  Each `nodeFormatter` will have access through the
    Node API to all cells and rows in the `<tbody>`, but not to the `<table>`,
    as it will not be attached yet.

    If a `nodeFormatter` returns `false`, the `o.td` and `o.cell` Nodes will be
    `destroy()`ed to remove them from the Node cache and free up memory.  The
    DOM elements will remain as will any content added to them.  _It is highly
    advisable to always return `false` from your `nodeFormatter`s_.

    @method render
    @return {BodyView} The instance
    @chainable
    @since 3.5.0
    **/
    render: function () {
        _yuitest_coverfunc("build/datatable-body/datatable-body.js", "render", 432);
_yuitest_coverline("build/datatable-body/datatable-body.js", 433);
var table   = this.get('container'),
            data    = this.get('modelList'),
            columns = this.get('columns'),
            tbody   = this.tbodyNode ||
                      (this.tbodyNode = this._createTBodyNode());

        // Needed for mutation
        _yuitest_coverline("build/datatable-body/datatable-body.js", 440);
this._createRowTemplate(columns);

        _yuitest_coverline("build/datatable-body/datatable-body.js", 442);
if (data) {
            _yuitest_coverline("build/datatable-body/datatable-body.js", 443);
tbody.setHTML(this._createDataHTML(columns));

            _yuitest_coverline("build/datatable-body/datatable-body.js", 445);
this._applyNodeFormatters(tbody, columns);
        }

        _yuitest_coverline("build/datatable-body/datatable-body.js", 448);
if (tbody.get('parentNode') !== table) {
            _yuitest_coverline("build/datatable-body/datatable-body.js", 449);
table.appendChild(tbody);
        }

        _yuitest_coverline("build/datatable-body/datatable-body.js", 452);
this.bindUI();

        _yuitest_coverline("build/datatable-body/datatable-body.js", 454);
return this;
    },

    /**
     Refreshes the provided row against the provided model and the Array of
     columns to be updated.

     @method refreshRow
     @param {Y.Node} row
     @param {Y.Model} model Y.Model representation of the row
     @param {Object[]} columns Array of column configuration objects

     @chainable
     */
    refreshRow: function (row, model, columns) {
        _yuitest_coverfunc("build/datatable-body/datatable-body.js", "refreshRow", 468);
_yuitest_coverline("build/datatable-body/datatable-body.js", 469);
var key,
            cell,
            len = columns.length,
            i;

        _yuitest_coverline("build/datatable-body/datatable-body.js", 474);
for (i = 0; i < len; i++) {
            _yuitest_coverline("build/datatable-body/datatable-body.js", 475);
key = columns[i];
            _yuitest_coverline("build/datatable-body/datatable-body.js", 476);
cell = row.one('.' + this.getClassName('col', key));
            _yuitest_coverline("build/datatable-body/datatable-body.js", 477);
this.refreshCell(cell, model);
        }

        _yuitest_coverline("build/datatable-body/datatable-body.js", 480);
return this;
    },

    /**
     Refreshes the given cell with the provided model data and the provided
     column configuration.

     Uses the provided column formatter if aviable.

     @method refreshCell
     @param {Y.Node} cell Y.Node pointer to the cell element to be updated
     @param {Y.Model} [model] Y.Model representation of the row
     @param {Object} [col] Column configuration object for the cell

     @chainable
     */
    refreshCell: function (cell, model, col) {
        _yuitest_coverfunc("build/datatable-body/datatable-body.js", "refreshCell", 496);
_yuitest_coverline("build/datatable-body/datatable-body.js", 497);
var content,
            formatterFn,
            formatterData,
            data = model.toJSON();

        _yuitest_coverline("build/datatable-body/datatable-body.js", 502);
cell = this.getCell(cell);
        _yuitest_coverline("build/datatable-body/datatable-body.js", 503);
model || (model = this.getRecord(cell));
        _yuitest_coverline("build/datatable-body/datatable-body.js", 504);
col || (col = this.getColumn(cell));

        _yuitest_coverline("build/datatable-body/datatable-body.js", 506);
if (col.nodeFormatter) {
            _yuitest_coverline("build/datatable-body/datatable-body.js", 507);
formatterData = {
                cell: cell.one('.' + this.getClassName('liner')) || cell,
                column: col,
                data: data,
                record: model,
                rowIndex: this._getRowIndex(cell.ancestor('tr')),
                td: cell,
                value: data[col.key]
            };

            _yuitest_coverline("build/datatable-body/datatable-body.js", 517);
keep = col.nodeFormatter.call(host,formatterData);

            _yuitest_coverline("build/datatable-body/datatable-body.js", 519);
if (keep === false) {
                // Remove from the Node cache to reduce
                // memory footprint.  This also purges events,
                // which you shouldn't be scoping to a cell
                // anyway.  You've been warned.  Incidentally,
                // you should always return false. Just sayin.
                _yuitest_coverline("build/datatable-body/datatable-body.js", 525);
cell.destroy(true);
            }

        } else {_yuitest_coverline("build/datatable-body/datatable-body.js", 528);
if (col.formatter) {
            _yuitest_coverline("build/datatable-body/datatable-body.js", 529);
if (!col._formatterFn) {
                _yuitest_coverline("build/datatable-body/datatable-body.js", 530);
col = this._setColumnsFormatterFn([col])[0];
            }

            _yuitest_coverline("build/datatable-body/datatable-body.js", 533);
formatterFn = col._formatterFn || null;

            _yuitest_coverline("build/datatable-body/datatable-body.js", 535);
if (formatterFn) {
                _yuitest_coverline("build/datatable-body/datatable-body.js", 536);
formatterData = {
                    value    : data[col.key],
                    data     : data,
                    column   : col,
                    record   : model,
                    className: '',
                    rowClass : '',
                    rowIndex : this._getRowIndex(cell.ancestor('tr'))
                };

                // Formatters can either return a value ...
                _yuitest_coverline("build/datatable-body/datatable-body.js", 547);
content = formatterFn.call(this.get('host'), formatterData);

                // ... or update the value property of the data obj passed
                _yuitest_coverline("build/datatable-body/datatable-body.js", 550);
if (content === undefined) {
                    _yuitest_coverline("build/datatable-body/datatable-body.js", 551);
content = formatterData.value;
                }
            }

            _yuitest_coverline("build/datatable-body/datatable-body.js", 555);
if (content === undefined || content === null || content === '') {
                _yuitest_coverline("build/datatable-body/datatable-body.js", 556);
content = col.emptyCellValue || '';
            }

        } else {
            _yuitest_coverline("build/datatable-body/datatable-body.js", 560);
content = data[col.key] || col.emptyCellValue || '';
        }}

        _yuitest_coverline("build/datatable-body/datatable-body.js", 563);
cell.setHTML(col.allowHTML ? content : Y.Escape.html(content));

        _yuitest_coverline("build/datatable-body/datatable-body.js", 565);
return this;
    },

    /**
     Returns column data from this.get('columns'). If a Y.Node is provided as
     the key, will try to determine the key from the classname
     @method getColumn
     @param {String|Y.Node} key
     @return {Object} Returns column configuration
     */
    getColumn: function (key) {
        _yuitest_coverfunc("build/datatable-body/datatable-body.js", "getColumn", 575);
_yuitest_coverline("build/datatable-body/datatable-body.js", 576);
if (Y.instanceOf(key, Y.Node)) {
            // get column name from node
            _yuitest_coverline("build/datatable-body/datatable-body.js", 578);
key = key.get('className').match(
                new RegExp( this.getClassName('col') +'-([^ ]*)' )
            )[1];
        }

        _yuitest_coverline("build/datatable-body/datatable-body.js", 583);
var cols = this.get('columns'),
            col = null;

        _yuitest_coverline("build/datatable-body/datatable-body.js", 586);
Y.Array.some(cols, function (_col) {
            _yuitest_coverfunc("build/datatable-body/datatable-body.js", "(anonymous 3)", 586);
_yuitest_coverline("build/datatable-body/datatable-body.js", 587);
if (_col.key === key) {
                _yuitest_coverline("build/datatable-body/datatable-body.js", 588);
col = _col;
                _yuitest_coverline("build/datatable-body/datatable-body.js", 589);
return true;
            }
        });

        _yuitest_coverline("build/datatable-body/datatable-body.js", 593);
return col;
    },

    // -- Protected and private methods ---------------------------------------
    /**
    Handles changes in the source's columns attribute.  Redraws the table data.

    @method _afterColumnsChange
    @param {EventFacade} e The `columnsChange` event object
    @protected
    @since 3.5.0
    **/
    // TODO: Preserve existing DOM
    // This will involve parsing and comparing the old and new column configs
    // and reacting to four types of changes:
    // 1. formatter, nodeFormatter, emptyCellValue changes
    // 2. column deletions
    // 3. column additions
    // 4. column moves (preserve cells)
    _afterColumnsChange: function () {
        _yuitest_coverfunc("build/datatable-body/datatable-body.js", "_afterColumnsChange", 612);
_yuitest_coverline("build/datatable-body/datatable-body.js", 613);
this.render();
    },

    /**
    Handles modelList changes, including additions, deletions, and updates.

    Modifies the existing table DOM accordingly.

    @method _afterDataChange
    @param {EventFacade} e The `change` event from the ModelList
    @protected
    @since 3.5.0
    **/
    _afterDataChange: function (e) {
        _yuitest_coverfunc("build/datatable-body/datatable-body.js", "_afterDataChange", 626);
_yuitest_coverline("build/datatable-body/datatable-body.js", 627);
var type = (e.type.match(/:(add|change|remove)$/) || [])[1],
            index = e.index,
            columns = this.get('columns'),
            col,
            changed = e.changed && Y.Object.keys(e.changed),
            key,
            row,
            i,
            len;

        _yuitest_coverline("build/datatable-body/datatable-body.js", 637);
for (i = 0, len = columns.length; i < len; i++ ) {
            _yuitest_coverline("build/datatable-body/datatable-body.js", 638);
col = columns[i];

            // since nodeFormatters typcially make changes outside of it's
            // cell, we need to see if there are any columns that have a
            // nodeFormatter and if so, we need to do a full render() of the
            // tbody
            _yuitest_coverline("build/datatable-body/datatable-body.js", 644);
if (col.hasOwnProperty('nodeFormatter')) {
                _yuitest_coverline("build/datatable-body/datatable-body.js", 645);
this.render();
                _yuitest_coverline("build/datatable-body/datatable-body.js", 646);
return;
            }
        }

        // TODO: if multiple rows are being added/remove/swapped, can we avoid the restriping?
        _yuitest_coverline("build/datatable-body/datatable-body.js", 651);
switch (type) {
            case 'change':
                _yuitest_coverline("build/datatable-body/datatable-body.js", 653);
for (i = 0, len = columns.length; i < len; i++) {
                    _yuitest_coverline("build/datatable-body/datatable-body.js", 654);
key = col.key || col.name;
                    _yuitest_coverline("build/datatable-body/datatable-body.js", 655);
if (col.formatter && !e.changed[key]) {
                        _yuitest_coverline("build/datatable-body/datatable-body.js", 656);
changed.push(key);
                    }
                }
                _yuitest_coverline("build/datatable-body/datatable-body.js", 659);
this.refreshRow(this.getRow(e.target), e.target, changed);
                _yuitest_coverline("build/datatable-body/datatable-body.js", 660);
break;
            case 'add':
                // we need to make sure we don't have an index larger than the data we have
                _yuitest_coverline("build/datatable-body/datatable-body.js", 663);
index =  Math.min(index, this.get('modelList').size() - 1);

                // updates the columns with formatter functions
                _yuitest_coverline("build/datatable-body/datatable-body.js", 666);
this._setColumnsFormatterFn(columns);
                _yuitest_coverline("build/datatable-body/datatable-body.js", 667);
row = Y.Node.create(this._createRowHTML(e.model, index, columns));
                _yuitest_coverline("build/datatable-body/datatable-body.js", 668);
this.tbodyNode.insert(row, index);
                _yuitest_coverline("build/datatable-body/datatable-body.js", 669);
this._restripe(index);
                _yuitest_coverline("build/datatable-body/datatable-body.js", 670);
break;
            case 'remove':
                _yuitest_coverline("build/datatable-body/datatable-body.js", 672);
this.getRow(index).remove(true);
                // we removed a row, so we need to back up our index to stripe
                _yuitest_coverline("build/datatable-body/datatable-body.js", 674);
this._restripe(index - 1);
                _yuitest_coverline("build/datatable-body/datatable-body.js", 675);
break;
            default:
                _yuitest_coverline("build/datatable-body/datatable-body.js", 677);
this.render();
        }
    },

    /**
     Toggles the odd/even classname of the row after the given index. This method
     is used to update rows after a row is inserted into or removed from the table.
     Note this event is delayed so the table is only restriped once when multiple
     rows are updated at one time.

     @protected
     @method _restripe
     @param {Number} [index] Index of row to start restriping after
     @since @SINCE@
     */
    _restripe: function (index) {
        _yuitest_coverfunc("build/datatable-body/datatable-body.js", "_restripe", 692);
_yuitest_coverline("build/datatable-body/datatable-body.js", 693);
var task = this._restripeTask,
            self;

        // index|0 to force int, avoid NaN. Math.max() to avoid neg indexes.
        _yuitest_coverline("build/datatable-body/datatable-body.js", 697);
index = Math.max((index|0), 0);

        _yuitest_coverline("build/datatable-body/datatable-body.js", 699);
if (!task) {
            _yuitest_coverline("build/datatable-body/datatable-body.js", 700);
self = this;

            _yuitest_coverline("build/datatable-body/datatable-body.js", 702);
this._restripeTask = {
                timer: setTimeout(function () {
                    // Check for self existence before continuing
                    _yuitest_coverfunc("build/datatable-body/datatable-body.js", "(anonymous 4)", 703);
_yuitest_coverline("build/datatable-body/datatable-body.js", 705);
if (!self || self.get('destroy') || !self.tbodyNode || !self.tbodyNode.inDoc()) {
                        _yuitest_coverline("build/datatable-body/datatable-body.js", 706);
self._restripeTask = null;
                        _yuitest_coverline("build/datatable-body/datatable-body.js", 707);
return;
                    }

                    _yuitest_coverline("build/datatable-body/datatable-body.js", 710);
var odd  = [self.CLASS_ODD, self.CLASS_EVEN],
                        even = [self.CLASS_EVEN, self.CLASS_ODD],
                        index = self._restripeTask.index;

                    _yuitest_coverline("build/datatable-body/datatable-body.js", 714);
self.tbodyNode.get('childNodes')
                        .slice(index)
                        .each(function (row, i) { // TODO: each vs batch
                            _yuitest_coverfunc("build/datatable-body/datatable-body.js", "(anonymous 5)", 716);
_yuitest_coverline("build/datatable-body/datatable-body.js", 717);
row.replaceClass.apply(row, (index + i) % 2 ? even : odd);
                        });

                    _yuitest_coverline("build/datatable-body/datatable-body.js", 720);
self._restripeTask = null;
                }, 0),

                index: index
            };
        } else {
            _yuitest_coverline("build/datatable-body/datatable-body.js", 726);
task.index = Math.min(task.index, index);
        }

    },

    /**
    Handles replacement of the modelList.

    Rerenders the `<tbody>` contents.

    @method _afterModelListChange
    @param {EventFacade} e The `modelListChange` event
    @protected
    @since 3.6.0
    **/
    _afterModelListChange: function () {
        _yuitest_coverfunc("build/datatable-body/datatable-body.js", "_afterModelListChange", 741);
_yuitest_coverline("build/datatable-body/datatable-body.js", 742);
var handles = this._eventHandles;

        _yuitest_coverline("build/datatable-body/datatable-body.js", 744);
if (handles.dataChange) {
            _yuitest_coverline("build/datatable-body/datatable-body.js", 745);
handles.dataChange.detach();
            _yuitest_coverline("build/datatable-body/datatable-body.js", 746);
delete handles.dataChange;
            _yuitest_coverline("build/datatable-body/datatable-body.js", 747);
this.bindUI();
        }

        _yuitest_coverline("build/datatable-body/datatable-body.js", 750);
if (this.tbodyNode) {
            _yuitest_coverline("build/datatable-body/datatable-body.js", 751);
this.render();
        }
    },

    /**
    Iterates the `modelList`, and calls any `nodeFormatter`s found in the
    `columns` param on the appropriate cell Nodes in the `tbody`.

    @method _applyNodeFormatters
    @param {Node} tbody The `<tbody>` Node whose columns to update
    @param {Object[]} columns The column configurations
    @protected
    @since 3.5.0
    **/
    _applyNodeFormatters: function (tbody, columns) {
        _yuitest_coverfunc("build/datatable-body/datatable-body.js", "_applyNodeFormatters", 765);
_yuitest_coverline("build/datatable-body/datatable-body.js", 766);
var host = this.host || this,
            data = this.get('modelList'),
            formatters = [],
            linerQuery = '.' + this.getClassName('liner'),
            rows, i, len;

        // Only iterate the ModelList again if there are nodeFormatters
        _yuitest_coverline("build/datatable-body/datatable-body.js", 773);
for (i = 0, len = columns.length; i < len; ++i) {
            _yuitest_coverline("build/datatable-body/datatable-body.js", 774);
if (columns[i].nodeFormatter) {
                _yuitest_coverline("build/datatable-body/datatable-body.js", 775);
formatters.push(i);
            }
        }

        _yuitest_coverline("build/datatable-body/datatable-body.js", 779);
if (data && formatters.length) {
            _yuitest_coverline("build/datatable-body/datatable-body.js", 780);
rows = tbody.get('childNodes');

            _yuitest_coverline("build/datatable-body/datatable-body.js", 782);
data.each(function (record, index) {
                _yuitest_coverfunc("build/datatable-body/datatable-body.js", "(anonymous 6)", 782);
_yuitest_coverline("build/datatable-body/datatable-body.js", 783);
var formatterData = {
                        data      : record.toJSON(),
                        record    : record,
                        rowIndex  : index
                    },
                    row = rows.item(index),
                    i, len, col, key, cells, cell, keep;


                _yuitest_coverline("build/datatable-body/datatable-body.js", 792);
if (row) {
                    _yuitest_coverline("build/datatable-body/datatable-body.js", 793);
cells = row.get('childNodes');
                    _yuitest_coverline("build/datatable-body/datatable-body.js", 794);
for (i = 0, len = formatters.length; i < len; ++i) {
                        _yuitest_coverline("build/datatable-body/datatable-body.js", 795);
cell = cells.item(formatters[i]);

                        _yuitest_coverline("build/datatable-body/datatable-body.js", 797);
if (cell) {
                            _yuitest_coverline("build/datatable-body/datatable-body.js", 798);
col = formatterData.column = columns[formatters[i]];
                            _yuitest_coverline("build/datatable-body/datatable-body.js", 799);
key = col.key || col.id;

                            _yuitest_coverline("build/datatable-body/datatable-body.js", 801);
formatterData.value = record.get(key);
                            _yuitest_coverline("build/datatable-body/datatable-body.js", 802);
formatterData.td    = cell;
                            _yuitest_coverline("build/datatable-body/datatable-body.js", 803);
formatterData.cell  = cell.one(linerQuery) || cell;

                            _yuitest_coverline("build/datatable-body/datatable-body.js", 805);
keep = col.nodeFormatter.call(host,formatterData);

                            _yuitest_coverline("build/datatable-body/datatable-body.js", 807);
if (keep === false) {
                                // Remove from the Node cache to reduce
                                // memory footprint.  This also purges events,
                                // which you shouldn't be scoping to a cell
                                // anyway.  You've been warned.  Incidentally,
                                // you should always return false. Just sayin.
                                _yuitest_coverline("build/datatable-body/datatable-body.js", 813);
cell.destroy(true);
                            }
                        }
                    }
                }
            });
        }
    },

    /**
    Binds event subscriptions from the UI and the host (if assigned).

    @method bindUI
    @protected
    @since 3.5.0
    **/
    bindUI: function () {
        _yuitest_coverfunc("build/datatable-body/datatable-body.js", "bindUI", 829);
_yuitest_coverline("build/datatable-body/datatable-body.js", 830);
var handles     = this._eventHandles,
            modelList   = this.get('modelList'),
            changeEvent = modelList.model.NAME + ':change';

        _yuitest_coverline("build/datatable-body/datatable-body.js", 834);
if (!handles.columnsChange) {
            _yuitest_coverline("build/datatable-body/datatable-body.js", 835);
handles.columnsChange = this.after('columnsChange',
                bind('_afterColumnsChange', this));
        }

        _yuitest_coverline("build/datatable-body/datatable-body.js", 839);
if (modelList && !handles.dataChange) {
            _yuitest_coverline("build/datatable-body/datatable-body.js", 840);
handles.dataChange = modelList.after(
                ['add', 'remove', 'reset', changeEvent],
                bind('_afterDataChange', this));
        }
    },

    /**
    Iterates the `modelList` and applies each Model to the `_rowTemplate`,
    allowing any column `formatter` or `emptyCellValue` to override cell
    content for the appropriate column.  The aggregated HTML string is
    returned.

    @method _createDataHTML
    @param {Object[]} columns The column configurations to customize the
                generated cell content or class names
    @return {HTML} The markup for all Models in the `modelList`, each applied
                to the `_rowTemplate`
    @protected
    @since 3.5.0
    **/
    _createDataHTML: function (columns) {
        _yuitest_coverfunc("build/datatable-body/datatable-body.js", "_createDataHTML", 860);
_yuitest_coverline("build/datatable-body/datatable-body.js", 861);
var data = this.get('modelList'),
            html = '';

        _yuitest_coverline("build/datatable-body/datatable-body.js", 864);
if (data) {
            _yuitest_coverline("build/datatable-body/datatable-body.js", 865);
data.each(function (model, index) {
                _yuitest_coverfunc("build/datatable-body/datatable-body.js", "(anonymous 7)", 865);
_yuitest_coverline("build/datatable-body/datatable-body.js", 866);
html += this._createRowHTML(model, index, columns);
            }, this);
        }

        _yuitest_coverline("build/datatable-body/datatable-body.js", 870);
return html;
    },

    /**
    Applies the data of a given Model, modified by any column formatters and
    supplemented by other template values to the instance's `_rowTemplate` (see
    `_createRowTemplate`).  The generated string is then returned.

    The data from Model's attributes is fetched by `toJSON` and this data
    object is appended with other properties to supply values to {placeholders}
    in the template.  For a template generated from a Model with 'foo' and 'bar'
    attributes, the data object would end up with the following properties
    before being used to populate the `_rowTemplate`:

      * `clientID` - From Model, used the assign the `<tr>`'s 'id' attribute.
      * `foo` - The value to populate the 'foo' column cell content.  This
        value will be the value stored in the Model's `foo` attribute, or the
        result of the column's `formatter` if assigned.  If the value is '',
        `null`, or `undefined`, and the column's `emptyCellValue` is assigned,
        that value will be used.
      * `bar` - Same for the 'bar' column cell content.
      * `foo-className` - String of CSS classes to apply to the `<td>`.
      * `bar-className` - Same.
      * `rowClass`      - String of CSS classes to apply to the `<tr>`. This
        will be the odd/even class per the specified index plus any additional
        classes assigned by column formatters (via `o.rowClass`).

    Because this object is available to formatters, any additional properties
    can be added to fill in custom {placeholders} in the `_rowTemplate`.

    @method _createRowHTML
    @param {Model} model The Model instance to apply to the row template
    @param {Number} index The index the row will be appearing
    @param {Object[]} columns The column configurations
    @return {HTML} The markup for the provided Model, less any `nodeFormatter`s
    @protected
    @since 3.5.0
    **/
    _createRowHTML: function (model, index, columns) {
        _yuitest_coverfunc("build/datatable-body/datatable-body.js", "_createRowHTML", 908);
_yuitest_coverline("build/datatable-body/datatable-body.js", 909);
var data     = model.toJSON(),
            clientId = model.get('clientId'),
            values   = {
                rowId   : this._getRowId(clientId),
                clientId: clientId,
                rowClass: (index % 2) ? this.CLASS_ODD : this.CLASS_EVEN
            },
            host = this.host || this,
            i, len, col, token, value, formatterData;

        _yuitest_coverline("build/datatable-body/datatable-body.js", 919);
for (i = 0, len = columns.length; i < len; ++i) {
            _yuitest_coverline("build/datatable-body/datatable-body.js", 920);
col   = columns[i];
            _yuitest_coverline("build/datatable-body/datatable-body.js", 921);
value = data[col.key];
            _yuitest_coverline("build/datatable-body/datatable-body.js", 922);
token = col._id || col.key;

            _yuitest_coverline("build/datatable-body/datatable-body.js", 924);
values[token + '-className'] = '';

            _yuitest_coverline("build/datatable-body/datatable-body.js", 926);
if (col._formatterFn) {
                _yuitest_coverline("build/datatable-body/datatable-body.js", 927);
formatterData = {
                    value    : value,
                    data     : data,
                    column   : col,
                    record   : model,
                    className: '',
                    rowClass : '',
                    rowIndex : index
                };

                // Formatters can either return a value
                _yuitest_coverline("build/datatable-body/datatable-body.js", 938);
value = col._formatterFn.call(host, formatterData);

                // or update the value property of the data obj passed
                _yuitest_coverline("build/datatable-body/datatable-body.js", 941);
if (value === undefined) {
                    _yuitest_coverline("build/datatable-body/datatable-body.js", 942);
value = formatterData.value;
                }

                _yuitest_coverline("build/datatable-body/datatable-body.js", 945);
values[token + '-className'] = formatterData.className;
                _yuitest_coverline("build/datatable-body/datatable-body.js", 946);
values.rowClass += ' ' + formatterData.rowClass;
            }

            _yuitest_coverline("build/datatable-body/datatable-body.js", 949);
if (value === undefined || value === null || value === '') {
                _yuitest_coverline("build/datatable-body/datatable-body.js", 950);
value = col.emptyCellValue || '';
            }

            _yuitest_coverline("build/datatable-body/datatable-body.js", 953);
values[token] = col.allowHTML ? value : htmlEscape(value);

            _yuitest_coverline("build/datatable-body/datatable-body.js", 955);
values.rowClass = values.rowClass.replace(/\s+/g, ' ');
        }

        _yuitest_coverline("build/datatable-body/datatable-body.js", 958);
return fromTemplate(this._rowTemplate, values);
    },

    /**
     Locates the row within the tbodyNode and returns the found index, or Null
     if it is not found in the tbodyNode
     @param {Y.Node} row
     @return {Number} Index of row in tbodyNode
     */
    _getRowIndex: function (row) {
        _yuitest_coverfunc("build/datatable-body/datatable-body.js", "_getRowIndex", 967);
_yuitest_coverline("build/datatable-body/datatable-body.js", 968);
var tbody = this.tbodyNode,
            index = 1;

        _yuitest_coverline("build/datatable-body/datatable-body.js", 971);
if (tbody && row) {

            //if row is not in the tbody, return
            _yuitest_coverline("build/datatable-body/datatable-body.js", 974);
if (row.ancestor('tbody') !== tbody) {
                _yuitest_coverline("build/datatable-body/datatable-body.js", 975);
return null;
            }

            // increment until we no longer have a previous node
            _yuitest_coverline("build/datatable-body/datatable-body.js", 979);
while (row = row.previous()) { // NOTE: assignment
                _yuitest_coverline("build/datatable-body/datatable-body.js", 980);
index++;
            }
        }

        _yuitest_coverline("build/datatable-body/datatable-body.js", 984);
return index;
    },

    /**
    Creates a custom HTML template string for use in generating the markup for
    individual table rows with {placeholder}s to capture data from the Models
    in the `modelList` attribute or from column `formatter`s.

    Assigns the `_rowTemplate` property.

    @method _createRowTemplate
    @param {Object[]} columns Array of column configuration objects
    @protected
    @since 3.5.0
    **/
    _createRowTemplate: function (columns) {
        _yuitest_coverfunc("build/datatable-body/datatable-body.js", "_createRowTemplate", 999);
_yuitest_coverline("build/datatable-body/datatable-body.js", 1000);
var html         = '',
            cellTemplate = this.CELL_TEMPLATE,
            i, len, col, key, token, headers, tokenValues, formatter;

        _yuitest_coverline("build/datatable-body/datatable-body.js", 1004);
this._setColumnsFormatterFn(columns);

        _yuitest_coverline("build/datatable-body/datatable-body.js", 1006);
for (i = 0, len = columns.length; i < len; ++i) {
            _yuitest_coverline("build/datatable-body/datatable-body.js", 1007);
col     = columns[i];
            _yuitest_coverline("build/datatable-body/datatable-body.js", 1008);
key     = col.key;
            _yuitest_coverline("build/datatable-body/datatable-body.js", 1009);
token   = col._id || key;
            _yuitest_coverline("build/datatable-body/datatable-body.js", 1010);
formatter = col._formatterFn;
            // Only include headers if there are more than one
            _yuitest_coverline("build/datatable-body/datatable-body.js", 1012);
headers = (col._headers || []).length > 1 ?
                        'headers="' + col._headers.join(' ') + '"' : '';

            _yuitest_coverline("build/datatable-body/datatable-body.js", 1015);
tokenValues = {
                content  : '{' + token + '}',
                headers  : headers,
                className: this.getClassName('col', token) + ' ' +
                           (col.className || '') + ' ' +
                           this.getClassName('cell') +
                           ' {' + token + '-className}'
            };
            _yuitest_coverline("build/datatable-body/datatable-body.js", 1023);
if (!formatter && col.formatter) {
                _yuitest_coverline("build/datatable-body/datatable-body.js", 1024);
tokenValues.content = col.formatter.replace(valueRegExp, tokenValues.content);
            }

            _yuitest_coverline("build/datatable-body/datatable-body.js", 1027);
if (col.nodeFormatter) {
                // Defer all node decoration to the formatter
                _yuitest_coverline("build/datatable-body/datatable-body.js", 1029);
tokenValues.content = '';
            }

            _yuitest_coverline("build/datatable-body/datatable-body.js", 1032);
html += fromTemplate(col.cellTemplate || cellTemplate, tokenValues);
        }

        _yuitest_coverline("build/datatable-body/datatable-body.js", 1035);
this._rowTemplate = fromTemplate(this.ROW_TEMPLATE, {
            content: html
        });
    },

    /**
     Parses the columns array and defines the column's _formatterFn if there
     is a formatter available on the column
     @protected
     @method _setColumnsFormatterFn
     @param {Object[]} columns Array of column configuration objects

     @return {Object[]} Returns modified columns configuration Array
     */
    _setColumnsFormatterFn: function (columns) {
        _yuitest_coverfunc("build/datatable-body/datatable-body.js", "_setColumnsFormatterFn", 1049);
_yuitest_coverline("build/datatable-body/datatable-body.js", 1050);
var Formatters = Y.DataTable.BodyView.Formatters,
            formatter,
            col,
            i,
            len;

        _yuitest_coverline("build/datatable-body/datatable-body.js", 1056);
for (i = 0, len = columns.length; i < len; i++) {
            _yuitest_coverline("build/datatable-body/datatable-body.js", 1057);
col = columns[i];
            _yuitest_coverline("build/datatable-body/datatable-body.js", 1058);
formatter = col.formatter;

            _yuitest_coverline("build/datatable-body/datatable-body.js", 1060);
if (!col._formatterFn && formatter) {
                _yuitest_coverline("build/datatable-body/datatable-body.js", 1061);
if (Lang.isFunction(formatter)) {
                    _yuitest_coverline("build/datatable-body/datatable-body.js", 1062);
col._formatterFn = formatter;
                } else {_yuitest_coverline("build/datatable-body/datatable-body.js", 1063);
if (formatter in Formatters) {
                    _yuitest_coverline("build/datatable-body/datatable-body.js", 1064);
col._formatterFn = Formatters[formatter].call(this.host || this, col);
                }}
            }
        }

        _yuitest_coverline("build/datatable-body/datatable-body.js", 1069);
return columns;
    },

    /**
    Creates the `<tbody>` node that will store the data rows.

    @method _createTBodyNode
    @return {Node}
    @protected
    @since 3.6.0
    **/
    _createTBodyNode: function () {
        _yuitest_coverfunc("build/datatable-body/datatable-body.js", "_createTBodyNode", 1080);
_yuitest_coverline("build/datatable-body/datatable-body.js", 1081);
return Y.Node.create(fromTemplate(this.TBODY_TEMPLATE, {
            className: this.getClassName('data')
        }));
    },

    /**
    Destroys the instance.

    @method destructor
    @protected
    @since 3.5.0
    **/
    destructor: function () {
        _yuitest_coverfunc("build/datatable-body/datatable-body.js", "destructor", 1093);
_yuitest_coverline("build/datatable-body/datatable-body.js", 1094);
(new Y.EventHandle(YObject.values(this._eventHandles))).detach();
    },

    /**
    Holds the event subscriptions needing to be detached when the instance is
    `destroy()`ed.

    @property _eventHandles
    @type {Object}
    @default undefined (initially unset)
    @protected
    @since 3.5.0
    **/
    //_eventHandles: null,

    /**
    Returns the row ID associated with a Model's clientId.

    @method _getRowId
    @param {String} clientId The Model clientId
    @return {String}
    @protected
    **/
    _getRowId: function (clientId) {
        _yuitest_coverfunc("build/datatable-body/datatable-body.js", "_getRowId", 1117);
_yuitest_coverline("build/datatable-body/datatable-body.js", 1118);
return this._idMap[clientId] || (this._idMap[clientId] = Y.guid());
    },

    /**
    Map of Model clientIds to row ids.

    @property _idMap
    @type {Object}
    @protected
    **/
    //_idMap,

    /**
    Initializes the instance. Reads the following configuration properties in
    addition to the instance attributes:

      * `columns` - (REQUIRED) The initial column information
      * `host`    - The object to serve as source of truth for column info and
                    for generating class names

    @method initializer
    @param {Object} config Configuration data
    @protected
    @since 3.5.0
    **/
    initializer: function (config) {
        _yuitest_coverfunc("build/datatable-body/datatable-body.js", "initializer", 1143);
_yuitest_coverline("build/datatable-body/datatable-body.js", 1144);
this.host = config.host;

        _yuitest_coverline("build/datatable-body/datatable-body.js", 1146);
this._eventHandles = {
            modelListChange: this.after('modelListChange',
                bind('_afterModelListChange', this))
        };
        _yuitest_coverline("build/datatable-body/datatable-body.js", 1150);
this._idMap = {};

        _yuitest_coverline("build/datatable-body/datatable-body.js", 1152);
this.CLASS_ODD  = this.getClassName('odd');
        _yuitest_coverline("build/datatable-body/datatable-body.js", 1153);
this.CLASS_EVEN = this.getClassName('even');

    }

    /**
    The HTML template used to create a full row of markup for a single Model in
    the `modelList` plus any customizations defined in the column
    configurations.

    @property _rowTemplate
    @type {HTML}
    @default (initially unset)
    @protected
    @since 3.5.0
    **/
    //_rowTemplate: null
},{
    /**
    Hash of formatting functions for cell contents.

    This property can be populated with a hash of formatting functions by the developer
    or a set of pre-defined functions can be loaded via the `datatable-formatters` module.

    See: [DataTable.BodyView.Formatters](./DataTable.BodyView.Formatters.html)
    @property Formatters
    @type Object
    @since 3.8.0
    @static
    **/
    Formatters: {}
});


}, '@VERSION@', {"requires": ["datatable-core", "view", "classnamemanager"]});
