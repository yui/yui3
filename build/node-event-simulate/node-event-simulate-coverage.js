if (typeof __coverage__ === 'undefined') { __coverage__ = {}; }
if (!__coverage__['build/node-event-simulate/node-event-simulate.js']) {
   __coverage__['build/node-event-simulate/node-event-simulate.js'] = {"path":"build/node-event-simulate/node-event-simulate.js","s":{"1":0,"2":0,"3":0,"4":0,"5":0},"b":{},"f":{"1":0,"2":0,"3":0},"fnMap":{"1":{"name":"(anonymous_1)","line":1,"loc":{"start":{"line":1,"column":31},"end":{"line":1,"column":50}}},"2":{"name":"(anonymous_2)","line":17,"loc":{"start":{"line":17,"column":28},"end":{"line":17,"column":53}}},"3":{"name":"(anonymous_3)","line":183,"loc":{"start":{"line":183,"column":35},"end":{"line":183,"column":64}}}},"statementMap":{"1":{"start":{"line":1,"column":0},"end":{"line":189,"column":83}},"2":{"start":{"line":17,"column":0},"end":{"line":20,"column":2}},"3":{"start":{"line":19,"column":4},"end":{"line":19,"column":61}},"4":{"start":{"line":183,"column":0},"end":{"line":186,"column":2}},"5":{"start":{"line":185,"column":4},"end":{"line":185,"column":53}}},"branchMap":{},"code":["(function () { YUI.add('node-event-simulate', function (Y, NAME) {","","/**\r"," * Adds functionality to simulate events.\r"," * @module node\r"," * @submodule node-event-simulate\r"," */\r","\r","/**\r"," * Simulates an event on the node.\r"," * @param {String} type The type of event (i.e., \"click\").\r"," * @param {Object} options (Optional) Extra options to copy onto the event object.\r"," * @return {void}\r"," * @for Node\r"," * @method simulate\r"," */\r","Y.Node.prototype.simulate = function (type, options) {\r","    \r","    Y.Event.simulate(Y.Node.getDOMNode(this), type, options);\r","};\r","\r","/**\r"," * Simulates the higher user level gesture of the given name on this node. \r"," * This method generates a set of low level touch events(Apple specific gesture \r"," * events as well for the iOS platforms) asynchronously. Note that gesture  \r"," * simulation is relying on `Y.Event.simulate()` method to generate \r"," * the touch events under the hood. The `Y.Event.simulate()` method\r"," * itself is a synchronous method.\r"," * \r"," * Supported gestures are `tap`, `doubletap`, `press`, `move`, `flick`, `pinch`\r"," * and `rotate`.\r"," * \r"," * The `pinch` gesture is used to simulate the pinching and spreading of two\r"," * fingers. During a pinch simulation, rotation is also possible. Essentially\r"," * `pinch` and `rotate` simulations share the same base implementation to allow\r"," * both pinching and rotation at the same time. The only difference is `pinch`\r"," * requires `start` and `end` option properties while `rotate` requires `rotation` \r"," * option property.\r"," * \r"," * The `pinch` and `rotate` gestures can be described as placing 2 fingers along a\r"," * circle. Pinching and spreading can be described by start and end circles while \r"," * rotation occurs on a single circle. If the radius of the start circle is greater \r"," * than the end circle, the gesture becomes a pinch, otherwise it is a spread spread.\r"," * \r"," * @example\r"," *\r"," *     var node = Y.one(\"#target\");\r"," *       \r"," *     // double tap example\r"," *     node.simulateGesture(\"doubletap\", function() {\r"," *         // my callback function\r"," *     });\r"," *     \r"," *     // flick example from the center of the node, move 50 pixels down for 50ms)\r"," *     node.simulateGesture(\"flick\", {\r"," *         axis: y,\r"," *         distance: -100\r"," *         duration: 50\r"," *     }, function() {\r"," *         // my callback function\r"," *     });\r"," *     \r"," *     // simulate rotating a node 75 degrees counter-clockwise \r"," *     node.simulateGesture(\"rotate\", {\r"," *         rotation: -75\r"," *     });\r"," *\r"," *     // simulate a pinch and a rotation at the same time. \r"," *     // fingers start on a circle of radius 100 px, placed at top/bottom\r"," *     // fingers end on a circle of radius 50px, placed at right/left \r"," *     node.simulateGesture(\"pinch\", {\r"," *         r1: 100,\r"," *         r2: 50,\r"," *         start: 0\r"," *         rotation: 90\r"," *     });\r"," *     \r"," * @method simulateGesture\r"," * @param {String} name The name of the supported gesture to simulate. The \r"," *      supported gesture name is one of \"tap\", \"doubletap\", \"press\", \"move\", \r"," *      \"flick\", \"pinch\" and \"rotate\". \r"," * @param {Object} [options] Extra options used to define the gesture behavior:\r"," * \r"," *      Valid options properties for the `tap` gesture:\r"," *      \r"," *      @param {Array} [options.point] (Optional) Indicates the [x,y] coordinates \r"," *        where the tap should be simulated. Default is the center of the node \r"," *        element.\r"," *      @param {Number} [options.hold=10] (Optional) The hold time in milliseconds. \r"," *        This is the time between `touchstart` and `touchend` event generation.\r"," *      @param {Number} [options.times=1] (Optional) Indicates the number of taps.\r"," *      @param {Number} [options.delay=10] (Optional) The number of milliseconds \r"," *        before the next tap simulation happens. This is valid only when `times` \r"," *        is more than 1. \r"," *        \r"," *      Valid options properties for the `doubletap` gesture:\r"," *      \r"," *      @param {Array} [options.point] (Optional) Indicates the [x,y] coordinates \r"," *        where the doubletap should be simulated. Default is the center of the \r"," *        node element.\r"," * \r"," *      Valid options properties for the `press` gesture:\r"," *      \r"," *      @param {Array} [options.point] (Optional) Indicates the [x,y] coordinates \r"," *        where the press should be simulated. Default is the center of the node \r"," *        element.\r"," *      @param {Number} [options.hold=3000] (Optional) The hold time in milliseconds. \r"," *        This is the time between `touchstart` and `touchend` event generation. \r"," *        Default is 3000ms (3 seconds).\r"," * \r"," *      Valid options properties for the `move` gesture:\r"," *      \r"," *      @param {Object} [options.path] (Optional) Indicates the path of the finger \r"," *        movement. It's an object with three optional properties: `point`, \r"," *        `xdist` and  `ydist`.\r"," *        @param {Array} [options.path.point] A starting point of the gesture.\r"," *          Default is the center of the node element.\r"," *        @param {Number} [options.path.xdist=200] A distance to move in pixels  \r"," *          along the X axis. A negative distance value indicates moving left.\r"," *        @param {Number} [options.path.ydist=0] A distance to move in pixels  \r"," *          along the Y axis. A negative distance value indicates moving up.\r"," *      @param {Number} [options.duration=1000] (Optional) The duration of the \r"," *        gesture in milliseconds.\r"," * \r"," *      Valid options properties for the `flick` gesture:\r"," *      \r"," *      @param {Array} [options.point] (Optional) Indicates the [x, y] coordinates \r"," *        where the flick should be simulated. Default is the center of the \r"," *        node element.\r"," *      @param {String} [options.axis='x'] (Optional) Valid values are either \r"," *        \"x\" or \"y\". Indicates axis to move along. The flick can move to one of \r"," *        4 directions(left, right, up and down).\r"," *      @param {Number} [options.distance=200] (Optional) Distance to move in pixels\r"," *      @param {Number} [options.duration=1000] (Optional) The duration of the \r"," *        gesture in milliseconds. User given value could be automatically \r"," *        adjusted by the framework if it is below the minimum velocity to be \r"," *        a flick gesture.\r"," * \r"," *      Valid options properties for the `pinch` gesture:\r"," *      \r"," *      @param {Array} [options.center] (Optional) The center of the circle where \r"," *        two fingers are placed. Default is the center of the node element.\r"," *      @param {Number} [options.r1] (Required) Pixel radius of the start circle \r"," *        where 2 fingers will be on when the gesture starts. The circles are \r"," *        centered at the center of the element.\r"," *      @param {Number} [options.r2] (Required) Pixel radius of the end circle \r"," *        when this gesture ends.\r"," *      @param {Number} [options.duration=1000] (Optional) The duration of the \r"," *        gesture in milliseconds.\r"," *      @param {Number} [options.start=0] (Optional) Starting degree of the first \r"," *        finger. The value is relative to the path of the north. Default is 0 \r"," *        (i.e., 12:00 on a clock).\r"," *      @param {Number} [options.rotation=0] (Optional) Degrees to rotate from \r"," *        the starting degree. A negative value means rotation to the \r"," *        counter-clockwise direction.\r"," * \r"," *      Valid options properties for the `rotate` gesture:\r"," *      \r"," *      @param {Array} [options.center] (Optional) The center of the circle where \r"," *        two fingers are placed. Default is the center of the node element.\r"," *      @param {Number} [options.r1] (Optional) Pixel radius of the start circle \r"," *        where 2 fingers will be on when the gesture starts. The circles are \r"," *        centered at the center of the element. Default is a fourth of the node \r"," *        element width or height, whichever is smaller.\r"," *      @param {Number} [options.r2] (Optional) Pixel radius of the end circle \r"," *        when this gesture ends. Default is a fourth of the node element width or \r"," *        height, whichever is smaller.\r"," *      @param {Number} [options.duration=1000] (Optional) The duration of the \r"," *        gesture in milliseconds.\r"," *      @param {Number} [options.start=0] (Optional) Starting degree of the first \r"," *        finger. The value is relative to the path of the north. Default is 0 \r"," *        (i.e., 12:00 on a clock).\r"," *      @param {Number} [options.rotation] (Required) Degrees to rotate from \r"," *        the starting degree. A negative value means rotation to the \r"," *        counter-clockwise direction.\r"," * \r"," * @param {Function} [cb] The callback to execute when the asynchronouse gesture  \r"," *      simulation is completed. \r"," *      @param {Error} cb.err An error object if the simulation is failed.  \r"," * @return {void}\r"," * @for Node\r"," */\r","Y.Node.prototype.simulateGesture = function (name, options, cb) {\r","\r","    Y.Event.simulateGesture(this, name, options, cb);\r","};\r","","","}, '@VERSION@', {\"requires\": [\"node-base\", \"event-simulate\", \"gesture-simulate\"]});","","}());"]};
}
var __cov_ghUrkaeEPJzSfU8Btpy5$g = __coverage__['build/node-event-simulate/node-event-simulate.js'];
__cov_ghUrkaeEPJzSfU8Btpy5$g.s['1']++;YUI.add('node-event-simulate',function(Y,NAME){__cov_ghUrkaeEPJzSfU8Btpy5$g.f['1']++;__cov_ghUrkaeEPJzSfU8Btpy5$g.s['2']++;Y.Node.prototype.simulate=function(type,options){__cov_ghUrkaeEPJzSfU8Btpy5$g.f['2']++;__cov_ghUrkaeEPJzSfU8Btpy5$g.s['3']++;Y.Event.simulate(Y.Node.getDOMNode(this),type,options);};__cov_ghUrkaeEPJzSfU8Btpy5$g.s['4']++;Y.Node.prototype.simulateGesture=function(name,options,cb){__cov_ghUrkaeEPJzSfU8Btpy5$g.f['3']++;__cov_ghUrkaeEPJzSfU8Btpy5$g.s['5']++;Y.Event.simulateGesture(this,name,options,cb);};},'@VERSION@',{'requires':['node-base','event-simulate','gesture-simulate']});
