if (typeof _yuitest_coverage == "undefined"){
    _yuitest_coverage = {};
    _yuitest_coverline = function(src, line){
        var coverage = _yuitest_coverage[src];
        if (!coverage.lines[line]){
            coverage.calledLines++;
        }
        coverage.lines[line]++;
    };
    _yuitest_coverfunc = function(src, name, line){
        var coverage = _yuitest_coverage[src],
            funcId = name + ":" + line;
        if (!coverage.functions[funcId]){
            coverage.calledFunctions++;
        }
        coverage.functions[funcId]++;
    };
}
_yuitest_coverage["build/charts-base/charts-base.js"] = {
    lines: {},
    functions: {},
    coveredLines: 0,
    calledLines: 0,
    coveredFunctions: 0,
    calledFunctions: 0,
    path: "build/charts-base/charts-base.js",
    code: []
};
_yuitest_coverage["build/charts-base/charts-base.js"].code=["YUI.add('charts-base', function (Y, NAME) {","","/**"," * The Charts widget provides an api for displaying data"," * graphically."," *"," * @module charts"," * @main charts"," */","","/**"," * The charts-base submodule contains the core functionality for the charts module."," *"," * @module charts"," * @submodule charts-base"," */","var CONFIG = Y.config,","    WINDOW = CONFIG.win,","    DOCUMENT = CONFIG.doc,","    Y_Lang = Y.Lang,","    IS_STRING = Y_Lang.isString,","    Y_DOM = Y.DOM,","    LeftAxisLayout,","    RightAxisLayout,","    BottomAxisLayout,","    TopAxisLayout,","    _getClassName = Y.ClassNameManager.getClassName,","    SERIES_MARKER = _getClassName(\"seriesmarker\"),","    ShapeGroup,","    CircleGroup,","    RectGroup,","    EllipseGroup,","    DiamondGroup;","","/**"," * Abstract class for creating groups of shapes with the same styles and dimensions."," *"," * @class ShapeGroup"," * @constructor"," */"," ShapeGroup = function(cfg)"," {","    ShapeGroup.superclass.constructor.apply(this, arguments);"," };",""," ShapeGroup.NAME = \"shapeGroup\";",""," Y.extend(ShapeGroup, Y.Path, {","    /**","     * Updates the shape.","     *","     * @method _draw","     * @private","     */","    _draw: function()","    {","        var xvalues = this.get(\"xvalues\"),","            yvalues = this.get(\"yvalues\"),","            x,","            y,","            xRad,","            yRad,","            i = 0,","            len,","            attrs = [],","            dimensions = this.get(\"dimensions\"),","            width = dimensions.width,","            height = dimensions.height,","            radius = dimensions.radius,","            yRadius = dimensions.yRadius,","            id = this.get(\"id\"),","            className = this.node.className,","            widthIsArray = Y_Lang.isArray(width),","            heightIsArray = Y_Lang.isArray(height),","            radiusIsArray = Y_Lang.isArray(radius),","            yRadiusIsArray = Y_Lang.isArray(yRadius);","        if(xvalues && yvalues && xvalues.length > 0)","        {","            this.clear();","","            len = xvalues.length;","            for(; i < len; ++i)","            {","                x = xvalues[i];","                y = yvalues[i];","                xRad = radiusIsArray ? radius[i] : radius;","                yRad = yRadiusIsArray ? yRadius[i] : yRadius;","                if(!isNaN(x) && !isNaN(y) && !isNaN(xRad))","                {","                    this.drawShape({","                        x: x,","                        y: y,","                        width: widthIsArray ? width[i] : width,","                        height: heightIsArray ? height[i] : height,","                        radius: xRad,","                        yRadius: yRad","                    });","                    this.closePath();","                    attrs[i] = {","                        id: id + \"_\" + i,","                        className: className,","                        coords: (x - this._left) + \", \" + (y - this._top)  + \", \" + radius,","                        shape: \"circle\"","                    };","                }","            }","            this._closePath();","        }","    },","","    /**","     * Parses and array of lengths into radii","     *","     * @method _getRadiusCollection","     * @param {Array} val Array of lengths","     * @return Array","     * @private","     */","    _getRadiusCollection: function(val)","    {","        var i = 0,","            len = val.length,","            radii = [];","        for(; i < len; ++i)","        {","            radii[i] = val[i] * 0.5;","        }","        return radii;","    }"," });","","ShapeGroup.ATTRS = Y.merge(Y.Path.ATTRS, {","    dimensions: {","        getter: function()","        {","            var dimensions = this._dimensions,","                radius,","                yRadius,","                width,","                height;","            if(dimensions.hasOwnProperty(\"radius\"))","            {","                return dimensions;","            }","            else","            {","                width = dimensions.width;","                height = dimensions.height;","                radius = Y_Lang.isArray(width) ? this._getRadiusCollection(width) : (width * 0.5);","                yRadius = Y_Lang.isArray(height) ? this._getRadiusCollection(height) : (height * 0.5);","                return {","                    width: width,","                    height: height,","                    radius: radius,","                    yRadius: yRadius","                };","            }","        },","","        setter: function(val)","        {","            this._dimensions = val;","            return val;","        }","    },","    xvalues: {","        getter: function()","        {","            return this._xvalues;","        },","        setter: function(val)","        {","            this._xvalues = val;","        }","    },","    yvalues: {","        getter: function()","        {","            return this._yvalues;","        },","        setter: function(val)","        {","            this._yvalues = val;","        }","    }","});","Y.ShapeGroup = ShapeGroup;","/**"," * Abstract class for creating groups of circles with the same styles and dimensions."," *"," * @module charts"," * @submodule charts-base"," * @class CircleGroup"," * @constructor"," */"," CircleGroup = function(cfg)"," {","    CircleGroup.superclass.constructor.apply(this, arguments);"," };",""," CircleGroup.NAME = \"circleGroup\";",""," Y.extend(CircleGroup, Y.ShapeGroup, {","    /**","     * Algorithm for drawing shape.","     *","     * @method drawShape","     * @param {Object} cfg Parameters used to draw the shape.","     */","    drawShape: function(cfg)","    {","        this.drawCircle(cfg.x, cfg.y, cfg.radius);","    }"," });","","CircleGroup.ATTRS = Y.merge(Y.ShapeGroup.ATTRS, {","    dimensions: {","        getter: function()","        {","            var dimensions = this._dimensions,","                radius,","                yRadius,","                width,","                height;","            if(dimensions.hasOwnProperty(\"radius\"))","            {","                return dimensions;","            }","            else","            {","                width = dimensions.width;","                height = dimensions.height;","                radius = Y_Lang.isArray(width) ? this._getRadiusCollection(width) : (width * 0.5);","                yRadius = radius;","                return {","                    width: width,","                    height: height,","                    radius: radius,","                    yRadius: yRadius","                };","            }","        }","    }","});","","CircleGroup.ATTRS = Y.ShapeGroup.ATTRS;","Y.CircleGroup = CircleGroup;","/**"," * Abstract class for creating groups of rects with the same styles and dimensions."," *"," * @module charts"," * @submodule charts-base"," * @class GroupRect"," * @constructor"," */"," RectGroup = function(cfg)"," {","    RectGroup.superclass.constructor.apply(this, arguments);"," };",""," RectGroup.NAME = \"rectGroup\";",""," Y.extend(RectGroup, Y.ShapeGroup, {","    /**","     * Updates the rect.","     *","     * @method _draw","     * @private","     */","    drawShape: function(cfg)","    {","        this.drawRect(cfg.x, cfg.y, cfg.width, cfg.height);","    }"," });","","RectGroup.ATTRS = Y.ShapeGroup.ATTRS;","Y.RectGroup = RectGroup;","/**"," * Abstract class for creating groups of diamonds with the same styles and dimensions."," *"," * @module charts"," * @submodule charts-base"," * @class GroupDiamond"," * @constructor"," */"," DiamondGroup = function(cfg)"," {","    DiamondGroup.superclass.constructor.apply(this, arguments);"," };",""," DiamondGroup.NAME = \"diamondGroup\";",""," Y.extend(DiamondGroup, Y.ShapeGroup, {","    /**","     * Updates the diamond.","     *","     * @method _draw","     * @private","     */","    drawShape: function(cfg)","    {","        this.drawDiamond(cfg.x, cfg.y, cfg.width, cfg.height);","    }"," });","","DiamondGroup.ATTRS = Y.ShapeGroup.ATTRS;","Y.DiamondGroup = DiamondGroup;","/**"," * Abstract class for creating groups of diamonds with the same styles and dimensions."," *"," * @module charts"," * @submodule charts-base"," * @class EllipseGroup"," * @constructor"," */"," EllipseGroup = function(cfg)"," {","    EllipseGroup.superclass.constructor.apply(this, arguments);"," };",""," EllipseGroup.NAME = \"diamondGroup\";",""," Y.extend(EllipseGroup, Y.ShapeGroup, {","    /**","     * Updates the diamond.","     *","     * @method _draw","     * @private","     */","    drawShape: function(cfg)","    {","        this.drawEllipse(cfg.x, cfg.y, cfg.width, cfg.height);","    }"," });","","EllipseGroup.ATTRS = Y.ShapeGroup.ATTRS;","Y.EllipseGroup = EllipseGroup;","/**"," * The Renderer class is a base class for chart components that use the `styles`"," * attribute."," *"," * @module charts"," * @submodule charts-base"," * @class Renderer"," * @constructor"," */","function Renderer(){}","","Renderer.ATTRS = {","        /**","         * Style properties for class","         *","         * @attribute styles","         * @type Object","         */","        styles:","        {","            getter: function()","            {","                this._styles = this._styles || this._getDefaultStyles();","                return this._styles;","            },","","            setter: function(val)","            {","                this._styles = this._setStyles(val);","            }","        },","","        /**","         * The graphic in which drawings will be rendered.","         *","         * @attribute graphic","         * @type Graphic","         */","        graphic: {}","};","Renderer.NAME = \"renderer\";","","Renderer.prototype = {","    /**","     * Storage for `styles` attribute.","     *","     * @property _styles","     * @type Object","     * @private","     */","	_styles: null,","","    /**","     * Method used by `styles` setter.","     *","     * @method _setStyles","     * @param {Object} newStyles Hash of properties to update.","     * @return Object","     * @protected","     */","	_setStyles: function(newstyles)","	{","		var styles = this.get(\"styles\");","        return this._mergeStyles(newstyles, styles);","	},","","    /**","     * Merges to object literals so that only specified properties are","     * overwritten.","     *","     * @method _mergeStyles","     * @param {Object} a Hash of new styles","     * @param {Object} b Hash of original styles","     * @return Object","     * @protected","     */","    _mergeStyles: function(a, b)","    {","        if(!b)","        {","            b = {};","        }","        var newstyles = Y.merge(b, {});","        Y.Object.each(a, function(value, key, a)","        {","            if(b.hasOwnProperty(key) && Y_Lang.isObject(value) && !Y_Lang.isFunction(value) && !Y_Lang.isArray(value))","            {","                newstyles[key] = this._mergeStyles(value, b[key]);","            }","            else","            {","                newstyles[key] = value;","            }","        }, this);","        return newstyles;","    },","","    /**","     * Gets the default value for the `styles` attribute.","     *","     * @method _getDefaultStyles","     * @return Object","     * @protected","     */","    _getDefaultStyles: function()","    {","        return {padding:{","            top:0,","            right: 0,","            bottom: 0,","            left: 0","        }};","    }","};","","Y.augment(Renderer, Y.Attribute);","Y.Renderer = Renderer;","","/**"," * Algorithmic strategy for rendering a left axis."," *"," * @module charts"," * @submodule charts-base"," * @class LeftAxisLayout"," * @constructor"," */","LeftAxisLayout = function() {};","","LeftAxisLayout.prototype = {","    /**","     *  Default margins for text fields.","     *","     *  @private","     *  @method _getDefaultMargins","     *  @return Object","     */","    _getDefaultMargins: function()","    {","        return {","            top: 0,","            left: 0,","            right: 4,","            bottom: 0","        };","    },","","    /**","     * Sets the length of the tick on either side of the axis line.","     *","     * @method setTickOffset","     * @protected","     */","    setTickOffsets: function()","    {","        var host = this,","            majorTicks = host.get(\"styles\").majorTicks,","            tickLength = majorTicks.length,","            halfTick = tickLength * 0.5,","            display = majorTicks.display;","        host.set(\"topTickOffset\",  0);","        host.set(\"bottomTickOffset\",  0);","","        switch(display)","        {","            case \"inside\" :","                host.set(\"rightTickOffset\",  tickLength);","                host.set(\"leftTickOffset\", 0);","            break;","            case \"outside\" :","                host.set(\"rightTickOffset\", 0);","                host.set(\"leftTickOffset\",  tickLength);","            break;","            case \"cross\":","                host.set(\"rightTickOffset\", halfTick);","                host.set(\"leftTickOffset\",  halfTick);","            break;","            default:","                host.set(\"rightTickOffset\", 0);","                host.set(\"leftTickOffset\", 0);","            break;","        }","    },","","    /**","     * Draws a tick","     *","     * @method drawTick","     * @param {Path} path reference to the path `Path` element in which to draw the tick.","     * @param {Object} pt Point on the axis in which the tick will intersect.","     * @param {Object} tickStyle Hash of properties to apply to the tick.","     * @protected","     */","    drawTick: function(path, pt, tickStyles)","    {","        var host = this,","            style = host.get(\"styles\"),","            padding = style.padding,","            tickLength = tickStyles.length,","            start = {x:padding.left, y:pt.y},","            end = {x:tickLength + padding.left, y:pt.y};","        host.drawLine(path, start, end);","    },","","    /**","     * Calculates the coordinates for the first point on an axis.","     *","     * @method getLineStart","     * @return {Object}","     * @protected","     */","    getLineStart: function()","    {","        var style = this.get(\"styles\"),","            padding = style.padding,","            majorTicks = style.majorTicks,","            tickLength = majorTicks.length,","            display = majorTicks.display,","            pt = {x:padding.left, y:0};","        if(display === \"outside\")","        {","            pt.x += tickLength;","        }","        else if(display === \"cross\")","        {","            pt.x += tickLength/2;","        }","        return pt;","    },","","    /**","     * Calculates the point for a label.","     *","     * @method getLabelPoint","     * @param {Object} point Point on the axis in which the tick will intersect.","     * @return {Object}","     * @protected","     */","    getLabelPoint: function(point)","    {","        return {x:point.x - this.get(\"leftTickOffset\"), y:point.y};","    },","","    /**","     * Updates the value for the `maxLabelSize` for use in calculating total size.","     *","     * @method updateMaxLabelSize","     * @param {HTMLElement} label to measure","     * @protected","     */","    updateMaxLabelSize: function(labelWidth, labelHeight)","    {","        var host = this,","            props = this._labelRotationProps,","            rot = props.rot,","            absRot = props.absRot,","            sinRadians = props.sinRadians,","            cosRadians = props.cosRadians,","            max;","        if(rot === 0)","        {","            max = labelWidth;","        }","        else if(absRot === 90)","        {","            max = labelHeight;","        }","        else","        {","            max = (cosRadians * labelWidth) + (sinRadians * labelHeight);","        }","        host._maxLabelSize = Math.max(host._maxLabelSize, max);","    },","","    /**","     * Determines the available label width when the axis width has been explicitly set.","     *","     * @method getExplicitlySized","     * @return Boolean","     * @protected","     */","    getExplicitlySized: function(styles)","    {","        if(this._explicitWidth)","        {","            var host = this,","                w = host._explicitWidth,","                totalTitleSize = host._totalTitleSize,","                leftTickOffset = host.get(\"leftTickOffset\"),","                margin = styles.label.margin.right;","            host._maxLabelSize =  w - (leftTickOffset + margin + totalTitleSize);","            return true;","        }","        return false;","    },","","    /**","     * Rotate and position title.","     *","     * @method positionTitle","     * @param {HTMLElement} label to rotate position","     * @protected","     */","    positionTitle: function(label)","    {","        var host = this,","            bounds = host._titleBounds,","            margin = host.get(\"styles\").title.margin,","            props = host._titleRotationProps,","            w = bounds.right - bounds.left,","            labelWidth = label.offsetWidth,","            labelHeight = label.offsetHeight,","            x = (labelWidth * -0.5) + (w * 0.5),","            y = (host.get(\"height\") * 0.5) - (labelHeight * 0.5);","        props.labelWidth = labelWidth;","        props.labelHeight = labelHeight;","        if(margin && margin.left)","        {","            x += margin.left;","        }","        props.x = x;","        props.y = y;","        props.transformOrigin = [0.5, 0.5];","        host._rotate(label, props);","    },","","    /**","     * Rotate and position labels.","     *","     * @method positionLabel","     * @param {HTMLElement} label to rotate position","     * @param {Object} pt hash containing the x and y coordinates in which the label will be positioned","     * against.","     * @protected","     */","    positionLabel: function(label, pt, styles, i)","    {","        var host = this,","            tickOffset = host.get(\"leftTickOffset\"),","            totalTitleSize = this._totalTitleSize,","            leftOffset = pt.x + totalTitleSize - tickOffset,","            topOffset = pt.y,","            props = this._labelRotationProps,","            rot = props.rot,","            absRot = props.absRot,","            maxLabelSize = host._maxLabelSize,","            labelWidth = this._labelWidths[i],","            labelHeight = this._labelHeights[i];","        if(rot === 0)","        {","            leftOffset -= labelWidth;","            topOffset -= labelHeight * 0.5;","        }","        else if(rot === 90)","        {","            leftOffset -= labelWidth * 0.5;","        }","        else if(rot === -90)","        {","            leftOffset -= labelWidth * 0.5;","            topOffset -= labelHeight;","        }","        else","        {","            leftOffset -= labelWidth + (labelHeight * absRot/360);","            topOffset -= labelHeight * 0.5;","        }","        props.labelWidth = labelWidth;","        props.labelHeight = labelHeight;","        props.x = Math.round(maxLabelSize + leftOffset);","        props.y = Math.round(topOffset);","        this._rotate(label, props);","    },","","    /**","     * Adjusts the coordinates of an axis label based on the rotation.","     *","     * @method _setRotationCoords","     * @param {Object} props Coordinates, dimension and rotation properties of the label.","     * @protected","     */","    _setRotationCoords: function(props)","    {","        var rot = props.rot,","            absRot = props.absRot,","            leftOffset,","            topOffset,","            labelWidth = props.labelWidth,","            labelHeight = props.labelHeight;","        if(rot === 0)","        {","            leftOffset = labelWidth;","            topOffset = labelHeight * 0.5;","        }","        else if(rot === 90)","        {","            topOffset = 0;","            leftOffset = labelWidth * 0.5;","        }","        else if(rot === -90)","        {","            leftOffset = labelWidth * 0.5;","            topOffset = labelHeight;","        }","        else","        {","            leftOffset = labelWidth + (labelHeight * absRot/360);","            topOffset = labelHeight * 0.5;","        }","        props.x -= leftOffset;","        props.y -= topOffset;","    },","","    /**","     * Returns the transformOrigin to use for an axis label based on the position of the axis","     * and the rotation of the label.","     *","     * @method _getTransformOrigin","     * @param {Number} rot The rotation (in degrees) of the label.","     * @return Array","     * @protected","     */","    _getTransformOrigin: function(rot)","    {","        var transformOrigin;","        if(rot === 0)","        {","            transformOrigin = [0, 0];","        }","        else if(rot === 90)","        {","            transformOrigin = [0.5, 0];","        }","        else if(rot === -90)","        {","            transformOrigin = [0.5, 1];","        }","        else","        {","            transformOrigin = [1, 0.5];","        }","        return transformOrigin;","    },","","    /**","     * Adjust the position of the Axis widget's content box for internal axes.","     *","     * @method offsetNodeForTick","     * @param {Node} cb Content box of the Axis.","     * @protected","     */","    offsetNodeForTick: function(cb)","    {","    },","","    /**","     * Sets the width of the axis based on its contents.","     *","     * @method setCalculatedSize","     * @protected","     */","    setCalculatedSize: function()","    {","        var host = this,","            graphic = this.get(\"graphic\"),","            style = host.get(\"styles\"),","            label = style.label,","            tickOffset = host.get(\"leftTickOffset\"),","            max = host._maxLabelSize,","            totalTitleSize = this._totalTitleSize,","            ttl = Math.round(totalTitleSize + tickOffset + max + label.margin.right);","        if(this._explicitWidth)","        {","            ttl = this._explicitWidth;","        }","        this.set(\"calculatedWidth\", ttl);","        graphic.set(\"x\", ttl - tickOffset);","    }","};","","Y.LeftAxisLayout = LeftAxisLayout;","/**"," * RightAxisLayout contains algorithms for rendering a right axis."," *"," * @module charts"," * @submodule charts-base"," * @class RightAxisLayout"," * @constructor"," */","RightAxisLayout = function(){};","","RightAxisLayout.prototype = {","    /**","     *  Default margins for text fields.","     *","     *  @private","     *  @method _getDefaultMargins","     *  @return Object","     */","    _getDefaultMargins: function()","    {","        return {","            top: 0,","            left: 4,","            right: 0,","            bottom: 0","        };","    },","","    /**","     * Sets the length of the tick on either side of the axis line.","     *","     * @method setTickOffset","     * @protected","     */","    setTickOffsets: function()","    {","        var host = this,","            majorTicks = host.get(\"styles\").majorTicks,","            tickLength = majorTicks.length,","            halfTick = tickLength * 0.5,","            display = majorTicks.display;","        host.set(\"topTickOffset\",  0);","        host.set(\"bottomTickOffset\",  0);","","        switch(display)","        {","            case \"inside\" :","                host.set(\"leftTickOffset\", tickLength);","                host.set(\"rightTickOffset\", 0);","            break;","            case \"outside\" :","                host.set(\"leftTickOffset\", 0);","                host.set(\"rightTickOffset\", tickLength);","            break;","            case \"cross\" :","                host.set(\"rightTickOffset\", halfTick);","                host.set(\"leftTickOffset\", halfTick);","            break;","            default:","                host.set(\"leftTickOffset\", 0);","                host.set(\"rightTickOffset\", 0);","            break;","        }","    },","","    /**","     * Draws a tick","     *","     * @method drawTick","     * @param {Path} path reference to the path `Path` element in which to draw the tick.","     * @param {Object} pt Point on the axis in which the tick will intersect.","     * @param {Object) tickStyle Hash of properties to apply to the tick.","     * @protected","     */","    drawTick: function(path, pt, tickStyles)","    {","        var host = this,","            style = host.get(\"styles\"),","            padding = style.padding,","            tickLength = tickStyles.length,","            start = {x:padding.left, y:pt.y},","            end = {x:padding.left + tickLength, y:pt.y};","        host.drawLine(path, start, end);","    },","","    /**","     * Calculates the coordinates for the first point on an axis.","     *","     * @method getLineStart","     * @return {Object}","     * @protected","     */","    getLineStart: function()","    {","        var host = this,","            style = host.get(\"styles\"),","            padding = style.padding,","            majorTicks = style.majorTicks,","            tickLength = majorTicks.length,","            display = majorTicks.display,","            pt = {x:padding.left, y:padding.top};","        if(display === \"inside\")","        {","            pt.x += tickLength;","        }","        else if(display === \"cross\")","        {","            pt.x += tickLength/2;","        }","        return pt;","    },","","    /**","     * Calculates the point for a label.","     *","     * @method getLabelPoint","     * @param {Object} point Point on the axis in which the tick will intersect.","     * @return {Object}","     * @protected","     */","    getLabelPoint: function(point)","    {","        return {x:point.x + this.get(\"rightTickOffset\"), y:point.y};","    },","","    /**","     * Updates the value for the `maxLabelSize` for use in calculating total size.","     *","     * @method updateMaxLabelSize","     * @param {HTMLElement} label to measure","     * @protected","     */","    updateMaxLabelSize: function(labelWidth, labelHeight)","    {","        var host = this,","            props = this._labelRotationProps,","            rot = props.rot,","            absRot = props.absRot,","            sinRadians = props.sinRadians,","            cosRadians = props.cosRadians,","            max;","        if(rot === 0)","        {","            max = labelWidth;","        }","        else if(absRot === 90)","        {","            max = labelHeight;","        }","        else","        {","            max = (cosRadians * labelWidth) + (sinRadians * labelHeight);","        }","        host._maxLabelSize = Math.max(host._maxLabelSize, max);","    },","","    /**","     * Determines the available label width when the axis width has been explicitly set.","     *","     * @method getExplicitlySized","     * @return Boolean","     * @protected","     */","    getExplicitlySized: function(styles)","    {","        if(this._explicitWidth)","        {","            var host = this,","                w = host._explicitWidth,","                totalTitleSize = this._totalTitleSize,","                rightTickOffset = host.get(\"rightTickOffset\"),","                margin = styles.label.margin.right;","            host._maxLabelSize =  w - (rightTickOffset + margin + totalTitleSize);","            return true;","        }","        return false;","    },","","    /**","     * Rotate and position title.","     *","     * @method positionTitle","     * @param {HTMLElement} label to rotate position","     * @protected","     */","    positionTitle: function(label)","    {","        var host = this,","            bounds = host._titleBounds,","            margin = host.get(\"styles\").title.margin,","            props = host._titleRotationProps,","            labelWidth = label.offsetWidth,","            labelHeight = label.offsetHeight,","            w = bounds.right - bounds.left,","            x = this.get(\"width\") - (labelWidth * 0.5) - (w * 0.5),","            y = (host.get(\"height\") * 0.5) - (labelHeight * 0.5);","        props.labelWidth = labelWidth;","        props.labelHeight = labelHeight;","        if(margin && margin.right)","        {","            x -= margin.left;","        }","        props.x = x;","        props.y = y;","        props.transformOrigin = [0.5, 0.5];","        host._rotate(label, props);","    },","","    /**","     * Rotate and position labels.","     *","     * @method positionLabel","     * @param {HTMLElement} label to rotate position","     * @param {Object} pt hash containing the x and y coordinates in which the label will be positioned","     * against.","     * @protected","     */","    positionLabel: function(label, pt, styles, i)","    {","        var host = this,","            tickOffset = host.get(\"rightTickOffset\"),","            labelStyles = styles.label,","            margin = 0,","            leftOffset = pt.x,","            topOffset = pt.y,","            props = this._labelRotationProps,","            rot = props.rot,","            absRot = props.absRot,","            labelWidth = this._labelWidths[i],","            labelHeight = this._labelHeights[i];","        if(labelStyles.margin && labelStyles.margin.left)","        {","            margin = labelStyles.margin.left;","        }","        if(rot === 0)","        {","            topOffset -= labelHeight * 0.5;","        }","        else if(rot === 90)","        {","            leftOffset -= labelWidth * 0.5;","            topOffset -= labelHeight;","        }","        else if(rot === -90)","        {","            leftOffset -= labelWidth * 0.5;","        }","        else","        {","            topOffset -= labelHeight * 0.5;","            leftOffset += labelHeight/2 * absRot/90;","        }","        leftOffset += margin;","        leftOffset += tickOffset;","        props.labelWidth = labelWidth;","        props.labelHeight = labelHeight;","        props.x = Math.round(leftOffset);","        props.y = Math.round(topOffset);","        this._rotate(label, props);","    },","","    /**","     * Adjusts the coordinates of an axis label based on the rotation.","     *","     * @method _setRotationCoords","     * @param {Object} props Coordinates, dimension and rotation properties of the label.","     * @protected","     */","    _setRotationCoords: function(props)","    {","        var rot = props.rot,","            absRot = props.absRot,","            leftOffset = 0,","            topOffset = 0,","            labelWidth = props.labelWidth,","            labelHeight = props.labelHeight;","        if(rot === 0)","        {","            topOffset = labelHeight * 0.5;","        }","        else if(rot === 90)","        {","            leftOffset = labelWidth * 0.5;","            topOffset = labelHeight;","        }","        else if(rot === -90)","        {","            leftOffset = labelWidth * 0.5;","        }","        else","        {","            topOffset = labelHeight * 0.5;","            leftOffset = labelHeight/2 * absRot/90;","        }","        props.x -= leftOffset;","        props.y -= topOffset;","    },","","    /**","     * Returns the transformOrigin to use for an axis label based on the position of the axis","     * and the rotation of the label.","     *","     * @method _getTransformOrigin","     * @param {Number} rot The rotation (in degrees) of the label.","     * @return Array","     * @protected","     */","    _getTransformOrigin: function(rot)","    {","        var transformOrigin;","        if(rot === 0)","        {","            transformOrigin = [0, 0];","        }","        else if(rot === 90)","        {","            transformOrigin = [0.5, 1];","        }","        else if(rot === -90)","        {","            transformOrigin = [0.5, 0];","        }","        else","        {","            transformOrigin = [0, 0.5];","        }","        return transformOrigin;","    },","","    /**","     * Adjusts position for inner ticks.","     *","     * @method offsetNodeForTick","     * @param {Node} cb contentBox of the axis","     * @protected","     */","    offsetNodeForTick: function(cb)","    {","        var host = this,","            tickOffset = host.get(\"leftTickOffset\"),","            offset = 0 - tickOffset;","        cb.setStyle(\"left\", offset);","    },","","    /**","     * Assigns a height based on the size of the contents.","     *","     * @method setCalculatedSize","     * @protected","     */","    setCalculatedSize: function()","    {","        var host = this,","            styles = host.get(\"styles\"),","            labelStyle = styles.label,","            totalTitleSize = this._totalTitleSize,","            ttl = Math.round(host.get(\"rightTickOffset\") + host._maxLabelSize + totalTitleSize + labelStyle.margin.left);","        if(this._explicitWidth)","        {","            ttl = this._explicitWidth;","        }","        host.set(\"calculatedWidth\", ttl);","        host.get(\"contentBox\").setStyle(\"width\", ttl);","    }","};","","Y.RightAxisLayout = RightAxisLayout;","/**"," * Contains algorithms for rendering a bottom axis."," *"," * @module charts"," * @submodule charts-base"," * @class BottomAxisLayout"," * @Constructor"," */","BottomAxisLayout = function(){};","","BottomAxisLayout.prototype = {","    /**","     *  Default margins for text fields.","     *","     *  @private","     *  @method _getDefaultMargins","     *  @return Object","     */","    _getDefaultMargins: function()","    {","        return {","            top: 4,","            left: 0,","            right: 0,","            bottom: 0","        };","    },","","    /**","     * Sets the length of the tick on either side of the axis line.","     *","     * @method setTickOffsets","     * @protected","     */","    setTickOffsets: function()","    {","        var host = this,","            majorTicks = host.get(\"styles\").majorTicks,","            tickLength = majorTicks.length,","            halfTick = tickLength * 0.5,","            display = majorTicks.display;","        host.set(\"leftTickOffset\",  0);","        host.set(\"rightTickOffset\",  0);","","        switch(display)","        {","            case \"inside\" :","                host.set(\"topTickOffset\", tickLength);","                host.set(\"bottomTickOffset\", 0);","            break;","            case \"outside\" :","                host.set(\"topTickOffset\", 0);","                host.set(\"bottomTickOffset\", tickLength);","            break;","            case \"cross\":","                host.set(\"topTickOffset\",  halfTick);","                host.set(\"bottomTickOffset\",  halfTick);","            break;","            default:","                host.set(\"topTickOffset\", 0);","                host.set(\"bottomTickOffset\", 0);","            break;","        }","    },","","    /**","     * Calculates the coordinates for the first point on an axis.","     *","     * @method getLineStart","     * @protected","     */","    getLineStart: function()","    {","        var style = this.get(\"styles\"),","            padding = style.padding,","            majorTicks = style.majorTicks,","            tickLength = majorTicks.length,","            display = majorTicks.display,","            pt = {x:0, y:padding.top};","        if(display === \"inside\")","        {","            pt.y += tickLength;","        }","        else if(display === \"cross\")","        {","            pt.y += tickLength/2;","        }","        return pt;","    },","","    /**","     * Draws a tick","     *","     * @method drawTick","     * @param {Path} path reference to the path `Path` element in which to draw the tick.","     * @param {Object} pt hash containing x and y coordinates","     * @param {Object} tickStyles hash of properties used to draw the tick","     * @protected","     */","    drawTick: function(path, pt, tickStyles)","    {","        var host = this,","            style = host.get(\"styles\"),","            padding = style.padding,","            tickLength = tickStyles.length,","            start = {x:pt.x, y:padding.top},","            end = {x:pt.x, y:tickLength + padding.top};","        host.drawLine(path, start, end);","    },","","    /**","     * Calculates the point for a label.","     *","     * @method getLabelPoint","     * @param {Object} pt Object containing x and y coordinates","     * @return Object","     * @protected","     */","    getLabelPoint: function(point)","    {","        return {x:point.x, y:point.y + this.get(\"bottomTickOffset\")};","    },","","    /**","     * Updates the value for the `maxLabelSize` for use in calculating total size.","     *","     * @method updateMaxLabelSize","     * @param {HTMLElement} label to measure","     * @protected","     */","    updateMaxLabelSize: function(labelWidth, labelHeight)","    {","        var host = this,","            props = this._labelRotationProps,","            rot = props.rot,","            absRot = props.absRot,","            sinRadians = props.sinRadians,","            cosRadians = props.cosRadians,","            max;","        if(rot === 0)","        {","            max = labelHeight;","        }","        else if(absRot === 90)","        {","            max = labelWidth;","        }","        else","        {","            max = (sinRadians * labelWidth) + (cosRadians * labelHeight);","        }","        host._maxLabelSize = Math.max(host._maxLabelSize, max);","    },","","    /**","     * Determines the available label height when the axis width has been explicitly set.","     *","     * @method getExplicitlySized","     * @return Boolean","     * @protected","     */","    getExplicitlySized: function(styles)","    {","        if(this._explicitHeight)","        {","            var host = this,","                h = host._explicitHeight,","                totalTitleSize = host._totalTitleSize,","                bottomTickOffset = host.get(\"bottomTickOffset\"),","                margin = styles.label.margin.right;","            host._maxLabelSize =  h - (bottomTickOffset + margin + totalTitleSize);","            return true;","        }","        return false;","    },","","    /**","     * Rotate and position title.","     *","     * @method positionTitle","     * @param {HTMLElement} label to rotate position","     * @protected","     */","    positionTitle: function(label)","    {","        var host = this,","            bounds = host._titleBounds,","            margin = host.get(\"styles\").title.margin,","            props = host._titleRotationProps,","            h = bounds.bottom - bounds.top,","            labelWidth = label.offsetWidth,","            labelHeight = label.offsetHeight,","            x = (host.get(\"width\") * 0.5) - (labelWidth * 0.5),","            y = host.get(\"height\") - labelHeight/2 - h/2;","        props.labelWidth = labelWidth;","        props.labelHeight = labelHeight;","        if(margin && margin.bottom)","        {","            y -= margin.bottom;","        }","        props.x = x;","        props.y = y;","        props.transformOrigin = [0.5, 0.5];","        host._rotate(label, props);","    },","","    /**","     * Rotate and position labels.","     *","     * @method positionLabel","     * @param {HTMLElement} label to rotate position","     * @param {Object} pt hash containing the x and y coordinates in which the label will be positioned","     * against.","     * @protected","     */","    positionLabel: function(label, pt, styles, i)","    {","        var host = this,","            tickOffset = host.get(\"bottomTickOffset\"),","            labelStyles = styles.label,","            margin = 0,","            props = host._labelRotationProps,","            rot = props.rot,","            absRot = props.absRot,","            leftOffset = Math.round(pt.x),","            topOffset = Math.round(pt.y),","            labelWidth = host._labelWidths[i],","            labelHeight = host._labelHeights[i];","        if(labelStyles.margin && labelStyles.margin.top)","        {","            margin = labelStyles.margin.top;","        }","        if(rot > 0)","        {","            topOffset -= labelHeight/2 * rot/90;","        }","        else if(rot < 0)","        {","            leftOffset -= labelWidth;","            topOffset -= labelHeight/2 * absRot/90;","        }","        else","        {","            leftOffset -= labelWidth * 0.5;","        }","        topOffset += margin;","        topOffset += tickOffset;","        props.labelWidth = labelWidth;","        props.labelHeight = labelHeight;","        props.x = leftOffset;","        props.y = topOffset;","        host._rotate(label, props);","    },","","    /**","     * Adjusts the coordinates of an axis label based on the rotation.","     *","     * @method _setRotationCoords","     * @param {Object} props Coordinates, dimension and rotation properties of the label.","     * @protected","     */","    _setRotationCoords: function(props)","    {","        var rot = props.rot,","            absRot = props.absRot,","            labelWidth = props.labelWidth,","            labelHeight = props.labelHeight,","            leftOffset,","            topOffset;","","        if(rot > 0)","        {","            leftOffset = 0;","            topOffset = labelHeight/2 * rot/90;","        }","        else if(rot < 0)","        {","            leftOffset = labelWidth;","            topOffset = labelHeight/2 * absRot/90;","        }","        else","        {","            leftOffset = labelWidth * 0.5;","            topOffset = 0;","        }","        props.x -= leftOffset;","        props.y -= topOffset;","    },","","    /**","     * Returns the transformOrigin to use for an axis label based on the position of the axis","     * and the rotation of the label.","     *","     * @method _getTransformOrigin","     * @param {Number} rot The rotation (in degrees) of the label.","     * @return Array","     * @protected","     */","    _getTransformOrigin: function(rot)","    {","        var transformOrigin;","        if(rot > 0)","        {","            transformOrigin = [0, 0.5];","        }","        else if(rot < 0)","        {","            transformOrigin = [1, 0.5];","        }","        else","        {","            transformOrigin = [0, 0];","        }","        return transformOrigin;","    },","","    /**","     * Adjusts position for inner ticks.","     *","     * @method offsetNodeForTick","     * @param {Node} cb contentBox of the axis","     * @protected","     */","    offsetNodeForTick: function(cb)","    {","        var host = this;","        host.get(\"contentBox\").setStyle(\"top\", 0 - host.get(\"topTickOffset\"));","    },","","    /**","     * Assigns a height based on the size of the contents.","     *","     * @method setCalculatedSize","     * @protected","     */","    setCalculatedSize: function()","    {","        var host = this,","            styles = host.get(\"styles\"),","            labelStyle = styles.label,","            totalTitleSize = host._totalTitleSize,","            ttl = Math.round(host.get(\"bottomTickOffset\") + host._maxLabelSize + labelStyle.margin.top + totalTitleSize);","        if(host._explicitHeight)","        {","            ttl = host._explicitHeight;","        }","        host.set(\"calculatedHeight\", ttl);","    }","};","Y.BottomAxisLayout = BottomAxisLayout;","/**"," * Contains algorithms for rendering a top axis."," *"," * @module charts"," * @submodule charts-base"," * @class TopAxisLayout"," * @constructor"," */","TopAxisLayout = function(){};","","TopAxisLayout.prototype = {","    /**","     *  Default margins for text fields.","     *","     *  @private","     *  @method _getDefaultMargins","     *  @return Object","     */","    _getDefaultMargins: function()","    {","        return {","            top: 0,","            left: 0,","            right: 0,","            bottom: 4","        };","    },","","    /**","     * Sets the length of the tick on either side of the axis line.","     *","     * @method setTickOffsets","     * @protected","     */","    setTickOffsets: function()","    {","        var host = this,","            majorTicks = host.get(\"styles\").majorTicks,","            tickLength = majorTicks.length,","            halfTick = tickLength * 0.5,","            display = majorTicks.display;","        host.set(\"leftTickOffset\",  0);","        host.set(\"rightTickOffset\",  0);","        switch(display)","        {","            case \"inside\" :","                host.set(\"bottomTickOffset\", tickLength);","                host.set(\"topTickOffset\", 0);","            break;","            case \"outside\" :","                host.set(\"bottomTickOffset\", 0);","                host.set(\"topTickOffset\",  tickLength);","            break;","            case \"cross\" :","                host.set(\"topTickOffset\", halfTick);","                host.set(\"bottomTickOffset\", halfTick);","            break;","            default:","                host.set(\"topTickOffset\", 0);","                host.set(\"bottomTickOffset\", 0);","            break;","        }","    },","","    /**","     * Calculates the coordinates for the first point on an axis.","     *","     * @method getLineStart","     * @protected","     */","    getLineStart: function()","    {","        var host = this,","            style = host.get(\"styles\"),","            padding = style.padding,","            majorTicks = style.majorTicks,","            tickLength = majorTicks.length,","            display = majorTicks.display,","            pt = {x:0, y:padding.top};","        if(display === \"outside\")","        {","            pt.y += tickLength;","        }","        else if(display === \"cross\")","        {","            pt.y += tickLength/2;","        }","        return pt;","    },","","    /**","     * Draws a tick","     *","     * @method drawTick","     * @param {Path} path reference to the path `Path` element in which to draw the tick.","     * @param {Object} pt hash containing x and y coordinates","     * @param {Object} tickStyles hash of properties used to draw the tick","     * @protected","     */","    drawTick: function(path, pt, tickStyles)","    {","        var host = this,","            style = host.get(\"styles\"),","            padding = style.padding,","            tickLength = tickStyles.length,","            start = {x:pt.x, y:padding.top},","            end = {x:pt.x, y:tickLength + padding.top};","        host.drawLine(path, start, end);","    },","","    /**","     * Calculates the point for a label.","     *","     * @method getLabelPoint","     * @param {Object} pt hash containing x and y coordinates","     * @return Object","     * @protected","     */","    getLabelPoint: function(pt)","    {","        return {x:pt.x, y:pt.y - this.get(\"topTickOffset\")};","    },","","    /**","     * Updates the value for the `maxLabelSize` for use in calculating total size.","     *","     * @method updateMaxLabelSize","     * @param {HTMLElement} label to measure","     * @protected","     */","    updateMaxLabelSize: function(labelWidth, labelHeight)","    {","        var host = this,","            props = this._labelRotationProps,","            rot = props.rot,","            absRot = props.absRot,","            sinRadians = props.sinRadians,","            cosRadians = props.cosRadians,","            max;","        if(rot === 0)","        {","            max = labelHeight;","        }","        else if(absRot === 90)","        {","            max = labelWidth;","        }","        else","        {","            max = (sinRadians * labelWidth) + (cosRadians * labelHeight);","        }","        host._maxLabelSize = Math.max(host._maxLabelSize, max);","    },","","    /**","     * Determines the available label height when the axis width has been explicitly set.","     *","     * @method getExplicitlySized","     * @return Boolean","     * @protected","     */","    getExplicitlySized: function(styles)","    {","        if(this._explicitHeight)","        {","            var host = this,","                h = host._explicitHeight,","                totalTitleSize = host._totalTitleSize,","                topTickOffset = host.get(\"topTickOffset\"),","                margin = styles.label.margin.right;","            host._maxLabelSize =  h - (topTickOffset + margin + totalTitleSize);","            return true;","        }","        return false;","    },","","    /**","     * Rotate and position title.","     *","     * @method positionTitle","     * @param {HTMLElement} label to rotate position","     * @protected","     */","    positionTitle: function(label)","    {","        var host = this,","            bounds = host._titleBounds,","            margin = host.get(\"styles\").title.margin,","            props = host._titleRotationProps,","            labelWidth = label.offsetWidth,","            labelHeight = label.offsetHeight,","            h = bounds.bottom - bounds.top,","            x = (host.get(\"width\") * 0.5) - (labelWidth * 0.5),","            y = h/2 - labelHeight/2;","        props.labelWidth = labelWidth;","        props.labelHeight = labelHeight;","        if(margin && margin.top)","        {","            y += margin.top;","        }","        props.x = x;","        props.y = y;","        props.transformOrigin = [0.5, 0.5];","        host._rotate(label, props);","    },","","    /**","     * Rotate and position labels.","     *","     * @method positionLabel","     * @param {HTMLElement} label to rotate position","     * @param {Object} pt hash containing the x and y coordinates in which the label will be positioned","     * against.","     * @protected","     */","    positionLabel: function(label, pt, styles, i)","    {","        var host = this,","            totalTitleSize = this._totalTitleSize,","            maxLabelSize = host._maxLabelSize,","            leftOffset = pt.x,","            topOffset = pt.y + totalTitleSize + maxLabelSize,","            props = this._labelRotationProps,","            rot = props.rot,","            absRot = props.absRot,","            labelWidth = this._labelWidths[i],","            labelHeight = this._labelHeights[i];","        if(rot === 0)","        {","            leftOffset -= labelWidth * 0.5;","            topOffset -= labelHeight;","        }","        else","        {","            if(rot === 90)","            {","                leftOffset -= labelWidth;","                topOffset -= (labelHeight * 0.5);","            }","            else if (rot === -90)","            {","                topOffset -= (labelHeight * 0.5);","            }","            else if(rot > 0)","            {","                leftOffset -= labelWidth;","                topOffset -= labelHeight - (labelHeight * rot/180);","            }","            else","            {","                topOffset -= labelHeight - (labelHeight * absRot/180);","            }","        }","        props.x = Math.round(leftOffset);","        props.y = Math.round(topOffset);","        props.labelWidth = labelWidth;","        props.labelHeight = labelHeight;","        this._rotate(label, props);","    },","","    /**","     * Adjusts the coordinates of an axis label based on the rotation.","     *","     * @method _setRotationCoords","     * @param {Object} props Coordinates, dimension and rotation properties of the label.","     * @protected","     */","    _setRotationCoords: function(props)","    {","        var rot = props.rot,","            absRot = props.absRot,","            labelWidth = props.labelWidth,","            labelHeight = props.labelHeight,","            leftOffset,","            topOffset;","        if(rot === 0)","        {","            leftOffset = labelWidth * 0.5;","            topOffset = labelHeight;","        }","        else","        {","            if(rot === 90)","            {","                leftOffset = labelWidth;","                topOffset = (labelHeight * 0.5);","            }","            else if (rot === -90)","            {","                topOffset = (labelHeight * 0.5);","            }","            else if(rot > 0)","            {","                leftOffset = labelWidth;","                topOffset = labelHeight - (labelHeight * rot/180);","            }","            else","            {","                topOffset = labelHeight - (labelHeight * absRot/180);","            }","        }","        props.x -= leftOffset;","        props.y -= topOffset;","    },","","    /**","     * Returns the transformOrigin to use for an axis label based on the position of the axis","     * and the rotation of the label.","     *","     * @method _getTransformOrigin","     * @param {Number} rot The rotation (in degrees) of the label.","     * @return Array","     * @protected","     */","    _getTransformOrigin: function(rot)","    {","        var transformOrigin;","        if(rot === 0)","        {","            transformOrigin = [0, 0];","        }","        else","        {","            if(rot === 90)","            {","                transformOrigin = [1, 0.5];","            }","            else if (rot === -90)","            {","                transformOrigin = [0, 0.5];","            }","            else if(rot > 0)","            {","                transformOrigin = [1, 0.5];","            }","            else","            {","                transformOrigin = [0, 0.5];","            }","        }","        return transformOrigin;","    },","","    /**","     * Adjusts position for inner ticks.","     *","     * @method offsetNodeForTick","     * @param {Node} cb contentBox of the axis","     * @protected","     */","    offsetNodeForTick: function(cb)","    {","    },","","    /**","     * Assigns a height based on the size of the contents.","     *","     * @method setCalculatedSize","     * @protected","     */","    setCalculatedSize: function()","    {","        var host = this,","            graphic = host.get(\"graphic\"),","            styles = host.get(\"styles\"),","            labelMargin = styles.label.margin,","            totalLabelSize = labelMargin.bottom + host._maxLabelSize,","            totalTitleSize = host._totalTitleSize,","            topTickOffset = this.get(\"topTickOffset\"),","            ttl = Math.round(topTickOffset + totalLabelSize + totalTitleSize);","        if(this._explicitHeight)","        {","           ttl = this._explicitWidth;","        }","        host.set(\"calculatedHeight\", ttl);","        graphic.set(\"y\", ttl - topTickOffset);","    }","};","Y.TopAxisLayout = TopAxisLayout;","","/**"," * The Axis class. Generates axes for a chart."," *"," * @module charts"," * @submodule charts-base"," * @class Axis"," * @extends Widget"," * @uses Renderer"," * @constructor"," * @param {Object} config (optional) Configuration parameters for the Chart."," */","Y.Axis = Y.Base.create(\"axis\", Y.Widget, [Y.Renderer], {","    /**","     * Storage for calculatedWidth value.","     *","     * @property _calculatedWidth","     * @type Number","     * @private","     */","    _calculatedWidth: 0,","","    /**","     * Storage for calculatedHeight value.","     *","     * @property _calculatedHeight","     * @type Number","     * @private","     */","    _calculatedHeight: 0,","","    /**","     * Handles change to the dataProvider","     *","     * @method _dataChangeHandler","     * @param {Object} e Event object","     * @private","     */","    _dataChangeHandler: function(e)","    {","        if(this.get(\"rendered\"))","        {","            this._drawAxis();","        }","    },","","    /**","     * Handles change to the position attribute","     *","     * @method _positionChangeHandler","     * @param {Object} e Event object","     * @private","     */","    _positionChangeHandler: function(e)","    {","        this._updateGraphic(e.newVal);","        this._updateHandler();","    },","","    /**","     * Updates the the Graphic instance","     *","     * @method _updateGraphic","     * @param {String} position Position of axis","     * @private","     */","    _updateGraphic: function(position)","    {","        var graphic = this.get(\"graphic\");","        if(position == \"none\")","        {","            if(graphic)","            {","                graphic.destroy();","            }","        }","        else","        {","            if(!graphic)","            {","                this._setCanvas();","            }","        }","    },","","    /**","     * Handles changes to axis.","     *","     * @method _updateHandler","     * @param {Object} e Event object","     * @private","     */","    _updateHandler: function(e)","    {","        if(this.get(\"rendered\"))","        {","            this._drawAxis();","        }","    },","","    /**","     * @method renderUI","     * @private","     */","    renderUI: function()","    {","        this._updateGraphic(this.get(\"position\"));","    },","","    /**","     * @method syncUI","     * @private","     */","    syncUI: function()","    {","        var layout = this._layout,","            defaultMargins,","            styles,","            label,","            title,","            i;","        if(layout)","        {","            defaultMargins = layout._getDefaultMargins();","            styles = this.get(\"styles\");","            label = styles.label.margin;","            title =styles.title.margin;","            //need to defaultMargins method to the layout classes.","            for(i in defaultMargins)","            {","                if(defaultMargins.hasOwnProperty(i))","                {","                    label[i] = label[i] === undefined ? defaultMargins[i] : label[i];","                    title[i] = title[i] === undefined ? defaultMargins[i] : title[i];","                }","            }","        }","        this._drawAxis();","    },","","    /**","     * Creates a graphic instance to be used for the axis line and ticks.","     *","     * @method _setCanvas","     * @private","     */","    _setCanvas: function()","    {","        var cb = this.get(\"contentBox\"),","            bb = this.get(\"boundingBox\"),","            p = this.get(\"position\"),","            pn = this._parentNode,","            w = this.get(\"width\"),","            h = this.get(\"height\");","        bb.setStyle(\"position\", \"absolute\");","        bb.setStyle(\"zIndex\", 2);","        w = w ? w + \"px\" : pn.getStyle(\"width\");","        h = h ? h + \"px\" : pn.getStyle(\"height\");","        if(p === \"top\" || p === \"bottom\")","        {","            cb.setStyle(\"width\", w);","        }","        else","        {","            cb.setStyle(\"height\", h);","        }","        cb.setStyle(\"position\", \"relative\");","        cb.setStyle(\"left\", \"0px\");","        cb.setStyle(\"top\", \"0px\");","        this.set(\"graphic\", new Y.Graphic());","        this.get(\"graphic\").render(cb);","    },","","    /**","     * Gets the default value for the `styles` attribute. Overrides","     * base implementation.","     *","     * @method _getDefaultStyles","     * @return Object","     * @protected","     */","    _getDefaultStyles: function()","    {","        var axisstyles = {","            majorTicks: {","                display:\"inside\",","                length:4,","                color:\"#dad8c9\",","                weight:1,","                alpha:1","            },","            minorTicks: {","                display:\"none\",","                length:2,","                color:\"#dad8c9\",","                weight:1","            },","            line: {","                weight:1,","                color:\"#dad8c9\",","                alpha:1","            },","            majorUnit: {","                determinant:\"count\",","                count:11,","                distance:75","            },","            top: \"0px\",","            left: \"0px\",","            width: \"100px\",","            height: \"100px\",","            label: {","                color:\"#808080\",","                alpha: 1,","                fontSize:\"85%\",","                rotation: 0,","                margin: {","                    top: undefined,","                    right: undefined,","                    bottom: undefined,","                    left: undefined","                }","            },","            title: {","                color:\"#808080\",","                alpha: 1,","                fontSize:\"85%\",","                rotation: undefined,","                margin: {","                    top: undefined,","                    right: undefined,","                    bottom: undefined,","                    left: undefined","                }","            },","            hideOverlappingLabelTicks: false","        };","","        return Y.merge(Y.Renderer.prototype._getDefaultStyles(), axisstyles);","    },","","    /**","     * Updates the axis when the size changes.","     *","     * @method _handleSizeChange","     * @param {Object} e Event object.","     * @private","     */","    _handleSizeChange: function(e)","    {","        var attrName = e.attrName,","            pos = this.get(\"position\"),","            vert = pos == \"left\" || pos == \"right\",","            cb = this.get(\"contentBox\"),","            hor = pos == \"bottom\" || pos == \"top\";","        cb.setStyle(\"width\", this.get(\"width\"));","        cb.setStyle(\"height\", this.get(\"height\"));","        if((hor && attrName == \"width\") || (vert && attrName == \"height\"))","        {","            this._drawAxis();","        }","    },","","    /**","     * Maps key values to classes containing layout algorithms","     *","     * @property _layoutClasses","     * @type Object","     * @private","     */","    _layoutClasses:","    {","        top : TopAxisLayout,","        bottom: BottomAxisLayout,","        left: LeftAxisLayout,","        right : RightAxisLayout","    },","","    /**","     * Draws a line segment between 2 points","     *","     * @method drawLine","     * @param {Object} startPoint x and y coordinates for the start point of the line segment","     * @param {Object} endPoint x and y coordinates for the for the end point of the line segment","     * @param {Object} line styles (weight, color and alpha to be applied to the line segment)","     * @private","     */","    drawLine: function(path, startPoint, endPoint)","    {","        path.moveTo(startPoint.x, startPoint.y);","        path.lineTo(endPoint.x, endPoint.y);","    },","","    /**","     * Generates the properties necessary for rotating and positioning a text field.","     *","     * @method _getTextRotationProps","     * @param {Object} styles properties for the text field","     * @return Object","     * @private","     */","    _getTextRotationProps: function(styles)","    {","        if(styles.rotation === undefined)","        {","            switch(this.get(\"position\"))","            {","                case \"left\" :","                    styles.rotation = -90;","                break;","                case \"right\" :","                    styles.rotation = 90;","                break;","                default :","                    styles.rotation = 0;","                break;","            }","        }","        var rot =  Math.min(90, Math.max(-90, styles.rotation)),","            absRot = Math.abs(rot),","            radCon = Math.PI/180,","            sinRadians = parseFloat(parseFloat(Math.sin(absRot * radCon)).toFixed(8)),","            cosRadians = parseFloat(parseFloat(Math.cos(absRot * radCon)).toFixed(8));","        return {","            rot: rot,","            absRot: absRot,","            radCon: radCon,","            sinRadians: sinRadians,","            cosRadians: cosRadians,","            textAlpha: styles.alpha","        };","    },","","    /**","     * Draws an axis.","     *","     * @method _drawAxis","     * @private","     */","    _drawAxis: function ()","    {","        if(this._drawing)","        {","            this._callLater = true;","            return;","        }","        this._drawing = true;","        this._callLater = false;","        if(this._layout)","        {","            var styles = this.get(\"styles\"),","                line = styles.line,","                labelStyles = styles.label,","                majorTickStyles = styles.majorTicks,","                drawTicks = majorTickStyles.display != \"none\",","                tickPoint,","                majorUnit = styles.majorUnit,","                len,","                majorUnitDistance,","                i = 0,","                layout = this._layout,","                layoutLength,","                position,","                lineStart,","                label,","                labelWidth,","                labelHeight,","                labelFunction = this.get(\"labelFunction\"),","                labelFunctionScope = this.get(\"labelFunctionScope\"),","                labelFormat = this.get(\"labelFormat\"),","                graphic = this.get(\"graphic\"),","                path = this.get(\"path\"),","                tickPath,","                explicitlySized;","            this._labelWidths = [];","            this._labelHeights = [];","            graphic.set(\"autoDraw\", false);","            path.clear();","            path.set(\"stroke\", {","                weight: line.weight,","                color: line.color,","                opacity: line.alpha","            });","            this._labelRotationProps = this._getTextRotationProps(labelStyles);","            this._labelRotationProps.transformOrigin = layout._getTransformOrigin(this._labelRotationProps.rot);","            layout.setTickOffsets.apply(this);","            layoutLength = this.getLength();","            lineStart = layout.getLineStart.apply(this);","            len = this.getTotalMajorUnits(majorUnit);","            majorUnitDistance = this.getMajorUnitDistance(len, layoutLength, majorUnit);","            this.set(\"edgeOffset\", this.getEdgeOffset(len, layoutLength) * 0.5);","            if(len < 1)","            {","                this._clearLabelCache();","            }","            else","            {","                tickPoint = this.getFirstPoint(lineStart);","                this.drawLine(path, lineStart, this.getLineEnd(tickPoint));","                if(drawTicks)","                {","                    tickPath = this.get(\"tickPath\");","                    tickPath.clear();","                    tickPath.set(\"stroke\", {","                        weight: majorTickStyles.weight,","                        color: majorTickStyles.color,","                        opacity: majorTickStyles.alpha","                    });","                   layout.drawTick.apply(this, [tickPath, tickPoint, majorTickStyles]);","                }","                this._createLabelCache();","                this._tickPoints = [];","                this._maxLabelSize = 0;","                this._totalTitleSize = 0;","                this._titleSize = 0;","                this._setTitle();","                explicitlySized = layout.getExplicitlySized.apply(this, [styles]);","                for(; i < len; ++i)","                {","                    if(drawTicks)","                    {","                        layout.drawTick.apply(this, [tickPath, tickPoint, majorTickStyles]);","                    }","                    position = this.getPosition(tickPoint);","                    label = this.getLabel(tickPoint, labelStyles);","                    this._labels.push(label);","                    this._tickPoints.push({x:tickPoint.x, y:tickPoint.y});","                    this.get(\"appendLabelFunction\")(label, labelFunction.apply(labelFunctionScope, [this.getLabelByIndex(i, len), labelFormat]));","                    labelWidth = Math.round(label.offsetWidth);","                    labelHeight = Math.round(label.offsetHeight);","                    if(!explicitlySized)","                    {","                        this._layout.updateMaxLabelSize.apply(this, [labelWidth, labelHeight]);","                    }","                    this._labelWidths.push(labelWidth);","                    this._labelHeights.push(labelHeight);","                    tickPoint = this.getNextPoint(tickPoint, majorUnitDistance);","                }","                this._clearLabelCache();","                if(this.get(\"overlapGraph\"))","                {","                   layout.offsetNodeForTick.apply(this, [this.get(\"contentBox\")]);","                }","                layout.setCalculatedSize.apply(this);","                if(this._titleTextField)","                {","                    this._layout.positionTitle.apply(this, [this._titleTextField]);","                }","                for(i = 0; i < len; ++i)","                {","                    layout.positionLabel.apply(this, [this.get(\"labels\")[i], this._tickPoints[i], styles, i]);","                }","            }","        }","        this._drawing = false;","        if(this._callLater)","        {","            this._drawAxis();","        }","        else","        {","            this._updatePathElement();","            this.fire(\"axisRendered\");","        }","    },","","    /**","     * Calculates and sets the total size of a title.","     *","     * @method _setTotalTitleSize","     * @param {Object} styles Properties for the title field.","     * @private","     */","    _setTotalTitleSize: function(styles)","    {","        var title = this._titleTextField,","            w = title.offsetWidth,","            h = title.offsetHeight,","            rot = this._titleRotationProps.rot,","            bounds,","            size,","            margin = styles.margin,","            position = this.get(\"position\"),","            matrix = new Y.Matrix();","        matrix.rotate(rot);","        bounds = matrix.getContentRect(w, h);","        if(position == \"left\" || position == \"right\")","        {","            size = bounds.right - bounds.left;","            if(margin)","            {","                size += margin.left + margin.right;","            }","        }","        else","        {","            size = bounds.bottom - bounds.top;","            if(margin)","            {","                size += margin.top + margin.bottom;","            }","        }","        this._titleBounds = bounds;","        this._totalTitleSize = size;","    },","","    /**","     *  Updates path.","     *","     *  @method _updatePathElement","     *  @private","     */","    _updatePathElement: function()","    {","        var path = this._path,","            tickPath = this._tickPath,","            redrawGraphic = false,","            graphic = this.get(\"graphic\");","        if(path)","        {","            redrawGraphic = true;","            path.end();","        }","        if(tickPath)","        {","            redrawGraphic = true;","            tickPath.end();","        }","        if(redrawGraphic)","        {","            graphic._redraw();","        }","    },","","    /**","     * Updates the content and style properties for a title field.","     *","     * @method _updateTitle","     * @private","     */","    _setTitle: function()","    {","        var i,","            styles,","            customStyles,","            title = this.get(\"title\"),","            titleTextField = this._titleTextField,","            parentNode;","        if(title !== null && title !== undefined)","        {","            customStyles = {","                    rotation: \"rotation\",","                    margin: \"margin\",","                    alpha: \"alpha\"","            };","            styles = this.get(\"styles\").title;","            if(!titleTextField)","            {","                titleTextField = DOCUMENT.createElement('span');","                titleTextField.style.display = \"block\";","                titleTextField.style.whiteSpace = \"nowrap\";","                titleTextField.setAttribute(\"class\", \"axisTitle\");","                this.get(\"contentBox\").append(titleTextField);","            }","            else if(!DOCUMENT.createElementNS)","            {","                if(titleTextField.style.filter)","                {","                    titleTextField.style.filter = null;","                }","            }","            titleTextField.style.position = \"absolute\";","            for(i in styles)","            {","                if(styles.hasOwnProperty(i) && !customStyles.hasOwnProperty(i))","                {","                    titleTextField.style[i] = styles[i];","                }","            }","            this.get(\"appendTitleFunction\")(titleTextField, title);","            this._titleTextField = titleTextField;","            this._titleRotationProps = this._getTextRotationProps(styles);","            this._setTotalTitleSize(styles);","        }","        else if(titleTextField)","        {","            parentNode = titleTextField.parentNode;","            if(parentNode)","            {","                parentNode.removeChild(titleTextField);","            }","            this._titleTextField = null;","            this._totalTitleSize = 0;","        }","    },","","    /**","     * Creates or updates an axis label.","     *","     * @method getLabel","     * @param {Object} pt x and y coordinates for the label","     * @param {Object} styles styles applied to label","     * @return HTMLElement","     * @private","     */","    getLabel: function(pt, styles)","    {","        var i,","            label,","            labelCache = this._labelCache,","            customStyles = {","                rotation: \"rotation\",","                margin: \"margin\",","                alpha: \"alpha\"","            };","        if(labelCache && labelCache.length > 0)","        {","            label = labelCache.shift();","        }","        else","        {","            label = DOCUMENT.createElement(\"span\");","            label.className = Y.Lang.trim([label.className, \"axisLabel\"].join(' '));","            this.get(\"contentBox\").append(label);","        }","        if(!DOCUMENT.createElementNS)","        {","            if(label.style.filter)","            {","                label.style.filter = null;","            }","        }","        label.style.display = \"block\";","        label.style.whiteSpace = \"nowrap\";","        label.style.position = \"absolute\";","        for(i in styles)","        {","            if(styles.hasOwnProperty(i) && !customStyles.hasOwnProperty(i))","            {","                label.style[i] = styles[i];","            }","        }","        return label;","    },","","    /**","     * Creates a cache of labels that can be re-used when the axis redraws.","     *","     * @method _createLabelCache","     * @private","     */","    _createLabelCache: function()","    {","        if(this._labels)","        {","            while(this._labels.length > 0)","            {","                this._labelCache.push(this._labels.shift());","            }","        }","        else","        {","            this._clearLabelCache();","        }","        this._labels = [];","    },","","    /**","     * Removes axis labels from the dom and clears the label cache.","     *","     * @method _clearLabelCache","     * @private","     */","    _clearLabelCache: function()","    {","        if(this._labelCache)","        {","            var len = this._labelCache.length,","                i = 0,","                label;","            for(; i < len; ++i)","            {","                label = this._labelCache[i];","                this._removeChildren(label);","                Y.Event.purgeElement(label, true);","                label.parentNode.removeChild(label);","            }","        }","        this._labelCache = [];","    },","","    /**","     * Gets the end point of an axis.","     *","     * @method getLineEnd","     * @return Object","     * @private","     */","    getLineEnd: function(pt)","    {","        var w = this.get(\"width\"),","            h = this.get(\"height\"),","            pos = this.get(\"position\");","        if(pos === \"top\" || pos === \"bottom\")","        {","            return {x:w, y:pt.y};","        }","        else","        {","            return {x:pt.x, y:h};","        }","    },","","    /**","     * Calcuates the width or height of an axis depending on its direction.","     *","     * @method getLength","     * @return Number","     * @private","     */","    getLength: function()","    {","        var l,","            style = this.get(\"styles\"),","            padding = style.padding,","            w = this.get(\"width\"),","            h = this.get(\"height\"),","            pos = this.get(\"position\");","        if(pos === \"top\" || pos === \"bottom\")","        {","            l = w - (padding.left + padding.right);","        }","        else","        {","            l = h - (padding.top + padding.bottom);","        }","        return l;","    },","","    /**","     * Gets the position of the first point on an axis.","     *","     * @method getFirstPoint","     * @param {Object} pt Object containing x and y coordinates.","     * @return Object","     * @private","     */","    getFirstPoint:function(pt)","    {","        var style = this.get(\"styles\"),","            pos = this.get(\"position\"),","            padding = style.padding,","            np = {x:pt.x, y:pt.y};","        if(pos === \"top\" || pos === \"bottom\")","        {","            np.x += padding.left + this.get(\"edgeOffset\");","        }","        else","        {","            np.y += this.get(\"height\") - (padding.top + this.get(\"edgeOffset\"));","        }","        return np;","    },","","    /**","     * Gets the position of the next point on an axis.","     *","     * @method getNextPoint","     * @param {Object} point Object containing x and y coordinates.","     * @param {Number} majorUnitDistance Distance in pixels between ticks.","     * @return Object","     * @private","     */","    getNextPoint: function(point, majorUnitDistance)","    {","        var pos = this.get(\"position\");","        if(pos === \"top\" || pos === \"bottom\")","        {","            point.x = point.x + majorUnitDistance;","        }","        else","        {","            point.y = point.y - majorUnitDistance;","        }","        return point;","    },","","    /**","     * Calculates the placement of last tick on an axis.","     *","     * @method getLastPoint","     * @return Object","     * @private","     */","    getLastPoint: function()","    {","        var style = this.get(\"styles\"),","            padding = style.padding,","            w = this.get(\"width\"),","            pos = this.get(\"position\");","        if(pos === \"top\" || pos === \"bottom\")","        {","            return {x:w - padding.right, y:padding.top};","        }","        else","        {","            return {x:padding.left, y:padding.top};","        }","    },","","    /**","     * Calculates position on the axis.","     *","     * @method getPosition","     * @param {Object} point contains x and y values","     * @private","     */","    getPosition: function(point)","    {","        var p,","            h = this.get(\"height\"),","            style = this.get(\"styles\"),","            padding = style.padding,","            pos = this.get(\"position\"),","            dataType = this.get(\"dataType\");","        if(pos === \"left\" || pos === \"right\")","        {","            //Numeric data on a vertical axis is displayed from bottom to top.","            //Categorical and Timeline data is displayed from top to bottom.","            if(dataType === \"numeric\")","            {","                p = (h - (padding.top + padding.bottom)) - (point.y - padding.top);","            }","            else","            {","                p = point.y - padding.top;","            }","        }","        else","        {","            p = point.x - padding.left;","        }","        return p;","    },","","    /**","     * Rotates and positions a text field.","     *","     * @method _rotate","     * @param {HTMLElement} label text field to rotate and position","     * @param {Object} props properties to be applied to the text field.","     * @private","     */","    _rotate: function(label, props)","    {","        var rot = props.rot,","            x = props.x,","            y = props.y,","            filterString,","            textAlpha,","            matrix = new Y.Matrix(),","            transformOrigin = props.transformOrigin || [0, 0],","            offsetRect;","        if(DOCUMENT.createElementNS)","        {","            matrix.translate(x, y);","            matrix.rotate(rot);","            Y_DOM.setStyle(label, \"transformOrigin\", (transformOrigin[0] * 100) + \"% \" + (transformOrigin[1] * 100) + \"%\");","            Y_DOM.setStyle(label, \"transform\", matrix.toCSSText());","        }","        else","        {","            textAlpha = props.textAlpha;","            if(Y_Lang.isNumber(textAlpha) && textAlpha < 1 && textAlpha > -1 && !isNaN(textAlpha))","            {","                filterString = \"progid:DXImageTransform.Microsoft.Alpha(Opacity=\" + Math.round(textAlpha * 100) + \")\";","            }","            if(rot !== 0)","            {","                //ms filters kind of, sort of uses a transformOrigin of 0, 0.","                //we'll translate the difference to create a true 0, 0 origin.","                matrix.rotate(rot);","                offsetRect = matrix.getContentRect(props.labelWidth, props.labelHeight);","                matrix.init();","                matrix.translate(offsetRect.left, offsetRect.top);","                matrix.translate(x, y);","                this._simulateRotateWithTransformOrigin(matrix, rot, transformOrigin, props.labelWidth, props.labelHeight);","                if(filterString)","                {","                    filterString += \" \";","                }","                else","                {","                    filterString = \"\";","                }","                filterString += matrix.toFilterText();","                label.style.left = matrix.dx + \"px\";","                label.style.top = matrix.dy + \"px\";","            }","            else","            {","                label.style.left = x + \"px\";","                label.style.top = y + \"px\";","            }","            if(filterString)","            {","                label.style.filter = filterString;","            }","        }","    },","","    /**","     * Simulates a rotation with a specified transformOrigin.","     *","     * @method _simulateTransformOrigin","     * @param {Matrix} matrix Reference to a `Matrix` instance.","     * @param {Number} rot The rotation (in degrees) that will be performed on a matrix.","     * @param {Array} transformOrigin An array represeniting the origin in which to perform the transform. The first","     * index represents the x origin and the second index represents the y origin.","     * @param {Number} w The width of the object that will be transformed.","     * @param {Number} h The height of the object that will be transformed.","     * @private","     */","    _simulateRotateWithTransformOrigin: function(matrix, rot, transformOrigin, w, h)","    {","        var transformX = transformOrigin[0] * w,","            transformY = transformOrigin[1] * h;","        transformX = !isNaN(transformX) ? transformX : 0;","        transformY = !isNaN(transformY) ? transformY : 0;","        matrix.translate(transformX, transformY);","        matrix.rotate(rot);","        matrix.translate(-transformX, -transformY);","    },","","    /**","     * Returns the coordinates (top, right, bottom, left) for the bounding box of the last label.","     *","     * @method getMaxLabelBounds","     * @return Object","     */","    getMaxLabelBounds: function()","    {","        return this._getLabelBounds(this.getMaximumValue());","    },","","    /**","     * Returns the coordinates (top, right, bottom, left) for the bounding box of the first label.","     *","     * @method getMinLabelBounds","     * @return Object","     */","    getMinLabelBounds: function()","    {","        return this._getLabelBounds(this.getMinimumValue());","    },","","    /**","     * Returns the coordinates (top, right, bottom, left) for the bounding box of a label.","     *","     * @method _getLabelBounds","     * @param {String} Value of the label","     * @return Object","     * @private","     */","    _getLabelBounds: function(val)","    {","        var layout = this._layout,","            labelStyles = this.get(\"styles\").label,","            matrix = new Y.Matrix(),","            label,","            props = this._getTextRotationProps(labelStyles);","            props.transformOrigin = layout._getTransformOrigin(props.rot);","        label = this.getLabel({x: 0, y: 0}, labelStyles);","        this.get(\"appendLabelFunction\")(label, this.get(\"labelFunction\").apply(this, [val, this.get(\"labelFormat\")]));","        props.labelWidth = label.offsetWidth;","        props.labelHeight = label.offsetHeight;","        this._removeChildren(label);","        Y.Event.purgeElement(label, true);","        label.parentNode.removeChild(label);","        props.x = 0;","        props.y = 0;","        layout._setRotationCoords(props);","        matrix.translate(props.x, props.y);","        this._simulateRotateWithTransformOrigin(matrix, props.rot, props.transformOrigin, props.labelWidth, props.labelHeight);","        return matrix.getContentRect(props.labelWidth, props.labelHeight);","    },","","    /**","     * Removes all DOM elements from an HTML element. Used to clear out labels during detruction","     * phase.","     *","     * @method _removeChildren","     * @private","     */","    _removeChildren: function(node)","    {","        if(node.hasChildNodes())","        {","            var child;","            while(node.firstChild)","            {","                child = node.firstChild;","                this._removeChildren(child);","                node.removeChild(child);","            }","        }","    },","","    /**","     * Destructor implementation Axis class. Removes all labels and the Graphic instance from the widget.","     *","     * @method destructor","     * @protected","     */","    destructor: function()","    {","        var cb = this.get(\"contentBox\").getDOMNode(),","            labels = this.get(\"labels\"),","            graphic = this.get(\"graphic\"),","            label,","            len = labels ? labels.length : 0;","        if(len > 0)","        {","            while(labels.length > 0)","            {","                label = labels.shift();","                this._removeChildren(label);","                cb.removeChild(label);","                label = null;","            }","        }","        if(graphic)","        {","            graphic.destroy();","        }","    },","","    /**","     * Length in pixels of largest text bounding box. Used to calculate the height of the axis.","     *","     * @property maxLabelSize","     * @type Number","     * @protected","     */","    _maxLabelSize: 0,","","    /**","     * Updates the content of text field. This method writes a value into a text field using","     * `appendChild`. If the value is a `String`, it is converted to a `TextNode` first.","     *","     * @method _setText","     * @param label {HTMLElement} label to be updated","     * @param val {String} value with which to update the label","     * @private","     */","    _setText: function(textField, val)","    {","        textField.innerHTML = \"\";","        if(Y_Lang.isNumber(val))","        {","            val = val + \"\";","        }","        else if(!val)","        {","            val = \"\";","        }","        if(IS_STRING(val))","        {","            val = DOCUMENT.createTextNode(val);","        }","        textField.appendChild(val);","    }","}, {","    ATTRS:","    {","        /**","         * When set, defines the width of a vertical axis instance. By default, vertical axes automatically size based","         * on their contents. When the width attribute is set, the axis will not calculate its width. When the width","         * attribute is explicitly set, axis labels will postion themselves off of the the inner edge of the axis and the","         * title, if present, will position itself off of the outer edge. If a specified width is less than the sum of","         * the axis' contents, excess content will overflow.","         *","         * @attribute width","         * @type Number","         */","        width: {","            lazyAdd: false,","","            getter: function()","            {","                if(this._explicitWidth)","                {","                    return this._explicitWidth;","                }","                return this._calculatedWidth;","            },","","            setter: function(val)","            {","                this._explicitWidth = val;","                return val;","            }","        },","","        /**","         * When set, defines the height of a horizontal axis instance. By default, horizontal axes automatically size based","         * on their contents. When the height attribute is set, the axis will not calculate its height. When the height","         * attribute is explicitly set, axis labels will postion themselves off of the the inner edge of the axis and the","         * title, if present, will position itself off of the outer edge. If a specified height is less than the sum of","         * the axis' contents, excess content will overflow.","         *","         * @attribute height","         * @type Number","         */","        height: {","            lazyAdd: false,","","            getter: function()","            {","                if(this._explicitHeight)","                {","                    return this._explicitHeight;","                }","                return this._calculatedHeight;","            },","","            setter: function(val)","            {","                this._explicitHeight = val;","                return val;","            }","        },","","        /**","         * Calculated value of an axis' width. By default, the value is used internally for vertical axes. If the `width`","         * attribute is explicitly set, this value will be ignored.","         *","         * @attribute calculatedWidth","         * @type Number","         * @private","         */","        calculatedWidth: {","            getter: function()","            {","                return this._calculatedWidth;","            },","","            setter: function(val)","            {","                this._calculatedWidth = val;","                return val;","            }","        },","","        /**","         * Calculated value of an axis' height. By default, the value is used internally for horizontal axes. If the `height`","         * attribute is explicitly set, this value will be ignored.","         *","         * @attribute calculatedHeight","         * @type Number","         * @private","         */","        calculatedHeight: {","            getter: function()","            {","                return this._calculatedHeight;","            },","","            setter: function(val)","            {","                this._calculatedHeight = val;","                return val;","            }","        },","","        /**","         * Difference betweend the first/last tick and edge of axis.","         *","         * @attribute edgeOffset","         * @type Number","         * @protected","         */","        edgeOffset:","        {","            value: 0","        },","","        /**","         * The graphic in which the axis line and ticks will be rendered.","         *","         * @attribute graphic","         * @type Graphic","         */","        graphic: {},","","        /**","         *  @attribute path","         *  @type Shape","         *  @readOnly","         *  @private","         */","        path: {","            readOnly: true,","","            getter: function()","            {","                if(!this._path)","                {","                    var graphic = this.get(\"graphic\");","                    if(graphic)","                    {","                        this._path = graphic.addShape({type:\"path\"});","                    }","                }","                return this._path;","            }","        },","","        /**","         *  @attribute tickPath","         *  @type Shape","         *  @readOnly","         *  @private","         */","        tickPath: {","            readOnly: true,","","            getter: function()","            {","                if(!this._tickPath)","                {","                    var graphic = this.get(\"graphic\");","                    if(graphic)","                    {","                        this._tickPath = graphic.addShape({type:\"path\"});","                    }","                }","                return this._tickPath;","            }","        },","","        /**","         * Contains the contents of the axis.","         *","         * @attribute node","         * @type HTMLElement","         */","        node: {},","","        /**","         * Direction of the axis.","         *","         * @attribute position","         * @type String","         */","        position: {","            setter: function(val)","            {","                var layoutClass = this._layoutClasses[val];","                if(val && val != \"none\")","                {","                    this._layout = new layoutClass();","                }","                return val;","            }","        },","","        /**","         * Distance determined by the tick styles used to calculate the distance between the axis","         * line in relation to the top of the axis.","         *","         * @attribute topTickOffset","         * @type Number","         */","        topTickOffset: {","            value: 0","        },","","        /**","         * Distance determined by the tick styles used to calculate the distance between the axis","         * line in relation to the bottom of the axis.","         *","         * @attribute bottomTickOffset","         * @type Number","         */","        bottomTickOffset: {","            value: 0","        },","","        /**","         * Distance determined by the tick styles used to calculate the distance between the axis","         * line in relation to the left of the axis.","         *","         * @attribute leftTickOffset","         * @type Number","         */","        leftTickOffset: {","            value: 0","        },","","        /**","         * Distance determined by the tick styles used to calculate the distance between the axis","         * line in relation to the right side of the axis.","         *","         * @attribute rightTickOffset","         * @type Number","         */","        rightTickOffset: {","            value: 0","        },","","        /**","         * Collection of labels used to render the axis.","         *","         * @attribute labels","         * @type Array","         */","        labels: {","            readOnly: true,","            getter: function()","            {","                return this._labels;","            }","        },","","        /**","         * Collection of points used for placement of labels and ticks along the axis.","         *","         * @attribute tickPoints","         * @type Array","         */","        tickPoints: {","            readOnly: true,","","            getter: function()","            {","                if(this.get(\"position\") == \"none\")","                {","                    return this.get(\"styles\").majorUnit.count;","                }","                return this._tickPoints;","            }","        },","","        /**","         * Indicates whether the axis overlaps the graph. If an axis is the inner most axis on a given","         * position and the tick position is inside or cross, the axis will need to overlap the graph.","         *","         * @attribute overlapGraph","         * @type Boolean","         */","        overlapGraph: {","            value:true,","","            validator: function(val)","            {","                return Y_Lang.isBoolean(val);","            }","        },","","        /**","         * Object which should have by the labelFunction","         *","         * @attribute labelFunctionScope","         * @type Object","         */","        labelFunctionScope: {},","","        /**","         * Length in pixels of largest text bounding box. Used to calculate the height of the axis.","         *","         * @attribute maxLabelSize","         * @type Number","         * @protected","         */","        maxLabelSize: {","            getter: function()","            {","                return this._maxLabelSize;","            },","","            setter: function(val)","            {","                this._maxLabelSize = val;","                return val;","            }","        },","","        /**","         *  Title for the axis. When specified, the title will display. The position of the title is determined by the axis position.","         *  <dl>","         *      <dt>top</dt><dd>Appears above the axis and it labels. The default rotation is 0.</dd>","         *      <dt>right</dt><dd>Appears to the right of the axis and its labels. The default rotation is 90.</dd>","         *      <dt>bottom</dt><dd>Appears below the axis and its labels. The default rotation is 0.</dd>","         *      <dt>left</dt><dd>Appears to the left of the axis and its labels. The default rotation is -90.</dd>","         *  </dl>","         *","         *  @attribute title","         *  @type String","         */","        title: {","            value: null","        },","","        /**","         * Method used for formatting a label. This attribute allows for the default label formatting method to overridden.","         * The method use would need to implement the arguments below and return a `String` or `HTMLElement`.","         * <dl>","         *      <dt>val</dt><dd>Label to be formatted. (`String`)</dd>","         *      <dt>format</dt><dd>Template for formatting label. (optional)</dd>","         * </dl>","         *","         * @attribute labelFunction","         * @type Function","         */","        labelFunction: {","            value: function(val, format)","            {","                return val;","            }","        },","","        /**","         * Function used to append an axis value to an axis label. This function has the following signature:","         *  <dl>","         *      <dt>textField</dt><dd>The axis label to be appended. (`HTMLElement`)</dd>","         *      <dt>val</dt><dd>The value to attach to the text field. This method will accept an `HTMLELement`","         *      or a `String`. This method does not use (`HTMLElement` | `String`)</dd>","         *  </dl>","         * The default method appends a value to the `HTMLElement` using the `appendChild` method. If the given","         * value is a `String`, the method will convert the the value to a `textNode` before appending to the","         * `HTMLElement`. This method will not convert an `HTMLString` to an `HTMLElement`.","         *","         * @attribute appendLabelFunction","         * @type Function","         */","        appendLabelFunction: {","            valueFn: function()","            {","                return this._setText;","            }","        },","","        /**","         * Function used to append a title value to the title object. This function has the following signature:","         *  <dl>","         *      <dt>textField</dt><dd>The title text field to be appended. (`HTMLElement`)</dd>","         *      <dt>val</dt><dd>The value to attach to the text field. This method will accept an `HTMLELement`","         *      or a `String`. This method does not use (`HTMLElement` | `String`)</dd>","         *  </dl>","         * The default method appends a value to the `HTMLElement` using the `appendChild` method. If the given","         * value is a `String`, the method will convert the the value to a `textNode` before appending to the","         * `HTMLElement` element. This method will not convert an `HTMLString` to an `HTMLElement`.","         *","         * @attribute appendTitleFunction","         * @type Function","         */","        appendTitleFunction: {","            valueFn: function()","            {","                return this._setText;","            }","        }","","        /**","         * Style properties used for drawing an axis. This attribute is inherited from `Renderer`. Below are the default values:","         *  <dl>","         *      <dt>majorTicks</dt><dd>Properties used for drawing ticks.","         *          <dl>","         *              <dt>display</dt><dd>Position of the tick. Possible values are `inside`, `outside`, `cross` and `none`.","         *              The default value is `inside`.</dd>","         *              <dt>length</dt><dd>The length (in pixels) of the tick. The default value is 4.</dd>","         *              <dt>color</dt><dd>The color of the tick. The default value is `#dad8c9`</dd>","         *              <dt>weight</dt><dd>Number indicating the width of the tick. The default value is 1.</dd>","         *              <dt>alpha</dt><dd>Number from 0 to 1 indicating the opacity of the tick. The default value is 1.</dd>","         *          </dl>","         *      </dd>","         *      <dt>line</dt><dd>Properties used for drawing the axis line.","         *          <dl>","         *              <dt>weight</dt><dd>Number indicating the width of the axis line. The default value is 1.</dd>","         *              <dt>color</dt><dd>The color of the axis line. The default value is `#dad8c9`.</dd>","         *              <dt>alpha</dt><dd>Number from 0 to 1 indicating the opacity of the tick. The default value is 1.</dd>","         *          </dl>","         *      </dd>","         *      <dt>majorUnit</dt><dd>Properties used to calculate the `majorUnit` for the axis.","         *          <dl>","         *              <dt>determinant</dt><dd>The algorithm used for calculating distance between ticks. The possible options are","         *              `count` and `distance`. If the `determinant` is `count`, the axis ticks will spaced so that a specified number","         *              of ticks appear on the axis. If the `determinant` is `distance`, the axis ticks will spaced out according to","         *              the specified distance. The default value is `count`.</dd>","         *              <dt>count</dt><dd>Number of ticks to appear on the axis when the `determinant` is `count`. The default value is 11.</dd>","         *              <dt>distance</dt><dd>The distance (in pixels) between ticks when the `determinant` is `distance`. The default","         *              value is 75.</dd>","         *          </dl>","         *      </dd>","         *      <dt>label</dt><dd>Properties and styles applied to the axis labels.","         *          <dl>","         *              <dt>color</dt><dd>The color of the labels. The default value is `#808080`.</dd>","         *              <dt>alpha</dt><dd>Number between 0 and 1 indicating the opacity of the labels. The default value is 1.</dd>","         *              <dt>fontSize</dt><dd>The font-size of the labels. The default value is 85%</dd>","         *              <dt>rotation</dt><dd>The rotation, in degrees (between -90 and 90) of the labels. The default value is 0.</dd>","         *              <dt>margin</dt><dd>The distance between the label and the axis/tick. Depending on the position of the `Axis`,","         *              only one of the properties used.","         *                  <dl>","         *                      <dt>top</dt><dd>Pixel value used for an axis with a `position` of `bottom`. The default value is 4.</dd>","         *                      <dt>right</dt><dd>Pixel value used for an axis with a `position` of `left`. The default value is 4.</dd>","         *                      <dt>bottom</dt><dd>Pixel value used for an axis with a `position` of `top`. The default value is 4.</dd>","         *                      <dt>left</dt><dd>Pixel value used for an axis with a `position` of `right`. The default value is 4.</dd>","         *                  </dl>","         *              </dd>","         *          </dl>","         *      </dd>","         *  </dl>","         *","         * @attribute styles","         * @type Object","         */","    }","});","/**"," * AxisType is an abstract class that manages the data for an axis."," *"," * @module charts"," * @submodule charts-base"," * @class AxisType"," * @constructor"," * @extends Axis"," */","Y.AxisType = Y.Base.create(\"baseAxis\", Y.Axis, [], {","    /**","     * @method initializer","     * @private","     */","    initializer: function()","    {","        this.after(\"dataReady\", Y.bind(this._dataChangeHandler, this));","        this.after(\"dataUpdate\", Y.bind(this._dataChangeHandler, this));","        this.after(\"minimumChange\", Y.bind(this._keyChangeHandler, this));","        this.after(\"maximumChange\", Y.bind(this._keyChangeHandler, this));","        this.after(\"keysChange\", this._keyChangeHandler);","        this.after(\"dataProviderChange\", this._dataProviderChangeHandler);","        this.after(\"alwaysShowZeroChange\", this._keyChangeHandler);","        this.after(\"roundingMethodChange\", this._keyChangeHandler);","    },","","    /**","     * @method bindUI","     * @private","     */","    bindUI: function()","    {","        this.after(\"stylesChange\", this._updateHandler);","        this.after(\"overlapGraphChange\", this._updateHandler);","        this.after(\"positionChange\", this._positionChangeHandler);","        this.after(\"widthChange\", this._handleSizeChange);","        this.after(\"heightChange\", this._handleSizeChange);","        this.after(\"calculatedWidthChange\", this._handleSizeChange);","        this.after(\"calculatedHeightChange\", this._handleSizeChange);","    },","","    /**","     * Handles changes to `dataProvider`.","     *","     * @method _dataProviderChangeHandler","     * @param {Object} e Event object.","     * @private","     */","    _dataProviderChangeHandler: function(e)","    {","        var keyCollection = this.get(\"keyCollection\").concat(),","            keys = this.get(\"keys\"),","            i;","        if(keys)","        {","            for(i in keys)","            {","                if(keys.hasOwnProperty(i))","                {","                    delete keys[i];","                }","            }","        }","        if(keyCollection && keyCollection.length)","        {","            this.set(\"keys\", keyCollection);","        }","    },","","    /**","     * Constant used to generate unique id.","     *","     * @property GUID","     * @type String","     * @private","     */","    GUID: \"yuibaseaxis\",","","    /**","     * Type of data used in `Axis`.","     *","     * @property _type","     * @type String","     * @readOnly","     * @private","     */","    _type: null,","","    /**","     * Storage for `setMaximum` attribute.","     *","     * @property _setMaximum","     * @type Object","     * @private","     */","    _setMaximum: null,","","    /**","     * Storage for `dataMaximum` attribute.","     *","     * @property _dataMaximum","     * @type Object","     * @private","     */","    _dataMaximum: null,","","    /**","     * Storage for `setMinimum` attribute.","     *","     * @property _setMinimum","     * @type Object","     * @private","     */","    _setMinimum: null,","","    /**","     * Reference to data array.","     *","     * @property _data","     * @type Array","     * @private","     */","    _data: null,","","    /**","     * Indicates whether the all data is up to date.","     *","     * @property _updateTotalDataFlag","     * @type Boolean","     * @private","     */","    _updateTotalDataFlag: true,","","    /**","     * Storage for `dataReady` attribute.","     *","     * @property _dataReady","     * @type Boolean","     * @readOnly","     * @private","     */","    _dataReady: false,","","    /**","     * Adds an array to the key hash.","     *","     * @method addKey","     * @param value Indicates what key to use in retrieving","     * the array.","     */","    addKey: function (value)","	{","        this.set(\"keys\", value);","	},","","    /**","     * Gets an array of values based on a key.","     *","     * @method _getKeyArray","     * @param {String} key Value key associated with the data array.","     * @param {Array} data Array in which the data resides.","     * @return Array","     * @private","     */","    _getKeyArray: function(key, data)","    {","        var i = 0,","            obj,","            keyArray = [],","            len = data.length;","        for(; i < len; ++i)","        {","            obj = data[i];","            keyArray[i] = obj[key];","        }","        return keyArray;","    },","","    /**","     * Sets data by key","     *","     * @method _setDataByKey","     * @param {String} key Key value to use.","     * @param {Array} data Array to use.","     * @private","     */","    _setDataByKey: function(key, data)","    {","        var i,","            obj,","            arr = [],","            dv = this._dataClone.concat(),","            len = dv.length;","        for(i = 0; i < len; ++i)","        {","            obj = dv[i];","            arr[i] = obj[key];","        }","        this.get(\"keys\")[key] = arr;","        this._updateTotalDataFlag = true;","    },","","    /**","     * Updates the total data array.","     *","     * @method _updateTotalData","     * @private","     */","    _updateTotalData: function()","    {","		var keys = this.get(\"keys\"),","            i;","        this._data = [];","        for(i in keys)","        {","            if(keys.hasOwnProperty(i))","            {","                this._data = this._data.concat(keys[i]);","            }","        }","        this._updateTotalDataFlag = false;","    },","","    /**","     * Removes an array from the key hash.","     *","     * @method removeKey","     * @param {String} value Indicates what key to use in removing from","     * the hash.","     */","    removeKey: function(value)","    {","        var keys = this.get(\"keys\");","        if(keys.hasOwnProperty(value))","        {","            delete keys[value];","            this._keyChangeHandler();","        }","    },","","    /**","     * Returns a value based of a key value and an index.","     *","     * @method getKeyValueAt","     * @param {String} key value used to look up the correct array","     * @param {Number} index within the array","     * @return Number","     */","    getKeyValueAt: function(key, index)","    {","        var value = NaN,","            keys = this.get(\"keys\");","        if(keys[key] && Y_Lang.isNumber(parseFloat(keys[key][index])))","        {","            value = keys[key][index];","        }","        return parseFloat(value);","    },","","    /**","     * Returns an array of values based on an identifier key.","     *","     * @method getDataByKey","     * @param {String} value value used to identify the array","     * @return Object","     */","    getDataByKey: function (value)","    {","        var keys = this.get(\"keys\");","        if(keys[value])","        {","            return keys[value];","        }","        return null;","    },","","    /**","     * Calculates the maximum and minimum values for the `Axis`.","     *","     * @method _updateMinAndMax","     * @private","     */","    _updateMinAndMax: function()","    {","        var data = this.get(\"data\"),","            max = 0,","            min = 0,","            len,","            num,","            i;","        if(data && data.length && data.length > 0)","        {","            len = data.length;","            max = min = data[0];","            if(len > 1)","            {","                for(i = 1; i < len; i++)","                {","                    num = data[i];","                    if(isNaN(num))","                    {","                        continue;","                    }","                    max = Math.max(num, max);","                    min = Math.min(num, min);","                }","            }","        }","        this._dataMaximum = max;","        this._dataMinimum = min;","    },","","    /**","     * Returns the total number of majorUnits that will appear on an axis.","     *","     * @method getTotalMajorUnits","     * @return Number","     */","    getTotalMajorUnits: function()","    {","        var units,","            majorUnit = this.get(\"styles\").majorUnit,","            len = this.get(\"length\");","        if(majorUnit.determinant === \"count\")","        {","            units = majorUnit.count;","        }","        else if(majorUnit.determinant === \"distance\")","        {","            units = (len/majorUnit.distance) + 1;","        }","        return units;","    },","","    /**","     * Returns the distance between major units on an axis.","     *","     * @method getMajorUnitDistance","     * @param {Number} len Number of ticks","     * @param {Number} uiLen Size of the axis.","     * @param {Object} majorUnit Hash of properties used to determine the majorUnit","     * @return Number","     */","    getMajorUnitDistance: function(len, uiLen, majorUnit)","    {","        var dist;","        if(majorUnit.determinant === \"count\")","        {","            dist = uiLen/(len - 1);","        }","        else if(majorUnit.determinant === \"distance\")","        {","            dist = majorUnit.distance;","        }","        return dist;","    },","","    /**","     * Gets the distance that the first and last ticks are offset from there respective","     * edges.","     *","     * @method getEdgeOffset","     * @param {Number} ct Number of ticks on the axis.","     * @param {Number} l Length (in pixels) of the axis.","     * @return Number","     */","    getEdgeOffset: function(ct, l)","    {","        return 0;","    },","","    /**","     * Calculates and returns a value based on the number of labels and the index of","     * the current label.","     *","     * @method getLabelByIndex","     * @param {Number} i Index of the label.","     * @param {Number} l Total number of labels.","     * @return String","     */","    getLabelByIndex: function(i, l)","    {","        var min = this.get(\"minimum\"),","            max = this.get(\"maximum\"),","            increm = (max - min)/(l-1),","            label;","            l -= 1;","        label = min + (i * increm);","        return label;","    },","","    /**","     * Updates the `Axis` after a change in keys.","     *","     * @method _keyChangeHandler","     * @param {Object} e Event object.","     * @private","     */","    _keyChangeHandler: function(e)","    {","        this._updateMinAndMax();","        this.fire(\"dataUpdate\");","    },","","    /**","     * Checks to see if data extends beyond the range of the axis. If so,","     * that data will need to be hidden. This method is internal, temporary and subject","     * to removal in the future.","     *","     * @method _hasDataOverflow","     * @protected","     * @return Boolean","     */","    _hasDataOverflow: function()","    {","        if(this.get(\"setMin\") || this.get(\"setMax\"))","        {","            return true;","        }","        return false;","    },","","    /**","     * Returns a string corresponding to the first label on an","     * axis.","     *","     * @method getMinimumValue","     * @return String","     */","    getMinimumValue: function()","    {","        return this.get(\"minimum\");","    },","","    /**","     * Returns a string corresponding to the last label on an","     * axis.","     *","     * @method getMaximumValue","     * @return String","     */","    getMaximumValue: function()","    {","        return this.get(\"maximum\");","    }","}, {","    ATTRS: {","        /**","         * Hash of array identifed by a string value.","         *","         * @attribute keys","         * @type Object","         */","        keys: {","            value: {},","","            setter: function(val)","            {","                var keys = {},","                    i,","                    len,","                    data = this.get(\"dataProvider\");","                if(Y_Lang.isArray(val))","                {","                    len = val.length;","                    for(i = 0; i < len; ++i)","                    {","                        keys[val[i]] = this._getKeyArray(val[i], data);","                    }","","                }","                else if(Y_Lang.isString(val))","                {","                    keys = this.get(\"keys\");","                    keys[val] = this._getKeyArray(val, data);","                }","                else","                {","                    for(i in val)","                    {","                        if(val.hasOwnProperty(i))","                        {","                            keys[i] = this._getKeyArray(i, data);","                        }","                    }","                }","                this._updateTotalDataFlag = true;","                return keys;","            }","        },","","        /**","         *Indicates how to round unit values.","         *  <dl>","         *      <dt>niceNumber</dt><dd>Units will be smoothed based on the number of ticks and data range.</dd>","         *      <dt>auto</dt><dd>If the range is greater than 1, the units will be rounded.</dd>","         *      <dt>numeric value</dt><dd>Units will be equal to the numeric value.</dd>","         *      <dt>null</dt><dd>No rounding will occur.</dd>","         *  </dl>","         *","         * @attribute roundingMethod","         * @type String","         * @default niceNumber","         */","        roundingMethod: {","            value: \"niceNumber\"","        },","","        /**","         *Returns the type of axis data","         *  <dl>","         *      <dt>time</dt><dd>Manages time data</dd>","         *      <dt>stacked</dt><dd>Manages stacked numeric data</dd>","         *      <dt>numeric</dt><dd>Manages numeric data</dd>","         *      <dt>category</dt><dd>Manages categorical data</dd>","         *  </dl>","         *","         * @attribute type","         * @type String","         */","        type:","        {","            readOnly: true,","","            getter: function ()","            {","                return this._type;","            }","        },","","        /**","         * Instance of `ChartDataProvider` that the class uses","         * to build its own data.","         *","         * @attribute dataProvider","         * @type Array","         */","        dataProvider:{","            setter: function (value)","            {","                return value;","            }","        },","","        /**","         * The maximum value contained in the `data` array. Used for","         * `maximum` when `autoMax` is true.","         *","         * @attribute dataMaximum","         * @type Number","         */","        dataMaximum: {","            getter: function ()","            {","                if(!this._dataMaximum)","                {","                    this._updateMinAndMax();","                }","                return this._dataMaximum;","            }","        },","","        /**","         * The maximum value that will appear on an axis.","         *","         * @attribute maximum","         * @type Number","         */","        maximum: {","            lazyAdd: false,","","            getter: function ()","            {","                var max = this.get(\"dataMaximum\"),","                    min = this.get(\"minimum\");","                //If all values are zero, force a range so that the Axis and related series","                //will still render.","                if(min === 0 && max === 0)","                {","                    max = 10;","                }","                if(Y_Lang.isNumber(this._setMaximum))","                {","                    max = this._setMaximum;","                }","                return parseFloat(max);","            },","            setter: function (value)","            {","                this._setMaximum = parseFloat(value);","                return value;","            }","        },","","        /**","         * The minimum value contained in the `data` array. Used for","         * `minimum` when `autoMin` is true.","         *","         * @attribute dataMinimum","         * @type Number","         */","        dataMinimum: {","            getter: function ()","            {","                if(!this._dataMinimum)","                {","                    this._updateMinAndMax();","                }","                return this._dataMinimum;","            }","        },","","        /**","         * The minimum value that will appear on an axis.","         *","         * @attribute minimum","         * @type Number","         */","        minimum: {","            lazyAdd: false,","","            getter: function ()","            {","                var min = this.get(\"dataMinimum\");","                if(Y_Lang.isNumber(this._setMinimum))","                {","                    min = this._setMinimum;","                }","                return parseFloat(min);","            },","            setter: function(val)","            {","                this._setMinimum = parseFloat(val);","                return val;","            }","        },","","        /**","         * Determines whether the maximum is calculated or explicitly","         * set by the user.","         *","         * @attribute setMax","         * @type Boolean","         */","        setMax: {","            readOnly: true,","","            getter: function()","            {","                return Y_Lang.isNumber(this._setMaximum);","            }","        },","","        /**","         * Determines whether the minimum is calculated or explicitly","         * set by the user.","         *","         * @attribute setMin","         * @type Boolean","         */","        setMin: {","            readOnly: true,","","            getter: function()","            {","                return Y_Lang.isNumber(this._setMinimum);","            }","        },","","        /**","         * Array of axis data","         *","         * @attribute data","         * @type Array","         */","        data: {","            getter: function ()","            {","                if(!this._data || this._updateTotalDataFlag)","                {","                    this._updateTotalData();","                }","                return this._data;","            }","        },","","        /**","         * Array containing all the keys in the axis.","","         * @attribute keyCollection","         * @type Array","         */","        keyCollection: {","            getter: function()","            {","                var keys = this.get(\"keys\"),","                    i,","                    col = [];","                for(i in keys)","                {","                    if(keys.hasOwnProperty(i))","                    {","                        col.push(i);","                    }","                }","                return col;","            },","            readOnly: true","        }","    }","});","/**"," * NumericAxis manages numeric data on an axis."," *"," * @module charts"," * @submodule charts-base"," * @class NumericAxis"," * @constructor"," * @param {Object} config (optional) Configuration parameters for the Chart."," * @extends AxisType"," */","function NumericAxis(config)","{","	NumericAxis.superclass.constructor.apply(this, arguments);","}","","NumericAxis.NAME = \"numericAxis\";","","NumericAxis.ATTRS = {","    /**","     * Indicates whether 0 should always be displayed.","     *","     * @attribute alwaysShowZero","     * @type Boolean","     */","	alwaysShowZero: {","	    value: true","	},","","    /**","     * Method used for formatting a label. This attribute allows for the default label formatting method to overridden.","     * The method use would need to implement the arguments below and return a `String` or an `HTMLElement`. The default","     * implementation of the method returns a `String`. The output of this method will be rendered to the DOM using","     * `appendChild`. If you override the `labelFunction` method and return an html string, you will also need to override","     * the Axis' `appendLabelFunction` to accept html as a `String`.","     * <dl>","     *      <dt>val</dt><dd>Label to be formatted. (`String`)</dd>","     *      <dt>format</dt><dd>Object containing properties used to format the label. (optional)</dd>","     * </dl>","     *","     * @attribute labelFunction","     * @type Function","     */","    labelFunction: {","        value: function(val, format)","        {","            if(format)","            {","                return Y.DataType.Number.format(val, format);","            }","            return val;","        }","    },","","    /**","     * Object containing properties used by the `labelFunction` to format a","     * label.","     *","     * @attribute labelFormat","     * @type Object","     */","    labelFormat: {","        value: {","            prefix: \"\",","            thousandsSeparator: \"\",","            decimalSeparator: \"\",","            decimalPlaces: \"0\",","            suffix: \"\"","        }","    }","};","","Y.extend(NumericAxis, Y.AxisType,","{","    /**","     * Formats a label based on the axis type and optionally specified format.","     *","     * @method formatLabel","     * @param {Object} value","     * @param {Object} format Pattern used to format the value.","     * @return String","     */","    formatLabel: function(val, format)","    {","        if(format)","        {","            return Y.DataType.Number.format(val, format);","        }","        return val;","    },","","    /**","     * Returns the sum of all values per key.","     *","     * @method getTotalByKey","     * @param {String} key The identifier for the array whose values will be calculated.","     * @return Number","     */","    getTotalByKey: function(key)","    {","        var total = 0,","            values = this.getDataByKey(key),","            i = 0,","            val,","            len = values ? values.length : 0;","        for(; i < len; ++i)","        {","           val = parseFloat(values[i]);","           if(!isNaN(val))","           {","                total += val;","           }","        }","        return total;","    },","","    /**","     * Type of data used in `Axis`.","     *","     * @property _type","     * @readOnly","     * @private","     */","    _type: \"numeric\",","","    /**","     * Helper method for getting a `roundingUnit` when calculating the minimum and maximum values.","     *","     * @method _getMinimumUnit","     * @param {Number} max Maximum number","     * @param {Number} min Minimum number","     * @param {Number} units Number of units on the axis","     * @return Number","     * @private","     */","    _getMinimumUnit:function(max, min, units)","    {","        return this._getNiceNumber(Math.ceil((max - min)/units));","    },","","    /**","     * Calculates a nice rounding unit based on the range.","     *","     * @method _getNiceNumber","     * @param {Number} roundingUnit The calculated rounding unit.","     * @return Number","     * @private","     */","    _getNiceNumber: function(roundingUnit)","    {","        var tempMajorUnit = roundingUnit,","            order = Math.ceil(Math.log(tempMajorUnit) * 0.4342944819032518),","            roundedMajorUnit = Math.pow(10, order),","            roundedDiff;","","        if (roundedMajorUnit / 2 >= tempMajorUnit)","        {","            roundedDiff = Math.floor((roundedMajorUnit / 2 - tempMajorUnit) / (Math.pow(10,order-1)/2));","            tempMajorUnit = roundedMajorUnit/2 - roundedDiff*Math.pow(10,order-1)/2;","        }","        else","        {","            tempMajorUnit = roundedMajorUnit;","        }","        if(!isNaN(tempMajorUnit))","        {","            return tempMajorUnit;","        }","        return roundingUnit;","","    },","","    /**","     * Calculates the maximum and minimum values for the `Axis`.","     *","     * @method _updateMinAndMax","     * @private","     */","    _updateMinAndMax: function()","    {","        var data = this.get(\"data\"),","            max,","            min,","            len,","            num,","            i = 0,","            key,","            setMax = this.get(\"setMax\"),","            setMin = this.get(\"setMin\");","        if(!setMax || !setMin)","        {","            if(data && data.length && data.length > 0)","            {","                len = data.length;","                for(; i < len; i++)","                {","                    num = data[i];","                    if(isNaN(num))","                    {","                        if(Y_Lang.isObject(num))","                        {","                            min = max = 0;","                            //hloc values","                            for(key in num)","                            {","                               if(num.hasOwnProperty(key))","                               {","                                    max = Math.max(num[key], max);","                                    min = Math.min(num[key], min);","                               }","                            }","                        }","                        max = setMax ? this._setMaximum : max;","                        min = setMin ? this._setMinimum : min;","                        continue;","                    }","","                    if(setMin)","                    {","                        min = this._setMinimum;","                    }","                    else if(min === undefined)","                    {","                        min = num;","                    }","                    else","                    {","                        min = Math.min(num, min);","                    }","                    if(setMax)","                    {","                        max = this._setMaximum;","                    }","                    else if(max === undefined)","                    {","                        max = num;","                    }","                    else","                    {","                        max = Math.max(num, max);","                    }","","                    this._actualMaximum = max;","                    this._actualMinimum = min;","                }","            }","            this._roundMinAndMax(min, max, setMin, setMax);","        }","    },","","    /**","     * Rounds the mimimum and maximum values based on the `roundingUnit` attribute.","     *","     * @method _roundMinAndMax","     * @param {Number} min Minimum value","     * @param {Number} max Maximum value","     * @private","     */","    _roundMinAndMax: function(min, max, setMin, setMax)","    {","        var roundingUnit,","            minimumRange,","            minGreaterThanZero = min >= 0,","            maxGreaterThanZero = max > 0,","            dataRangeGreater,","            maxRound,","            minRound,","            topTicks,","            botTicks,","            tempMax,","            tempMin,","            units = this.getTotalMajorUnits() - 1,","            alwaysShowZero = this.get(\"alwaysShowZero\"),","            roundingMethod = this.get(\"roundingMethod\"),","            useIntegers = (max - min)/units >= 1;","        if(roundingMethod)","        {","            if(roundingMethod == \"niceNumber\")","            {","                roundingUnit = this._getMinimumUnit(max, min, units);","                if(minGreaterThanZero && maxGreaterThanZero)","                {","                    if((alwaysShowZero || min < roundingUnit) && !setMin)","                    {","                        min = 0;","                        roundingUnit = this._getMinimumUnit(max, min, units);","                    }","                    else","                    {","                       min = this._roundDownToNearest(min, roundingUnit);","                    }","                    if(setMax)","                    {","                        if(!alwaysShowZero)","                        {","                            min = max - (roundingUnit * units);","                        }","                    }","                    else if(setMin)","                    {","                        max = min + (roundingUnit * units);","                    }","                    else","                    {","                        max = this._roundUpToNearest(max, roundingUnit);","                    }","                }","                else if(maxGreaterThanZero && !minGreaterThanZero)","                {","                    if(alwaysShowZero)","                    {","                        topTicks = Math.round(units/((-1 * min)/max + 1));","                        topTicks = Math.max(Math.min(topTicks, units - 1), 1);","                        botTicks = units - topTicks;","                        tempMax = Math.ceil( max/topTicks );","                        tempMin = Math.floor( min/botTicks ) * -1;","","                        if(setMin)","                        {","                            while(tempMin < tempMax && botTicks >= 0)","                            {","                                botTicks--;","                                topTicks++;","                                tempMax = Math.ceil( max/topTicks );","                                tempMin = Math.floor( min/botTicks ) * -1;","                            }","                            //if there are any bottom ticks left calcualate the maximum by multiplying by the tempMin value","                            //if not, it's impossible to ensure that a zero is shown. skip it","                            if(botTicks > 0)","                            {","                                max = tempMin * topTicks;","                            }","                            else","                            {","                                max = min + (roundingUnit * units);","                            }","                        }","                        else if(setMax)","                        {","                            while(tempMax < tempMin && topTicks >= 0)","                            {","                                botTicks++;","                                topTicks--;","                                tempMin = Math.floor( min/botTicks ) * -1;","                                tempMax = Math.ceil( max/topTicks );","                            }","                            //if there are any top ticks left calcualate the minimum by multiplying by the tempMax value","                            //if not, it's impossible to ensure that a zero is shown. skip it","                            if(topTicks > 0)","                            {","                                min = tempMax * botTicks * -1;","                            }","                            else","                            {","                                min = max - (roundingUnit * units);","                            }","                        }","                        else","                        {","                            roundingUnit = Math.max(tempMax, tempMin);","                            roundingUnit = this._getNiceNumber(roundingUnit);","                            max = roundingUnit * topTicks;","                            min = roundingUnit * botTicks * -1;","                        }","                    }","                    else","                    {","                        if(setMax)","                        {","                            min = max - (roundingUnit * units);","                        }","                        else if(setMin)","                        {","                            max = min + (roundingUnit * units);","                        }","                        else","                        {","                            min = this._roundDownToNearest(min, roundingUnit);","                            max = this._roundUpToNearest(max, roundingUnit);","                        }","                    }","                }","                else","                {","                    if(setMin)","                    {","                        if(alwaysShowZero)","                        {","                            max = 0;","                        }","                        else","                        {","                            max = min + (roundingUnit * units);","                        }","                    }","                    else if(!setMax)","                    {","                        if(alwaysShowZero || max === 0 || max + roundingUnit > 0)","                        {","                            max = 0;","                            roundingUnit = this._getMinimumUnit(max, min, units);","                            min = max - (roundingUnit * units);","                        }","                        else","                        {","                            min = this._roundDownToNearest(min, roundingUnit);","                            max = this._roundUpToNearest(max, roundingUnit);","                        }","                    }","                    else","                    {","                        min = max - (roundingUnit * units);","                    }","                }","            }","            else if(roundingMethod == \"auto\")","            {","                if(minGreaterThanZero && maxGreaterThanZero)","                {","                    if((alwaysShowZero || min < (max-min)/units) && !setMin)","                    {","                        min = 0;","                    }","","                    roundingUnit = (max - min)/units;","                    if(useIntegers)","                    {","                        roundingUnit = Math.ceil(roundingUnit);","                    }","                    max = min + (roundingUnit * units);","                }","                else if(maxGreaterThanZero && !minGreaterThanZero)","                {","                    if(alwaysShowZero)","                    {","                        topTicks = Math.round( units / ( (-1 * min) /max + 1) );","                        topTicks = Math.max(Math.min(topTicks, units - 1), 1);","                        botTicks = units - topTicks;","","                        if(useIntegers)","                        {","                            tempMax = Math.ceil( max/topTicks );","                            tempMin = Math.floor( min/botTicks ) * -1;","                        }","                        else","                        {","                            tempMax = max/topTicks;","                            tempMin = min/botTicks * -1;","                        }","                        roundingUnit = Math.max(tempMax, tempMin);","                        max = roundingUnit * topTicks;","                        min = roundingUnit * botTicks * -1;","                    }","                    else","                    {","                        roundingUnit = (max - min)/units;","                        if(useIntegers)","                        {","                            roundingUnit = Math.ceil(roundingUnit);","                        }","                        min = this._roundDownToNearest(min, roundingUnit);","                        max = this._roundUpToNearest(max, roundingUnit);","                    }","                }","                else","                {","                    roundingUnit = (max - min)/units;","                    if(useIntegers)","                    {","                        roundingUnit = Math.ceil(roundingUnit);","                    }","                    if(alwaysShowZero || max === 0 || max + roundingUnit > 0)","                    {","                        max = 0;","                        roundingUnit = (max - min)/units;","                        if(useIntegers)","                        {","                            Math.ceil(roundingUnit);","                        }","                        min = max - (roundingUnit * units);","                    }","                    else","                    {","                        min = this._roundDownToNearest(min, roundingUnit);","                        max = this._roundUpToNearest(max, roundingUnit);","                    }","","                }","            }","            else if(!isNaN(roundingMethod) && isFinite(roundingMethod))","            {","                roundingUnit = roundingMethod;","                minimumRange = roundingUnit * units;","                dataRangeGreater = (max - min) > minimumRange;","                minRound = this._roundDownToNearest(min, roundingUnit);","                maxRound = this._roundUpToNearest(max, roundingUnit);","                if(setMax)","                {","                    min = max - minimumRange;","                }","                else if(setMin)","                {","                    max = min + minimumRange;","                }","                else if(minGreaterThanZero && maxGreaterThanZero)","                {","                    if(alwaysShowZero || minRound <= 0)","                    {","                        min = 0;","                    }","                    else","                    {","                        min = minRound;","                    }","                    max = min + minimumRange;","                }","                else if(maxGreaterThanZero && !minGreaterThanZero)","                {","                    min = minRound;","                    max = maxRound;","                }","                else","                {","                    if(alwaysShowZero || maxRound >= 0)","                    {","                        max = 0;","                    }","                    else","                    {","                        max = maxRound;","                    }","                    min = max - minimumRange;","                }","            }","        }","        this._dataMaximum = max;","        this._dataMinimum = min;","    },","","    /**","     * Calculates and returns a value based on the number of labels and the index of","     * the current label.","     *","     * @method getLabelByIndex","     * @param {Number} i Index of the label.","     * @param {Number} l Total number of labels.","     * @return String","     */","    getLabelByIndex: function(i, l)","    {","        var min = this.get(\"minimum\"),","            max = this.get(\"maximum\"),","            increm = (max - min)/(l-1),","            label,","            roundingMethod = this.get(\"roundingMethod\");","            l -= 1;","        //respect the min and max. calculate all other labels.","        if(i === 0)","        {","            label = min;","        }","        else if(i === l)","        {","            label = max;","        }","        else","        {","            label = (i * increm);","            if(roundingMethod == \"niceNumber\")","            {","                label = this._roundToNearest(label, increm);","            }","            label += min;","        }","        return parseFloat(label);","    },","","    /**","     * Rounds a Number to the nearest multiple of an input. For example, by rounding","     * 16 to the nearest 10, you will receive 20. Similar to the built-in function Math.round().","     *","     * @method _roundToNearest","     * @param {Number} number Number to round","     * @param {Number} nearest Multiple to round towards.","     * @return Number","     * @private","     */","    _roundToNearest: function(number, nearest)","    {","        nearest = nearest || 1;","        if(nearest === 0)","        {","            return number;","        }","        var roundedNumber = Math.round(this._roundToPrecision(number / nearest, 10)) * nearest;","        return this._roundToPrecision(roundedNumber, 10);","    },","","    /**","     * Rounds a Number up to the nearest multiple of an input. For example, by rounding","     * 16 up to the nearest 10, you will receive 20. Similar to the built-in function Math.ceil().","     *","     * @method _roundUpToNearest","     * @param {Number} number Number to round","     * @param {Number} nearest Multiple to round towards.","     * @return Number","     * @private","     */","    _roundUpToNearest: function(number, nearest)","    {","        nearest = nearest || 1;","        if(nearest === 0)","        {","            return number;","        }","        return Math.ceil(this._roundToPrecision(number / nearest, 10)) * nearest;","    },","","    /**","     * Rounds a Number down to the nearest multiple of an input. For example, by rounding","     * 16 down to the nearest 10, you will receive 10. Similar to the built-in function Math.floor().","     *","     * @method _roundDownToNearest","     * @param {Number} number Number to round","     * @param {Number} nearest Multiple to round towards.","     * @return Number","     * @private","     */","    _roundDownToNearest: function(number, nearest)","    {","        nearest = nearest || 1;","        if(nearest === 0)","        {","            return number;","        }","        return Math.floor(this._roundToPrecision(number / nearest, 10)) * nearest;","    },","","    /**","     * Rounds a number to a certain level of precision. Useful for limiting the number of","     * decimal places on a fractional number.","     *","     * @method _roundToPrecision","     * @param {Number} number Number to round","     * @param {Number} precision Multiple to round towards.","     * @return Number","     * @private","     */","    _roundToPrecision: function(number, precision)","    {","        precision = precision || 0;","        var decimalPlaces = Math.pow(10, precision);","        return Math.round(decimalPlaces * number) / decimalPlaces;","    },","","    /**","     * Checks to see if data extends beyond the range of the axis. If so,","     * that data will need to be hidden. This method is internal, temporary and subject","     * to removal in the future.","     *","     * @method _hasDataOverflow","     * @protected","     * @return Boolean","     */","    _hasDataOverflow: function()","    {","        var roundingMethod,","            min,","            max;","        if(this.get(\"setMin\") || this.get(\"setMax\"))","        {","            return true;","        }","        roundingMethod = this.get(\"roundingMethod\");","        min = this._actualMinimum;","        max = this._actualMaximum;","        if(Y_Lang.isNumber(roundingMethod) && ((Y_Lang.isNumber(max) && max > this._dataMaximum) || (Y_Lang.isNumber(min) && min < this._dataMinimum)))","        {","            return true;","        }","        return false;","    }","});","","Y.NumericAxis = NumericAxis;","","/**"," * StackedAxis manages stacked numeric data on an axis."," *"," * @module charts"," * @submodule charts-base"," * @class StackedAxis"," * @constructor"," * @param {Object} config (optional) Configuration parameters for the Chart."," * @extends NumericAxis"," */","function StackedAxis(config)","{","	StackedAxis.superclass.constructor.apply(this, arguments);","}","","StackedAxis.NAME = \"stackedAxis\";","","","Y.extend(StackedAxis, Y.NumericAxis,","{","    /**","     * Calculates the maximum and minimum values for the `Axis`.","     *","     * @method _updateMinAndMax","     * @private","     */","    _updateMinAndMax: function()","    {","        var max = 0,","            min = 0,","            pos = 0,","            neg = 0,","            len = 0,","            i = 0,","            key,","            num,","            keys = this.get(\"keys\"),","            setMin = this.get(\"setMin\"),","            setMax = this.get(\"setMax\");","","        for(key in keys)","        {","            if(keys.hasOwnProperty(key))","            {","                len = Math.max(len, keys[key].length);","            }","        }","        for(; i < len; ++i)","        {","            pos = 0;","            neg = 0;","            for(key in keys)","            {","                if(keys.hasOwnProperty(key))","                {","                    num = keys[key][i];","                    if(isNaN(num))","                    {","                        continue;","                    }","                    if(num >= 0)","                    {","                        pos += num;","                    }","                    else","                    {","                        neg += num;","                    }","                }","            }","            if(pos > 0)","            {","                max = Math.max(max, pos);","            }","            else","            {","                max = Math.max(max, neg);","            }","            if(neg < 0)","            {","                min = Math.min(min, neg);","            }","            else","            {","                min = Math.min(min, pos);","            }","        }","        this._actualMaximum = max;","        this._actualMinimum = min;","        if(setMax)","        {","            max = this._setMaximum;","        }","        if(setMin)","        {","            min = this._setMinimum;","        }","        this._roundMinAndMax(min, max, setMin, setMax);","    }","});","","Y.StackedAxis = StackedAxis;","","/**"," * TimeAxis manages time data on an axis."," *"," * @module charts"," * @submodule charts-base"," * @class TimeAxis"," * @constructor"," * @param {Object} config (optional) Configuration parameters for the Chart."," * @extends AxisType"," */","function TimeAxis(config)","{","	TimeAxis.superclass.constructor.apply(this, arguments);","}","","TimeAxis.NAME = \"timeAxis\";","","TimeAxis.ATTRS =","{","    /**","     * Indicates whether the maximum is calculated or explicitly set.","     *","     * @attribute setMax","     * @readOnly","     * @type Boolean","     * @private","     */","    setMax: {","        readOnly: true,","","        getter: function()","        {","            var max = this._getNumber(this._setMaximum);","            return (Y_Lang.isNumber(max));","        }","    },","","    /**","     * Indicates whether the minimum is calculated or explicitly set.","     *","     * @attribute setMin","     * @readOnly","     * @type Boolean","     * @private","     */","    setMin: {","        readOnly: true,","","        getter: function()","        {","            var min = this._getNumber(this._setMinimum);","            return (Y_Lang.isNumber(min));","        }","    },","","    /**","     * The maximum value that will appear on an axis. Unless explicitly set, this value is calculated by the `Axis`.","     *","     * @attribute maximum","     * @type Number","     */","    maximum: {","        getter: function ()","        {","            var max = this._getNumber(this._setMaximum);","            if(!Y_Lang.isNumber(max))","            {","                max = this._getNumber(this.get(\"dataMaximum\"));","            }","            return parseFloat(max);","        },","        setter: function (value)","        {","            this._setMaximum = this._getNumber(value);","            return value;","        }","    },","","    /**","     * The minimum value that will appear on an axis. Unless explicitly set, this value is calculated by the `Axis`.","     *","     * @attribute minimum","     * @type Number","     */","    minimum: {","        getter: function ()","        {","            var min = this._getNumber(this._setMinimum);","            if(!Y_Lang.isNumber(min))","            {","                min = this._getNumber(this.get(\"dataMinimum\"));","            }","            return parseFloat(min);","        },","        setter: function (value)","        {","            this._setMinimum = this._getNumber(value);","            return value;","        }","    },","","    /**","     * Method used for formatting a label. This attribute allows for the default label formatting method to overridden.","     * The method use would need to implement the arguments below and return a `String` or an `HTMLElement`. The default","     * implementation of the method returns a `String`. The output of this method will be rendered to the DOM using","     * `appendChild`. If you override the `labelFunction` method and return an html string, you will also need to override","     * the Axis' `appendLabelFunction` to accept html as a `String`.","     * <dl>","     *      <dt>val</dt><dd>Label to be formatted. (`String`)</dd>","     *      <dt>format</dt><dd>STRFTime string used to format the label. (optional)</dd>","     * </dl>","     *","     * @attribute labelFunction","     * @type Function","     */","    labelFunction: {","        value: function(val, format)","        {","            val = Y.DataType.Date.parse(val);","            if(format)","            {","                return Y.DataType.Date.format(val, {format:format});","            }","            return val;","        }","    },","","    /**","     * Pattern used by the `labelFunction` to format a label.","     *","     * @attribute labelFormat","     * @type String","     */","    labelFormat: {","        value: \"%b %d, %y\"","    }","};","","Y.extend(TimeAxis, Y.AxisType, {","    /**","     * Formats a label based on the axis type and optionally specified format.","     *","     * @method formatLabel","     * @param {Object} value","     * @param {Object} format Pattern used to format the value.","     * @return String","     */","    formatLabel: function(val, format)","    {","        val = Y.DataType.Date.parse(val);","        if(format)","        {","            return Y.DataType.Date.format(val, {format:format});","        }","        return val;","    },","","    /**","     * Constant used to generate unique id.","     *","     * @property GUID","     * @type String","     * @private","     */","    GUID: \"yuitimeaxis\",","","    /**","     * Type of data used in `Axis`.","     *","     * @property _dataType","     * @readOnly","     * @private","     */","    _dataType: \"time\",","","    /**","     * Calculates and returns a value based on the number of labels and the index of","     * the current label.","     *","     * @method getLabelByIndex","     * @param {Number} i Index of the label.","     * @param {Number} l Total number of labels.","     * @return String","     */","    getLabelByIndex: function(i, l)","    {","        var min = this.get(\"minimum\"),","            max = this.get(\"maximum\"),","            position = this.get(\"position\"),","            increm,","            label;","            l -= 1;","        increm = ((max - min)/l) * i;","        if(position == \"bottom\" || position == \"top\")","        {","            label = min + increm;","        }","        else","        {","            label = max - increm;","        }","        return label;","    },","","    /**","     * Gets an array of values based on a key.","     *","     * @method _getKeyArray","     * @param {String} key Value key associated with the data array.","     * @param {Array} data Array in which the data resides.","     * @return Array","     * @private","     */","    _getKeyArray: function(key, data)","    {","        var obj,","            keyArray = [],","            i = 0,","            val,","            len = data.length;","        for(; i < len; ++i)","        {","            obj = data[i][key];","            if(Y_Lang.isDate(obj))","            {","                val = obj.valueOf();","            }","            else","            {","                val = new Date(obj);","                if(Y_Lang.isDate(val))","                {","                    val = val.valueOf();","                }","                else if(!Y_Lang.isNumber(obj))","                {","                    if(Y_Lang.isNumber(parseFloat(obj)))","                    {","                        val = parseFloat(obj);","                    }","                    else","                    {","                        if(typeof obj != \"string\")","                        {","                            obj = obj;","                        }","                        val = new Date(obj).valueOf();","                    }","                }","                else","                {","                    val = obj;","                }","            }","            keyArray[i] = val;","        }","        return keyArray;","    },","","    /**","     * Sets data by key","     *","     * @method _setDataByKey","     * @param {String} key Key value to use.","     * @param {Array} data Array to use.","     * @private","     */","    _setDataByKey: function(key, data)","    {","        var obj,","            arr = [],","            dv = this._dataClone.concat(),","            i,","            val,","            len = dv.length;","        for(i = 0; i < len; ++i)","        {","            obj = dv[i][key];","            if(Y_Lang.isDate(obj))","            {","                val = obj.valueOf();","            }","            else","            {","                val = new Date(obj);","                if(Y_Lang.isDate(val))","                {","                    val = val.valueOf();","                }","                else if(!Y_Lang.isNumber(obj))","                {","                    if(Y_Lang.isNumber(parseFloat(obj)))","                    {","                        val = parseFloat(obj);","                    }","                    else","                    {","                        if(typeof obj != \"string\")","                        {","                            obj = obj.toString();","                        }","                        val = new Date(obj).valueOf();","                    }","                }","                else","                {","                    val = obj;","                }","            }","            arr[i] = val;","        }","        this.get(\"keys\")[key] = arr;","        this._updateTotalDataFlag = true;","    },","","    /**","     * Parses value into a number.","     *","     * @method _getNumber","     * @param val {Object} Value to parse into a number","     * @return Number","     * @private","     */","    _getNumber: function(val)","    {","        if(Y_Lang.isDate(val))","        {","            val = val.valueOf();","        }","        else if(!Y_Lang.isNumber(val) && val)","        {","            val = new Date(val).valueOf();","        }","","        return val;","    }","});","","Y.TimeAxis = TimeAxis;","","/**"," * CategoryAxis manages category data on an axis."," *"," * @module charts"," * @submodule charts-base"," * @class CategoryAxis"," * @constructor"," * @param {Object} config (optional) Configuration parameters for the Chart."," * @extends AxisType"," */","function CategoryAxis(config)","{","	CategoryAxis.superclass.constructor.apply(this, arguments);","}","","CategoryAxis.NAME = \"categoryAxis\";","","Y.extend(CategoryAxis, Y.AxisType,","{","    /**","     * Formats a label based on the axis type and optionally specified format.","     *","     * @method formatLabel","     * @param {Object} value","     * @param {Object} format Pattern used to format the value.","     * @return String","     */","    formatLabel: function(val, format)","    {","        return val;","    },","","    /**","     * Object storing key data.","     *","     * @property _indices","     * @private","     */","    _indices: null,","","    /**","     * Constant used to generate unique id.","     *","     * @property GUID","     * @type String","     * @private","     */","    GUID: \"yuicategoryaxis\",","","    /**","     * Type of data used in `Axis`.","     *","     * @property _dataType","     * @readOnly","     * @private","     */","    _type: \"category\",","","    /**","     * Calculates the maximum and minimum values for the `Axis`.","     *","     * @method _updateMinAndMax","     * @private","     */","    _updateMinAndMax: function()","    {","        this._dataMaximum = Math.max(this.get(\"data\").length - 1, 0);","        this._dataMinimum = 0;","    },","","    /**","     * Gets an array of values based on a key.","     *","     * @method _getKeyArray","     * @param {String} key Value key associated with the data array.","     * @param {Array} data Array in which the data resides.","     * @return Array","     * @private","     */","    _getKeyArray: function(key, data)","    {","        var i = 0,","            obj,","            keyArr = [],","            labels = [],","            len = data.length;","        if(!this._indices)","        {","            this._indices = {};","        }","        for(; i < len; ++i)","        {","            obj = data[i];","            keyArr[i] = i;","            labels[i] = obj[key];","        }","        this._indices[key] = keyArr;","        return labels;","    },","","    /**","     * Sets data by key","     *","     * @method _setDataByKey","     * @param {String} key Key value to use.","     * @param {Array} data Array to use.","     * @private","     */","    _setDataByKey: function(key)","    {","        var i,","            obj,","            arr = [],","            labels = [],","            dv = this._dataClone.concat(),","            len = dv.length;","        if(!this._indices)","        {","            this._indices = {};","        }","        for(i = 0; i < len; ++i)","        {","            obj = dv[i];","            arr[i] = i;","            labels[i] = obj[key];","        }","        this._indices[key] = arr;","        this.get(\"keys\")[key] = labels.concat();","        this._updateTotalDataFlag = true;","    },","","    /**","     * Returns an array of values based on an identifier key.","     *","     * @method getDataByKey","     * @param {String} value value used to identify the array","     * @return Array","     */","    getDataByKey: function (value)","    {","        if(!this._indices)","        {","            this.get(\"keys\");","        }","        var keys = this._indices;","        if(keys[value])","        {","            return keys[value];","        }","        return null;","    },","","    /**","     * Returns the total number of majorUnits that will appear on an axis.","     *","     * @method getTotalMajorUnits","     * @param {Object} majorUnit Object containing properties related to the majorUnit.","     * @param {Number} len Length of the axis.","     * @return Number","     */","    getTotalMajorUnits: function(majorUnit, len)","    {","        return this.get(\"data\").length;","    },","","    /**","     * Returns the distance between major units on an axis.","     *","     * @method getMajorUnitDistance","     * @param {Number} len Number of ticks","     * @param {Number} uiLen Size of the axis.","     * @param {Object} majorUnit Hash of properties used to determine the majorUnit","     * @return Number","     */","    getMajorUnitDistance: function(len, uiLen, majorUnit)","    {","        var dist;","        if(majorUnit.determinant === \"count\")","        {","            dist = uiLen/len;","        }","        else if(majorUnit.determinant === \"distance\")","        {","            dist = majorUnit.distance;","        }","        return dist;","    },","","    /**","     * Gets the distance that the first and last ticks are offset from there respective","     * edges.","     *","     * @method getEdgeOffset","     * @param {Number} ct Number of ticks on the axis.","     * @param {Number} l Length (in pixels) of the axis.","     * @return Number","     */","    getEdgeOffset: function(ct, l)","    {","        return l/ct;","    },","","    /**","     * Returns a value based of a key value and an index.","     *","     * @method getKeyValueAt","     * @param {String} key value used to look up the correct array","     * @param {Number} index within the array","     * @return String","     */","    getKeyValueAt: function(key, index)","    {","        var value = NaN,","            keys = this.get(\"keys\");","        if(keys[key] && keys[key][index])","        {","            value = keys[key][index];","        }","        return value;","    },","","    /**","     * Calculates and returns a value based on the number of labels and the index of","     * the current label.","     *","     * @method getLabelByIndex","     * @param {Number} i Index of the label.","     * @param {Number} l Total number of labels.","     * @return String","     */","    getLabelByIndex: function(i, l)","    {","        var label,","            data = this.get(\"data\"),","            position = this.get(\"position\");","        if(position == \"bottom\" || position == \"top\")","        {","            label = data[i];","        }","        else","        {","            label = data[l - (i + 1)];","        }","        return label;","    },","","    /**","     * Returns a string corresponding to the first label on an","     * axis.","     *","     * @method getMinimumValue","     * @return String","     */","    getMinimumValue: function()","    {","        var data = this.get(\"data\"),","            label = data[0];","        return label;","    },","","    /**","     * Returns a string corresponding to the last label on an","     * axis.","     *","     * @method getMaximumValue","     * @return String","     */","    getMaximumValue: function()","    {","        var data = this.get(\"data\"),","            len = data.length - 1,","            label = data[len];","        return label;","    }","});","","Y.CategoryAxis = CategoryAxis;","","/**"," * Utility class used for calculating curve points."," *"," * @module charts"," * @submodule charts-base"," * @class CurveUtil"," * @constructor"," */","function CurveUtil()","{","}","","CurveUtil.prototype = {","    /**","     * Creates an array of start, end and control points for splines.","     *","     * @method getCurveControlPoints","     * @param {Array} xcoords Collection of x-coordinates used for calculate the curves","     * @param {Array} ycoords Collection of y-coordinates used for calculate the curves","     * @return Object","     * @protected","     */","    getCurveControlPoints: function(xcoords, ycoords)","    {","		var outpoints = [],","            i = 1,","            l = xcoords.length - 1,","		    xvals = [],","		    yvals = [];","","","		// Too few points, need at least two","		if (l < 1)","        {","			return null;","		}","","        outpoints[0] = {","            startx: xcoords[0],","            starty: ycoords[0],","            endx: xcoords[1],","            endy: ycoords[1]","        };","","		// Special case, the Bezier should be a straight line","        if (l === 1)","        {","			outpoints[0].ctrlx1 = (2.0*xcoords[0] + xcoords[1])/3.0;","			outpoints[0].ctrly2 = (2.0*ycoords[0] + ycoords[1])/3.0;","			outpoints[0].ctrlx2 = 2.0*outpoints[0].ctrlx1 - xcoords[0];","            outpoints[0].ctrly2 = 2.0*outpoints[0].ctrly1 - ycoords[0];","            return outpoints;","		}","","		for (; i < l; ++i)","        {","			outpoints.push({startx: Math.round(xcoords[i]), starty: Math.round(ycoords[i]), endx: Math.round(xcoords[i+1]), endy: Math.round(ycoords[i+1])});","			xvals[i] = 4.0 * xcoords[i] + 2*xcoords[i+1];","			yvals[i] = 4.0*ycoords[i] + 2*ycoords[i+1];","		}","","		xvals[0] = xcoords[0] + (2.0 * xcoords[1]);","		xvals[l-1] = (8.0 * xcoords[l-1] + xcoords[l]) / 2.0;","		xvals = this.getControlPoints(xvals.concat());","        yvals[0] = ycoords[0] + (2.0 * ycoords[1]);","		yvals[l-1] = (8.0 * ycoords[l-1] + ycoords[l]) / 2.0;","		yvals = this.getControlPoints(yvals.concat());","","        for (i = 0; i < l; ++i)","        {","			outpoints[i].ctrlx1 = Math.round(xvals[i]);","            outpoints[i].ctrly1 = Math.round(yvals[i]);","","			if (i < l-1)","            {","				outpoints[i].ctrlx2 = Math.round(2*xcoords[i+1] - xvals[i+1]);","                outpoints[i].ctrly2 = Math.round(2*ycoords[i+1] - yvals[i+1]);","			}","			else","            {","				outpoints[i].ctrlx2 = Math.round((xcoords[l] + xvals[l-1])/2);","                outpoints[i].ctrly2 = Math.round((ycoords[l] + yvals[l-1])/2);","			}","		}","","		return outpoints;","	},","","    /**","     * Gets the control points for the curve.","     *","     * @method getControlPoints","     * @param {Array} vals Collection of values coords used to generate control points.","     * @return Array","     * @private","     */","	getControlPoints: function(vals)","    {","		var l = vals.length,","            x = [],","            tmp = [],","            b = 2.0,","            i = 1;","		x[0] = vals[0] / b;","		for (; i < l; ++i)","        {","			tmp[i] = 1/b;","			b = (i < l-1 ? 4.0 : 3.5) - tmp[i];","			x[i] = (vals[i] - x[i-1]) / b;","		}","","		for (i = 1; i < l; ++i)","        {","			x[l-i-1] -= tmp[l-i] * x[l-i];","		}","","		return x;","	}","};","Y.CurveUtil = CurveUtil;","/**"," * Utility class used for creating stacked series."," *"," * @module charts"," * @submodule charts-base"," * @class StackingUtil"," * @constructor"," */","function StackingUtil(){}","","StackingUtil.prototype = {","    /**","     * Indicates whether the series is stacked.","     *","     * @property _stacked","     * @private","     */","    _stacked: true,","","    /**","     * @protected","     *","     * Adjusts coordinate values for stacked series.","     *","     * @method _stackCoordinates","     */","    _stackCoordinates: function()","    {","        if(this.get(\"direction\") == \"vertical\")","        {","            this._stackXCoords();","        }","        else","        {","            this._stackYCoords();","        }","    },","","    /**","     * Stacks coordinates for a stacked vertical series.","     *","     * @method _stackXCoords","     * @protected","     */","    _stackXCoords: function()","    {","        var order = this.get(\"order\"),","            type = this.get(\"type\"),","            graph = this.get(\"graph\"),","            seriesCollection = graph.seriesTypes[type],","            i = 0,","            xcoords = this.get(\"xcoords\"),","            ycoords = this.get(\"ycoords\"),","            len,","            coord,","            prevCoord,","            prevOrder,","            stackedXCoords = xcoords.concat(),","            prevXCoords,","            prevYCoords,","            nullIndices = [],","            nullIndex;","        if(order > 0)","        {","            prevXCoords = seriesCollection[order - 1].get(\"stackedXCoords\");","            prevYCoords = seriesCollection[order - 1].get(\"stackedYCoords\");","            len = prevXCoords.length;","        }","        else","        {","            len = xcoords.length;","        }","        for(; i < len; i = i + 1)","        {","            if(Y_Lang.isNumber(xcoords[i]))","            {","                if(order > 0)","                {","                    prevCoord = prevXCoords[i];","                    if(!Y_Lang.isNumber(prevCoord))","                    {","                        prevOrder = order;","                        while(prevOrder >  - 1 && !Y_Lang.isNumber(prevCoord))","                        {","                            prevOrder = prevOrder - 1;","                            if(prevOrder > -1)","                            {","                                prevCoord = seriesCollection[prevOrder].get(\"stackedXCoords\")[i];","                            }","                            else","                            {","                                prevCoord = this._leftOrigin;","                            }","                        }","                    }","                    xcoords[i] = xcoords[i] + prevCoord;","                }","                stackedXCoords[i] = xcoords[i];","            }","            else","            {","                nullIndices.push(i);","            }","        }","        this._cleanXNaN(stackedXCoords, ycoords);","        len = nullIndices.length;","        if(len > 0)","        {","            for(i = 0; i < len; i = i + 1)","            {","                nullIndex = nullIndices[i];","                coord = order > 0 ? prevXCoords[nullIndex] : this._leftOrigin;","                stackedXCoords[nullIndex] =  Math.max(stackedXCoords[nullIndex], coord);","            }","        }","        this.set(\"stackedXCoords\", stackedXCoords);","        this.set(\"stackedYCoords\", ycoords);","    },","","    /**","     * Stacks coordinates for a stacked horizontal series.","     *","     * @method _stackYCoords","     * @protected","     */","    _stackYCoords: function()","    {","        var order = this.get(\"order\"),","            type = this.get(\"type\"),","            graph = this.get(\"graph\"),","            h = graph.get(\"height\"),","            seriesCollection = graph.seriesTypes[type],","            i = 0,","            xcoords = this.get(\"xcoords\"),","            ycoords = this.get(\"ycoords\"),","            len,","            coord,","            prevCoord,","            prevOrder,","            stackedYCoords = ycoords.concat(),","            prevXCoords,","            prevYCoords,","            nullIndices = [],","            nullIndex;","        if(order > 0)","        {","            prevXCoords = seriesCollection[order - 1].get(\"stackedXCoords\");","            prevYCoords = seriesCollection[order - 1].get(\"stackedYCoords\");","            len = prevYCoords.length;","        }","        else","        {","            len = ycoords.length;","        }","        for(; i < len; i = i + 1)","        {","            if(Y_Lang.isNumber(ycoords[i]))","            {","                if(order > 0)","                {","                    prevCoord = prevYCoords[i];","                    if(!Y_Lang.isNumber(prevCoord))","                    {","                        prevOrder = order;","                        while(prevOrder >  - 1 && !Y_Lang.isNumber(prevCoord))","                        {","                            prevOrder = prevOrder - 1;","                            if(prevOrder > -1)","                            {","                                prevCoord = seriesCollection[prevOrder].get(\"stackedYCoords\")[i];","                            }","                            else","                            {","                                prevCoord = this._bottomOrigin;","                            }","                        }","                    }","                    ycoords[i] = prevCoord - (h - ycoords[i]);","                }","                stackedYCoords[i] = ycoords[i];","            }","            else","            {","                nullIndices.push(i);","            }","        }","        this._cleanYNaN(xcoords, stackedYCoords);","        len = nullIndices.length;","        if(len > 0)","        {","            for(i = 0; i < len; i = i + 1)","            {","                nullIndex = nullIndices[i];","                coord = order > 0 ? prevYCoords[nullIndex] : h;","                stackedYCoords[nullIndex] =  Math.min(stackedYCoords[nullIndex], coord);","            }","        }","        this.set(\"stackedXCoords\", xcoords);","        this.set(\"stackedYCoords\", stackedYCoords);","    },","","    /**","     * Cleans invalid x-coordinates by calculating their value based on the corresponding y-coordinate, the","     * previous valid x-coordinate with its corresponding y-coordinate and the next valid x-coordinate with","     * its corresponding y-coordinate. If there is no previous or next valid x-coordinate, the value will not","     * be altered.","     *","     * @method _cleanXNaN","     * @param {Array} xcoords An array of x-coordinate values","     * @param {Array} ycoords An arry of y-coordinate values","     * @private","     */","    _cleanXNaN: function(xcoords, ycoords)","    {","        var previousValidIndex,","            nextValidIndex,","            previousValidX,","            previousValidY,","            x,","            y,","            nextValidX,","            nextValidY,","            isNumber = Y_Lang.isNumber,","            m,","            i = 0,","            len = ycoords.length;","        for(; i < len; ++i)","        {","            x = xcoords[i];","            y = ycoords[i];","            //if x is invalid, calculate where it should be","            if(!isNumber(x) && i > 0 && i < len - 1)","            {","                previousValidY = ycoords[i - 1];","                //check to see if the previous value is valid","                previousValidX = this._getPreviousValidCoordValue(xcoords, i);","                nextValidY = ycoords[i + 1];","                nextValidX = this._getNextValidCoordValue(xcoords, i);","                //check to see if the next value is valid","                if(isNumber(previousValidX) && isNumber(nextValidX))","                {","                    //calculate slope and solve for x","                    m = (nextValidY - previousValidY) / (nextValidX - previousValidX);","                    xcoords[i] = (y + (m * previousValidX) - previousValidY)/m;","                }","                previousValidIndex = NaN;","                nextValidIndex = NaN;","            }","        }","    },","","    /**","     * Returns the previous valid (numeric) value in an array if available.","     *","     * @method _getPreviousValidCoordValue","     * @param {Array} coords Array of values","     * @param {Number} index The index in the array in which to begin searching.","     * @return Number","     * @private","     */","    _getPreviousValidCoordValue: function(coords, index)","    {","        var coord,","            isNumber = Y_Lang.isNumber,","            limit = -1;","        while(!isNumber(coord) && index > limit)","        {","            index = index - 1;","            coord = coords[index];","        }","        return coord;","    },","","    /**","     * Returns the next valid (numeric) value in an array if available.","     *","     * @method _getNextValidCoordValue","     * @param {Array} coords Array of values","     * @param {Number} index The index in the array in which to begin searching.","     * @return Number","     * @private","     */","    _getNextValidCoordValue: function(coords, index)","    {","        var coord,","            isNumber = Y_Lang.isNumber,","            limit = coords.length;","        while(!isNumber(coord) && index < limit)","        {","            index = index + 1;","            coord = coords[index];","        }","        return coord;","    },","","    /**","     * Cleans invalid y-coordinates by calculating their value based on the corresponding x-coordinate, the","     * previous valid y-coordinate with its corresponding x-coordinate and the next valid y-coordinate with","     * its corresponding x-coordinate. If there is no previous or next valid y-coordinate, the value will not","     * be altered.","     *","     * @method _cleanYNaN","     * @param {Array} xcoords An array of x-coordinate values","     * @param {Array} ycoords An arry of y-coordinate values","     * @private","     */","    _cleanYNaN: function(xcoords, ycoords)","    {","        var previousValidIndex,","            nextValidIndex,","            previousValidX,","            previousValidY,","            x,","            y,","            nextValidX,","            nextValidY,","            isNumber = Y_Lang.isNumber,","            m,","            i = 0,","            len = xcoords.length;","        for(; i < len; ++i)","        {","            x = xcoords[i];","            y = ycoords[i];","            //if y is invalid, calculate where it should be","            if(!isNumber(y) && i > 0 && i < len - 1)","            {","                //check to see if the previous value is valid","                previousValidX = xcoords[i - 1];","                previousValidY = this._getPreviousValidCoordValue(ycoords, i);","                //check to see if the next value is valid","                nextValidX = xcoords[i + 1];","                nextValidY = this._getNextValidCoordValue(ycoords, i);","                if(isNumber(previousValidY) && isNumber(nextValidY))","                {","                    //calculate slope and solve for y","                    m = (nextValidY - previousValidY) / (nextValidX - previousValidX);","                    ycoords[i] = previousValidY + ((m * x) - (m * previousValidX));","                }","                previousValidIndex = NaN;","                nextValidIndex = NaN;","            }","        }","    }","};","Y.StackingUtil = StackingUtil;","/**"," * Utility class used for drawing lines."," *"," * @module charts"," * @submodule charts-base"," * @class Lines"," * @constructor"," */","function Lines(){}","","Lines.prototype = {","    /**","     * @property _lineDefaults","     * @type Object","     * @private","     */","    _lineDefaults: null,","","    /**","     * Creates a graphic in which to draw a series.","     *","     * @method _getGraphic","     * @return Graphic","     * @private","     */","    _getGraphic: function()","    {","        var graphic = this.get(\"graphic\") || this.get(\"graph\").get(\"graphic\");","        if(!this._lineGraphic)","        {","            this._lineGraphic = graphic.addShape({type: \"path\"});","        }","        this._lineGraphic.clear();","        return this._lineGraphic;","    },","","    /**","     * Toggles visibility","     *","     * @method _toggleVisible","     * @param {Boolean} visible indicates visibilitye","     * @private","     */","    _toggleVisible: function(visible)","    {","        if(this._lineGraphic)","        {","            this._lineGraphic.set(\"visible\", visible);","        }","    },","","    /**","     * Draws lines for the series.","     *","     * @method drawLines","     * @protected","     */","    drawLines: function()","    {","        if(this.get(\"xcoords\").length < 1)","        {","            return;","        }","        var isNumber = Y_Lang.isNumber,","            xcoords,","            ycoords,","            direction = this.get(\"direction\"),","            len,","            lastPointValid,","            pointValid,","            noPointsRendered = true,","            lastValidX,","            lastValidY,","            nextX,","            nextY,","            i,","            styles = this.get(\"styles\").line,","            lineType = styles.lineType,","            lc = styles.color || this._getDefaultColor(this.get(\"graphOrder\"), \"line\"),","            lineAlpha = styles.alpha,","            dashLength = styles.dashLength,","            gapSpace = styles.gapSpace,","            connectDiscontinuousPoints = styles.connectDiscontinuousPoints,","            discontinuousType = styles.discontinuousType,","            discontinuousDashLength = styles.discontinuousDashLength,","            discontinuousGapSpace = styles.discontinuousGapSpace,","            path = this._getGraphic();","        if(this._stacked)","        {","            xcoords = this.get(\"stackedXCoords\");","            ycoords = this.get(\"stackedYCoords\");","        }","        else","        {","            xcoords = this.get(\"xcoords\");","            ycoords = this.get(\"ycoords\");","        }","        len = direction === \"vertical\" ? ycoords.length : xcoords.length;","        path.set(\"stroke\", {","            weight: styles.weight,","            color: lc,","            opacity: lineAlpha","        });","        for(i = 0; i < len; i = ++i)","        {","            nextX = xcoords[i];","            nextY = ycoords[i];","            pointValid = isNumber(nextX) && isNumber(nextY);","            if(!pointValid)","            {","                lastPointValid = pointValid;","                continue;","            }","            if(noPointsRendered)","            {","                noPointsRendered = false;","                path.moveTo(nextX, nextY);","            }","            else if(lastPointValid)","            {","                if(lineType != \"dashed\")","                {","                    path.lineTo(nextX, nextY);","                }","                else","                {","                    this.drawDashedLine(path, lastValidX, lastValidY, nextX, nextY,","                                                dashLength,","                                                gapSpace);","                }","            }","            else if(!connectDiscontinuousPoints)","            {","                path.moveTo(nextX, nextY);","            }","            else","            {","                if(discontinuousType != \"solid\")","                {","                    this.drawDashedLine(path, lastValidX, lastValidY, nextX, nextY,","                                                discontinuousDashLength,","                                                discontinuousGapSpace);","                }","                else","                {","                    path.lineTo(nextX, nextY);","                }","            }","            lastValidX = nextX;","            lastValidY = nextY;","            lastPointValid = true;","        }","        path.end();","    },","","    /**","     * Connects data points with a consistent curve for a series.","     *","     * @method drawSpline","     * @protected","     */","    drawSpline: function()","    {","        if(this.get(\"xcoords\").length < 1)","        {","            return;","        }","        var xcoords = this.get(\"xcoords\"),","            ycoords = this.get(\"ycoords\"),","            curvecoords = this.getCurveControlPoints(xcoords, ycoords),","            len = curvecoords.length,","            cx1,","            cx2,","            cy1,","            cy2,","            x,","            y,","            i = 0,","            styles = this.get(\"styles\").line,","            path = this._getGraphic(),","            lineAlpha = styles.alpha,","            color = styles.color || this._getDefaultColor(this.get(\"graphOrder\"), \"line\");","        path.set(\"stroke\", {","            weight: styles.weight,","            color: color,","            opacity: lineAlpha","        });","        path.moveTo(xcoords[0], ycoords[0]);","        for(; i < len; i = ++i)","        {","            x = curvecoords[i].endx;","            y = curvecoords[i].endy;","            cx1 = curvecoords[i].ctrlx1;","            cx2 = curvecoords[i].ctrlx2;","            cy1 = curvecoords[i].ctrly1;","            cy2 = curvecoords[i].ctrly2;","            path.curveTo(cx1, cy1, cx2, cy2, x, y);","        }","        path.end();","    },","","    /**","     * Draws a dashed line between two points.","     *","     * @method drawDashedLine","     * @param {Number} xStart	The x position of the start of the line","     * @param {Number} yStart	The y position of the start of the line","     * @param {Number} xEnd		The x position of the end of the line","     * @param {Number} yEnd		The y position of the end of the line","     * @param {Number} dashSize	the size of dashes, in pixels","     * @param {Number} gapSize	the size of gaps between dashes, in pixels","     * @private","     */","    drawDashedLine: function(path, xStart, yStart, xEnd, yEnd, dashSize, gapSize)","    {","        dashSize = dashSize || 10;","        gapSize = gapSize || 10;","        var segmentLength = dashSize + gapSize,","            xDelta = xEnd - xStart,","            yDelta = yEnd - yStart,","            delta = Math.sqrt(Math.pow(xDelta, 2) + Math.pow(yDelta, 2)),","            segmentCount = Math.floor(Math.abs(delta / segmentLength)),","            radians = Math.atan2(yDelta, xDelta),","            xCurrent = xStart,","            yCurrent = yStart,","            i;","        xDelta = Math.cos(radians) * segmentLength;","        yDelta = Math.sin(radians) * segmentLength;","","        for(i = 0; i < segmentCount; ++i)","        {","            path.moveTo(xCurrent, yCurrent);","            path.lineTo(xCurrent + Math.cos(radians) * dashSize, yCurrent + Math.sin(radians) * dashSize);","            xCurrent += xDelta;","            yCurrent += yDelta;","        }","","        path.moveTo(xCurrent, yCurrent);","        delta = Math.sqrt((xEnd - xCurrent) * (xEnd - xCurrent) + (yEnd - yCurrent) * (yEnd - yCurrent));","","        if(delta > dashSize)","        {","            path.lineTo(xCurrent + Math.cos(radians) * dashSize, yCurrent + Math.sin(radians) * dashSize);","        }","        else if(delta > 0)","        {","            path.lineTo(xCurrent + Math.cos(radians) * delta, yCurrent + Math.sin(radians) * delta);","        }","","        path.moveTo(xEnd, yEnd);","    },","","    /**","     * Default values for `styles` attribute.","     *","     * @method _getLineDefaults","     * @return Object","     * @protected","     */","    _getLineDefaults: function()","    {","        return {","            alpha: 1,","            weight: 6,","            lineType:\"solid\",","            dashLength:10,","            gapSpace:10,","            connectDiscontinuousPoints:true,","            discontinuousType:\"solid\",","            discontinuousDashLength:10,","            discontinuousGapSpace:10","        };","    }","};","Y.augment(Lines, Y.Attribute);","Y.Lines = Lines;","/**"," * Utility class used for drawing area fills."," *"," * @module charts"," * @class Fills"," * @constructor"," */","function Fills(cfg)","{","    var attrs = {","        area: {","            getter: function()","            {","                return this._defaults || this._getAreaDefaults();","            },","","            setter: function(val)","            {","                var defaults = this._defaults || this._getAreaDefaults();","                this._defaults = Y.merge(defaults, val);","            }","        }","    };","    this.addAttrs(attrs, cfg);","    this.get(\"styles\");","}","","Fills.prototype = {","    /**","     * Returns a path shape used for drawing fills.","     *","     * @method _getPath","     * @return Path","     * @private","     */","    _getPath: function()","    {","        var path = this._path;","        if(!path)","        {","            path = this.get(\"graph\").get(\"graphic\").addShape({type:\"path\"});","            this._path = path;","        }","        return path;","    },","","    /**","     * Toggles visibility","     *","     * @method _toggleVisible","     * @param {Boolean} visible indicates visibilitye","     * @private","     */","    _toggleVisible: function(visible)","    {","        if(this._path)","        {","            this._path.set(\"visible\", visible);","        }","    },","","    /**","     * Draws fill","     *","     * @method drawFill","     * @param {Array} xcoords The x-coordinates for the series.","     * @param {Array} ycoords The y-coordinates for the series.","     * @protected","     */","    drawFill: function(xcoords, ycoords)","    {","        if(xcoords.length < 1)","        {","            return;","        }","        var isNumber = Y_Lang.isNumber,","            len = xcoords.length,","            firstX = xcoords[0],","            firstY = ycoords[0],","            lastValidX = firstX,","            lastValidY = firstY,","            nextX,","            nextY,","            pointValid,","            noPointsRendered = true,","            i = 0,","            styles = this.get(\"styles\").area,","            path = this._getPath(),","            color = styles.color || this._getDefaultColor(this.get(\"graphOrder\"), \"slice\");","        path.clear();","        path.set(\"fill\", {","            color: color,","            opacity: styles.alpha","        });","        path.set(\"stroke\", {weight: 0});","        for(; i < len; i = ++i)","        {","            nextX = xcoords[i];","            nextY = ycoords[i];","            pointValid = isNumber(nextX) && isNumber(nextY);","            if(!pointValid)","            {","                continue;","            }","            if(noPointsRendered)","            {","                this._firstValidX = nextX;","                this._firstValidY = nextY;","                noPointsRendered = false;","                path.moveTo(nextX, nextY);","            }","            else","            {","                path.lineTo(nextX, nextY);","            }","            lastValidX = nextX;","            lastValidY = nextY;","        }","        this._lastValidX = lastValidX;","        this._lastValidY = lastValidY;","        path.end();","    },","","    /**","     * Draws a fill for a spline","     *","     * @method drawAreaSpline","     * @protected","     */","    drawAreaSpline: function()","    {","        if(this.get(\"xcoords\").length < 1)","        {","            return;","        }","        var xcoords = this.get(\"xcoords\"),","            ycoords = this.get(\"ycoords\"),","            curvecoords = this.getCurveControlPoints(xcoords, ycoords),","            len = curvecoords.length,","            cx1,","            cx2,","            cy1,","            cy2,","            x,","            y,","            i = 0,","            firstX = xcoords[0],","            firstY = ycoords[0],","            styles = this.get(\"styles\").area,","            path = this._getPath(),","            color = styles.color || this._getDefaultColor(this.get(\"graphOrder\"), \"slice\");","        path.set(\"fill\", {","            color: color,","            opacity: styles.alpha","        });","        path.set(\"stroke\", {weight: 0});","        path.moveTo(firstX, firstY);","        for(; i < len; i = ++i)","        {","            x = curvecoords[i].endx;","            y = curvecoords[i].endy;","            cx1 = curvecoords[i].ctrlx1;","            cx2 = curvecoords[i].ctrlx2;","            cy1 = curvecoords[i].ctrly1;","            cy2 = curvecoords[i].ctrly2;","            path.curveTo(cx1, cy1, cx2, cy2, x, y);","        }","        if(this.get(\"direction\") === \"vertical\")","        {","            path.lineTo(this._leftOrigin, y);","            path.lineTo(this._leftOrigin, firstY);","        }","        else","        {","            path.lineTo(x, this._bottomOrigin);","            path.lineTo(firstX, this._bottomOrigin);","        }","        path.lineTo(firstX, firstY);","        path.end();","    },","","    /**","     * Draws a a stacked area spline","     *","     * @method drawStackedAreaSpline","     * @protected","     */","    drawStackedAreaSpline: function()","    {","        if(this.get(\"xcoords\").length < 1)","        {","            return;","        }","        var xcoords = this.get(\"xcoords\"),","            ycoords = this.get(\"ycoords\"),","            curvecoords,","            order = this.get(\"order\"),","            type = this.get(\"type\"),","            graph = this.get(\"graph\"),","            seriesCollection = graph.seriesTypes[type],","            prevXCoords,","            prevYCoords,","            len,","            cx1,","            cx2,","            cy1,","            cy2,","            x,","            y,","            i = 0,","            firstX,","            firstY,","            styles = this.get(\"styles\").area,","            path = this._getPath(),","            color = styles.color || this._getDefaultColor(this.get(\"graphOrder\"), \"slice\");","        firstX = xcoords[0];","        firstY = ycoords[0];","        curvecoords = this.getCurveControlPoints(xcoords, ycoords);","        len = curvecoords.length;","        path.set(\"fill\", {","            color: color,","            opacity: styles.alpha","        });","        path.set(\"stroke\", {weight: 0});","        path.moveTo(firstX, firstY);","        for(; i < len; i = ++i)","        {","            x = curvecoords[i].endx;","            y = curvecoords[i].endy;","            cx1 = curvecoords[i].ctrlx1;","            cx2 = curvecoords[i].ctrlx2;","            cy1 = curvecoords[i].ctrly1;","            cy2 = curvecoords[i].ctrly2;","            path.curveTo(cx1, cy1, cx2, cy2, x, y);","        }","        if(order > 0)","        {","            prevXCoords = seriesCollection[order - 1].get(\"xcoords\").concat().reverse();","            prevYCoords = seriesCollection[order - 1].get(\"ycoords\").concat().reverse();","            curvecoords = this.getCurveControlPoints(prevXCoords, prevYCoords);","            i = 0;","            len = curvecoords.length;","            path.lineTo(prevXCoords[0], prevYCoords[0]);","            for(; i < len; i = ++i)","            {","                x = curvecoords[i].endx;","                y = curvecoords[i].endy;","                cx1 = curvecoords[i].ctrlx1;","                cx2 = curvecoords[i].ctrlx2;","                cy1 = curvecoords[i].ctrly1;","                cy2 = curvecoords[i].ctrly2;","                path.curveTo(cx1, cy1, cx2, cy2, x, y);","            }","        }","        else","        {","            if(this.get(\"direction\") === \"vertical\")","            {","                path.lineTo(this._leftOrigin, ycoords[ycoords.length-1]);","                path.lineTo(this._leftOrigin, firstY);","            }","            else","            {","                path.lineTo(xcoords[xcoords.length-1], this._bottomOrigin);","                path.lineTo(firstX, this._bottomOrigin);","            }","","        }","        path.lineTo(firstX, firstY);","        path.end();","    },","","    /**","     * Storage for default area styles.","     *","     * @property _defaults","     * @type Object","     * @private","     */","    _defaults: null,","","    /**","     * Concatenates coordinate array with correct coordinates for closing an area fill.","     *","     * @method _getClosingPoints","     * @return Array","     * @protected","     */","    _getClosingPoints: function()","    {","        var xcoords = this.get(\"xcoords\").concat(),","            ycoords = this.get(\"ycoords\").concat(),","            firstValidIndex,","            lastValidIndex;","        if(this.get(\"direction\") === \"vertical\")","        {","            lastValidIndex = this._getLastValidIndex(xcoords);","            firstValidIndex = this._getFirstValidIndex(xcoords);","            ycoords.push(ycoords[lastValidIndex]);","            ycoords.push(ycoords[firstValidIndex]);","            xcoords.push(this._leftOrigin);","            xcoords.push(this._leftOrigin);","        }","        else","        {","            lastValidIndex = this._getLastValidIndex(ycoords);","            firstValidIndex = this._getFirstValidIndex(ycoords);","            xcoords.push(xcoords[lastValidIndex]);","            xcoords.push(xcoords[firstValidIndex]);","            ycoords.push(this._bottomOrigin);","            ycoords.push(this._bottomOrigin);","        }","        xcoords.push(xcoords[0]);","        ycoords.push(ycoords[0]);","        return [xcoords, ycoords];","    },","","    /**","     * Returns the order of the series closest to the current series that has a valid value for the current index.","     *","     * @method _getHighestValidOrder","     * @param {Array} seriesCollection Array of series of a given type.","     * @param {Number} index Index of the series item.","     * @param {Number} order Index of the the series in the seriesCollection","     * @param {String} direction Indicates the direction of the series","     * @return Number","     * @private","     */","    _getHighestValidOrder: function(seriesCollection, index, order, direction)","    {","        var coords = direction == \"vertical\" ? \"stackedXCoords\" : \"stackedYCoords\",","            coord;","        while(isNaN(coord) && order > -1)","        {","          order = order - 1;","          if(order > -1)","          {","            coord = seriesCollection[order].get(coords)[index];","          }","        }","        return order;","    },","","    /**","     * Returns an array containing the x and y coordinates for a given series and index.","     *","     * @method _getCoordsByOrderAndIndex","     * @param {Array} seriesCollection Array of series of a given type.","     * @param {Number} index Index of the series item.","     * @param {Number} order Index of the the series in the seriesCollection","     * @param {String} direction Indicates the direction of the series","     * @return Array","     * @private","     */","    _getCoordsByOrderAndIndex: function(seriesCollection, index, order, direction)","    {","        var xcoord,","            ycoord;","        if(direction == \"vertical\")","        {","            xcoord = order < 0 ? this._leftOrigin : seriesCollection[order].get(\"stackedXCoords\")[index];","            ycoord = this.get(\"stackedYCoords\")[index];","        }","        else","        {","            xcoord = this.get(\"stackedXCoords\")[index];","            ycoord = order < 0 ? this._bottomOrigin : seriesCollection[order].get(\"stackedYCoords\")[index];","        }","        return [xcoord, ycoord];","    },","","    /**","     * Concatenates coordinate array with the correct coordinates for closing an area stack.","     *","     * @method _getStackedClosingPoints","     * @return Array","     * @protected","     */","    _getStackedClosingPoints: function()","    {","        var order = this.get(\"order\"),","            type = this.get(\"type\"),","            graph = this.get(\"graph\"),","            direction = this.get(\"direction\"),","            seriesCollection = graph.seriesTypes[type],","            firstValidIndex,","            lastValidIndex,","            xcoords = this.get(\"stackedXCoords\"),","            ycoords = this.get(\"stackedYCoords\"),","            limit,","            previousSeries,","            previousSeriesFirstValidIndex,","            previousSeriesLastValidIndex,","            previousXCoords,","            previousYCoords,","            coords,","            closingXCoords,","            closingYCoords,","            currentIndex,","            highestValidOrder,","            oldOrder;","        if(order < 1)","        {","          return this._getClosingPoints();","        }","","        previousSeries = seriesCollection[order - 1];","        previousXCoords = previousSeries.get(\"stackedXCoords\").concat();","        previousYCoords = previousSeries.get(\"stackedYCoords\").concat();","        if(direction == \"vertical\")","        {","            firstValidIndex = this._getFirstValidIndex(xcoords);","            lastValidIndex = this._getLastValidIndex(xcoords);","            previousSeriesFirstValidIndex = previousSeries._getFirstValidIndex(previousXCoords);","            previousSeriesLastValidIndex = previousSeries._getLastValidIndex(previousXCoords);","        }","        else","        {","            firstValidIndex = this._getFirstValidIndex(ycoords);","            lastValidIndex = this._getLastValidIndex(ycoords);","            previousSeriesFirstValidIndex = previousSeries._getFirstValidIndex(previousYCoords);","            previousSeriesLastValidIndex = previousSeries._getLastValidIndex(previousYCoords);","        }","        if(previousSeriesLastValidIndex >= firstValidIndex && previousSeriesFirstValidIndex <= lastValidIndex)","        {","            previousSeriesFirstValidIndex = Math.max(firstValidIndex, previousSeriesFirstValidIndex);","            previousSeriesLastValidIndex = Math.min(lastValidIndex, previousSeriesLastValidIndex);","            previousXCoords = previousXCoords.slice(previousSeriesFirstValidIndex, previousSeriesLastValidIndex + 1);","            previousYCoords = previousYCoords.slice(previousSeriesFirstValidIndex, previousSeriesLastValidIndex + 1);","            limit = previousSeriesFirstValidIndex;","        }","        else","        {","            limit = lastValidIndex;","        }","","        closingXCoords = [xcoords[firstValidIndex]];","        closingYCoords = [ycoords[firstValidIndex]];","        currentIndex = firstValidIndex;","        while((isNaN(highestValidOrder) || highestValidOrder < order - 1) && currentIndex <= limit)","        {","            oldOrder = highestValidOrder;","            highestValidOrder = this._getHighestValidOrder(seriesCollection, currentIndex, order, direction);","            if(!isNaN(oldOrder) && highestValidOrder > oldOrder)","            {","                coords = this._getCoordsByOrderAndIndex(seriesCollection, currentIndex, oldOrder, direction);","                closingXCoords.push(coords[0]);","                closingYCoords.push(coords[1]);","            }","            coords = this._getCoordsByOrderAndIndex(seriesCollection, currentIndex, highestValidOrder, direction);","            closingXCoords.push(coords[0]);","            closingYCoords.push(coords[1]);","            currentIndex = currentIndex + 1;","        }","        if(previousXCoords && previousXCoords.length > 0 && previousSeriesLastValidIndex > firstValidIndex && previousSeriesFirstValidIndex < lastValidIndex)","        {","            closingXCoords = closingXCoords.concat(previousXCoords);","            closingYCoords = closingYCoords.concat(previousYCoords);","            highestValidOrder = order -1;","        }","        currentIndex = Math.max(firstValidIndex, previousSeriesLastValidIndex);","        order = order - 1;","        highestValidOrder = NaN;","        while(currentIndex <= lastValidIndex)","        {","            oldOrder = highestValidOrder;","            highestValidOrder = this._getHighestValidOrder(seriesCollection, currentIndex, order, direction);","            if(!isNaN(oldOrder))","            {","                if(highestValidOrder > oldOrder)","                {","                    coords = this._getCoordsByOrderAndIndex(seriesCollection, currentIndex, oldOrder, direction);","                    closingXCoords.push(coords[0]);","                    closingYCoords.push(coords[1]);","                }","                else if(highestValidOrder < oldOrder)","                {","                    coords = this._getCoordsByOrderAndIndex(seriesCollection, currentIndex - 1, highestValidOrder, direction);","                    closingXCoords.push(coords[0]);","                    closingYCoords.push(coords[1]);","                }","            }","            coords = this._getCoordsByOrderAndIndex(seriesCollection, currentIndex, highestValidOrder, direction);","            closingXCoords.push(coords[0]);","            closingYCoords.push(coords[1]);","            currentIndex = currentIndex + 1;","        }","","        closingXCoords.reverse();","        closingYCoords.reverse();","        return [xcoords.concat(closingXCoords), ycoords.concat(closingYCoords)];","    },","","    /**","     * Returns default values for area styles.","     *","     * @method _getAreaDefaults","     * @return Object","     * @private","     */","    _getAreaDefaults: function()","    {","        return {","        };","    }","};","Y.augment(Fills, Y.Attribute);","Y.Fills = Fills;","/**"," * Utility class used for drawing markers."," *"," * @module charts"," * @submodule charts-base"," * @class Plots"," * @constructor"," */","function Plots(cfg)","{","    var attrs = {","        markers: {","            getter: function()","            {","                return this._markers;","            }","        }","    };","    this.addAttrs(attrs, cfg);","}","","Plots.prototype = {","    /**","     * Storage for default marker styles.","     *","     * @property _plotDefaults","     * @type Object","     * @private","     */","    _plotDefaults: null,","","    /**","     * Draws the markers","     *","     * @method drawPlots","     * @protected","     */","    drawPlots: function()","    {","        if(!this.get(\"xcoords\") || this.get(\"xcoords\").length < 1)","		{","			return;","		}","        var isNumber = Y_Lang.isNumber,","            style = Y.clone(this.get(\"styles\").marker),","            w = style.width,","            h = style.height,","            xcoords = this.get(\"xcoords\"),","            ycoords = this.get(\"ycoords\"),","            i = 0,","            len = xcoords.length,","            top = ycoords[0],","            left,","            marker,","            offsetWidth = w/2,","            offsetHeight = h/2,","            xvalues,","            yvalues,","            fillColors = null,","            borderColors = null,","            graphOrder = this.get(\"graphOrder\"),","            groupMarkers = this.get(\"groupMarkers\");","        if(groupMarkers)","        {","            xvalues = [];","            yvalues = [];","            for(; i < len; ++i)","            {","                xvalues.push(parseFloat(xcoords[i] - offsetWidth));","                yvalues.push(parseFloat(ycoords[i] - offsetHeight));","            }","            this._createGroupMarker({","                xvalues: xvalues,","                yvalues: yvalues,","                fill: style.fill,","                border: style.border,","                dimensions: {","                    width: w,","                    height: h","                },","                graphOrder: graphOrder,","                shape: style.shape","            });","            return;","        }","        if(Y_Lang.isArray(style.fill.color))","        {","            fillColors = style.fill.color.concat();","        }","        if(Y_Lang.isArray(style.border.color))","        {","            borderColors = style.border.color.concat();","        }","        this._createMarkerCache();","        for(; i < len; ++i)","        {","            top = parseFloat(ycoords[i] - offsetHeight);","            left = parseFloat(xcoords[i] - offsetWidth);","            if(!isNumber(left) || !isNumber(top))","            {","                this._markers.push(null);","                continue;","            }","            if(fillColors)","            {","                style.fill.color = fillColors[i % fillColors.length];","            }","            if(borderColors)","            {","                style.border.color = borderColors[i % borderColors.length];","            }","","            style.x = left;","            style.y = top;","            marker = this.getMarker(style, graphOrder, i);","        }","        this._clearMarkerCache();","    },","","    /**","     * Pre-defined group shapes.","     *","     * @property _groupShapes","     * @private","     */","    _groupShapes: {","        circle: Y.CircleGroup,","        rect: Y.RectGroup,","        ellipse: Y.EllipseGroup,","        diamond: Y.DiamondGroup","    },","","    /**","     * Returns the correct group shape class.","     *","     * @method _getGroupShape","     * @param {Shape | String} shape Indicates which shape class.","     * @return Function","     * @protected","     */","    _getGroupShape: function(shape)","    {","        if(Y_Lang.isString(shape))","        {","            shape = this._groupShapes[shape];","        }","        return shape;","    },","","    /**","     * Gets the default values for series that use the utility. This method is used by","     * the class' `styles` attribute's getter to get build default values.","     *","     * @method _getPlotDefaults","     * @return Object","     * @protected","     */","    _getPlotDefaults: function()","    {","        var defs = {","            fill:{","                type: \"solid\",","                alpha: 1,","                colors:null,","                alphas: null,","                ratios: null","            },","            border:{","                weight: 1,","                alpha: 1","            },","            width: 10,","            height: 10,","            shape: \"circle\"","        };","        defs.fill.color = this._getDefaultColor(this.get(\"graphOrder\"), \"fill\");","        defs.border.color = this._getDefaultColor(this.get(\"graphOrder\"), \"border\");","        return defs;","    },","","    /**","     * Collection of markers to be used in the series.","     *","     * @property _markers","     * @type Array","     * @private","     */","    _markers: null,","","    /**","     * Collection of markers to be re-used on a series redraw.","     *","     * @property _markerCache","     * @type Array","     * @private","     */","    _markerCache: null,","","    /**","     * Gets and styles a marker. If there is a marker in cache, it will use it. Otherwise","     * it will create one.","     *","     * @method getMarker","     * @param {Object} styles Hash of style properties.","     * @param {Number} order Order of the series.","     * @param {Number} index Index within the series associated with the marker.","     * @return Shape","     * @protected","     */","    getMarker: function(styles, order, index)","    {","        var marker,","            border = styles.border;","        styles.id = this.get(\"chart\").get(\"id\") + \"_\" + order + \"_\" + index;","        //fix name differences between graphic layer","        border.opacity = border.alpha;","        styles.stroke = border;","        styles.fill.opacity = styles.fill.alpha;","        if(this._markerCache.length > 0)","        {","            while(!marker)","            {","                if(this._markerCache.length < 1)","                {","                    marker = this._createMarker(styles, order, index);","                    break;","                }","                marker = this._markerCache.shift();","","            }","            marker.set(styles);","        }","        else","        {","            marker = this._createMarker(styles, order, index);","        }","        this._markers.push(marker);","        return marker;","    },","","    /**","     * Creates a shape to be used as a marker.","     *","     * @method _createMarker","     * @param {Object} styles Hash of style properties.","     * @param {Number} order Order of the series.","     * @param {Number} index Index within the series associated with the marker.","     * @return Shape","     * @private","     */","    _createMarker: function(styles, order, index)","    {","        var graphic = this.get(\"graphic\"),","            marker,","            cfg = Y.clone(styles);","        graphic.set(\"autoDraw\", false);","        cfg.type = cfg.shape;","        marker = graphic.addShape(cfg);","        marker.addClass(SERIES_MARKER);","        return marker;","    },","","    /**","     * Creates a cache of markers for reuse.","     *","     * @method _createMarkerCache","     * @private","     */","    _createMarkerCache: function()","    {","        if(this._groupMarker)","        {","            this._groupMarker.destroy();","            this._groupMarker = null;","        }","        if(this._markers && this._markers.length > 0)","        {","            this._markerCache = this._markers.concat();","        }","        else","        {","            this._markerCache = [];","        }","        this._markers = [];","    },","","    /**","     * Draws a series of markers in a single shape instance.","     *","     * @method _createGroupMarkers","     * @param {Object} styles Set of configuration properties used to create the markers.","     * @protected","     */","    _createGroupMarker: function(styles)","    {","        var marker,","            markers = this.get(\"markers\"),","            border = styles.border,","            graphic,","            cfg,","            shape;","        if(markers && markers.length > 0)","        {","            while(markers.length > 0)","            {","                marker = markers.shift();","                marker.destroy();","            }","            this.set(\"markers\", []);","        }","        //fix name differences between graphic layer","        border.opacity = border.alpha;","        cfg = {","            id: this.get(\"chart\").get(\"id\") + \"_\" + styles.graphOrder,","            stroke: border,","            fill: styles.fill,","            dimensions: styles.dimensions,","            xvalues: styles.xvalues,","            yvalues: styles.yvalues","        };","        cfg.fill.opacity = styles.fill.alpha;","        shape = this._getGroupShape(styles.shape);","        if(shape)","        {","            cfg.type = shape;","        }","        if(styles.hasOwnProperty(\"radius\") && !isNaN(styles.radius))","        {","            cfg.dimensions.radius = styles.radius;","        }","        if(this._groupMarker)","        {","            this._groupMarker.destroy();","        }","        graphic = this.get(\"graphic\");","        this._groupMarker = graphic.addShape(cfg);","        graphic._redraw();","    },","","    /**","     * Toggles visibility","     *","     * @method _toggleVisible","     * @param {Boolean} visible indicates visibilitye","     * @private","     */","    _toggleVisible: function(visible)","    {","        var marker,","            markers = this.get(\"markers\"),","            i = 0,","            len;","        if(markers)","        {","            len = markers.length;","            for(; i < len; ++i)","            {","                marker = markers[i];","                if(marker)","                {","                    marker.set(\"visible\", visible);","                }","            }","        }","    },","","    /**","     * Removes unused markers from the marker cache","     *","     * @method _clearMarkerCache","     * @private","     */","    _clearMarkerCache: function()","    {","        var marker;","        while(this._markerCache.length > 0)","        {","            marker = this._markerCache.shift();","            if(marker)","            {","                marker.destroy();","            }","        }","    },","","    /**","     * Resizes and positions markers based on a mouse interaction.","     *","     * @method updateMarkerState","     * @param {String} type state of the marker","     * @param {Number} i index of the marker","     * @protected","     */","    updateMarkerState: function(type, i)","    {","        if(this._markers && this._markers[i])","        {","            var w,","                h,","                styles = Y.clone(this.get(\"styles\").marker),","                state = this._getState(type),","                xcoords = this.get(\"xcoords\"),","                ycoords = this.get(\"ycoords\"),","                marker = this._markers[i],","                markerStyles = state == \"off\" || !styles[state] ? styles : styles[state];","                markerStyles.fill.color = this._getItemColor(markerStyles.fill.color, i);","                markerStyles.border.color = this._getItemColor(markerStyles.border.color, i);","                markerStyles.stroke = markerStyles.border;","                marker.set(markerStyles);","                w = markerStyles.width;","                h = markerStyles.height;","                marker.set(\"x\", (xcoords[i] - w/2));","                marker.set(\"y\",  (ycoords[i] - h/2));","                marker.set(\"visible\", this.get(\"visible\"));","        }","    },","","    /**","     * Parses a color from an array.","     *","     * @method _getItemColor","     * @param {Array} val collection of colors","     * @param {Number} i index of the item","     * @return String","     * @protected","     */","    _getItemColor: function(val, i)","    {","        if(Y_Lang.isArray(val))","        {","            return val[i % val.length];","        }","        return val;","    },","","    /**","     * Method used by `styles` setter. Overrides base implementation.","     *","     * @method _setStyles","     * @param {Object} newStyles Hash of properties to update.","     * @return Object","     * @protected","     */","    _setStyles: function(val)","    {","        val = this._parseMarkerStyles(val);","        return Y.Renderer.prototype._setStyles.apply(this, [val]);","    },","","    /**","     * Combines new styles with existing styles.","     *","     * @method _parseMarkerStyles","     * @param {Object} Object containing style properties for the marker.","     * @return Object","     * @private","     */","    _parseMarkerStyles: function(val)","    {","        if(val.marker)","        {","            var defs = this._getPlotDefaults();","            val.marker = this._mergeStyles(val.marker, defs);","            if(val.marker.over)","            {","                val.marker.over = this._mergeStyles(val.marker.over, val.marker);","            }","            if(val.marker.down)","            {","                val.marker.down = this._mergeStyles(val.marker.down, val.marker);","            }","        }","        return val;","    },","","    /**","     * Returns marker state based on event type","     *","     * @method _getState","     * @param {String} type event type","     * @return String","     * @protected","     */","    _getState: function(type)","    {","        var state;","        switch(type)","        {","            case \"mouseout\" :","                state = \"off\";","            break;","            case \"mouseover\" :","                state = \"over\";","            break;","            case \"mouseup\" :","                state = \"over\";","            break;","            case \"mousedown\" :","                state = \"down\";","            break;","        }","        return state;","    },","","    /**","     * @property _statSyles","     * @type Object","     * @private","     */","    _stateSyles: null","};","","Y.augment(Plots, Y.Attribute);","Y.Plots = Plots;","/**"," * Histogram is the base class for Column and Bar series."," *"," * @module charts"," * @submodule charts-base"," * @class Histogram"," * @constructor"," */","function Histogram(){}","","Histogram.prototype = {","    /**","     * Draws the series.","     *","     * @method drawSeries","     * @protected","     */","    drawSeries: function()","    {","        if(this.get(\"xcoords\").length < 1)","        {","            return;","        }","        var style = Y.clone(this.get(\"styles\").marker),","            setSize,","            calculatedSize,","            xcoords = this.get(\"xcoords\"),","            ycoords = this.get(\"ycoords\"),","            i = 0,","            len = xcoords.length,","            top = ycoords[0],","            type = this.get(\"type\"),","            graph = this.get(\"graph\"),","            seriesCollection = graph.seriesTypes[type],","            seriesLen = seriesCollection.length,","            seriesSize = 0,","            totalSize = 0,","            offset = 0,","            ratio,","            renderer,","            order = this.get(\"order\"),","            graphOrder = this.get(\"graphOrder\"),","            left,","            marker,","            setSizeKey,","            calculatedSizeKey,","            config,","            fillColors = null,","            borderColors = null,","            xMarkerPlane = [],","            yMarkerPlane = [],","            xMarkerPlaneLeft,","            xMarkerPlaneRight,","            yMarkerPlaneTop,","            yMarkerPlaneBottom,","            dimensions = {","                width: [],","                height: []","            },","            xvalues = [],","            yvalues = [],","            groupMarkers = this.get(\"groupMarkers\");","        if(Y_Lang.isArray(style.fill.color))","        {","            fillColors = style.fill.color.concat();","        }","        if(Y_Lang.isArray(style.border.color))","        {","            borderColors = style.border.color.concat();","        }","        if(this.get(\"direction\") == \"vertical\")","        {","            setSizeKey = \"height\";","            calculatedSizeKey = \"width\";","        }","        else","        {","            setSizeKey = \"width\";","            calculatedSizeKey = \"height\";","        }","        setSize = style[setSizeKey];","        calculatedSize = style[calculatedSizeKey];","        this._createMarkerCache();","        for(; i < seriesLen; ++i)","        {","            renderer = seriesCollection[i];","            seriesSize += renderer.get(\"styles\").marker[setSizeKey];","            if(order > i)","            {","                offset = seriesSize;","            }","        }","        totalSize = len * seriesSize;","        this._maxSize = graph.get(setSizeKey);","        if(totalSize > this._maxSize)","        {","            ratio = graph.get(setSizeKey)/totalSize;","            seriesSize *= ratio;","            offset *= ratio;","            setSize *= ratio;","            setSize = Math.max(setSize, 1);","            this._maxSize = setSize;","        }","        offset -= seriesSize/2;","        for(i = 0; i < len; ++i)","        {","            xMarkerPlaneLeft = xcoords[i] - seriesSize/2;","            xMarkerPlaneRight = xMarkerPlaneLeft + seriesSize;","            yMarkerPlaneTop = ycoords[i] - seriesSize/2;","            yMarkerPlaneBottom = yMarkerPlaneTop + seriesSize;","            xMarkerPlane.push({start: xMarkerPlaneLeft, end: xMarkerPlaneRight});","            yMarkerPlane.push({start: yMarkerPlaneTop, end: yMarkerPlaneBottom});","            if(isNaN(xcoords[i]) || isNaN(ycoords[i]))","            {","                this._markers.push(null);","                continue;","            }","            config = this._getMarkerDimensions(xcoords[i], ycoords[i], calculatedSize, offset);","            if(!isNaN(config.calculatedSize) && config.calculatedSize > 0)","            {","                top = config.top;","                left = config.left;","","                if(groupMarkers)","                {","                    dimensions[setSizeKey][i] = setSize;","                    dimensions[calculatedSizeKey][i] = config.calculatedSize;","                    xvalues.push(left);","                    yvalues.push(top);","                }","                else","                {","                    style[setSizeKey] = setSize;","                    style[calculatedSizeKey] = config.calculatedSize;","                    style.x = left;","                    style.y = top;","                    if(fillColors)","                    {","                        style.fill.color = fillColors[i % fillColors.length];","                    }","                    if(borderColors)","                    {","                        style.border.color = borderColors[i % borderColors.length];","                    }","                    marker = this.getMarker(style, graphOrder, i);","                }","","            }","            else if(!groupMarkers)","            {","                this._markers.push(null);","            }","        }","        this.set(\"xMarkerPlane\", xMarkerPlane);","        this.set(\"yMarkerPlane\", yMarkerPlane);","        if(groupMarkers)","        {","            this._createGroupMarker({","                fill: style.fill,","                border: style.border,","                dimensions: dimensions,","                xvalues: xvalues,","                yvalues: yvalues,","                shape: style.shape","            });","        }","        else","        {","            this._clearMarkerCache();","        }","    },","","    /**","     * Collection of default colors used for marker fills in a series when not specified by user.","     *","     * @property _defaultFillColors","     * @type Array","     * @protected","     */","    _defaultFillColors: [\"#66007f\", \"#a86f41\", \"#295454\", \"#996ab2\", \"#e8cdb7\", \"#90bdbd\",\"#000000\",\"#c3b8ca\", \"#968373\", \"#678585\"],","","    /**","     * Gets the default style values for the markers.","     *","     * @method _getPlotDefaults","     * @return Object","     * @private","     */","    _getPlotDefaults: function()","    {","        var defs = {","            fill:{","                type: \"solid\",","                alpha: 1,","                colors:null,","                alphas: null,","                ratios: null","            },","            border:{","                weight: 0,","                alpha: 1","            },","            width: 12,","            height: 12,","            shape: \"rect\",","","            padding:{","                top: 0,","                left: 0,","                right: 0,","                bottom: 0","            }","        };","        defs.fill.color = this._getDefaultColor(this.get(\"graphOrder\"), \"fill\");","        defs.border.color = this._getDefaultColor(this.get(\"graphOrder\"), \"border\");","        return defs;","    }","};","","Y.Histogram = Histogram;","/**"," * The CartesianSeries class creates a chart with horizontal and vertical axes."," *"," * @module charts"," * @submodule charts-base"," * @class CartesianSeries"," * @extends Base"," * @uses Renderer"," * @constructor"," */","Y.CartesianSeries = Y.Base.create(\"cartesianSeries\", Y.Base, [Y.Renderer], {","    /**","     * Storage for `xDisplayName` attribute.","     *","     * @property _xDisplayName","     * @type String","     * @private","     */","    _xDisplayName: null,","","    /**","     * Storage for `yDisplayName` attribute.","     *","     * @property _yDisplayName","     * @type String","     * @private","     */","    _yDisplayName: null,","","    /**","     * Th x-coordinate for the left edge of the series.","     *","     * @property _leftOrigin","     * @type String","     * @private","     */","    _leftOrigin: null,","","    /**","     * The y-coordinate for the bottom edge of the series.","     *","     * @property _bottomOrigin","     * @type String","     * @private","     */","    _bottomOrigin: null,","","    /**","     * @method render","     * @private","     */","    render: function()","    {","        this._setCanvas();","        this.addListeners();","        this.set(\"rendered\", true);","        this.validate();","    },","","    /**","     * Adds event listeners.","     *","     * @method addListeners","     * @private","     */","    addListeners: function()","    {","        var xAxis = this.get(\"xAxis\"),","            yAxis = this.get(\"yAxis\");","        if(xAxis)","        {","            this._xDataReadyHandle = xAxis.after(\"dataReady\", Y.bind(this._xDataChangeHandler, this));","            this._xDataUpdateHandle = xAxis.after(\"dataUpdate\", Y.bind(this._xDataChangeHandler, this));","        }","        if(yAxis)","        {","            this._yDataReadyHandle = yAxis.after(\"dataReady\", Y.bind(this._yDataChangeHandler, this));","            this._yDataUpdateHandle = yAxis.after(\"dataUpdate\", Y.bind(this._yDataChangeHandler, this));","        }","        this._xAxisChangeHandle = this.after(\"xAxisChange\", this._xAxisChangeHandler);","        this._yAxisChangeHandle = this.after(\"yAxisChange\", this._yAxisChangeHandler);","        this._stylesChangeHandle = this.after(\"stylesChange\", function(e) {","            var axesReady = this._updateAxisData();","            if(axesReady)","            {","                this.draw();","            }","        });","        this._widthChangeHandle = this.after(\"widthChange\", function(e) {","            var axesReady = this._updateAxisData();","            if(axesReady)","            {","                this.draw();","            }","        });","        this._heightChangeHandle = this.after(\"heightChange\", function(e) {","            var axesReady = this._updateAxisData();","            if(axesReady)","            {","                this.draw();","            }","        });","        this._visibleChangeHandle = this.after(\"visibleChange\", this._handleVisibleChange);","    },","","    /**","     * Event handler for the xAxisChange event.","     *","     * @method _xAxisChangeHandler","     * @param {Object} e Event object.","     * @private","     */","    _xAxisChangeHandler: function(e)","    {","        var xAxis = this.get(\"xAxis\");","        xAxis.after(\"dataReady\", Y.bind(this._xDataChangeHandler, this));","        xAxis.after(\"dataUpdate\", Y.bind(this._xDataChangeHandler, this));","    },","","    /**","     * Event handler the yAxisChange event.","     *","     * @method _yAxisChangeHandler","     * @param {Object} e Event object.","     * @private","     */","    _yAxisChangeHandler: function(e)","    {","        var yAxis = this.get(\"yAxis\");","        yAxis.after(\"dataReady\", Y.bind(this._yDataChangeHandler, this));","        yAxis.after(\"dataUpdate\", Y.bind(this._yDataChangeHandler, this));","    },","","    /**","     * Constant used to generate unique id.","     *","     * @property GUID","     * @type String","     * @private","     */","    GUID: \"yuicartesianseries\",","","    /**","     * Event handler for xDataChange event.","     *","     * @method _xDataChangeHandler","     * @param {Object} event Event object.","     * @private","     */","    _xDataChangeHandler: function(event)","    {","        var axesReady = this._updateAxisData();","        if(axesReady)","        {","            this.draw();","        }","    },","","    /**","     * Event handler for yDataChange event.","     *","     * @method _yDataChangeHandler","     * @param {Object} event Event object.","     * @private","     */","    _yDataChangeHandler: function(event)","    {","        var axesReady = this._updateAxisData();","        if(axesReady)","        {","            this.draw();","        }","    },","","    /**","     * Checks to ensure that both xAxis and yAxis data are available. If so, set the `xData` and `yData` attributes","     * and return `true`. Otherwise, return `false`.","     *","     * @method _updateAxisData","     * @return Boolean","     * @private","     */","    _updateAxisData: function()","    {","        var xAxis = this.get(\"xAxis\"),","            yAxis = this.get(\"yAxis\"),","            xKey = this.get(\"xKey\"),","            yKey = this.get(\"yKey\"),","            yData,","            xData;","        if(!xAxis || !yAxis || !xKey || !yKey)","        {","            return false;","        }","        xData = xAxis.getDataByKey(xKey);","        yData = yAxis.getDataByKey(yKey);","        if(!xData || !yData)","        {","            return false;","        }","        this.set(\"xData\", xData.concat());","        this.set(\"yData\", yData.concat());","        return true;","    },","","    /**","     * Draws the series is the xAxis and yAxis data are both available.","     *","     * @method validate","     * @private","     */","    validate: function()","    {","        if((this.get(\"xData\") && this.get(\"yData\")) || this._updateAxisData())","        {","            this.draw();","        }","        else","        {","            this.fire(\"drawingComplete\");","        }","    },","","    /**","     * Creates a `Graphic` instance.","     *","     * @method _setCanvas","     * @protected","     */","    _setCanvas: function()","    {","        var graph = this.get(\"graph\"),","            graphic = graph.get(\"graphic\");","        this.set(\"graphic\", graphic);","    },","","    /**","     * Calculates the coordinates for the series.","     *","     * @method setAreaData","     * @protected","     */","    setAreaData: function()","    {","        var isNumber = Y_Lang.isNumber,","            nextX, nextY,","            graph = this.get(\"graph\"),","            w = graph.get(\"width\"),","            h = graph.get(\"height\"),","            xAxis = this.get(\"xAxis\"),","            yAxis = this.get(\"yAxis\"),","            xData = this.get(\"xData\").concat(),","            yData = this.get(\"yData\").concat(),","            xValue,","            yValue,","            xOffset = xAxis.getEdgeOffset(xData.length, w),","            yOffset = yAxis.getEdgeOffset(yData.length, h),","            padding = this.get(\"styles\").padding,","			leftPadding = padding.left,","			topPadding = padding.top,","			dataWidth = w - (leftPadding + padding.right + xOffset),","			dataHeight = h - (topPadding + padding.bottom + yOffset),","			xcoords = [],","			ycoords = [],","			xMax = xAxis.get(\"maximum\"),","			xMin = xAxis.get(\"minimum\"),","			yMax = yAxis.get(\"maximum\"),","			yMin = yAxis.get(\"minimum\"),","            xScaleFactor = dataWidth / (xMax - xMin),","			yScaleFactor = dataHeight / (yMax - yMin),","            dataLength,","            direction = this.get(\"direction\"),","            i = 0,","            xMarkerPlane = [],","            yMarkerPlane = [],","            xMarkerPlaneOffset = this.get(\"xMarkerPlaneOffset\"),","            yMarkerPlaneOffset = this.get(\"yMarkerPlaneOffset\"),","            graphic = this.get(\"graphic\");","        graphic.set(\"width\", w);","        graphic.set(\"height\", h);","        dataLength = xData.length;","        xOffset *= 0.5;","        yOffset *= 0.5;","        //Assuming a vertical graph has a range/category for its vertical axis.","        if(direction === \"vertical\")","        {","            yData = yData.reverse();","        }","        this._leftOrigin = Math.round(((0 - xMin) * xScaleFactor) + leftPadding + xOffset);","        this._bottomOrigin = Math.round((dataHeight + topPadding + yOffset));","        if(yMin < 0)","        {","            this._bottomOrigin = this._bottomOrigin - ((0 - yMin) * yScaleFactor);","        }","        for (; i < dataLength; ++i)","		{","            xValue = parseFloat(xData[i]);","            yValue = parseFloat(yData[i]);","            if(isNumber(xValue))","            {","                nextX = (((xValue - xMin) * xScaleFactor) + leftPadding + xOffset);","            }","            else","            {","                nextX = NaN;","            }","            if(isNumber(yValue))","            {","			    nextY = ((dataHeight + topPadding + yOffset) - (yValue - yMin) * yScaleFactor);","            }","            else","            {","                nextY = NaN;","            }","            xcoords.push(nextX);","            ycoords.push(nextY);","            xMarkerPlane.push({start:nextX - xMarkerPlaneOffset, end: nextX + xMarkerPlaneOffset});","            yMarkerPlane.push({start:nextY - yMarkerPlaneOffset, end: nextY + yMarkerPlaneOffset});","        }","        this.set(\"xcoords\", xcoords);","		this.set(\"ycoords\", ycoords);","        this.set(\"xMarkerPlane\", xMarkerPlane);","        this.set(\"yMarkerPlane\", yMarkerPlane);","        this._dataLength = dataLength;","    },","","    /**","     * Finds the first valid index of an array coordinates.","     *","     * @method _getFirstValidIndex","     * @param {Array} coords An array of x or y coordinates.","     * @return Number","     * @private","     */","    _getFirstValidIndex: function(coords)","    {","        var coord,","            i = -1,","            limit = coords.length;","        while(!Y_Lang.isNumber(coord) && i < limit)","        {","            i += 1;","            coord = coords[i];","        }","        return i;","    },","","    /**","     * Finds the last valid index of an array coordinates.","     *","     * @method _getLastValidIndex","     * @param {Array} coords An array of x or y coordinates.","     * @return Number","     * @private","     */","    _getLastValidIndex: function(coords)","    {","        var coord,","            i = coords.length,","            limit = -1;","        while(!Y_Lang.isNumber(coord) && i > limit)","        {","            i -= 1;","            coord = coords[i];","        }","        return i;","    },","","    /**","     * Draws the series.","     *","     * @method draw","     * @protected","     */","    draw: function()","    {","        var graph = this.get(\"graph\"),","            w = graph.get(\"width\"),","            h = graph.get(\"height\");","        if(this.get(\"rendered\"))","        {","            if((isFinite(w) && isFinite(h) && w > 0 && h > 0) && ((this.get(\"xData\") && this.get(\"yData\")) || this._updateAxisData()))","            {","                if(this._drawing)","                {","                    this._callLater = true;","                    return;","                }","                this._drawing = true;","                this._callLater = false;","                this.setAreaData();","                if(this.get(\"xcoords\") && this.get(\"ycoords\"))","                {","                    this.drawSeries();","                }","                this._drawing = false;","                if(this._callLater)","                {","                    this.draw();","                }","                else","                {","                    this._toggleVisible(this.get(\"visible\"));","                    this.fire(\"drawingComplete\");","                }","            }","        }","    },","","    /**","     * Default value for plane offsets when the parent chart's `interactiveType` is `planar`.","     *","     * @property _defaultPlaneOffset","     * @type Number","     * @private","     */","    _defaultPlaneOffset: 4,","","    /**","     * Gets the default value for the `styles` attribute. Overrides","     * base implementation.","     *","     * @method _getDefaultStyles","     * @return Object","     * @protected","     */","    _getDefaultStyles: function()","    {","        return {padding:{","                top: 0,","                left: 0,","                right: 0,","                bottom: 0","            }};","    },","","    /**","     * Collection of default colors used for lines in a series when not specified by user.","     *","     * @property _defaultLineColors","     * @type Array","     * @protected","     */","    _defaultLineColors:[\"#426ab3\", \"#d09b2c\", \"#000000\", \"#b82837\", \"#b384b5\", \"#ff7200\", \"#779de3\", \"#cbc8ba\", \"#7ed7a6\", \"#007a6c\"],","","    /**","     * Collection of default colors used for marker fills in a series when not specified by user.","     *","     * @property _defaultFillColors","     * @type Array","     * @protected","     */","    _defaultFillColors:[\"#6084d0\", \"#eeb647\", \"#6c6b5f\", \"#d6484f\", \"#ce9ed1\", \"#ff9f3b\", \"#93b7ff\", \"#e0ddd0\", \"#94ecba\", \"#309687\"],","","    /**","     * Collection of default colors used for marker borders in a series when not specified by user.","     *","     * @property _defaultBorderColors","     * @type Array","     * @protected","     */","    _defaultBorderColors:[\"#205096\", \"#b38206\", \"#000000\", \"#94001e\", \"#9d6fa0\", \"#e55b00\", \"#5e85c9\", \"#adab9e\", \"#6ac291\", \"#006457\"],","","    /**","     * Collection of default colors used for area fills, histogram fills and pie fills in a series when not specified by user.","     *","     * @property _defaultSliceColors","     * @type Array","     * @protected","     */","    _defaultSliceColors: [\"#66007f\", \"#a86f41\", \"#295454\", \"#996ab2\", \"#e8cdb7\", \"#90bdbd\",\"#000000\",\"#c3b8ca\", \"#968373\", \"#678585\"],","","    /**","     * Parses a color based on a series order and type.","     *","     * @method _getDefaultColor","     * @param {Number} index Index indicating the series order.","     * @param {String} type Indicates which type of object needs the color.","     * @return String","     * @protected","     */","    _getDefaultColor: function(index, type)","    {","        var colors = {","                line: this._defaultLineColors,","                fill: this._defaultFillColors,","                border: this._defaultBorderColors,","                slice: this._defaultSliceColors","            },","            col = colors[type],","            l = col.length;","        index = index || 0;","        if(index >= l)","        {","            index = index % l;","        }","        type = type || \"fill\";","        return colors[type][index];","    },","","    /**","     * Shows/hides contents of the series.","     *","     * @method _handleVisibleChange","     * @param {Object} e Event object.","     * @protected","     */","    _handleVisibleChange: function(e)","    {","        this._toggleVisible(this.get(\"visible\"));","    },","","    /**","     * Returns the sum of all values for the series.","     *","     * @method getTotalValues","     * @return Number","     */","    getTotalValues: function()","    {","        var total = this.get(\"valueAxis\").getTotalByKey(this.get(\"valueKey\"));","        return total;","    },","","    /**","     * Destructor implementation for the CartesianSeries class. Calls destroy on all Graphic instances.","     *","     * @method destructor","     * @protected","     */","    destructor: function()","    {","        var marker,","            markers = this.get(\"markers\");","        if(this.get(\"rendered\"))","        {","            if(this._xDataReadyHandle)","            {","                this._xDataReadyHandle.detach();","            }","            if(this._xDataUpdateHandle)","            {","                this._xDataUpdateHandle.detach();","            }","            if(this._yDataReadyHandle)","            {","                this._yDataReadyHandle.detach();","            }","            if(this._yDataUpdateHandle)","            {","                this._yDataUpdateHandle.detach();","            }","            this._xAxisChangeHandle.detach();","            this._yAxisChangeHandle.detach();","            this._stylesChangeHandle.detach();","            this._widthChangeHandle.detach();","            this._heightChangeHandle.detach();","            this._visibleChangeHandle.detach();","        }","        while(markers && markers.length > 0)","        {","            marker = markers.shift();","            if(marker && marker instanceof Y.Shape)","            {","                marker.destroy();","            }","        }","        if(this._path)","        {","            this._path.destroy();","            this._path = null;","        }","        if(this._lineGraphic)","        {","            this._lineGraphic.destroy();","            this._lineGraphic = null;","        }","        if(this._groupMarker)","        {","            this._groupMarker.destroy();","            this._groupMarker = null;","        }","    }","        /**","         * Event handle for the x-axis' dataReady event.","         *","         * @property _xDataReadyHandle","         * @type {EventHandle}","         * @private","         */","","        /**","         * Event handle for the x-axis dataUpdate event.","         *","         * @property _xDataUpdateHandle","         * @type {EventHandle}","         * @private","         */","","        /**","         * Event handle for the y-axis dataReady event.","         *","         * @property _yDataReadyHandle","         * @type {EventHandle}","         * @private","         */","","        /**","         * Event handle for the y-axis dataUpdate event.","         * @property _yDataUpdateHandle","         * @type {EventHandle}","         * @private","         */","","        /**","         * Event handle for the xAxisChange event.","         * @property _xAxisChangeHandle","         * @type {EventHandle}","         * @private","         */","","        /**","         * Event handle for the yAxisChange event.","         * @property _yAxisChangeHandle","         * @type {EventHandle}","         * @private","         */","","        /**","         * Event handle for the stylesChange event.","         * @property _stylesChangeHandle","         * @type {EventHandle}","         * @private","         */","","        /**","         * Event handle for the widthChange event.","         * @property _widthChangeHandle","         * @type {EventHandle}","         * @private","         */","","        /**","         * Event handle for the heightChange event.","         * @property _heightChangeHandle","         * @type {EventHandle}","         * @private","         */","","        /**","         * Event handle for the visibleChange event.","         * @property _visibleChangeHandle","         * @type {EventHandle}","         * @private","         */","}, {","    ATTRS: {","        /**","         * Name used for for displaying data related to the x-coordinate.","         *","         * @attribute xDisplayName","         * @type String","         */","        xDisplayName: {","            getter: function()","            {","                return this._xDisplayName || this.get(\"xKey\");","            },","","            setter: function(val)","            {","                this._xDisplayName = val.toString();","                return val;","            }","        },","","        /**","         * Name used for for displaying data related to the y-coordinate.","         *","         * @attribute yDisplayName","         * @type String","         */","        yDisplayName: {","            getter: function()","            {","                return this._yDisplayName || this.get(\"yKey\");","            },","","            setter: function(val)","            {","                this._yDisplayName = val.toString();","                return val;","            }","        },","","        /**","         * Name used for for displaying category data","         *","         * @attribute categoryDisplayName","         * @type String","         * @readOnly","         */","        categoryDisplayName: {","            lazyAdd: false,","","            getter: function()","            {","                return this.get(\"direction\") == \"vertical\" ? this.get(\"yDisplayName\") : this.get(\"xDisplayName\");","           },","","            setter: function(val)","            {","                if(this.get(\"direction\") == \"vertical\")","                {","                    this._yDisplayName = val;","                }","                else","                {","                    this._xDisplayName = val;","                }","                return val;","            }","        },","","        /**","         * Name used for for displaying value data","         *","         * @attribute valueDisplayName","         * @type String","         * @readOnly","         */","        valueDisplayName: {","            lazyAdd: false,","","            getter: function()","            {","                return this.get(\"direction\") == \"vertical\" ? this.get(\"xDisplayName\") : this.get(\"yDisplayName\");","            },","","            setter: function(val)","            {","                if(this.get(\"direction\") == \"vertical\")","                {","                    this._xDisplayName = val;","                }","                else","                {","                    this._yDisplayName = val;","                }","                return val;","            }","        },","","        /**","         * Read-only attribute indicating the type of series.","         *","         * @attribute type","         * @type String","         * @default cartesian","         */","        type: {","            value: \"cartesian\"","        },","","        /**","         * Order of this instance of this `type`.","         *","         * @attribute order","         * @type Number","         */","        order: {},","","        /**","         * Order of the instance","         *","         * @attribute graphOrder","         * @type Number","         */","        graphOrder: {},","","        /**","         * x coordinates for the series.","         *","         * @attribute xcoords","         * @type Array","         */","        xcoords: {},","","        /**","         * y coordinates for the series","         *","         * @attribute ycoords","         * @type Array","         */","        ycoords: {},","","        /**","         * Reference to the `Chart` application.","         *","         * @attribute chart","         * @type ChartBase","         * @readOnly","         */","        chart: {","            readOnly: true,","","            getter: function()","            {","                return this.get(\"graph\").get(\"chart\");","            }","        },","","        /**","         * Reference to the `Graph` in which the series is drawn into.","         *","         * @attribute graph","         * @type Graph","         */","        graph: {},","","        /**","         * Reference to the `Axis` instance used for assigning","         * x-values to the graph.","         *","         * @attribute xAxis","         * @type Axis","         */","        xAxis: {},","","        /**","         * Reference to the `Axis` instance used for assigning","         * y-values to the graph.","         *","         * @attribute yAxis","         * @type Axis","         */","        yAxis: {},","","        /**","         * Indicates which array to from the hash of value arrays in","         * the x-axis `Axis` instance.","         *","         * @attribute xKey","         * @type String","         */","        xKey: {","            setter: function(val)","            {","                return val.toString();","            }","        },","","        /**","         * Indicates which array to from the hash of value arrays in","         * the y-axis `Axis` instance.","         *","         * @attribute yKey","         * @type String","         */","        yKey: {","            setter: function(val)","            {","                return val.toString();","            }","        },","","        /**","         * Array of x values for the series.","         *","         * @attribute xData","         * @type Array","         */","        xData: {},","","        /**","         * Array of y values for the series.","         *","         * @attribute yData","         * @type Array","         */","        yData: {},","","        /**","         * Indicates whether the Series has been through its initial set up.","         *","         * @attribute rendered","         * @type Boolean","         */","        rendered: {","            value: false","        },","","        /*","         * Returns the width of the parent graph","         *","         * @attribute width","         * @type Number","         */","        width: {","            readOnly: true,","","            getter: function()","            {","                this.get(\"graph\").get(\"width\");","            }","        },","","        /**","         * Returns the height of the parent graph","         *","         * @attribute height","         * @type Number","         */","        height: {","            readOnly: true,","","            getter: function()","            {","                this.get(\"graph\").get(\"height\");","            }","        },","","        /**","         * Indicates whether to show the series","         *","         * @attribute visible","         * @type Boolean","         * @default true","         */","        visible: {","            value: true","        },","","        /**","         * Collection of area maps along the xAxis. Used to determine mouseover for multiple","         * series.","         *","         * @attribute xMarkerPlane","         * @type Array","         */","        xMarkerPlane: {},","","        /**","         * Collection of area maps along the yAxis. Used to determine mouseover for multiple","         * series.","         *","         * @attribute yMarkerPlane","         * @type Array","         */","        yMarkerPlane: {},","","        /**","         * Distance from a data coordinate to the left/right for setting a hotspot.","         *","         * @attribute xMarkerPlaneOffset","         * @type Number","         */","        xMarkerPlaneOffset: {","            getter: function() {","                var marker = this.get(\"styles\").marker;","                if(marker && marker.width && isFinite(marker.width))","                {","                    return marker.width * 0.5;","                }","                return this._defaultPlaneOffset;","            }","        },","","        /**","         * Distance from a data coordinate to the top/bottom for setting a hotspot.","         *","         * @attribute yMarkerPlaneOffset","         * @type Number","         */","        yMarkerPlaneOffset: {","            getter: function() {","                var marker = this.get(\"styles\").marker;","                if(marker && marker.height && isFinite(marker.height))","                {","                    return marker.height * 0.5;","                }","                return this._defaultPlaneOffset;","            }","        },","","        /**","         * Direction of the series","         *","         * @attribute direction","         * @type String","         */","        direction: {","            value: \"horizontal\"","        },","","        /**","         * Indicates whether or not markers for a series will be grouped and rendered in a single complex shape instance.","         *","         * @attribute groupMarkers","         * @type Boolean","         */","        groupMarkers: {","            getter: function()","            {","                if(this._groupMarkers === undefined)","                {","                    return this.get(\"graph\").get(\"groupMarkers\");","                }","                else","                {","                    return this._groupMarkers;","                }","            },","","            setter: function(val)","            {","                this._groupMarkers = val;","                return val;","            }","        }","    }","});","/**"," * The MarkerSeries class renders quantitative data by plotting relevant data points"," * on a graph."," *"," * @module charts"," * @submodule charts-base"," * @class MarkerSeries"," * @extends CartesianSeries"," * @uses Plots"," * @constructor"," */","Y.MarkerSeries = Y.Base.create(\"markerSeries\", Y.CartesianSeries, [Y.Plots], {","    /**","     * @protected","     *","     * Draws the series.","     *","     * @method drawSeries","     */","    drawSeries: function()","    {","        this.drawPlots();","    },","","    /**","     * @protected","     *","     * Method used by `styles` setter. Overrides base implementation.","     *","     * @method _setStyles","     * @param {Object} newStyles Hash of properties to update.","     * @return Object","     */","    _setStyles: function(val)","    {","        if(!val.marker)","        {","            val = {marker:val};","        }","        val = this._parseMarkerStyles(val);","        return Y.MarkerSeries.superclass._mergeStyles.apply(this, [val, this._getDefaultStyles()]);","    },","","    /**","     * @protected","     *","     * Gets the default value for the `styles` attribute. Overrides","     * base implementation.","     *","     * @method _getDefaultStyles","     * @return Object","     */","    _getDefaultStyles: function()","    {","        var styles = this._mergeStyles({marker:this._getPlotDefaults()}, Y.MarkerSeries.superclass._getDefaultStyles());","        return styles;","    }","},{","    ATTRS : {","        /**","         * Read-only attribute indicating the type of series.","         *","         * @attribute type","         * @type String","         * @default marker","         */","        type: {","            value:\"marker\"","        }","","        /**","         * Style properties used for drawing markers. This attribute is inherited from `Renderer`. Below are the default","         * values:","         *  <dl>","         *      <dt>fill</dt><dd>A hash containing the following values:","         *          <dl>","         *              <dt>color</dt><dd>Color of the fill. The default value is determined by the order of the series on","         *              the graph. The color will be retrieved from the below array:<br/>","         *              `[\"#6084d0\", \"#eeb647\", \"#6c6b5f\", \"#d6484f\", \"#ce9ed1\", \"#ff9f3b\", \"#93b7ff\", \"#e0ddd0\", \"#94ecba\", \"#309687\"]`","         *              </dd>","         *              <dt>alpha</dt><dd>Number from 0 to 1 indicating the opacity of the marker fill. The default value is 1.</dd>","         *          </dl>","         *      </dd>","         *      <dt>border</dt><dd>A hash containing the following values:","         *          <dl>","         *              <dt>color</dt><dd>Color of the border. The default value is determined by the order of the series on","         *              the graph. The color will be retrieved from the below array:<br/>","         *              `[\"#205096\", \"#b38206\", \"#000000\", \"#94001e\", \"#9d6fa0\", \"#e55b00\", \"#5e85c9\", \"#adab9e\", \"#6ac291\", \"#006457\"]`","         *              <dt>alpha</dt><dd>Number from 0 to 1 indicating the opacity of the marker border. The default value is 1.</dd>","         *              <dt>weight</dt><dd>Number indicating the width of the border. The default value is 1.</dd>","         *          </dl>","         *      </dd>","         *      <dt>width</dt><dd>indicates the width of the marker. The default value is 10.</dd>","         *      <dt>height</dt><dd>indicates the height of the marker The default value is 10.</dd>","         *      <dt>over</dt><dd>hash containing styles for markers when highlighted by a `mouseover` event. The default","         *      values for each style is null. When an over style is not set, the non-over value will be used. For example,","         *      the default value for `marker.over.fill.color` is equivalent to `marker.fill.color`.</dd>","         *  </dl>","         *","         * @attribute styles","         * @type Object","         */","    }","});","","/**"," * The LineSeries class renders quantitative data on a graph by connecting relevant data points."," *"," * @module charts"," * @submodule charts-base"," * @class LineSeries"," * @extends CartesianSeries"," * @uses Lines"," * @constructor"," */","Y.LineSeries = Y.Base.create(\"lineSeries\", Y.CartesianSeries, [Y.Lines], {","    /**","     * @protected","     *","     * @method drawSeries","     */","    drawSeries: function()","    {","        this.drawLines();","    },","","    /**","     * @protected","     *","     * Method used by `styles` setter. Overrides base implementation.","     *","     * @method _setStyles","     * @param {Object} newStyles Hash of properties to update.","     * @return Object","     */","    _setStyles: function(val)","    {","        if(!val.line)","        {","            val = {line:val};","        }","        return Y.LineSeries.superclass._setStyles.apply(this, [val]);","    },","","    /**","     * @protected","     *","     * Gets the default value for the `styles` attribute. Overrides","     * base implementation.","     *","     * @method _getDefaultStyles","     * @return Object","     */","    _getDefaultStyles: function()","    {","        var styles = this._mergeStyles({line:this._getLineDefaults()}, Y.LineSeries.superclass._getDefaultStyles());","        return styles;","    }","},","{","    ATTRS: {","        /**","         * Read-only attribute indicating the type of series.","         *","         * @attribute type","         * @type String","         * @default line","         */","        type: {","            value:\"line\"","        }","","        /**","         * Style properties used for drawing lines. This attribute is inherited from `Renderer`. Below are the","         * default values:","         *  <dl>","         *      <dt>color</dt><dd>The color of the line. The default value is determined by the order of the series","         *      on the graph. The color will be retrieved from the following array:","         *      `[\"#426ab3\", \"#d09b2c\", \"#000000\", \"#b82837\", \"#b384b5\", \"#ff7200\", \"#779de3\", \"#cbc8ba\", \"#7ed7a6\", \"#007a6c\"]`","         *      <dt>weight</dt><dd>Number that indicates the width of the line. The default value is 6.</dd>","         *      <dt>alpha</dt><dd>Number between 0 and 1 that indicates the opacity of the line. The default value is 1.</dd>","         *      <dt>lineType</dt><dd>Indicates whether the line is solid or dashed. The default value is solid.</dd>","         *      <dt>dashLength</dt><dd>When the `lineType` is dashed, indicates the length of the dash. The default","         *      value is 10.</dd>","         *      <dt>gapSpace</dt><dd>When the `lineType` is dashed, indicates the distance between dashes. The default","         *      value is 10.</dd>","         *      <dt>connectDiscontinuousPoints</dt><dd>Indicates whether or not to connect lines when there is a missing","         *      or null value between points. The default value is true.</dd>","         *      <dt>discontinuousType</dt><dd>Indicates whether the line between discontinuous points is solid or dashed.","         *      The default value is solid.</dd>","         *      <dt>discontinuousDashLength</dt><dd>When the `discontinuousType` is dashed, indicates the length of the","         *      dash. The default value is 10.</dd>","         *      <dt>discontinuousGapSpace</dt><dd>When the `discontinuousType` is dashed, indicates the distance between","         *      dashes. The default value is 10.</dd>","         *  </dl>","         *","         * @attribute styles","         * @type Object","         */","    }","});","","","","","","","/**"," * SplineSeries renders a graph with data points connected by a curve."," *"," * @module charts"," * @submodule charts-base"," * @class SplineSeries"," * @constructor"," * @extends CartesianSeries"," * @uses CurveUtil"," * @uses Lines"," */","Y.SplineSeries = Y.Base.create(\"splineSeries\",  Y.LineSeries, [Y.CurveUtil, Y.Lines], {","    /**","     * @protected","     *","     * Draws the series.","     *","     * @method drawSeries","     */","    drawSeries: function()","    {","        this.drawSpline();","    }","}, {","	ATTRS : {","        /**","         * Read-only attribute indicating the type of series.","         *","         * @attribute type","         * @type String","         * @default spline","         */","        type : {","            value:\"spline\"","        }","","        /**","         * Style properties used for drawing lines. This attribute is inherited from `Renderer`.","         * Below are the default values:","         *  <dl>","         *      <dt>color</dt><dd>The color of the line. The default value is determined by the order of the series on","         *      the graph. The color will be retrieved from the following array:","         *      `[\"#426ab3\", \"#d09b2c\", \"#000000\", \"#b82837\", \"#b384b5\", \"#ff7200\", \"#779de3\", \"#cbc8ba\", \"#7ed7a6\", \"#007a6c\"]`","         *      <dt>weight</dt><dd>Number that indicates the width of the line. The default value is 6.</dd>","         *      <dt>alpha</dt><dd>Number between 0 and 1 that indicates the opacity of the line. The default value is 1.</dd>","         *      <dt>lineType</dt><dd>Indicates whether the line is solid or dashed. The default value is solid.</dd>","         *      <dt>dashLength</dt><dd>When the `lineType` is dashed, indicates the length of the dash. The default value","         *      is 10.</dd>","         *      <dt>gapSpace</dt><dd>When the `lineType` is dashed, indicates the distance between dashes. The default value is","         *      10.</dd>","         *      <dt>connectDiscontinuousPoints</dt><dd>Indicates whether or not to connect lines when there is a missing or null","         *      value between points. The default value is true.</dd>","         *      <dt>discontinuousType</dt><dd>Indicates whether the line between discontinuous points is solid or dashed. The","         *      default value is solid.</dd>","         *      <dt>discontinuousDashLength</dt><dd>When the `discontinuousType` is dashed, indicates the length of the dash.","         *      The default value is 10.</dd>","         *      <dt>discontinuousGapSpace</dt><dd>When the `discontinuousType` is dashed, indicates the distance between dashes.","         *      The default value is 10.</dd>","         *  </dl>","         *","         * @attribute styles","         * @type Object","         */","    }","});","","","","","","","/**"," * StackedSplineSeries creates spline graphs in which the different series are stacked along a value axis"," * to indicate their contribution to a cumulative total."," *"," * @module charts"," * @submodule charts-base"," * @class StackedSplineSeries"," * @constructor"," * @extends SplineSeries"," * @extends StackingUtil"," */","Y.StackedSplineSeries = Y.Base.create(\"stackedSplineSeries\", Y.SplineSeries, [Y.StackingUtil], {","    /**","     * @protected","     *","     * Calculates the coordinates for the series. Overrides base implementation.","     *","     * @method setAreaData","     */","    setAreaData: function()","    {","        Y.StackedSplineSeries.superclass.setAreaData.apply(this);","        this._stackCoordinates.apply(this);","    }","}, {","    ATTRS: {","        /**","         * Read-only attribute indicating the type of series.","         *","         * @attribute type","         * @type String","         * @default stackedSpline","         */","        type: {","            value:\"stackedSpline\"","        }","    }","});","","/**"," * StackedMarkerSeries plots markers with different series stacked along the value axis to indicate each"," * series' contribution to a cumulative total."," *"," * @module charts"," * @submodule charts-base"," * @class StackedMarkerSeries"," * @constructor"," * @extends MarkerSeries"," * @extends StackingUtil"," */","Y.StackedMarkerSeries = Y.Base.create(\"stackedMarkerSeries\", Y.MarkerSeries, [Y.StackingUtil], {","    /**","     * @protected","     *","     * Calculates the coordinates for the series. Overrides base implementation.","     *","     * @method setAreaData","     */","    setAreaData: function()","    {","        Y.StackedMarkerSeries.superclass.setAreaData.apply(this);","        this._stackCoordinates.apply(this);","    }","}, {","    ATTRS: {","        /**","         * Read-only attribute indicating the type of series.","         *","         * @attribute type","         * @type String","         * @default stackedMarker","         */","        type: {","            value:\"stackedMarker\"","        }","    }","});","","/**"," * The ColumnSeries class renders columns positioned horizontally along a category or time axis. The columns'"," * lengths are proportional to the values they represent along a vertical axis."," * and the relevant data points."," *"," * @module charts"," * @submodule charts-base"," * @class ColumnSeries"," * @extends MarkerSeries"," * @uses Histogram"," * @constructor"," */","Y.ColumnSeries = Y.Base.create(\"columnSeries\", Y.MarkerSeries, [Y.Histogram], {","    /**","     * Helper method for calculating the size of markers.","     *","     * @method _getMarkerDimensions","     * @param {Number} xcoord The x-coordinate representing the data point for the marker.","     * @param {Number} ycoord The y-coordinate representing the data point for the marker.","     * @param {Number} calculatedSize The calculated size for the marker. For a `BarSeries` is it the width. For a `ColumnSeries` it is the height.","     * @param {Number} offset Distance of position offset dictated by other marker series in the same graph.","     * @return Object","     * @private","     */","    _getMarkerDimensions: function(xcoord, ycoord, calculatedSize, offset)","    {","        var config = {","            left: xcoord + offset","        };","        if(this._bottomOrigin >= ycoord)","        {","            config.top = ycoord;","            config.calculatedSize = this._bottomOrigin - config.top;","        }","        else","        {","            config.top = this._bottomOrigin;","            config.calculatedSize = ycoord - this._bottomOrigin;","        }","        return config;","    },","","    /**","     * Resizes and positions markers based on a mouse interaction.","     *","     * @method updateMarkerState","     * @param {String} type state of the marker","     * @param {Number} i index of the marker","     * @protected","     */","    updateMarkerState: function(type, i)","    {","        if(this._markers && this._markers[i])","        {","            var styles = Y.clone(this.get(\"styles\").marker),","                markerStyles,","                state = this._getState(type),","                xcoords = this.get(\"xcoords\"),","                ycoords = this.get(\"ycoords\"),","                marker = this._markers[i],","                markers,","                graph = this.get(\"graph\"),","                seriesStyles,","                seriesCollection = graph.seriesTypes[this.get(\"type\")],","                seriesLen = seriesCollection.length,","                seriesSize = 0,","                offset = 0,","                renderer,","                n = 0,","                xs = [],","                order = this.get(\"order\"),","                config;","            markerStyles = state == \"off\" || !styles[state] ? Y.clone(styles) : Y.clone(styles[state]);","            markerStyles.fill.color = this._getItemColor(markerStyles.fill.color, i);","            markerStyles.border.color = this._getItemColor(markerStyles.border.color, i);","            config = this._getMarkerDimensions(xcoords[i], ycoords[i], styles.width, offset);","            markerStyles.height = config.calculatedSize;","            markerStyles.width = Math.min(this._maxSize, markerStyles.width);","            marker.set(markerStyles);","            for(; n < seriesLen; ++n)","            {","                xs[n] = xcoords[i] + seriesSize;","                seriesStyles = seriesCollection[n].get(\"styles\").marker;","                seriesSize += Math.min(this._maxSize, seriesStyles.width);","                if(order > n)","                {","                    offset = seriesSize;","                }","                offset -= seriesSize/2;","            }","            for(n = 0; n < seriesLen; ++n)","            {","                markers = seriesCollection[n].get(\"markers\");","                if(markers)","                {","                    renderer = markers[i];","                    if(renderer && renderer !== undefined)","                    {","                        renderer.set(\"x\", (xs[n] - seriesSize/2));","                    }","                }","            }","        }","    }","}, {","    ATTRS: {","        /**","         * Read-only attribute indicating the type of series.","         *","         * @attribute type","         * @type String","         * @readOnly","         * @default column","         */","        type: {","            value: \"column\"","        }","","        /**","         * Style properties used for drawing markers. This attribute is inherited from `MarkerSeries`. Below are the default values:","         *  <dl>","         *      <dt>fill</dt><dd>A hash containing the following values:","         *          <dl>","         *              <dt>color</dt><dd>Color of the fill. The default value is determined by the order of the series on the graph. The color","         *              will be retrieved from the below array:<br/>","         *              `[\"#66007f\", \"#a86f41\", \"#295454\", \"#996ab2\", \"#e8cdb7\", \"#90bdbd\",\"#000000\",\"#c3b8ca\", \"#968373\", \"#678585\"]`","         *              </dd>","         *              <dt>alpha</dt><dd>Number from 0 to 1 indicating the opacity of the marker fill. The default value is 1.</dd>","         *          </dl>","         *      </dd>","         *      <dt>border</dt><dd>A hash containing the following values:","         *          <dl>","         *              <dt>color</dt><dd>Color of the border. The default value is determined by the order of the series on the graph. The color","         *              will be retrieved from the below array:<br/>","         *              `[\"#205096\", \"#b38206\", \"#000000\", \"#94001e\", \"#9d6fa0\", \"#e55b00\", \"#5e85c9\", \"#adab9e\", \"#6ac291\", \"#006457\"]`","         *              <dt>alpha</dt><dd>Number from 0 to 1 indicating the opacity of the marker border. The default value is 1.</dd>","         *              <dt>weight</dt><dd>Number indicating the width of the border. The default value is 1.</dd>","         *          </dl>","         *      </dd>","         *      <dt>width</dt><dd>indicates the width of the marker. The default value is 12.</dd>","         *      <dt>over</dt><dd>hash containing styles for markers when highlighted by a `mouseover` event. The default","         *      values for each style is null. When an over style is not set, the non-over value will be used. For example,","         *      the default value for `marker.over.fill.color` is equivalent to `marker.fill.color`.</dd>","         *  </dl>","         *","         * @attribute styles","         * @type Object","         */","    }","});","/**"," * The BarSeries class renders bars positioned vertically along a category or time axis. The bars'"," * lengths are proportional to the values they represent along a horizontal axis."," * and the relevant data points."," *"," * @module charts"," * @submodule charts-base"," * @class BarSeries"," * @extends MarkerSeries"," * @uses Histogram"," * @constructor"," */","Y.BarSeries = Y.Base.create(\"barSeries\", Y.MarkerSeries, [Y.Histogram], {","    /**","     * Helper method for calculating the size of markers.","     *","     * @method _getMarkerDimensions","     * @param {Number} xcoord The x-coordinate representing the data point for the marker.","     * @param {Number} ycoord The y-coordinate representing the data point for the marker.","     * @param {Number} calculatedSize The calculated size for the marker. For a `BarSeries` is it the width. For a `ColumnSeries` it is the height.","     * @param {Number} offset Distance of position offset dictated by other marker series in the same graph.","     * @return Object","     * @private","     */","    _getMarkerDimensions: function(xcoord, ycoord, calculatedSize, offset)","    {","        var config = {","            top: ycoord + offset","        };","        if(xcoord >= this._leftOrigin)","        {","            config.left = this._leftOrigin;","            config.calculatedSize = xcoord - config.left;","        }","        else","        {","            config.left = xcoord;","            config.calculatedSize = this._leftOrigin - xcoord;","        }","        return config;","    },","","    /**","     * Resizes and positions markers based on a mouse interaction.","     *","     * @method updateMarkerState","     * @param {String} type state of the marker","     * @param {Number} i index of the marker","     * @protected","     */","    updateMarkerState: function(type, i)","    {","        if(this._markers && this._markers[i])","        {","            var styles = Y.clone(this.get(\"styles\").marker),","                markerStyles,","                state = this._getState(type),","                xcoords = this.get(\"xcoords\"),","                ycoords = this.get(\"ycoords\"),","                marker = this._markers[i],","                markers,","                graph = this.get(\"graph\"),","                seriesCollection = graph.seriesTypes[this.get(\"type\")],","                seriesLen = seriesCollection.length,","                seriesStyles,","                seriesSize = 0,","                offset = 0,","                renderer,","                n = 0,","                ys = [],","                order = this.get(\"order\"),","                config;","            markerStyles = state == \"off\" || !styles[state] ? styles : styles[state];","            markerStyles.fill.color = this._getItemColor(markerStyles.fill.color, i);","            markerStyles.border.color = this._getItemColor(markerStyles.border.color, i);","            config = this._getMarkerDimensions(xcoords[i], ycoords[i], styles.height, offset);","            markerStyles.width = config.calculatedSize;","            markerStyles.height = Math.min(this._maxSize, markerStyles.height);","            marker.set(markerStyles);","            for(; n < seriesLen; ++n)","            {","                ys[n] = ycoords[i] + seriesSize;","                seriesStyles = seriesCollection[n].get(\"styles\").marker;","                seriesSize += Math.min(this._maxSize, seriesStyles.height);","                if(order > n)","                {","                    offset = seriesSize;","                }","                offset -= seriesSize/2;","            }","            for(n = 0; n < seriesLen; ++n)","            {","                markers = seriesCollection[n].get(\"markers\");","                if(markers)","                {","                    renderer = markers[i];","                    if(renderer && renderer !== undefined)","                    {","                        renderer.set(\"y\", (ys[n] - seriesSize/2));","                    }","                }","            }","        }","    }","}, {","    ATTRS: {","        /**","         * Read-only attribute indicating the type of series.","         *","         * @attribute type","         * @type String","         * @default bar","         */","        type: {","            value: \"bar\"","        },","","        /**","         * Indicates the direction of the category axis that the bars are plotted against.","         *","         * @attribute direction","         * @type String","         */","        direction: {","            value: \"vertical\"","        }","","        /**","         * Style properties used for drawing markers. This attribute is inherited from `MarkerSeries`. Below are the default values:","         *  <dl>","         *      <dt>fill</dt><dd>A hash containing the following values:","         *          <dl>","         *              <dt>color</dt><dd>Color of the fill. The default value is determined by the order of the series on the graph. The color","         *              will be retrieved from the below array:<br/>","         *              `[\"#66007f\", \"#a86f41\", \"#295454\", \"#996ab2\", \"#e8cdb7\", \"#90bdbd\",\"#000000\",\"#c3b8ca\", \"#968373\", \"#678585\"]`","         *              </dd>","         *              <dt>alpha</dt><dd>Number from 0 to 1 indicating the opacity of the marker fill. The default value is 1.</dd>","         *          </dl>","         *      </dd>","         *      <dt>border</dt><dd>A hash containing the following values:","         *          <dl>","         *              <dt>color</dt><dd>Color of the border. The default value is determined by the order of the series on the graph. The color","         *              will be retrieved from the below array:<br/>","         *              `[\"#205096\", \"#b38206\", \"#000000\", \"#94001e\", \"#9d6fa0\", \"#e55b00\", \"#5e85c9\", \"#adab9e\", \"#6ac291\", \"#006457\"]`","         *              <dt>alpha</dt><dd>Number from 0 to 1 indicating the opacity of the marker border. The default value is 1.</dd>","         *              <dt>weight</dt><dd>Number indicating the width of the border. The default value is 1.</dd>","         *          </dl>","         *      </dd>","         *      <dt>height</dt><dd>indicates the width of the marker. The default value is 12.</dd>","         *      <dt>over</dt><dd>hash containing styles for markers when highlighted by a `mouseover` event. The default","         *      values for each style is null. When an over style is not set, the non-over value will be used. For example,","         *      the default value for `marker.over.fill.color` is equivalent to `marker.fill.color`.</dd>","         *  </dl>","         *","         * @attribute styles","         * @type Object","         */","    }","});","/**"," * The AreaSeries class renders quantitative data on a graph by creating a fill between 0"," * and the relevant data points."," *"," * @module charts"," * @submodule charts-base"," * @class AreaSeries"," * @extends CartesianSeries"," * @uses Fills"," * @constructor"," */","Y.AreaSeries = Y.Base.create(\"areaSeries\", Y.CartesianSeries, [Y.Fills], {","    /**","     * @protected","     *","     * Renders the series.","     *","     * @method drawSeries","     */","    drawSeries: function()","    {","        this.drawFill.apply(this, this._getClosingPoints());","    },","","    /**","     * @protected","     *","     * Method used by `styles` setter. Overrides base implementation.","     *","     * @method _setStyles","     * @param {Object} newStyles Hash of properties to update.","     * @return Object","     */","    _setStyles: function(val)","    {","        if(!val.area)","        {","            val = {area:val};","        }","        return Y.AreaSeries.superclass._setStyles.apply(this, [val]);","    },","","    /**","     * @protected","     *","     * Gets the default value for the `styles` attribute. Overrides","     * base implementation.","     *","     * @method _getDefaultStyles","     * @return Object","     */","    _getDefaultStyles: function()","    {","        var styles = this._mergeStyles({area:this._getAreaDefaults()}, Y.AreaSeries.superclass._getDefaultStyles());","        return styles;","    }","},","{","    ATTRS: {","        /**","         * Read-only attribute indicating the type of series.","         *","         * @attribute type","         * @type String","         * @default area","         */","        type: {","            value:\"area\"","        }","","        /**","         * Style properties used for drawing area fills. This attribute is inherited from `Renderer`. Below are the default values:","         *","         *  <dl>","         *      <dt>color</dt><dd>The color of the fill. The default value is determined by the order of the series on the graph. The color will be","         *      retrieved from the following array:","         *      `[\"#66007f\", \"#a86f41\", \"#295454\", \"#996ab2\", \"#e8cdb7\", \"#90bdbd\",\"#000000\",\"#c3b8ca\", \"#968373\", \"#678585\"]`","         *      </dd>","         *      <dt>alpha</dt><dd>Number between 0 and 1 that indicates the opacity of the fill. The default value is 1</dd>","         *  </dl>","         *","         * @attribute styles","         * @type Object","         */","    }","});","","","","","","","/**"," * AreaSplineSeries renders an area graph with data points connected by a curve."," *"," * @module charts"," * @submodule charts-base"," * @class AreaSplineSeries"," * @constructor"," * @extends CartesianSeries"," * @uses Fills"," * @uses CurveUtil"," */","Y.AreaSplineSeries = Y.Base.create(\"areaSplineSeries\", Y.AreaSeries, [Y.CurveUtil], {","    /**","     * @protected","     *","     * Draws the series.","     *","     * @method drawSeries","     */","    drawSeries: function()","    {","        this.drawAreaSpline();","    }","}, {","	ATTRS : {","        /**","         * Read-only attribute indicating the type of series.","         *","         * @attribute type","         * @type String","         * @default areaSpline","         */","        type: {","            value:\"areaSpline\"","        }","","        /**","         * Style properties used for drawing area fills. This attribute is inherited from `Renderer`. Below are the default values:","         *","         *  <dl>","         *      <dt>color</dt><dd>The color of the fill. The default value is determined by the order of the series on the graph. The color will be","         *      retrieved from the following array:","         *      `[\"#66007f\", \"#a86f41\", \"#295454\", \"#996ab2\", \"#e8cdb7\", \"#90bdbd\",\"#000000\",\"#c3b8ca\", \"#968373\", \"#678585\"]`","         *      </dd>","         *      <dt>alpha</dt><dd>Number between 0 and 1 that indicates the opacity of the fill. The default value is 1</dd>","         *  </dl>","         *","         * @attribute styles","         * @type Object","         */","    }","});","","/**"," * StackedAreaSplineSeries creates a stacked area chart with points data points connected by a curve."," *"," * @module charts"," * @submodule charts-base"," * @class StackedAreaSplineSeries"," * @constructor"," * @extends AreaSeries"," * @uses CurveUtil"," * @uses StackingUtil"," */","Y.StackedAreaSplineSeries = Y.Base.create(\"stackedAreaSplineSeries\", Y.AreaSeries, [Y.CurveUtil, Y.StackingUtil], {","    /**","     * @protected","     *","     * Draws the series.","     *","     * @method drawSeries","     */","    drawSeries: function()","    {","        this._stackCoordinates();","        this.drawStackedAreaSpline();","    }","}, {","    ATTRS : {","        /**","         * Read-only attribute indicating the type of series.","         *","         * @attribute type","         * @type String","         * @default stackedAreaSpline","         */","        type: {","            value:\"stackedAreaSpline\"","        }","    }","});","","/**"," * The ComboSeries class renders a combination of lines, plots and area fills in a single series."," * Each series type has a corresponding boolean attribute indicating if it is rendered. By default,"," * lines and plots are rendered and area is not."," *"," * @module charts"," * @submodule charts-base"," * @class ComboSeries"," * @extends CartesianSeries"," * @uses Fills"," * @uses Lines"," * @uses Plots"," * @constructor"," */","Y.ComboSeries = Y.Base.create(\"comboSeries\", Y.CartesianSeries, [Y.Fills, Y.Lines, Y.Plots], {","	/**","     * @protected","     *","     * Draws the series.","     *","     * @method drawSeries","     */","    drawSeries: function()","    {","        if(this.get(\"showAreaFill\"))","        {","            this.drawFill.apply(this, this._getClosingPoints());","        }","        if(this.get(\"showLines\"))","        {","            this.drawLines();","        }","        if(this.get(\"showMarkers\"))","        {","            this.drawPlots();","        }","    },","","    /**","     * Toggles visibility","     *","     * @method _toggleVisible","     * @param {Boolean} visible indicates visibilitye","     * @private","     */","    _toggleVisible: function(visible)","    {","        var markers,","            marker,","            len,","            i;","        if(this.get(\"showAreaFill\") && this._path)","        {","            this._path.set(\"visible\", visible);","        }","        if(this.get(\"showLines\") && this._lineGraphic)","        {","            this._lineGraphic.set(\"visible\", visible);","        }","        if(this.get(\"showMarkers\"))","        {","            markers = this.get(\"markers\");","            if(markers)","            {","                i = 0;","                len = markers.length;","                for(; i < len; ++i)","                {","                    marker = markers[i];","                    if(marker)","                    {","                        marker.set(\"visible\", visible);","                    }","                }","            }","        }","    },","","    /**","     * @protected","     *","     * Returns the default hash for the `styles` attribute.","     *","     * @method _getDefaultStyles","     * @return Object","     */","    _getDefaultStyles: function()","    {","        var styles = Y.ComboSeries.superclass._getDefaultStyles();","        styles.line = this._getLineDefaults();","        styles.marker = this._getPlotDefaults();","        styles.area = this._getAreaDefaults();","        return styles;","    }","},","{","    ATTRS: {","        /**","         * Read-only attribute indicating the type of series.","         *","         * @attribute type","         * @type String","         * @default combo","         */","        type: {","            value:\"combo\"","        },","","        /**","         * Indicates whether a fill is displayed.","         *","         * @attribute showAreaFill","         * @type Boolean","         * @default false","         */","        showAreaFill: {","            value: false","        },","","        /**","         * Indicates whether lines are displayed.","         *","         * @attribute showLines","         * @type Boolean","         * @default true","         */","        showLines: {","            value: true","        },","","        /**","         * Indicates whether markers are displayed.","         *","         * @attribute showMarkers","         * @type Boolean","         * @default true","         */","        showMarkers: {","            value: true","        },","","        /**","         * Reference to the styles of the markers. These styles can also","         * be accessed through the `styles` attribute. Below are default","         * values:","         *  <dl>","         *      <dt>fill</dt><dd>A hash containing the following values:","         *          <dl>","         *              <dt>color</dt><dd>Color of the fill. The default value is determined by the order of the series on the","         *              graph. The color will be retrieved from the below array:<br/>","         *              `[\"#6084d0\", \"#eeb647\", \"#6c6b5f\", \"#d6484f\", \"#ce9ed1\", \"#ff9f3b\", \"#93b7ff\", \"#e0ddd0\", \"#94ecba\", \"#309687\"]`","         *              </dd>","         *              <dt>alpha</dt><dd>Number from 0 to 1 indicating the opacity of the marker fill. The default value is 1.</dd>","         *          </dl>","         *      </dd>","         *      <dt>border</dt><dd>A hash containing the following values:","         *          <dl>","         *              <dt>color</dt><dd>Color of the border. The default value is determined by the order of the series on the graph.","         *              The color will be retrieved from the below array:<br/>","         *              `[\"#205096\", \"#b38206\", \"#000000\", \"#94001e\", \"#9d6fa0\", \"#e55b00\", \"#5e85c9\", \"#adab9e\", \"#6ac291\", \"#006457\"]`","         *              <dt>alpha</dt><dd>Number from 0 to 1 indicating the opacity of the marker border. The default value is 1.</dd>","         *              <dt>weight</dt><dd>Number indicating the width of the border. The default value is 1.</dd>","         *          </dl>","         *      </dd>","         *      <dt>width</dt><dd>indicates the width of the marker. The default value is 10.</dd>","         *      <dt>height</dt><dd>indicates the height of the marker The default value is 10.</dd>","         *      <dt>over</dt><dd>hash containing styles for markers when highlighted by a `mouseover` event. The default","         *      values for each style is null. When an over style is not set, the non-over value will be used. For example,","         *      the default value for `marker.over.fill.color` is equivalent to `marker.fill.color`.</dd>","         *  </dl>","         *","         * @attribute marker","         * @type Object","         */","        marker: {","            lazyAdd: false,","            getter: function()","            {","                return this.get(\"styles\").marker;","            },","            setter: function(val)","            {","                this.set(\"styles\", {marker:val});","            }","        },","","        /**","         * Reference to the styles of the lines. These styles can also be accessed through the `styles` attribute.","         * Below are the default values:","         *  <dl>","         *      <dt>color</dt><dd>The color of the line. The default value is determined by the order of the series on the graph. The color","         *      will be retrieved from the following array:","         *      `[\"#426ab3\", \"#d09b2c\", \"#000000\", \"#b82837\", \"#b384b5\", \"#ff7200\", \"#779de3\", \"#cbc8ba\", \"#7ed7a6\", \"#007a6c\"]`","         *      <dt>weight</dt><dd>Number that indicates the width of the line. The default value is 6.</dd>","         *      <dt>alpha</dt><dd>Number between 0 and 1 that indicates the opacity of the line. The default value is 1.</dd>","         *      <dt>lineType</dt><dd>Indicates whether the line is solid or dashed. The default value is solid.</dd>","         *      <dt>dashLength</dt><dd>When the `lineType` is dashed, indicates the length of the dash. The default value is 10.</dd>","         *      <dt>gapSpace</dt><dd>When the `lineType` is dashed, indicates the distance between dashes. The default value is 10.</dd>","         *      <dt>connectDiscontinuousPoints</dt><dd>Indicates whether or not to connect lines when there is a missing or null value","         *      between points. The default value is true.</dd>","         *      <dt>discontinuousType</dt><dd>Indicates whether the line between discontinuous points is solid or dashed. The default","         *      value is solid.</dd>","         *      <dt>discontinuousDashLength</dt><dd>When the `discontinuousType` is dashed, indicates the length of the dash. The default","         *      value is 10.</dd>","         *      <dt>discontinuousGapSpace</dt><dd>When the `discontinuousType` is dashed, indicates the distance between dashes. The default","         *      value is 10.</dd>","         *  </dl>","         *","         * @attribute line","         * @type Object","         */","        line: {","            lazyAdd: false,","            getter: function()","            {","                return this.get(\"styles\").line;","            },","            setter: function(val)","            {","                this.set(\"styles\", {line:val});","            }","        },","","        /**","         * Reference to the styles of the area fills. These styles can also be accessed through the `styles` attribute.","         * Below are the default values:","         *","         *  <dl>","         *      <dt>color</dt><dd>The color of the fill. The default value is determined by the order of the series on the","         *      graph. The color will be retrieved from the following array:","         *      `[\"#66007f\", \"#a86f41\", \"#295454\", \"#996ab2\", \"#e8cdb7\", \"#90bdbd\",\"#000000\",\"#c3b8ca\", \"#968373\", \"#678585\"]`","         *      </dd>","         *      <dt>alpha</dt><dd>Number between 0 and 1 that indicates the opacity of the fill. The default value is 1</dd>","         *  </dl>","         *","         * @attribute area","         * @type Object","         */","        area: {","            lazyAdd: false,","            getter: function()","            {","                return this.get(\"styles\").area;","            },","            setter: function(val)","            {","                this.set(\"styles\", {area:val});","            }","        }","","        /**","         * Style properties for the series. Contains a key indexed hash of the following:","         *  <dl>","         *      <dt>marker</dt><dd>Style properties for the markers in the series. Specific style attributes are listed","         *      <a href=\"#attr_marker\">here</a>.</dd>","         *      <dt>line</dt><dd>Style properties for the lines in the series. Specific","         *      style attributes are listed <a href=\"#attr_line\">here</a>.</dd>","         *      <dt>area</dt><dd>Style properties for the area fills in the series. Specific style attributes are listed","         *      <a href=\"#attr_area\">here</a>.</dd>","         *  </dl>","         *","         * @attribute styles","         * @type Object","         */","    }","});","","","","","","","/**"," * The StackedComboSeries class renders a combination of lines, plots and area fills in a single series. Series"," * are stacked along the value axis to indicate each series contribution to a cumulative total. Each"," * series type has a corresponding boolean attribute indicating if it is rendered. By default, all three types are"," * rendered."," *"," * @module charts"," * @submodule charts-base"," * @class StackedComboSeries"," * @extends ComboSeries"," * @uses StackingUtil"," * @constructor"," */","Y.StackedComboSeries = Y.Base.create(\"stackedComboSeries\", Y.ComboSeries, [Y.StackingUtil], {","    /**","     * @protected","     *","     * Calculates the coordinates for the series. Overrides base implementation.","     *","     * @method setAreaData","     */","    setAreaData: function()","    {","        Y.StackedComboSeries.superclass.setAreaData.apply(this);","        this._stackCoordinates.apply(this);","    },","","    /**","     * @protected","     *","     * Draws the series.","     *","     * @method drawSeries","     */","    drawSeries: function()","    {","        if(this.get(\"showAreaFill\"))","        {","            this.drawFill.apply(this, this._getStackedClosingPoints());","        }","        if(this.get(\"showLines\"))","        {","            this.drawLines();","        }","        if(this.get(\"showMarkers\"))","        {","            this.drawPlots();","        }","    }","","}, {","    ATTRS : {","        /**","         * Read-only attribute indicating the type of series.","         *","         * @attribute type","         * @type String","         * @default stackedCombo","         */","        type: {","            value: \"stackedCombo\"","        },","","        /**","         * Indicates whether a fill is displayed.","         *","         * @attribute showAreaFill","         * @type Boolean","         * @default true","         */","        showAreaFill: {","            value: true","        }","    }","});","/**"," * The ComboSplineSeries class renders a combination of splines, plots and areaspline fills in a single series. Each"," * series type has a corresponding boolean attribute indicating if it is rendered. By default, splines and plots"," * are rendered and areaspline is not."," *"," * @module charts"," * @submodule charts-base"," * @class ComboSplineSeries"," * @extends ComboSeries"," * @extends CurveUtil"," * @constructor"," */","Y.ComboSplineSeries = Y.Base.create(\"comboSplineSeries\", Y.ComboSeries, [Y.CurveUtil], {","    /**","     * @protected","     *","     * Draws the series.","     *","     * @method drawSeries","     */","    drawSeries: function()","    {","        if(this.get(\"showAreaFill\"))","        {","            this.drawAreaSpline();","        }","        if(this.get(\"showLines\"))","        {","            this.drawSpline();","        }","        if(this.get(\"showMarkers\"))","        {","            this.drawPlots();","        }","    }","}, {","    ATTRS: {","        /**","         * Read-only attribute indicating the type of series.","         *","         * @attribute type","         * @type String","         * @default comboSpline","         */","        type: {","            value : \"comboSpline\"","        }","    }","});","/**"," * The StackedComboSplineSeries class renders a combination of splines, plots and areaspline fills in a single series. Series"," * are stacked along the value axis to indicate each series contribution to a cumulative total. Each"," * series type has a corresponding boolean attribute indicating if it is rendered. By default, all three types are"," * rendered."," *"," * @module charts"," * @submodule charts-base"," * @class StackedComboSplineSeries"," * @extends StackedComboSeries"," * @uses CurveUtil"," * @constructor"," */","Y.StackedComboSplineSeries = Y.Base.create(\"stackedComboSplineSeries\", Y.StackedComboSeries, [Y.CurveUtil], {","    /**","	 * @protected","     *","     * Draws the series.","     *","     * @method drawSeries","	 */","	drawSeries: function()","    {","        if(this.get(\"showAreaFill\"))","        {","            this.drawStackedAreaSpline();","        }","        if(this.get(\"showLines\"))","        {","            this.drawSpline();","        }","        if(this.get(\"showMarkers\"))","        {","            this.drawPlots();","        }","    }","}, {","    ATTRS: {","        /**","         * Read-only attribute indicating the type of series.","         *","         * @attribute type","         * @type String","         * @default stackedComboSpline","         */","        type : {","            value : \"stackedComboSpline\"","        },","","        /**","         * Indicates whether a fill is displayed.","         *","         * @attribute showAreaFill","         * @type Boolean","         * @default true","         */","        showAreaFill: {","            value: true","        }","    }","});","/**"," * StackedLineSeries creates line graphs in which the different series are stacked along a value axis"," * to indicate their contribution to a cumulative total."," *"," * @module charts"," * @submodule charts-base"," * @class StackedLineSeries"," * @constructor"," * @extends  LineSeries"," * @uses StackingUtil"," */","Y.StackedLineSeries = Y.Base.create(\"stackedLineSeries\", Y.LineSeries, [Y.StackingUtil], {","    /**","     * @protected","     *","     * Calculates the coordinates for the series. Overrides base implementation.","     *","     * @method setAreaData","     */","    setAreaData: function()","    {","        Y.StackedLineSeries.superclass.setAreaData.apply(this);","        this._stackCoordinates.apply(this);","    }","}, {","    ATTRS: {","        /**","         * Read-only attribute indicating the type of series.","         *","         * @attribute type","         * @type String","         * @default stackedLine","         */","        type: {","            value:\"stackedLine\"","        }","    }","});","/**"," * StackedAreaSeries area fills to display data showing its contribution to a whole."," *"," * @module charts"," * @submodule charts-base"," * @class StackedAreaSeries"," * @constructor"," * @param {Object} config (optional) Configuration parameters for the Chart."," * @extends AreaSeries"," * @uses StackingUtil"," */","Y.StackedAreaSeries = Y.Base.create(\"stackedAreaSeries\", Y.AreaSeries, [Y.StackingUtil], {","    /**","     * @protected","     *","     * Calculates the coordinates for the series. Overrides base implementation.","     *","     * @method setAreaData","     */","    setAreaData: function()","    {","        Y.StackedAreaSeries.superclass.setAreaData.apply(this);","        this._stackCoordinates.apply(this);","    },","","    /**","     * @protected","     *","     * Draws the series","     *","     * @method drawSeries","     */","	drawSeries: function()","    {","        this.drawFill.apply(this, this._getStackedClosingPoints());","    }","}, {","    ATTRS: {","        /**","         * Read-only attribute indicating the type of series.","         *","         * @attribute type","         * @type String","         * @default stackedArea","         */","        type: {","            value:\"stackedArea\"","        }","    }","});","/**"," * The StackedColumnSeries renders column chart in which series are stacked vertically to show"," * their contribution to the cumulative total."," *"," * @module charts"," * @submodule charts-base"," * @class StackedColumnSeries"," * @extends ColumnSeries"," * @uses StackingUtil"," * @constructor"," */","Y.StackedColumnSeries = Y.Base.create(\"stackedColumnSeries\", Y.ColumnSeries, [Y.StackingUtil], {","    /**","     * Draws the series.","     *","     * @method drawSeries","	 * @protected","	 */","	drawSeries: function()","	{","        if(this.get(\"xcoords\").length < 1)","        {","            return;","        }","        var isNumber = Y_Lang.isNumber,","            style = Y.clone(this.get(\"styles\").marker),","            w = style.width,","            h = style.height,","            xcoords = this.get(\"xcoords\"),","            ycoords = this.get(\"ycoords\"),","            i = 0,","            len = xcoords.length,","            top = ycoords[0],","            type = this.get(\"type\"),","            graph = this.get(\"graph\"),","            seriesCollection = graph.seriesTypes[type],","            ratio,","            order = this.get(\"order\"),","            graphOrder = this.get(\"graphOrder\"),","            left,","            marker,","            fillColors,","            borderColors,","            lastCollection,","            negativeBaseValues,","            positiveBaseValues,","            useOrigin = order === 0,","            totalWidth = len * w,","            dimensions = {","                width: [],","                height: []","            },","            xvalues = [],","            yvalues = [],","            groupMarkers = this.get(\"groupMarkers\");","        if(Y_Lang.isArray(style.fill.color))","        {","            fillColors = style.fill.color.concat();","        }","        if(Y_Lang.isArray(style.border.color))","        {","            borderColors = style.border.color.concat();","        }","        this._createMarkerCache();","        if(totalWidth > this.get(\"width\"))","        {","            ratio = this.width/totalWidth;","            w *= ratio;","            w = Math.max(w, 1);","        }","        if(!useOrigin)","        {","            lastCollection = seriesCollection[order - 1];","            negativeBaseValues = lastCollection.get(\"negativeBaseValues\");","            positiveBaseValues = lastCollection.get(\"positiveBaseValues\");","            if(!negativeBaseValues || !positiveBaseValues)","            {","                useOrigin = true;","                positiveBaseValues = [];","                negativeBaseValues = [];","            }","        }","        else","        {","            negativeBaseValues = [];","            positiveBaseValues = [];","        }","        this.set(\"negativeBaseValues\", negativeBaseValues);","        this.set(\"positiveBaseValues\", positiveBaseValues);","        for(i = 0; i < len; ++i)","        {","            left = xcoords[i];","            top = ycoords[i];","","            if(!isNumber(top) || !isNumber(left))","            {","                if(useOrigin)","                {","                    negativeBaseValues[i] = this._bottomOrigin;","                    positiveBaseValues[i] = this._bottomOrigin;","                }","                this._markers.push(null);","                continue;","            }","            if(useOrigin)","            {","                h = Math.abs(this._bottomOrigin - top);","                if(top < this._bottomOrigin)","                {","                    positiveBaseValues[i] = top;","                    negativeBaseValues[i] = this._bottomOrigin;","                }","                else if(top > this._bottomOrigin)","                {","                    positiveBaseValues[i] = this._bottomOrigin;","                    negativeBaseValues[i] = top;","                    top -= h;","                }","                else","                {","                    positiveBaseValues[i] = top;","                    negativeBaseValues[i] = top;","                }","            }","            else","            {","                if(top > this._bottomOrigin)","                {","                    top += (negativeBaseValues[i] - this._bottomOrigin);","                    h = top - negativeBaseValues[i];","                    negativeBaseValues[i] = top;","                    top -= h;","                }","                else if(top <= this._bottomOrigin)","                {","                    top = positiveBaseValues[i] - (this._bottomOrigin - top);","                    h = positiveBaseValues[i] - top;","                    positiveBaseValues[i] = top;","                }","            }","            if(!isNaN(h) && h > 0)","            {","                left -= w/2;","                if(groupMarkers)","                {","                    dimensions.width[i] = w;","                    dimensions.height[i] = h;","                    xvalues.push(left);","                    yvalues.push(top);","                }","                else","                {","                    style.width = w;","                    style.height = h;","                    style.x = left;","                    style.y = top;","                    if(fillColors)","                    {","                        style.fill.color = fillColors[i % fillColors.length];","                    }","                    if(borderColors)","                    {","                        style.border.color = borderColors[i % borderColors.length];","                    }","                    marker = this.getMarker(style, graphOrder, i);","                }","            }","            else if(!groupMarkers)","            {","               this._markers.push(null);","            }","        }","        if(groupMarkers)","        {","            this._createGroupMarker({","                fill: style.fill,","                border: style.border,","                dimensions: dimensions,","                xvalues: xvalues,","                yvalues: yvalues,","                shape: style.shape","            });","        }","        else","        {","            this._clearMarkerCache();","        }","    },","","    /**","     * Resizes and positions markers based on a mouse interaction.","     *","     * @method updateMarkerState","     * @param {String} type state of the marker","     * @param {Number} i index of the marker","     * @protected","     */","    updateMarkerState: function(type, i)","    {","        if(this._markers && this._markers[i])","        {","            var styles,","                markerStyles,","                state = this._getState(type),","                xcoords = this.get(\"xcoords\"),","                marker = this._markers[i],","                offset = 0,","                fillColor,","                borderColor;","            styles = this.get(\"styles\").marker;","            offset = styles.width * 0.5;","            markerStyles = state == \"off\" || !styles[state] ? Y.clone(styles) : Y.clone(styles[state]);","            markerStyles.height = marker.get(\"height\");","            markerStyles.x = (xcoords[i] - offset);","            markerStyles.y = marker.get(\"y\");","            markerStyles.id = marker.get(\"id\");","            fillColor = markerStyles.fill.color;","            borderColor = markerStyles.border.color;","            if(Y_Lang.isArray(fillColor))","            {","                markerStyles.fill.color = fillColor[i % fillColor.length];","            }","            else","            {","                markerStyles.fill.color = this._getItemColor(markerStyles.fill.color, i);","            }","            if(Y_Lang.isArray(borderColor))","            {","                markerStyles.border.color = borderColor[i % borderColor.length];","            }","            else","            {","                markerStyles.border.color = this._getItemColor(markerStyles.border.color, i);","            }","            marker.set(markerStyles);","        }","    },","","    /**","     * Gets the default values for the markers.","     *","     * @method _getPlotDefaults","     * @return Object","     * @protected","     */","    _getPlotDefaults: function()","    {","        var defs = {","            fill:{","                type: \"solid\",","                alpha: 1,","                colors:null,","                alphas: null,","                ratios: null","            },","            border:{","                weight: 0,","                alpha: 1","            },","            width: 24,","            height: 24,","            shape: \"rect\",","","            padding:{","                top: 0,","                left: 0,","                right: 0,","                bottom: 0","            }","        };","        defs.fill.color = this._getDefaultColor(this.get(\"graphOrder\"), \"fill\");","        defs.border.color = this._getDefaultColor(this.get(\"graphOrder\"), \"border\");","        return defs;","    }","}, {","    ATTRS: {","        /**","         * Read-only attribute indicating the type of series.","         *","         * @attribute type","         * @type String","         * @default stackedColumn","         */","        type: {","            value: \"stackedColumn\"","        },","","        /**","         * @attribute negativeBaseValues","         * @type Array","         * @default null","         * @private","         */","        negativeBaseValues: {","            value: null","        },","","        /**","         * @attribute positiveBaseValues","         * @type Array","         * @default null","         * @private","         */","        positiveBaseValues: {","            value: null","        }","","        /**","         * Style properties used for drawing markers. This attribute is inherited from `ColumnSeries`. Below are the default values:","         *  <dl>","         *      <dt>fill</dt><dd>A hash containing the following values:","         *          <dl>","         *              <dt>color</dt><dd>Color of the fill. The default value is determined by the order of the series on the graph. The color","         *              will be retrieved from the below array:<br/>","         *              `[\"#66007f\", \"#a86f41\", \"#295454\", \"#996ab2\", \"#e8cdb7\", \"#90bdbd\",\"#000000\",\"#c3b8ca\", \"#968373\", \"#678585\"]`","         *              </dd>","         *              <dt>alpha</dt><dd>Number from 0 to 1 indicating the opacity of the marker fill. The default value is 1.</dd>","         *          </dl>","         *      </dd>","         *      <dt>border</dt><dd>A hash containing the following values:","         *          <dl>","         *              <dt>color</dt><dd>Color of the border. The default value is determined by the order of the series on the graph. The color","         *              will be retrieved from the below array:<br/>","         *              `[\"#205096\", \"#b38206\", \"#000000\", \"#94001e\", \"#9d6fa0\", \"#e55b00\", \"#5e85c9\", \"#adab9e\", \"#6ac291\", \"#006457\"]`","         *              <dt>alpha</dt><dd>Number from 0 to 1 indicating the opacity of the marker border. The default value is 1.</dd>","         *              <dt>weight</dt><dd>Number indicating the width of the border. The default value is 1.</dd>","         *          </dl>","         *      </dd>","         *      <dt>width</dt><dd>indicates the width of the marker. The default value is 24.</dd>","         *      <dt>over</dt><dd>hash containing styles for markers when highlighted by a `mouseover` event. The default","         *      values for each style is null. When an over style is not set, the non-over value will be used. For example,","         *      the default value for `marker.over.fill.color` is equivalent to `marker.fill.color`.</dd>","         *  </dl>","         *","         * @attribute styles","         * @type Object","         */","    }","});","","/**"," * The StackedBarSeries renders bar chart in which series are stacked horizontally to show"," * their contribution to the cumulative total."," *"," * @module charts"," * @submodule charts-base"," * @class StackedBarSeries"," * @extends BarSeries"," * @uses StackingUtil"," * @constructor"," */","Y.StackedBarSeries = Y.Base.create(\"stackedBarSeries\", Y.BarSeries, [Y.StackingUtil], {","    /**","     * @protected","     *","     * Draws the series.","     *","     * @method drawSeries","     */","    drawSeries: function()","	{","        if(this.get(\"xcoords\").length < 1)","        {","            return;","        }","","        var isNumber = Y_Lang.isNumber,","            style = Y.clone(this.get(\"styles\").marker),","            w = style.width,","            h = style.height,","            xcoords = this.get(\"xcoords\"),","            ycoords = this.get(\"ycoords\"),","            i = 0,","            len = xcoords.length,","            top = ycoords[0],","            type = this.get(\"type\"),","            graph = this.get(\"graph\"),","            seriesCollection = graph.seriesTypes[type],","            ratio,","            order = this.get(\"order\"),","            graphOrder = this.get(\"graphOrder\"),","            left,","            marker,","            lastCollection,","            negativeBaseValues,","            positiveBaseValues,","            fillColors,","            borderColors,","            useOrigin = order === 0,","            totalHeight = len * h,","            dimensions = {","                width: [],","                height: []","            },","            xvalues = [],","            yvalues = [],","            groupMarkers = this.get(\"groupMarkers\");","        if(Y_Lang.isArray(style.fill.color))","        {","            fillColors = style.fill.color.concat();","        }","        if(Y_Lang.isArray(style.border.color))","        {","            borderColors = style.border.color.concat();","        }","        this._createMarkerCache();","        if(totalHeight > this.get(\"height\"))","        {","            ratio = this.height/totalHeight;","            h *= ratio;","            h = Math.max(h, 1);","        }","        if(!useOrigin)","        {","            lastCollection = seriesCollection[order - 1];","            negativeBaseValues = lastCollection.get(\"negativeBaseValues\");","            positiveBaseValues = lastCollection.get(\"positiveBaseValues\");","            if(!negativeBaseValues || !positiveBaseValues)","            {","                useOrigin = true;","                positiveBaseValues = [];","                negativeBaseValues = [];","            }","        }","        else","        {","            negativeBaseValues = [];","            positiveBaseValues = [];","        }","        this.set(\"negativeBaseValues\", negativeBaseValues);","        this.set(\"positiveBaseValues\", positiveBaseValues);","        for(i = 0; i < len; ++i)","        {","            top = ycoords[i];","            left = xcoords[i];","            if(!isNumber(top) || !isNumber(left))","            {","                if(useOrigin)","                {","                    positiveBaseValues[i] = this._leftOrigin;","                    negativeBaseValues[i] = this._leftOrigin;","                }","                this._markers.push(null);","                continue;","            }","            if(useOrigin)","            {","                w = Math.abs(left - this._leftOrigin);","                if(left > this._leftOrigin)","                {","                    positiveBaseValues[i] = left;","                    negativeBaseValues[i] = this._leftOrigin;","                    left -= w;","                }","                else if(left < this._leftOrigin)","                {","                    positiveBaseValues[i] = this._leftOrigin;","                    negativeBaseValues[i] = left;","                }","                else","                {","                    positiveBaseValues[i] = left;","                    negativeBaseValues[i] = this._leftOrigin;","                }","            }","            else","            {","                if(left < this._leftOrigin)","                {","                    left = negativeBaseValues[i] - (this._leftOrigin - xcoords[i]);","                    w = negativeBaseValues[i] - left;","                    negativeBaseValues[i] = left;","                }","                else if(left >= this._leftOrigin)","                {","                    left += (positiveBaseValues[i] - this._leftOrigin);","                    w = left - positiveBaseValues[i];","                    positiveBaseValues[i] = left;","                    left -= w;","                }","            }","            if(!isNaN(w) && w > 0)","            {","                top -= h/2;","                if(groupMarkers)","                {","                    dimensions.width[i] = w;","                    dimensions.height[i] = h;","                    xvalues.push(left);","                    yvalues.push(top);","                }","                else","                {","                    style.width = w;","                    style.height = h;","                    style.x = left;","                    style.y = top;","                    if(fillColors)","                    {","                        style.fill.color = fillColors[i % fillColors.length];","                    }","                    if(borderColors)","                    {","                        style.border.color = borderColors[i % borderColors.length];","                    }","                    marker = this.getMarker(style, graphOrder, i);","                }","            }","            else if(!groupMarkers)","            {","                this._markers.push(null);","            }","        }","        if(groupMarkers)","        {","            this._createGroupMarker({","                fill: style.fill,","                border: style.border,","                dimensions: dimensions,","                xvalues: xvalues,","                yvalues: yvalues,","                shape: style.shape","            });","        }","        else","        {","            this._clearMarkerCache();","        }","    },","","    /**","     * @protected","     *","     * Resizes and positions markers based on a mouse interaction.","     *","     * @method updateMarkerState","     * @param {String} type state of the marker","     * @param {Number} i index of the marker","     */","    updateMarkerState: function(type, i)","    {","        if(this._markers[i])","        {","            var state = this._getState(type),","                ycoords = this.get(\"ycoords\"),","                marker = this._markers[i],","                styles = this.get(\"styles\").marker,","                h = styles.height,","                markerStyles = state == \"off\" || !styles[state] ? Y.clone(styles) : Y.clone(styles[state]),","                fillColor,","                borderColor;","            markerStyles.y = (ycoords[i] - h/2);","            markerStyles.x = marker.get(\"x\");","            markerStyles.width = marker.get(\"width\");","            markerStyles.id = marker.get(\"id\");","            fillColor = markerStyles.fill.color;","            borderColor = markerStyles.border.color;","            if(Y_Lang.isArray(fillColor))","            {","                markerStyles.fill.color = fillColor[i % fillColor.length];","            }","            else","            {","                markerStyles.fill.color = this._getItemColor(markerStyles.fill.color, i);","            }","            if(Y_Lang.isArray(borderColor))","            {","                markerStyles.border.color = borderColor[i % borderColor.length];","            }","            else","            {","                markerStyles.border.color = this._getItemColor(markerStyles.border.color, i);","            }","            marker.set(markerStyles);","        }","    },","","    /**","     * @protected","     *","     * Returns default values for the `styles` attribute.","     *","     * @method _getPlotDefaults","     * @return Object","     */","    _getPlotDefaults: function()","    {","        var defs = {","            fill:{","                type: \"solid\",","                alpha: 1,","                colors:null,","                alphas: null,","                ratios: null","            },","            border:{","                weight: 0,","                alpha: 1","            },","            width: 24,","            height: 24,","            shape: \"rect\",","","            padding:{","                top: 0,","                left: 0,","                right: 0,","                bottom: 0","            }","        };","        defs.fill.color = this._getDefaultColor(this.get(\"graphOrder\"), \"fill\");","        defs.border.color = this._getDefaultColor(this.get(\"graphOrder\"), \"border\");","        return defs;","    }","}, {","    ATTRS: {","        /**","         * Read-only attribute indicating the type of series.","         *","         * @attribute type","         * @type String","         * @default stackedBar","         */","        type: {","            value: \"stackedBar\"","        },","","        /**","         * Direction of the series","         *","         * @attribute direction","         * @type String","         * @default vertical","         */","        direction: {","            value: \"vertical\"","        },","","        /**","         * @private","         *","         * @attribute negativeBaseValues","         * @type Array","         * @default null","         */","        negativeBaseValues: {","            value: null","        },","","        /**","         * @private","         *","         * @attribute positiveBaseValues","         * @type Array","         * @default null","         */","        positiveBaseValues: {","            value: null","        }","","        /**","         * Style properties used for drawing markers. This attribute is inherited from `BarSeries`. Below are the default values:","         *  <dl>","         *      <dt>fill</dt><dd>A hash containing the following values:","         *          <dl>","         *              <dt>color</dt><dd>Color of the fill. The default value is determined by the order of the series on the graph. The color","         *              will be retrieved from the below array:<br/>","         *              `[\"#66007f\", \"#a86f41\", \"#295454\", \"#996ab2\", \"#e8cdb7\", \"#90bdbd\",\"#000000\",\"#c3b8ca\", \"#968373\", \"#678585\"]`","         *              </dd>","         *              <dt>alpha</dt><dd>Number from 0 to 1 indicating the opacity of the marker fill. The default value is 1.</dd>","         *          </dl>","         *      </dd>","         *      <dt>border</dt><dd>A hash containing the following values:","         *          <dl>","         *              <dt>color</dt><dd>Color of the border. The default value is determined by the order of the series on the graph. The color","         *              will be retrieved from the below array:<br/>","         *              `[\"#205096\", \"#b38206\", \"#000000\", \"#94001e\", \"#9d6fa0\", \"#e55b00\", \"#5e85c9\", \"#adab9e\", \"#6ac291\", \"#006457\"]`","         *              <dt>alpha</dt><dd>Number from 0 to 1 indicating the opacity of the marker border. The default value is 1.</dd>","         *              <dt>weight</dt><dd>Number indicating the width of the border. The default value is 1.</dd>","         *          </dl>","         *      </dd>","         *      <dt>height</dt><dd>indicates the width of the marker. The default value is 24.</dd>","         *      <dt>over</dt><dd>hash containing styles for markers when highlighted by a `mouseover` event. The default","         *      values for each style is null. When an over style is not set, the non-over value will be used. For example,","         *      the default value for `marker.over.fill.color` is equivalent to `marker.fill.color`.</dd>","         *  </dl>","         *","         * @attribute styles","         * @type Object","         */","    }","});","","/**"," * PieSeries visualizes data as a circular chart divided into wedges which represent data as a"," * percentage of a whole."," *"," * @module charts"," * @submodule charts-base"," * @class PieSeries"," * @constructor"," * @extends MarkerSeries"," */","Y.PieSeries = Y.Base.create(\"pieSeries\", Y.MarkerSeries, [], {","    /**","     * Image map used for interactivity when rendered with canvas.","     *","     * @property _map","     * @type HTMLElement","     * @private","     */","    _map: null,","","    /**","     * Image used for image map when rendered with canvas.","     *","     * @property _image","     * @type HTMLElement","     * @private","     */","    _image: null,","","    /**","     * Creates or updates the image map when rendered with canvas.","     *","     * @method _setMap","     * @private","     */","    _setMap: function()","    {","        var id = \"pieHotSpotMapi_\" + Math.round(100000 * Math.random()),","            cb = this.get(\"graph\").get(\"contentBox\"),","            areaNode;","        if(this._image)","        {","            cb.removeChild(this._image);","            while(this._areaNodes && this._areaNodes.length > 0)","            {","                areaNode = this._areaNodes.shift();","                this._map.removeChild(areaNode);","            }","            cb.removeChild(this._map);","        }","        this._image = DOCUMENT.createElement(\"img\");","        this._image.src = \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAYAAAABCAYAAAD9yd/wAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAABJJREFUeNpiZGBgSGPAAgACDAAIkABoFyloZQAAAABJRU5ErkJggg==\";","        cb.appendChild(this._image);","        this._image.setAttribute(\"usemap\", \"#\" + id);","        this._image.style.zIndex = 3;","        this._image.style.opacity = 0;","        this._image.setAttribute(\"alt\", \"imagemap\");","        this._map = DOCUMENT.createElement(\"map\");","        this._map.style.zIndex = 5;","        cb.appendChild(this._map);","        this._map.setAttribute(\"name\", id);","        this._map.setAttribute(\"id\", id);","        this._areaNodes = [];","    },","","    /**","     * Storage for `categoryDisplayName` attribute.","     *","     * @property _categoryDisplayName","     * @private","     */","    _categoryDisplayName: null,","","    /**","     * Storage for `valueDisplayName` attribute.","     *","     * @property _valueDisplayName","     * @private","     */","    _valueDisplayName: null,","","    /**","     * Adds event listeners.","     *","     * @method addListeners","     * @private","     */","    addListeners: function()","    {","        var categoryAxis = this.get(\"categoryAxis\"),","            valueAxis = this.get(\"valueAxis\");","        if(categoryAxis)","        {","            categoryAxis.after(\"dataReady\", Y.bind(this._categoryDataChangeHandler, this));","            categoryAxis.after(\"dataUpdate\", Y.bind(this._categoryDataChangeHandler, this));","        }","        if(valueAxis)","        {","            valueAxis.after(\"dataReady\", Y.bind(this._valueDataChangeHandler, this));","            valueAxis.after(\"dataUpdate\", Y.bind(this._valueDataChangeHandler, this));","        }","        this.after(\"categoryAxisChange\", this.categoryAxisChangeHandler);","        this.after(\"valueAxisChange\", this.valueAxisChangeHandler);","        this.after(\"stylesChange\", this._updateHandler);","    },","","    /**","     * Draws the series.","     *","     * @method validate","     * @private","     */","    validate: function()","    {","        this.draw();","        this._renderered = true;","    },","","    /**","     * Event handler for the categoryAxisChange event.","     *","     * @method _categoryAxisChangeHandler","     * @param {Object} e Event object.","     * @private","     */","    _categoryAxisChangeHandler: function(e)","    {","        var categoryAxis = this.get(\"categoryAxis\");","        categoryAxis.after(\"dataReady\", Y.bind(this._categoryDataChangeHandler, this));","        categoryAxis.after(\"dataUpdate\", Y.bind(this._categoryDataChangeHandler, this));","    },","","    /**","     * Event handler for the valueAxisChange event.","     *","     * @method _valueAxisChangeHandler","     * @param {Object} e Event object.","     * @private","     */","    _valueAxisChangeHandler: function(e)","    {","        var valueAxis = this.get(\"valueAxis\");","        valueAxis.after(\"dataReady\", Y.bind(this._valueDataChangeHandler, this));","        valueAxis.after(\"dataUpdate\", Y.bind(this._valueDataChangeHandler, this));","    },","","    /**","     * Constant used to generate unique id.","     *","     * @property GUID","     * @type String","     * @private","     */","    GUID: \"pieseries\",","","    /**","     * Event handler for categoryDataChange event.","     *","     * @method _categoryDataChangeHandler","     * @param {Object} event Event object.","     * @private","     */","    _categoryDataChangeHandler: function(event)","    {","       if(this._rendered && this.get(\"categoryKey\") && this.get(\"valueKey\"))","        {","            this.draw();","        }","    },","","    /**","     * Event handler for valueDataChange event.","     *","     * @method _valueDataChangeHandler","     * @param {Object} event Event object.","     * @private","     */","    _valueDataChangeHandler: function(event)","    {","        if(this._rendered && this.get(\"categoryKey\") && this.get(\"valueKey\"))","        {","            this.draw();","        }","    },","","    /**","     * Draws the series. Overrides the base implementation.","     *","     * @method draw","     * @protected","     */","    draw: function()","    {","        var graph = this.get(\"graph\"),","            w = graph.get(\"width\"),","            h = graph.get(\"height\");","        if(isFinite(w) && isFinite(h) && w > 0 && h > 0)","        {","            this._rendered = true;","            if(this._drawing)","            {","                this._callLater = true;","                return;","            }","            this._drawing = true;","            this._callLater = false;","            this.drawSeries();","            this._drawing = false;","            if(this._callLater)","            {","                this.draw();","            }","            else","            {","                this.fire(\"drawingComplete\");","            }","        }","    },","","    /**","     * Draws the markers","     *","     * @method drawPlots","     * @protected","     */","    drawPlots: function()","    {","        var values = this.get(\"valueAxis\").getDataByKey(this.get(\"valueKey\")).concat(),","            catValues = this.get(\"categoryAxis\").getDataByKey(this.get(\"categoryKey\")).concat(),","            totalValue = 0,","            itemCount = values.length,","            styles = this.get(\"styles\").marker,","            fillColors = styles.fill.colors,","            fillAlphas = styles.fill.alphas || [\"1\"],","            borderColors = styles.border.colors,","            borderWeights = [styles.border.weight],","            borderAlphas = [styles.border.alpha],","            tbw = borderWeights.concat(),","            tbc = borderColors.concat(),","            tba = borderAlphas.concat(),","            tfc,","            tfa,","            padding = styles.padding,","            graph = this.get(\"graph\"),","            minDimension = Math.min(graph.get(\"width\"), graph.get(\"height\")),","            w = minDimension - (padding.left + padding.right),","            h = minDimension - (padding.top + padding.bottom),","            startAngle = -90,","            halfWidth = w / 2,","            halfHeight = h / 2,","            radius = Math.min(halfWidth, halfHeight),","            i = 0,","            value,","            angle = 0,","            lc,","            la,","            lw,","            wedgeStyle,","            marker,","            graphOrder = this.get(\"graphOrder\"),","            isCanvas = Y.Graphic.NAME == \"canvasGraphic\";","        for(; i < itemCount; ++i)","        {","            value = parseFloat(values[i]);","","            values.push(value);","            if(!isNaN(value))","            {","                totalValue += value;","            }","        }","","        tfc = fillColors ? fillColors.concat() : null;","        tfa = fillAlphas ? fillAlphas.concat() : null;","        this._createMarkerCache();","        if(isCanvas)","        {","            this._setMap();","            this._image.width = w;","            this._image.height = h;","        }","        for(i = 0; i < itemCount; i++)","        {","            value = values[i];","            if(totalValue === 0)","            {","                angle = 360 / values.length;","            }","            else","            {","                angle = 360 * (value / totalValue);","            }","            if(tfc && tfc.length < 1)","            {","                tfc = fillColors.concat();","            }","            if(tfa && tfa.length < 1)","            {","                tfa = fillAlphas.concat();","            }","            if(tbw && tbw.length < 1)","            {","                tbw = borderWeights.concat();","            }","            if(tbw && tbc.length < 1)","            {","                tbc = borderColors.concat();","            }","            if(tba && tba.length < 1)","            {","                tba = borderAlphas.concat();","            }","            lw = tbw ? tbw.shift() : null;","            lc = tbc ? tbc.shift() : null;","            la = tba ? tba.shift() : null;","            startAngle += angle;","            wedgeStyle = {","                border: {","                    color:lc,","                    weight:lw,","                    alpha:la","                },","                fill: {","                    color:tfc ? tfc.shift() : this._getDefaultColor(i, \"slice\"),","                    alpha:tfa ? tfa.shift() : null","                },","                type: \"pieslice\",","                arc: angle,","                radius: radius,","                startAngle: startAngle,","                cx: halfWidth,","                cy: halfHeight,","                width: w,","                height: h","            };","            marker = this.getMarker(wedgeStyle, graphOrder, i);","            if(isCanvas)","            {","                this._addHotspot(wedgeStyle, graphOrder, i);","            }","        }","        this._clearMarkerCache();","    },","","    /**","     *  Adds an interactive map when rendering in canvas.","     *","     *  @method _addHotspot","     *  @param {Object} cfg Object containing data used to draw the hotspot","     *  @param {Number} seriesIndex Index of series in the `seriesCollection`.","     *  @param {Number} index Index of the marker using the hotspot.","     *  @private","     */","    _addHotspot: function(cfg, seriesIndex, index)","    {","        var areaNode = DOCUMENT.createElement(\"area\"),","            i = 1,","            x = cfg.cx,","            y = cfg.cy,","            arc = cfg.arc,","            startAngle = cfg.startAngle - arc,","            endAngle = cfg.startAngle,","            radius = cfg.radius,","            ax = x + Math.cos(startAngle / 180 * Math.PI) * radius,","            ay = y + Math.sin(startAngle / 180 * Math.PI) * radius,","            bx = x + Math.cos(endAngle / 180 * Math.PI) * radius,","            by = y + Math.sin(endAngle / 180 * Math.PI) * radius,","            numPoints = Math.floor(arc/10) - 1,","            divAngle = (arc/(Math.floor(arc/10)) / 180) * Math.PI,","            angleCoord = Math.atan((ay - y)/(ax - x)),","            pts = x + \", \" + y + \", \" + ax + \", \" + ay,","            cosAng,","            sinAng,","            multDivAng;","        for(i = 1; i <= numPoints; ++i)","        {","            multDivAng = divAngle * i;","            cosAng = Math.cos(angleCoord + multDivAng);","            sinAng = Math.sin(angleCoord + multDivAng);","            if(startAngle <= 90)","            {","                pts += \", \" + (x + (radius * Math.cos(angleCoord + (divAngle * i))));","                pts += \", \" + (y + (radius * Math.sin(angleCoord + (divAngle * i))));","            }","            else","            {","                pts += \", \" + (x - (radius * Math.cos(angleCoord + (divAngle * i))));","                pts += \", \" + (y - (radius * Math.sin(angleCoord + (divAngle * i))));","            }","        }","        pts += \", \" + bx + \", \" + by;","        pts += \", \" + x + \", \" + y;","        this._map.appendChild(areaNode);","        areaNode.setAttribute(\"class\", SERIES_MARKER);","        areaNode.setAttribute(\"id\", \"hotSpot_\" + seriesIndex + \"_\" + index);","        areaNode.setAttribute(\"shape\", \"polygon\");","        areaNode.setAttribute(\"coords\", pts);","        this._areaNodes.push(areaNode);","","    },","","    /**","     * Resizes and positions markers based on a mouse interaction.","     *","     * @method updateMarkerState","     * @param {String} type state of the marker","     * @param {Number} i index of the marker","     * @protected","     */","    updateMarkerState: function(type, i)","    {","        if(this._markers[i])","        {","            var state = this._getState(type),","                markerStyles,","                indexStyles,","                marker = this._markers[i],","                styles = this.get(\"styles\").marker;","            markerStyles = state == \"off\" || !styles[state] ? styles : styles[state];","            indexStyles = this._mergeStyles(markerStyles, {});","            indexStyles.fill.color = indexStyles.fill.colors[i % indexStyles.fill.colors.length];","            indexStyles.fill.alpha = indexStyles.fill.alphas[i % indexStyles.fill.alphas.length];","            marker.set(indexStyles);","        }","    },","","    /**","     * Creates a shape to be used as a marker.","     *","     * @method _createMarker","     * @param {Object} styles Hash of style properties.","     * @param {Number} order Order of the series.","     * @param {Number} index Index within the series associated with the marker.","     * @return Shape","     * @private","     */","    _createMarker: function(styles, order, index)","    {","        var graphic = this.get(\"graphic\"),","            marker,","            cfg = Y.clone(styles);","        graphic.set(\"autoDraw\", false);","        marker = graphic.addShape(cfg);","        marker.addClass(SERIES_MARKER);","        return marker;","    },","","    /**","     * Creates a cache of markers for reuse.","     *","     * @method _createMarkerCache","     * @private","     */","    _clearMarkerCache: function()","    {","        var len = this._markerCache.length,","            i = 0,","            marker;","        for(; i < len; ++i)","        {","            marker = this._markerCache[i];","            if(marker)","            {","                marker.destroy();","            }","        }","        this._markerCache = [];","    },","","    /**","     * Gets the default style values for the markers.","     *","     * @method _getPlotDefaults","     * @return Object","     * @private","     */","    _getPlotDefaults: function()","    {","         var defs = {","            padding:{","                top: 0,","                left: 0,","                right: 0,","                bottom: 0","            },","            fill:{","                alphas:[\"1\"]","            },","            border: {","                weight: 0,","                alpha: 1","            }","        };","        defs.fill.colors = this._defaultSliceColors;","        defs.border.colors = this._defaultBorderColors;","        return defs;","    },","","    /**","     * Collection of default colors used for lines in a series when not specified by user.","     *","     * @property _defaultLineColors","     * @type Array","     * @protected","     */","    _defaultLineColors:[\"#426ab3\", \"#d09b2c\", \"#000000\", \"#b82837\", \"#b384b5\", \"#ff7200\", \"#779de3\", \"#cbc8ba\", \"#7ed7a6\", \"#007a6c\"],","","    /**","     * Collection of default colors used for marker fills in a series when not specified by user.","     *","     * @property _defaultFillColors","     * @type Array","     * @protected","     */","    _defaultFillColors:[\"#6084d0\", \"#eeb647\", \"#6c6b5f\", \"#d6484f\", \"#ce9ed1\", \"#ff9f3b\", \"#93b7ff\", \"#e0ddd0\", \"#94ecba\", \"#309687\"],","","    /**","     * Collection of default colors used for marker borders in a series when not specified by user.","     *","     * @property _defaultBorderColors","     * @type Array","     * @protected","     */","    _defaultBorderColors:[\"#205096\", \"#b38206\", \"#000000\", \"#94001e\", \"#9d6fa0\", \"#e55b00\", \"#5e85c9\", \"#adab9e\", \"#6ac291\", \"#006457\"],","","    /**","     * Collection of default colors used for area fills, histogram fills and pie fills in a series when not specified by user.","     *","     * @property _defaultSliceColors","     * @type Array","     * @protected","     */","    _defaultSliceColors: [\"#66007f\", \"#a86f41\", \"#295454\", \"#996ab2\", \"#e8cdb7\", \"#90bdbd\",\"#000000\",\"#c3b8ca\", \"#968373\", \"#678585\"],","","    /**","     * Colors used if style colors are not specified","     *","     * @method _getDefaultColor","     * @param {Number} index Index indicating the series order.","     * @param {String} type Indicates which type of object needs the color.","     * @return String","     * @protected","     */","    _getDefaultColor: function(index, type)","    {","        var colors = {","                line: this._defaultLineColors,","                fill: this._defaultFillColors,","                border: this._defaultBorderColors,","                slice: this._defaultSliceColors","            },","            col = colors[type],","            l = col.length;","        index = index || 0;","        if(index >= l)","        {","            index = index % l;","        }","        type = type || \"fill\";","        return colors[type][index];","    }","}, {","    ATTRS: {","        /**","         * Read-only attribute indicating the type of series.","         *","         * @attribute type","         * @type String","         * @default pie","         */","        type: {","            value: \"pie\"","        },","","        /**","         * Order of this instance of this `type`.","         *","         * @attribute order","         * @type Number","         */","        order: {},","","        /**","         * Reference to the `Graph` in which the series is drawn into.","         *","         * @attribute graph","         * @type Graph","         */","        graph: {},","","        /**","         * Reference to the `Axis` instance used for assigning","         * category values to the graph.","         *","         * @attribute categoryAxis","         * @type Axis","         */","        categoryAxis: {","            value: null,","","            validator: function(value)","            {","                return value !== this.get(\"categoryAxis\");","            }","        },","","        /**","         * Reference to the `Axis` instance used for assigning","         * series values to the graph.","         *","         * @attribute categoryAxis","         * @type Axis","         */","        valueAxis: {","            value: null,","","            validator: function(value)","            {","                return value !== this.get(\"valueAxis\");","            }","        },","","        /**","         * Indicates which array to from the hash of value arrays in","         * the category `Axis` instance.","         *","         * @attribute categoryKey","         * @type String","         */","        categoryKey: {","            value: null,","","            validator: function(value)","            {","                return value !== this.get(\"categoryKey\");","            }","        },","        /**","         * Indicates which array to from the hash of value arrays in","         * the value `Axis` instance.","         *","         * @attribute valueKey","         * @type String","         */","        valueKey: {","            value: null,","","            validator: function(value)","            {","                return value !== this.get(\"valueKey\");","            }","        },","","        /**","         * Name used for for displaying category data","         *","         * @attribute categoryDisplayName","         * @type String","         */","        categoryDisplayName: {","            setter: function(val)","            {","                this._categoryDisplayName = val;","                return val;","            },","","            getter: function()","            {","                return this._categoryDisplayName || this.get(\"categoryKey\");","            }","        },","","        /**","         * Name used for for displaying value data","         *","         * @attribute valueDisplayName","         * @type String","         */","        valueDisplayName: {","            setter: function(val)","            {","                this._valueDisplayName = val;","                return val;","            },","","            getter: function()","            {","                return this._valueDisplayName || this.get(\"valueKey\");","            }","        },","","        /**","         * @attribute slices","         * @type Array","         * @private","         */","        slices: null","","        /**","         * Style properties used for drawing markers. This attribute is inherited from `MarkerSeries`. Below are  the default","         * values:","         *  <dl>","         *      <dt>fill</dt><dd>A hash containing the following values:","         *          <dl>","         *              <dt>colors</dt><dd>An array of colors to be used for the marker fills. The color for each marker  is","         *              retrieved from the array below:<br/>","         *              `[\"#66007f\", \"#a86f41\", \"#295454\", \"#996ab2\", \"#e8cdb7\", \"#90bdbd\",\"#000000\",\"#c3b8ca\", \"#968373\", \"#678585\"]`","         *              </dd>","         *              <dt>alphas</dt><dd>An array of alpha references (Number from 0 to 1) indicating the opacity of each marker","         *              fill. The default value is [1].</dd>","         *          </dl>","         *      </dd>","         *      <dt>border</dt><dd>A hash containing the following values:","         *          <dl>","         *              <dt>color</dt><dd>An array of colors to be used for the marker borders. The color for each marker is","         *              retrieved from the array below:<br/>","         *              `[\"#205096\", \"#b38206\", \"#000000\", \"#94001e\", \"#9d6fa0\", \"#e55b00\", \"#5e85c9\", \"#adab9e\", \"#6ac291\", \"#006457\"]`","         *              <dt>alpha</dt><dd>Number from 0 to 1 indicating the opacity of the marker border. The default value is 1.</dd>","         *              <dt>weight</dt><dd>Number indicating the width of the border. The default value is 1.</dd>","         *          </dl>","         *      </dd>","         *      <dt>over</dt><dd>hash containing styles for markers when highlighted by a `mouseover` event. The default","         *      values for each style is null. When an over style is not set, the non-over value will be used. For example,","         *      the default value for `marker.over.fill.color` is equivalent to `marker.fill.color`.</dd>","         *  </dl>","         *","         * @attribute styles","         * @type Object","         */","    }","});","/**"," * Gridlines draws gridlines on a Graph."," *"," * @module charts"," * @submodule charts-base"," * @class Gridlines"," * @constructor"," * @extends Base"," * @uses Renderer"," */","Y.Gridlines = Y.Base.create(\"gridlines\", Y.Base, [Y.Renderer], {","    /**","     * Reference to the `Path` element used for drawing Gridlines.","     *","     * @property _path","     * @type Path","     * @private","     */","    _path: null,","","    /**","     * Removes the Gridlines.","     *","     * @method remove","     * @private","     */","    remove: function()","    {","        var path = this._path;","        if(path)","        {","            path.destroy();","        }","    },","","    /**","     * Draws the gridlines","     *","     * @method draw","     * @protected","     */","    draw: function()","    {","        if(this.get(\"axis\") && this.get(\"graph\"))","        {","            this._drawGridlines();","        }","    },","","    /**","     * Algorithm for drawing gridlines","     *","     * @method _drawGridlines","     * @private","     */","    _drawGridlines: function()","    {","        var path,","            axis = this.get(\"axis\"),","            axisPosition = axis.get(\"position\"),","            points,","            i = 0,","            l,","            direction = this.get(\"direction\"),","            graph = this.get(\"graph\"),","            w = graph.get(\"width\"),","            h = graph.get(\"height\"),","            line = this.get(\"styles\").line,","            color = line.color,","            weight = line.weight,","            alpha = line.alpha,","            lineFunction = direction == \"vertical\" ? this._verticalLine : this._horizontalLine;","        if(isFinite(w) && isFinite(h) && w > 0 && h > 0)","        {","            if(axisPosition != \"none\" && axis && axis.get(\"tickPoints\"))","            {","                points = axis.get(\"tickPoints\");","                l = points.length;","            }","            else","            {","                points = [];","                l = axis.get(\"styles\").majorUnit.count;","                for(; i < l; ++i)","                {","                    points[i] = {","                        x: w * (i/(l-1)),","                        y: h * (i/(l-1))","                    };","                }","                i = 0;","            }","            path = graph.get(\"gridlines\");","            path.set(\"width\", w);","            path.set(\"height\", h);","            path.set(\"stroke\", {","                weight: weight,","                color: color,","                opacity: alpha","            });","            for(; i < l; ++i)","            {","                lineFunction(path, points[i], w, h);","            }","            path.end();","        }","    },","","    /**","     * Algorithm for horizontal lines.","     *","     * @method _horizontalLine","     * @param {Path} path Reference to path element","     * @param {Object} pt Coordinates corresponding to a major unit of an axis.","     * @param {Number} w Width of the Graph","     * @param {Number} h Height of the Graph","     * @private","     */","    _horizontalLine: function(path, pt, w, h)","    {","        path.moveTo(0, pt.y);","        path.lineTo(w, pt.y);","    },","","    /**","     * Algorithm for vertical lines.","     *","     * @method _verticalLine","     * @param {Path} path Reference to path element","     * @param {Object} pt Coordinates corresponding to a major unit of an axis.","     * @param {Number} w Width of the Graph","     * @param {Number} h Height of the Graph","     * @private","     */","    _verticalLine: function(path, pt, w, h)","    {","        path.moveTo(pt.x, 0);","        path.lineTo(pt.x, h);","    },","","    /**","     * Gets the default value for the `styles` attribute. Overrides","     * base implementation.","     *","     * @method _getDefaultStyles","     * @return Object","     * @protected","     */","    _getDefaultStyles: function()","    {","        var defs = {","            line: {","                color:\"#f0efe9\",","                weight: 1,","                alpha: 1","            }","        };","        return defs;","    }","","},","{","    ATTRS: {","        /**","         * Indicates the direction of the gridline.","         *","         * @attribute direction","         * @type String","         */","        direction: {},","","        /**","         * Indicate the `Axis` in which to bind","         * the gridlines.","         *","         * @attribute axis","         * @type Axis","         */","        axis: {},","","        /**","         * Indicates the `Graph` in which the gridlines","         * are drawn.","         *","         * @attribute graph","         * @type Graph","         */","        graph: {}","    }","});","/**"," * Graph manages and contains series instances for a `CartesianChart`"," * instance."," *"," * @module charts"," * @submodule charts-base"," * @class Graph"," * @constructor"," * @extends Widget"," * @uses Renderer"," */","Y.Graph = Y.Base.create(\"graph\", Y.Widget, [Y.Renderer], {","    /**","     * @method bindUI","     * @private","     */","    bindUI: function()","    {","        var bb = this.get(\"boundingBox\");","        bb.setStyle(\"position\", \"absolute\");","        this.after(\"widthChange\", this._sizeChangeHandler);","        this.after(\"heightChange\", this._sizeChangeHandler);","        this.after(\"stylesChange\", this._updateStyles);","        this.after(\"groupMarkersChange\", this._drawSeries);","    },","","    /**","     * @method syncUI","     * @private","     */","    syncUI: function()","    {","        var background,","            cb,","            bg,","            sc = this.get(\"seriesCollection\"),","            series,","            i = 0,","            len = sc ? sc.length : 0,","            hgl = this.get(\"horizontalGridlines\"),","            vgl = this.get(\"verticalGridlines\");","        if(this.get(\"showBackground\"))","        {","            background = this.get(\"background\");","            cb = this.get(\"contentBox\");","            bg = this.get(\"styles\").background;","            bg.stroke = bg.border;","            bg.stroke.opacity = bg.stroke.alpha;","            bg.fill.opacity = bg.fill.alpha;","            bg.width = this.get(\"width\");","            bg.height = this.get(\"height\");","            bg.type = bg.shape;","            background.set(bg);","        }","        for(; i < len; ++i)","        {","            series = sc[i];","            if(series instanceof Y.CartesianSeries)","            {","                series.render();","            }","        }","        if(hgl && hgl instanceof Y.Gridlines)","        {","            hgl.draw();","        }","        if(vgl && vgl instanceof Y.Gridlines)","        {","            vgl.draw();","        }","    },","","    /**","     * Object of arrays containing series mapped to a series type.","     *","     * @property seriesTypes","     * @type Object","     * @private","     */","    seriesTypes: null,","","    /**","     * Returns a series instance based on an index.","     *","     * @method getSeriesByIndex","     * @param {Number} val index of the series","     * @return CartesianSeries","     */","    getSeriesByIndex: function(val)","    {","        var col = this.get(\"seriesCollection\"),","            series;","        if(col && col.length > val)","        {","            series = col[val];","        }","        return series;","    },","","    /**","     * Returns a series instance based on a key value.","     *","     * @method getSeriesByKey","     * @param {String} val key value of the series","     * @return CartesianSeries","     */","    getSeriesByKey: function(val)","    {","        var obj = this._seriesDictionary,","            series;","        if(obj && obj.hasOwnProperty(val))","        {","            series = obj[val];","        }","        return series;","    },","","    /**","     * Adds dispatcher to a `_dispatcher` used to","     * to ensure all series have redrawn before for firing event.","     *","     * @method addDispatcher","     * @param {CartesianSeries} val series instance to add","     * @protected","     */","    addDispatcher: function(val)","    {","        if(!this._dispatchers)","        {","            this._dispatchers = [];","        }","        this._dispatchers.push(val);","    },","","    /**","     * Collection of series to be displayed in the graph.","     *","     * @property _seriesCollection","     * @type Array","     * @private","     */","    _seriesCollection: null,","","    /**","     * Object containing key value pairs of `CartesianSeries` instances.","     *","     * @property _seriesDictionary","     * @type Object","     * @private","     */","    _seriesDictionary: null,","","    /**","     * Parses series instances to be displayed in the graph.","     *","     * @method _parseSeriesCollection","     * @param {Array} Collection of `CartesianSeries` instances or objects container `CartesianSeries` attributes values.","     * @private","     */","    _parseSeriesCollection: function(val)","    {","        if(!val)","        {","            return;","        }","        var len = val.length,","            i = 0,","            series,","            seriesKey;","        this._seriesCollection = [];","        this._seriesDictionary = {};","        this.seriesTypes = [];","        for(; i < len; ++i)","        {","            series = val[i];","            if(!(series instanceof Y.CartesianSeries) && !(series instanceof Y.PieSeries))","            {","                this._createSeries(series);","                continue;","            }","            this._addSeries(series);","        }","        len = this._seriesCollection.length;","        for(i = 0; i < len; ++i)","        {","            series = this.get(\"seriesCollection\")[i];","            seriesKey = series.get(\"direction\") == \"horizontal\" ? \"yKey\" : \"xKey\";","            this._seriesDictionary[series.get(seriesKey)] = series;","        }","    },","","    /**","     * Adds a series to the graph.","     *","     * @method _addSeries","     * @param {CartesianSeries} series Series to add to the graph.","     * @private","     */","    _addSeries: function(series)","    {","        var type = series.get(\"type\"),","            seriesCollection = this.get(\"seriesCollection\"),","            graphSeriesLength = seriesCollection.length,","            seriesTypes = this.seriesTypes,","            typeSeriesCollection;","        if(!series.get(\"graph\"))","        {","            series.set(\"graph\", this);","        }","        seriesCollection.push(series);","        if(!seriesTypes.hasOwnProperty(type))","        {","            this.seriesTypes[type] = [];","        }","        typeSeriesCollection = this.seriesTypes[type];","        series.set(\"graphOrder\", graphSeriesLength);","        series.set(\"order\", typeSeriesCollection.length);","        typeSeriesCollection.push(series);","        this.addDispatcher(series);","        series.after(\"drawingComplete\", Y.bind(this._drawingCompleteHandler, this));","        this.fire(\"seriesAdded\", series);","    },","","    /**","     * Creates a `CartesianSeries` instance from an object containing attribute key value pairs. The key value pairs include","     * attributes for the specific series and a type value which defines the type of series to be used.","     *","     * @method createSeries","     * @param {Object} seriesData Series attribute key value pairs.","     * @private","     */","    _createSeries: function(seriesData)","    {","        var type = seriesData.type,","            seriesCollection = this.get(\"seriesCollection\"),","            seriesTypes = this.seriesTypes,","            typeSeriesCollection,","            seriesType,","            series;","            seriesData.graph = this;","        if(!seriesTypes.hasOwnProperty(type))","        {","            seriesTypes[type] = [];","        }","        typeSeriesCollection = seriesTypes[type];","        seriesData.graph = this;","        seriesData.order = typeSeriesCollection.length;","        seriesData.graphOrder = seriesCollection.length;","        seriesType = this._getSeries(seriesData.type);","        series = new seriesType(seriesData);","        this.addDispatcher(series);","        series.after(\"drawingComplete\", Y.bind(this._drawingCompleteHandler, this));","        typeSeriesCollection.push(series);","        seriesCollection.push(series);","        if(this.get(\"rendered\"))","        {","            series.render();","        }","    },","","    /**","     * String reference for pre-defined `Series` classes.","     *","     * @property _seriesMap","     * @type Object","     * @private","     */","    _seriesMap: {","        line : Y.LineSeries,","        column : Y.ColumnSeries,","        bar : Y.BarSeries,","        area :  Y.AreaSeries,","        candlestick : Y.CandlestickSeries,","        ohlc : Y.OHLCSeries,","        stackedarea : Y.StackedAreaSeries,","        stackedline : Y.StackedLineSeries,","        stackedcolumn : Y.StackedColumnSeries,","        stackedbar : Y.StackedBarSeries,","        markerseries : Y.MarkerSeries,","        spline : Y.SplineSeries,","        areaspline : Y.AreaSplineSeries,","        stackedspline : Y.StackedSplineSeries,","        stackedareaspline : Y.StackedAreaSplineSeries,","        stackedmarkerseries : Y.StackedMarkerSeries,","        pie : Y.PieSeries,","        combo : Y.ComboSeries,","        stackedcombo : Y.StackedComboSeries,","        combospline : Y.ComboSplineSeries,","        stackedcombospline : Y.StackedComboSplineSeries","    },","","    /**","     * Returns a specific `CartesianSeries` class based on key value from a look up table of a direct reference to a","     * class. When specifying a key value, the following options are available:","     *","     *  <table>","     *      <tr><th>Key Value</th><th>Class</th></tr>","     *      <tr><td>line</td><td>Y.LineSeries</td></tr>","     *      <tr><td>column</td><td>Y.ColumnSeries</td></tr>","     *      <tr><td>bar</td><td>Y.BarSeries</td></tr>","     *      <tr><td>area</td><td>Y.AreaSeries</td></tr>","     *      <tr><td>stackedarea</td><td>Y.StackedAreaSeries</td></tr>","     *      <tr><td>stackedline</td><td>Y.StackedLineSeries</td></tr>","     *      <tr><td>stackedcolumn</td><td>Y.StackedColumnSeries</td></tr>","     *      <tr><td>stackedbar</td><td>Y.StackedBarSeries</td></tr>","     *      <tr><td>markerseries</td><td>Y.MarkerSeries</td></tr>","     *      <tr><td>spline</td><td>Y.SplineSeries</td></tr>","     *      <tr><td>areaspline</td><td>Y.AreaSplineSeries</td></tr>","     *      <tr><td>stackedspline</td><td>Y.StackedSplineSeries</td></tr>","     *      <tr><td>stackedareaspline</td><td>Y.StackedAreaSplineSeries</td></tr>","     *      <tr><td>stackedmarkerseries</td><td>Y.StackedMarkerSeries</td></tr>","     *      <tr><td>pie</td><td>Y.PieSeries</td></tr>","     *      <tr><td>combo</td><td>Y.ComboSeries</td></tr>","     *      <tr><td>stackedcombo</td><td>Y.StackedComboSeries</td></tr>","     *      <tr><td>combospline</td><td>Y.ComboSplineSeries</td></tr>","     *      <tr><td>stackedcombospline</td><td>Y.StackedComboSplineSeries</td></tr>","     *  </table>","     *","     * When referencing a class directly, you can specify any of the above classes or any custom class that extends","     * `CartesianSeries` or `PieSeries`.","     *","     * @method _getSeries","     * @param {String | Object} type Series type.","     * @return CartesianSeries","     * @private","     */","    _getSeries: function(type)","    {","        var seriesClass;","        if(Y_Lang.isString(type))","        {","            seriesClass = this._seriesMap[type];","        }","        else","        {","            seriesClass = type;","        }","        return seriesClass;","    },","","    /**","     * Event handler for marker events.","     *","     * @method _markerEventHandler","     * @param {Object} e Event object.","     * @private","     */","    _markerEventHandler: function(e)","    {","        var type = e.type,","            markerNode = e.currentTarget,","            strArr = markerNode.getAttribute(\"id\").split(\"_\"),","            series = this.getSeriesByIndex(strArr[1]),","            index = strArr[2];","        series.updateMarkerState(type, index);","    },","","    /**","     * Collection of `CartesianSeries` instances to be redrawn.","     *","     * @property _dispatchers","     * @type Array","     * @private","     */","    _dispatchers: null,","","    /**","     * Updates the `Graph` styles.","     *","     * @method _updateStyles","     * @private","     */","    _updateStyles: function()","    {","        var styles = this.get(\"styles\").background,","            border = styles.border;","            border.opacity = border.alpha;","            styles.stroke = border;","            styles.fill.opacity = styles.fill.alpha;","        this.get(\"background\").set(styles);","        this._sizeChangeHandler();","    },","","    /**","     * Event handler for size changes.","     *","     * @method _sizeChangeHandler","     * @param {Object} e Event object.","     * @private","     */","    _sizeChangeHandler: function(e)","    {","        var hgl = this.get(\"horizontalGridlines\"),","            vgl = this.get(\"verticalGridlines\"),","            w = this.get(\"width\"),","            h = this.get(\"height\"),","            bg = this.get(\"styles\").background,","            weight,","            background;","        if(bg && bg.border)","        {","            weight = bg.border.weight || 0;","        }","        if(this.get(\"showBackground\"))","        {","            background = this.get(\"background\");","            if(w && h)","            {","                background.set(\"width\", w);","                background.set(\"height\", h);","            }","        }","        if(this._gridlines)","        {","            this._gridlines.clear();","        }","        if(hgl && hgl instanceof Y.Gridlines)","        {","            hgl.draw();","        }","        if(vgl && vgl instanceof Y.Gridlines)","        {","            vgl.draw();","        }","        this._drawSeries();","    },","","    /**","     * Draws each series.","     *","     * @method _drawSeries","     * @private","     */","    _drawSeries: function()","    {","        if(this._drawing)","        {","            this._callLater = true;","            return;","        }","        var sc,","            i,","            len,","            graphic = this.get(\"graphic\");","        graphic.set(\"autoDraw\", false);","        this._callLater = false;","        this._drawing = true;","        sc = this.get(\"seriesCollection\");","        i = 0;","        len = sc ? sc.length : 0;","        for(; i < len; ++i)","        {","            sc[i].draw();","            if((!sc[i].get(\"xcoords\") || !sc[i].get(\"ycoords\")) && !sc[i] instanceof Y.PieSeries)","            {","                this._callLater = true;","                break;","            }","        }","        this._drawing = false;","        if(this._callLater)","        {","            this._drawSeries();","        }","    },","","    /**","     * Event handler for series drawingComplete event.","     *","     * @method _drawingCompleteHandler","     * @param {Object} e Event object.","     * @private","     */","    _drawingCompleteHandler: function(e)","    {","        var series = e.currentTarget,","            graphic,","            index = Y.Array.indexOf(this._dispatchers, series);","        if(index > -1)","        {","            this._dispatchers.splice(index, 1);","        }","        if(this._dispatchers.length < 1)","        {","            graphic = this.get(\"graphic\");","            if(!graphic.get(\"autoDraw\"))","            {","                graphic._redraw();","            }","            this.fire(\"chartRendered\");","        }","    },","","    /**","     * Gets the default value for the `styles` attribute. Overrides","     * base implementation.","     *","     * @method _getDefaultStyles","     * @return Object","     * @protected","     */","    _getDefaultStyles: function()","    {","        var defs = {","            background: {","                shape: \"rect\",","                fill:{","                    color:\"#faf9f2\"","                },","                border: {","                    color:\"#dad8c9\",","                    weight: 1","                }","            }","        };","        return defs;","    },","","    /**","     * Destructor implementation Graph class. Removes all Graphic instances from the widget.","     *","     * @method destructor","     * @protected","     */","    destructor: function()","    {","        if(this._graphic)","        {","            this._graphic.destroy();","            this._graphic = null;","        }","        if(this._background)","        {","            this._background.get(\"graphic\").destroy();","            this._background = null;","        }","        if(this._gridlines)","        {","            this._gridlines.get(\"graphic\").destroy();","            this._gridlines = null;","        }","    }","}, {","    ATTRS: {","        /**","         * The x-coordinate for the graph.","         *","         * @attribute x","         * @type Number","         * @protected","         */","        x: {","            setter: function(val)","            {","                this.get(\"boundingBox\").setStyle(\"left\", val + \"px\");","                return val;","            }","        },","","        /**","         * The y-coordinate for the graph.","         *","         * @attribute y","         * @type Number","         * @protected","         */","        y: {","            setter: function(val)","            {","                this.get(\"boundingBox\").setStyle(\"top\", val + \"px\");","                return val;","            }","        },","","        /**","         * Reference to the chart instance using the graph.","         *","         * @attribute chart","         * @type ChartBase","         * @readOnly","         */","        chart: {},","","        /**","         * Collection of series. When setting the `seriesCollection` the array can contain a combination of either","         * `CartesianSeries` instances or object literals with properties that will define a series.","         *","         * @attribute seriesCollection","         * @type CartesianSeries","         */","        seriesCollection: {","            getter: function()","            {","                return this._seriesCollection;","            },","","            setter: function(val)","            {","                this._parseSeriesCollection(val);","                return this._seriesCollection;","            }","        },","","        /**","         * Indicates whether the `Graph` has a background.","         *","         * @attribute showBackground","         * @type Boolean","         * @default true","         */","        showBackground: {","            value: true","        },","","        /**","         * Read-only hash lookup for all series on in the `Graph`.","         *","         * @attribute seriesDictionary","         * @type Object","         * @readOnly","         */","        seriesDictionary: {","            readOnly: true,","","            getter: function()","            {","                return this._seriesDictionary;","            }","        },","","        /**","         * Reference to the horizontal `Gridlines` instance.","         *","         * @attribute horizontalGridlines","         * @type Gridlines","         * @default null","         */","        horizontalGridlines: {","            value: null,","","            setter: function(val)","            {","                var gl = this.get(\"horizontalGridlines\");","                if(gl && gl instanceof Y.Gridlines)","                {","                    gl.remove();","                }","                if(val instanceof Y.Gridlines)","                {","                    gl = val;","                    val.set(\"graph\", this);","                    return val;","                }","                else if(val && val.axis)","                {","                    gl = new Y.Gridlines({direction:\"horizontal\", axis:val.axis, graph:this, styles:val.styles});","                    return gl;","                }","            }","        },","","        /**","         * Reference to the vertical `Gridlines` instance.","         *","         * @attribute verticalGridlines","         * @type Gridlines","         * @default null","         */","        verticalGridlines: {","            value: null,","","            setter: function(val)","            {","                var gl = this.get(\"verticalGridlines\");","                if(gl && gl instanceof Y.Gridlines)","                {","                    gl.remove();","                }","                if(val instanceof Y.Gridlines)","                {","                    gl = val;","                    val.set(\"graph\", this);","                    return val;","                }","                else if(val && val.axis)","                {","                    gl = new Y.Gridlines({direction:\"vertical\", axis:val.axis, graph:this, styles:val.styles});","                    return gl;","                }","            }","        },","","        /**","         * Reference to graphic instance used for the background.","         *","         * @attribute background","         * @type Graphic","         * @readOnly","         */","        background: {","            getter: function()","            {","                if(!this._background)","                {","                    this._backgroundGraphic = new Y.Graphic({render:this.get(\"contentBox\")});","                    this._backgroundGraphic.get(\"node\").style.zIndex = 0;","                    this._background = this._backgroundGraphic.addShape({type: \"rect\"});","                }","                return this._background;","            }","        },","","        /**","         * Reference to graphic instance used for gridlines.","         *","         * @attribute gridlines","         * @type Graphic","         * @readOnly","         */","        gridlines: {","            readOnly: true,","","            getter: function()","            {","                if(!this._gridlines)","                {","                    this._gridlinesGraphic = new Y.Graphic({render:this.get(\"contentBox\")});","                    this._gridlinesGraphic.get(\"node\").style.zIndex = 1;","                    this._gridlines = this._gridlinesGraphic.addShape({type: \"path\"});","                }","                return this._gridlines;","            }","        },","","        /**","         * Reference to graphic instance used for series.","         *","         * @attribute graphic","         * @type Graphic","         * @readOnly","         */","        graphic: {","            readOnly: true,","","            getter: function()","            {","                if(!this._graphic)","                {","                    this._graphic = new Y.Graphic({render:this.get(\"contentBox\")});","                    this._graphic.get(\"node\").style.zIndex = 2;","                    this._graphic.set(\"autoDraw\", false);","                }","                return this._graphic;","            }","        },","","        /**","         * Indicates whether or not markers for a series will be grouped and rendered in a single complex shape instance.","         *","         * @attribute groupMarkers","         * @type Boolean","         */","        groupMarkers: {","            value: false","        }","","        /**","         * Style properties used for drawing a background. Below are the default values:","         *  <dl>","         *      <dt>background</dt><dd>An object containing the following values:","         *          <dl>","         *              <dt>fill</dt><dd>Defines the style properties for the fill. Contains the following values:","         *                  <dl>","         *                      <dt>color</dt><dd>Color of the fill. The default value is #faf9f2.</dd>","         *                      <dt>alpha</dt><dd>Number from 0 to 1 indicating the opacity of the background fill.","         *                      The default value is 1.</dd>","         *                  </dl>","         *              </dd>","         *              <dt>border</dt><dd>Defines the style properties for the border. Contains the following values:","         *                  <dl>","         *                      <dt>color</dt><dd>Color of the border. The default value is #dad8c9.</dd>","         *                      <dt>alpha</dt><dd>Number from 0 to 1 indicating the opacity of the background border.","         *                      The default value is 1.</dd>","         *                      <dt>weight</dt><dd>Number indicating the width of the border. The default value is 1.</dd>","         *                  </dl>","         *              </dd>","         *          </dl>","         *      </dd>","         *  </dl>","         *","         * @attribute styles","         * @type Object","         */","    }","});","/**"," * The ChartBase class is an abstract class used to create charts."," *"," * @module charts"," * @submodule charts-base"," * @class ChartBase"," * @constructor"," */","function ChartBase() {}","","ChartBase.ATTRS = {","    /**","     * Data used to generate the chart.","     *","     * @attribute dataProvider","     * @type Array","     */","    dataProvider: {","        lazyAdd: false,","","        valueFn: function()","        {","            var defDataProvider = [];","            if(!this._seriesKeysExplicitlySet)","            {","                this._seriesKeys = this._buildSeriesKeys(defDataProvider);","            }","            return defDataProvider;","        },","","        setter: function(val)","        {","            var dataProvider = this._setDataValues(val);","            if(!this._seriesKeysExplicitlySet)","            {","                this._seriesKeys = this._buildSeriesKeys(dataProvider);","            }","            return dataProvider;","        }","    },","","    /**","     * A collection of keys that map to the series axes. If no keys are set,","     * they will be generated automatically depending on the data structure passed into","     * the chart.","     *","     * @attribute seriesKeys","     * @type Array","     */","    seriesKeys: {","        getter: function()","        {","            return this._seriesKeys;","        },","","        setter: function(val)","        {","            this._seriesKeysExplicitlySet = true;","            this._seriesKeys = val;","            return val;","        }","    },","","    /**","     * Sets the `aria-label` for the chart.","     *","     * @attribute ariaLabel","     * @type String","     */","    ariaLabel: {","        value: \"Chart Application\",","","        setter: function(val)","        {","            var cb = this.get(\"contentBox\");","            if(cb)","            {","                cb.setAttribute(\"aria-label\", val);","            }","            return val;","        }","    },","","    /**","     * Sets the aria description for the chart.","     *","     * @attribute ariaDescription","     * @type String","     */","    ariaDescription: {","        value: \"Use the up and down keys to navigate between series. Use the left and right keys to navigate through items in a series.\",","","        setter: function(val)","        {","            if(this._description)","            {","                this._description.setContent(\"\");","                this._description.appendChild(DOCUMENT.createTextNode(val));","            }","            return val;","        }","    },","","    /**","     * Reference to the default tooltip available for the chart.","     * <p>Contains the following properties:</p>","     *  <dl>","     *      <dt>node</dt><dd>Reference to the actual dom node</dd>","     *      <dt>showEvent</dt><dd>Event that should trigger the tooltip</dd>","     *      <dt>hideEvent</dt><dd>Event that should trigger the removal of a tooltip (can be an event or an array of events)</dd>","     *      <dt>styles</dt><dd>A hash of style properties that will be applied to the tooltip node</dd>","     *      <dt>show</dt><dd>Indicates whether or not to show the tooltip</dd>","     *      <dt>markerEventHandler</dt><dd>Displays and hides tooltip based on marker events</dd>","     *      <dt>planarEventHandler</dt><dd>Displays and hides tooltip based on planar events</dd>","     *      <dt>markerLabelFunction</dt><dd>Reference to the function used to format a marker event triggered tooltip's text.","     *      The method contains the following arguments:","     *  <dl>","     *      <dt>categoryItem</dt><dd>An object containing the following:","     *  <dl>","     *      <dt>axis</dt><dd>The axis to which the category is bound.</dd>","     *      <dt>displayName</dt><dd>The display name set to the category (defaults to key if not provided).</dd>","     *      <dt>key</dt><dd>The key of the category.</dd>","     *      <dt>value</dt><dd>The value of the category.</dd>","     *  </dl>","     *  </dd>","     *  <dt>valueItem</dt><dd>An object containing the following:","     *      <dl>","     *          <dt>axis</dt><dd>The axis to which the item's series is bound.</dd>","     *          <dt>displayName</dt><dd>The display name of the series. (defaults to key if not provided)</dd>","     *          <dt>key</dt><dd>The key for the series.</dd>","     *          <dt>value</dt><dd>The value for the series item.</dd>","     *      </dl>","     *  </dd>","     *  <dt>itemIndex</dt><dd>The index of the item within the series.</dd>","     *  <dt>series</dt><dd> The `CartesianSeries` instance of the item.</dd>","     *  <dt>seriesIndex</dt><dd>The index of the series in the `seriesCollection`.</dd>","     *  </dl>","     *  The method returns an `HTMLElement` which is written into the DOM using `appendChild`. If you override this method and choose","     *  to return an html string, you will also need to override the tooltip's `setTextFunction` method to accept an html string.","     *  </dd>","     *  <dt>planarLabelFunction</dt><dd>Reference to the function used to format a planar event triggered tooltip's text","     *  <dl>","     *      <dt>categoryAxis</dt><dd> `CategoryAxis` Reference to the categoryAxis of the chart.","     *      <dt>valueItems</dt><dd>Array of objects for each series that has a data point in the coordinate plane of the event. Each","     *      object contains the following data:","     *  <dl>","     *      <dt>axis</dt><dd>The value axis of the series.</dd>","     *      <dt>key</dt><dd>The key for the series.</dd>","     *      <dt>value</dt><dd>The value for the series item.</dd>","     *      <dt>displayName</dt><dd>The display name of the series. (defaults to key if not provided)</dd>","     *  </dl>","     *  </dd>","     *      <dt>index</dt><dd>The index of the item within its series.</dd>","     *      <dt>seriesArray</dt><dd>Array of series instances for each value item.</dd>","     *      <dt>seriesIndex</dt><dd>The index of the series in the `seriesCollection`.</dd>","     *  </dl>","     *  </dd>","     *  </dl>","     *  The method returns an `HTMLElement` which is written into the DOM using `appendChild`. If you override this method and choose","     *  to return an html string, you will also need to override the tooltip's `setTextFunction` method to accept an html string.","     *  </dd>","     *  <dt>setTextFunction</dt><dd>Method that writes content returned from `planarLabelFunction` or `markerLabelFunction` into the","     *  the tooltip node. Has the following signature:","     *  <dl>","     *      <dt>label</dt><dd>The `HTMLElement` that the content is to be added.</dd>","     *      <dt>val</dt><dd>The content to be rendered into tooltip. This can be a `String` or `HTMLElement`. If an HTML string is used,","     *      it will be rendered as a string.</dd>","     *  </dl>","     *  </dd>","     *  </dl>","     * @attribute tooltip","     * @type Object","     */","    tooltip: {","        valueFn: \"_getTooltip\",","","        setter: function(val)","        {","            return this._updateTooltip(val);","        }","    },","","    /**","     * The key value used for the chart's category axis.","     *","     * @attribute categoryKey","     * @type String","     * @default category","     */","    categoryKey: {","        value: \"category\"","    },","","    /**","     * Indicates the type of axis to use for the category axis.","     *","     *  <dl>","     *      <dt>category</dt><dd>Specifies a `CategoryAxis`.</dd>","     *      <dt>time</dt><dd>Specifies a `TimeAxis</dd>","     *  </dl>","     *","     * @attribute categoryType","     * @type String","     * @default category","     */","    categoryType:{","        value:\"category\"","    },","","    /**","     * Indicates the the type of interactions that will fire events.","     *","     *  <dl>","     *      <dt>marker</dt><dd>Events will be broadcasted when the mouse interacts with individual markers.</dd>","     *      <dt>planar</dt><dd>Events will be broadcasted when the mouse intersects the plane of any markers on the chart.</dd>","     *      <dt>none</dt><dd>No events will be broadcasted.</dd>","     *  </dl>","     *","     * @attribute interactionType","     * @type String","     * @default marker","     */","    interactionType: {","        value: \"marker\"","    },","","    /**","     * Reference to all the axes in the chart.","     *","     * @attribute axesCollection","     * @type Array","     */","    axesCollection: {},","","    /**","     * Reference to graph instance.","     *","     * @attribute graph","     * @type Graph","     */","    graph: {","        valueFn: \"_getGraph\"","    },","","    /**","     * Indicates whether or not markers for a series will be grouped and rendered in a single complex shape instance.","     *","     * @attribute groupMarkers","     * @type Boolean","     */","    groupMarkers: {","        value: false","    }","};","","ChartBase.prototype = {","    /**","     * Handles groupMarkers change event.","     *","     * @method _groupMarkersChangeHandler","     * @param {Object} e Event object.","     * @private","     */","    _groupMarkersChangeHandler: function(e)","    {","        var graph = this.get(\"graph\"),","            useGroupMarkers = e.newVal;","        if(graph)","        {","            graph.set(\"groupMarkers\", useGroupMarkers);","        }","    },","","    /**","     * Handler for itemRendered event.","     *","     * @method _itemRendered","     * @param {Object} e Event object.","     * @private","     */","    _itemRendered: function(e)","    {","        this._itemRenderQueue = this._itemRenderQueue.splice(1 + Y.Array.indexOf(this._itemRenderQueue, e.currentTarget), 1);","        if(this._itemRenderQueue.length < 1)","        {","            this._redraw();","        }","    },","","    /**","     * Default value function for the `Graph` attribute.","     *","     * @method _getGraph","     * @return Graph","     * @private","     */","    _getGraph: function()","    {","        var graph = new Y.Graph({","            chart:this,","            groupMarkers: this.get(\"groupMarkers\")","        });","        graph.after(\"chartRendered\", Y.bind(function(e) {","            this.fire(\"chartRendered\");","        }, this));","        return graph;","    },","","    /**","     * Returns a series instance by index or key value.","     *","     * @method getSeries","     * @param val","     * @return CartesianSeries","     */","    getSeries: function(val)","    {","        var series = null,","            graph = this.get(\"graph\");","        if(graph)","        {","            if(Y_Lang.isNumber(val))","            {","                series = graph.getSeriesByIndex(val);","            }","            else","            {","                series = graph.getSeriesByKey(val);","            }","        }","        return series;","    },","","    /**","     * Returns an `Axis` instance by key reference. If the axis was explicitly set through the `axes` attribute,","     * the key will be the same as the key used in the `axes` object. For default axes, the key for","     * the category axis is the value of the `categoryKey` (`category`). For the value axis, the default","     * key is `values`.","     *","     * @method getAxisByKey","     * @param {String} val Key reference used to look up the axis.","     * @return Axis","     */","    getAxisByKey: function(val)","    {","        var axis,","            axes = this.get(\"axes\");","        if(axes && axes.hasOwnProperty(val))","        {","            axis = axes[val];","        }","        return axis;","    },","","    /**","     * Returns the category axis for the chart.","     *","     * @method getCategoryAxis","     * @return Axis","     */","    getCategoryAxis: function()","    {","        var axis,","            key = this.get(\"categoryKey\"),","            axes = this.get(\"axes\");","        if(axes.hasOwnProperty(key))","        {","            axis = axes[key];","        }","        return axis;","    },","","    /**","     * Default direction of the chart.","     *","     * @property _direction","     * @type String","     * @default horizontal","     * @private","     */","    _direction: \"horizontal\",","","    /**","     * Storage for the `dataProvider` attribute.","     *","     * @property _dataProvider","     * @type Array","     * @private","     */","    _dataProvider: null,","","    /**","     * Setter method for `dataProvider` attribute.","     *","     * @method _setDataValues","     * @param {Array} val Array to be set as `dataProvider`.","     * @return Array","     * @private","     */","    _setDataValues: function(val)","    {","        if(Y_Lang.isArray(val[0]))","        {","            var hash,","                dp = [],","                cats = val[0],","                i = 0,","                l = cats.length,","                n,","                sl = val.length;","            for(; i < l; ++i)","            {","                hash = {category:cats[i]};","                for(n = 1; n < sl; ++n)","                {","                    hash[\"series\" + n] = val[n][i];","                }","                dp[i] = hash;","            }","            return dp;","        }","        return val;","    },","","    /**","     * Storage for `seriesCollection` attribute.","     *","     * @property _seriesCollection","     * @type Array","     * @private","     */","    _seriesCollection: null,","","    /**","     * Setter method for `seriesCollection` attribute.","     *","     * @property _setSeriesCollection","     * @param {Array} val Array of either `CartesianSeries` instances or objects containing series attribute key value pairs.","     * @private","     */","    _setSeriesCollection: function(val)","    {","        this._seriesCollection = val;","    },","    /**","     * Helper method that returns the axis class that a key references.","     *","     * @method _getAxisClass","     * @param {String} t The type of axis.","     * @return Axis","     * @private","     */","    _getAxisClass: function(t)","    {","        return this._axisClass[t];","    },","","    /**","     * Key value pairs of axis types.","     *","     * @property _axisClass","     * @type Object","     * @private","     */","    _axisClass: {","        stacked: Y.StackedAxis,","        numeric: Y.NumericAxis,","        category: Y.CategoryAxis,","        time: Y.TimeAxis","    },","","    /**","     * Collection of axes.","     *","     * @property _axes","     * @type Array","     * @private","     */","    _axes: null,","","    /**","     * @method initializer","     * @private","     */","    initializer: function()","    {","        this._itemRenderQueue = [];","        this._seriesIndex = -1;","        this._itemIndex = -1;","        this.after(\"dataProviderChange\", this._dataProviderChangeHandler);","    },","","    /**","     * @method renderUI","     * @private","     */","    renderUI: function()","    {","        var tt = this.get(\"tooltip\"),","            bb = this.get(\"boundingBox\"),","            cb = this.get(\"contentBox\");","        //move the position = absolute logic to a class file","        bb.setStyle(\"position\", \"absolute\");","        cb.setStyle(\"position\", \"absolute\");","        this._addAxes();","        this._addSeries();","        if(tt && tt.show)","        {","            this._addTooltip();","        }","        this._setAriaElements(bb, cb);","    },","","    /**","     * Creates an aria `live-region`, `aria-label` and `aria-describedby` for the Chart.","     *","     * @method _setAriaElements","     * @param {Node} cb Reference to the Chart's `contentBox` attribute.","     * @private","     */","    _setAriaElements: function(bb, cb)","    {","        var description = this._getAriaOffscreenNode(),","            id = this.get(\"id\") + \"_description\",","            liveRegion = this._getAriaOffscreenNode();","        cb.set(\"tabIndex\", 0);","        cb.set(\"role\", \"img\");","        cb.setAttribute(\"aria-label\", this.get(\"ariaLabel\"));","        cb.setAttribute(\"aria-describedby\", id);","        description.set(\"id\", id);","        description.set(\"tabIndex\", -1);","        description.appendChild(DOCUMENT.createTextNode(this.get(\"ariaDescription\")));","        liveRegion.set(\"id\", \"live-region\");","        liveRegion.set(\"aria-live\", \"polite\");","        liveRegion.set(\"aria-atomic\", \"true\");","        liveRegion.set(\"role\", \"status\");","        bb.setAttribute(\"role\", \"application\");","        bb.appendChild(description);","        bb.appendChild(liveRegion);","        this._description = description;","        this._liveRegion = liveRegion;","    },","","    /**","     * Sets a node offscreen for use as aria-description or aria-live-regin.","     *","     * @method _setOffscreen","     * @return Node","     * @private","     */","    _getAriaOffscreenNode: function()","    {","        var node = Y.Node.create(\"<div></div>\"),","            ie = Y.UA.ie,","            clipRect = (ie && ie < 8) ? \"rect(1px 1px 1px 1px)\" : \"rect(1px, 1px, 1px, 1px)\";","        node.setStyle(\"position\", \"absolute\");","        node.setStyle(\"height\", \"1px\");","        node.setStyle(\"width\", \"1px\");","        node.setStyle(\"overflow\", \"hidden\");","        node.setStyle(\"clip\", clipRect);","        return node;","    },","","    /**","     * @method syncUI","     * @private","     */","    syncUI: function()","    {","        this._redraw();","    },","","    /**","     * @method bindUI","     * @private","     */","    bindUI: function()","    {","        this.after(\"tooltipChange\", Y.bind(this._tooltipChangeHandler, this));","        this.after(\"widthChange\", this._sizeChanged);","        this.after(\"heightChange\", this._sizeChanged);","        this.after(\"groupMarkersChange\", this._groupMarkersChangeHandler);","        var tt = this.get(\"tooltip\"),","            hideEvent = \"mouseout\",","            showEvent = \"mouseover\",","            cb = this.get(\"contentBox\"),","            interactionType = this.get(\"interactionType\"),","            i = 0,","            len,","            markerClassName = \".\" + SERIES_MARKER,","            isTouch = ((WINDOW && (\"ontouchstart\" in WINDOW)) && !(Y.UA.chrome && Y.UA.chrome < 6));","        Y.on(\"keydown\", Y.bind(function(e) {","            var key = e.keyCode,","                numKey = parseFloat(key),","                msg;","            if(numKey > 36 && numKey < 41)","            {","                e.halt();","                msg = this._getAriaMessage(numKey);","                this._liveRegion.setContent(\"\");","                this._liveRegion.appendChild(DOCUMENT.createTextNode(msg));","            }","        }, this), this.get(\"contentBox\"));","        if(interactionType == \"marker\")","        {","            //if touch capabilities, toggle tooltip on touchend. otherwise, the tooltip attribute's hideEvent/showEvent types.","            hideEvent = tt.hideEvent;","            showEvent = tt.showEvent;","            if(isTouch)","            {","                Y.delegate(\"touchend\", Y.bind(this._markerEventDispatcher, this), cb, markerClassName);","                //hide active tooltip if the chart is touched","                Y.on(\"touchend\", Y.bind(function(e) {","                    e.halt(true);","                    if(this._activeMarker)","                    {","                        this._activeMarker = null;","                        this.hideTooltip(e);","                    }","                }, this));","            }","            else","            {","                Y.delegate(\"mouseenter\", Y.bind(this._markerEventDispatcher, this), cb, markerClassName);","                Y.delegate(\"mousedown\", Y.bind(this._markerEventDispatcher, this), cb, markerClassName);","                Y.delegate(\"mouseup\", Y.bind(this._markerEventDispatcher, this), cb, markerClassName);","                Y.delegate(\"mouseleave\", Y.bind(this._markerEventDispatcher, this), cb, markerClassName);","                Y.delegate(\"click\", Y.bind(this._markerEventDispatcher, this), cb, markerClassName);","                Y.delegate(\"mousemove\", Y.bind(this._positionTooltip, this), cb, markerClassName);","            }","        }","        else if(interactionType == \"planar\")","        {","            if(isTouch)","            {","                this._overlay.on(\"touchend\", Y.bind(this._planarEventDispatcher, this));","            }","            else","            {","                this._overlay.on(\"mousemove\", Y.bind(this._planarEventDispatcher, this));","                this.on(\"mouseout\", this.hideTooltip);","            }","        }","        if(tt)","        {","            this.on(\"markerEvent:touchend\", Y.bind(function(e) {","                var marker = e.series.get(\"markers\")[e.index];","                if(this._activeMarker && marker === this._activeMarker)","                {","                    this._activeMarker = null;","                    this.hideTooltip(e);","                }","                else","                {","","                    this._activeMarker = marker;","                    tt.markerEventHandler.apply(this, [e]);","                }","            }, this));","            if(hideEvent && showEvent && hideEvent == showEvent)","            {","                this.on(interactionType + \"Event:\" + hideEvent, this.toggleTooltip);","            }","            else","            {","                if(showEvent)","                {","                    this.on(interactionType + \"Event:\" + showEvent, tt[interactionType + \"EventHandler\"]);","                }","                if(hideEvent)","                {","                    if(Y_Lang.isArray(hideEvent))","                    {","                        len = hideEvent.length;","                        for(; i < len; ++i)","                        {","                            this.on(interactionType + \"Event:\" + hideEvent[i], this.hideTooltip);","                        }","                    }","                    this.on(interactionType + \"Event:\" + hideEvent, this.hideTooltip);","                }","            }","        }","    },","","    /**","     * Event handler for marker events.","     *","     * @method _markerEventDispatcher","     * @param {Object} e Event object.","     * @private","     */","    _markerEventDispatcher: function(e)","    {","        var type = e.type,","            cb = this.get(\"contentBox\"),","            markerNode = e.currentTarget,","            strArr = markerNode.getAttribute(\"id\").split(\"_\"),","            index = strArr.pop(),","            seriesIndex = strArr.pop(),","            series = this.getSeries(parseInt(seriesIndex, 10)),","            items = this.getSeriesItems(series, index),","            isTouch = e && e.hasOwnProperty(\"changedTouches\"),","            pageX = isTouch ? e.changedTouches[0].pageX : e.pageX,","            pageY = isTouch ? e.changedTouches[0].pageY : e.pageY,","            x = pageX - cb.getX(),","            y = pageY - cb.getY();","        if(type == \"mouseenter\")","        {","            type = \"mouseover\";","        }","        else if(type == \"mouseleave\")","        {","            type = \"mouseout\";","        }","        series.updateMarkerState(type, index);","        e.halt();","        /**","         * Broadcasts when `interactionType` is set to `marker` and a series marker has received a mouseover event.","         *","         *","         * @event markerEvent:mouseover","         * @preventable false","         * @param {EventFacade} e Event facade with the following additional","         *   properties:","         *  <dl>","         *      <dt>categoryItem</dt><dd>Hash containing information about the category `Axis`.</dd>","         *      <dt>valueItem</dt><dd>Hash containing information about the value `Axis`.</dd>","         *      <dt>node</dt><dd>The dom node of the marker.</dd>","         *      <dt>x</dt><dd>The x-coordinate of the mouse in relation to the Chart.</dd>","         *      <dt>y</dt><dd>The y-coordinate of the mouse in relation to the Chart.</dd>","         *      <dt>series</dt><dd>Reference to the series of the marker.</dd>","         *      <dt>index</dt><dd>Index of the marker in the series.</dd>","         *      <dt>seriesIndex</dt><dd>The `order` of the marker's series.</dd>","         *  </dl>","         */","        /**","         * Broadcasts when `interactionType` is set to `marker` and a series marker has received a mouseout event.","         *","         * @event markerEvent:mouseout","         * @preventable false","         * @param {EventFacade} e Event facade with the following additional","         *   properties:","         *  <dl>","         *      <dt>categoryItem</dt><dd>Hash containing information about the category `Axis`.</dd>","         *      <dt>valueItem</dt><dd>Hash containing information about the value `Axis`.</dd>","         *      <dt>node</dt><dd>The dom node of the marker.</dd>","         *      <dt>x</dt><dd>The x-coordinate of the mouse in relation to the Chart.</dd>","         *      <dt>y</dt><dd>The y-coordinate of the mouse in relation to the Chart.</dd>","         *      <dt>series</dt><dd>Reference to the series of the marker.</dd>","         *      <dt>index</dt><dd>Index of the marker in the series.</dd>","         *      <dt>seriesIndex</dt><dd>The `order` of the marker's series.</dd>","         *  </dl>","         */","        /**","         * Broadcasts when `interactionType` is set to `marker` and a series marker has received a mousedown event.","         *","         * @event markerEvent:mousedown","         * @preventable false","         * @param {EventFacade} e Event facade with the following additional","         *   properties:","         *  <dl>","         *      <dt>categoryItem</dt><dd>Hash containing information about the category `Axis`.</dd>","         *      <dt>valueItem</dt><dd>Hash containing information about the value `Axis`.</dd>","         *      <dt>node</dt><dd>The dom node of the marker.</dd>","         *      <dt>x</dt><dd>The x-coordinate of the mouse in relation to the Chart.</dd>","         *      <dt>y</dt><dd>The y-coordinate of the mouse in relation to the Chart.</dd>","         *      <dt>series</dt><dd>Reference to the series of the marker.</dd>","         *      <dt>index</dt><dd>Index of the marker in the series.</dd>","         *      <dt>seriesIndex</dt><dd>The `order` of the marker's series.</dd>","         *  </dl>","         */","        /**","         * Broadcasts when `interactionType` is set to `marker` and a series marker has received a mouseup event.","         *","         * @event markerEvent:mouseup","         * @preventable false","         * @param {EventFacade} e Event facade with the following additional","         *   properties:","         *  <dl>","         *      <dt>categoryItem</dt><dd>Hash containing information about the category `Axis`.</dd>","         *      <dt>valueItem</dt><dd>Hash containing information about the value `Axis`.</dd>","         *      <dt>node</dt><dd>The dom node of the marker.</dd>","         *      <dt>x</dt><dd>The x-coordinate of the mouse in relation to the Chart.</dd>","         *      <dt>y</dt><dd>The y-coordinate of the mouse in relation to the Chart.</dd>","         *      <dt>series</dt><dd>Reference to the series of the marker.</dd>","         *      <dt>index</dt><dd>Index of the marker in the series.</dd>","         *      <dt>seriesIndex</dt><dd>The `order` of the marker's series.</dd>","         *  </dl>","         */","        /**","         * Broadcasts when `interactionType` is set to `marker` and a series marker has received a click event.","         *","         * @event markerEvent:click","         * @preventable false","         * @param {EventFacade} e Event facade with the following additional","         *   properties:","         *  <dl>","         *      <dt>categoryItem</dt><dd>Hash containing information about the category `Axis`.</dd>","         *      <dt>valueItem</dt><dd>Hash containing information about the value `Axis`.</dd>","         *      <dt>node</dt><dd>The dom node of the marker.</dd>","         *      <dt>x</dt><dd>The x-coordinate of the mouse in relation to the Chart.</dd>","         *      <dt>y</dt><dd>The y-coordinate of the mouse in relation to the Chart.</dd>","         *      <dt>pageX</dt><dd>The x location of the event on the page (including scroll)</dd>","         *      <dt>pageY</dt><dd>The y location of the event on the page (including scroll)</dd>","         *      <dt>series</dt><dd>Reference to the series of the marker.</dd>","         *      <dt>index</dt><dd>Index of the marker in the series.</dd>","         *      <dt>seriesIndex</dt><dd>The `order` of the marker's series.</dd>","         *      <dt>originEvent</dt><dd>Underlying dom event.</dd>","         *  </dl>","         */","        this.fire(\"markerEvent:\" + type, {","            originEvent: e,","            pageX:pageX,","            pageY:pageY,","            categoryItem:items.category,","            valueItem:items.value,","            node:markerNode,","            x:x,","            y:y,","            series:series,","            index:index,","            seriesIndex:seriesIndex","        });","    },","","    /**","     * Event handler for dataProviderChange.","     *","     * @method _dataProviderChangeHandler","     * @param {Object} e Event object.","     * @private","     */","    _dataProviderChangeHandler: function(e)","    {","        var dataProvider = e.newVal,","            axes,","            i,","            axis;","        this._seriesIndex = -1;","        this._itemIndex = -1;","        if(this instanceof Y.CartesianChart)","        {","            this.set(\"axes\", this.get(\"axes\"));","            this.set(\"seriesCollection\", this.get(\"seriesCollection\"));","        }","        axes = this.get(\"axes\");","        if(axes)","        {","            for(i in axes)","            {","                if(axes.hasOwnProperty(i))","                {","                    axis = axes[i];","                    if(axis instanceof Y.Axis)","                    {","                        if(axis.get(\"position\") != \"none\")","                        {","                            this._addToAxesRenderQueue(axis);","                        }","                        axis.set(\"dataProvider\", dataProvider);","                    }","                }","            }","        }","    },","","    /**","     * Event listener for toggling the tooltip. If a tooltip is visible, hide it. If not, it","     * will create and show a tooltip based on the event object.","     *","     * @method toggleTooltip","     * @param {Object} e Event object.","     */","    toggleTooltip: function(e)","    {","        var tt = this.get(\"tooltip\");","        if(tt.visible)","        {","            this.hideTooltip();","        }","        else","        {","            tt.markerEventHandler.apply(this, [e]);","        }","    },","","    /**","     * Shows a tooltip","     *","     * @method _showTooltip","     * @param {String} msg Message to dispaly in the tooltip.","     * @param {Number} x x-coordinate","     * @param {Number} y y-coordinate","     * @private","     */","    _showTooltip: function(msg, x, y)","    {","        var tt = this.get(\"tooltip\"),","            node = tt.node;","        if(msg)","        {","            tt.visible = true;","            tt.setTextFunction(node, msg);","            node.setStyle(\"top\", y + \"px\");","            node.setStyle(\"left\", x + \"px\");","            node.setStyle(\"visibility\", \"visible\");","        }","    },","","    /**","     * Positions the tooltip","     *","     * @method _positionTooltip","     * @param {Object} e Event object.","     * @private","     */","    _positionTooltip: function(e)","    {","        var tt = this.get(\"tooltip\"),","            node = tt.node,","            cb = this.get(\"contentBox\"),","            x = (e.pageX + 10) - cb.getX(),","            y = (e.pageY + 10) - cb.getY();","        if(node)","        {","            node.setStyle(\"left\", x + \"px\");","            node.setStyle(\"top\", y + \"px\");","        }","    },","","    /**","     * Hides the default tooltip","     *","     * @method hideTooltip","     */","    hideTooltip: function()","    {","        var tt = this.get(\"tooltip\"),","            node = tt.node;","        tt.visible = false;","        node.set(\"innerHTML\", \"\");","        node.setStyle(\"left\", -10000);","        node.setStyle(\"top\", -10000);","        node.setStyle(\"visibility\", \"hidden\");","    },","","    /**","     * Adds a tooltip to the dom.","     *","     * @method _addTooltip","     * @private","     */","    _addTooltip: function()","    {","        var tt = this.get(\"tooltip\"),","            id = this.get(\"id\") + \"_tooltip\",","            cb = this.get(\"contentBox\"),","            oldNode = DOCUMENT.getElementById(id);","        if(oldNode)","        {","            cb.removeChild(oldNode);","        }","        tt.node.set(\"id\", id);","        tt.node.setStyle(\"visibility\", \"hidden\");","        cb.appendChild(tt.node);","    },","","    /**","     * Updates the tooltip attribute.","     *","     * @method _updateTooltip","     * @param {Object} val Object containing properties for the tooltip.","     * @return Object","     * @private","     */","    _updateTooltip: function(val)","    {","        var tt = this.get(\"tooltip\") || this._getTooltip(),","            i,","            styles,","            node,","            props = {","                markerLabelFunction:\"markerLabelFunction\",","                planarLabelFunction:\"planarLabelFunction\",","                setTextFunction:\"setTextFunction\",","                showEvent:\"showEvent\",","                hideEvent:\"hideEvent\",","                markerEventHandler:\"markerEventHandler\",","                planarEventHandler:\"planarEventHandler\",","                show:\"show\"","            };","        if(Y_Lang.isObject(val))","        {","            styles = val.styles;","            node = Y.one(val.node) || tt.node;","            if(styles)","            {","                for(i in styles)","                {","                    if(styles.hasOwnProperty(i))","                    {","                        node.setStyle(i, styles[i]);","                    }","                }","            }","            for(i in props)","            {","                if(val.hasOwnProperty(i))","                {","                    tt[i] = val[i];","                }","            }","            tt.node = node;","        }","        return tt;","    },","","    /**","     * Default getter for `tooltip` attribute.","     *","     * @method _getTooltip","     * @return Object","     * @private","     */","    _getTooltip: function()","    {","        var node = DOCUMENT.createElement(\"div\"),","            tooltipClass = _getClassName(\"chart-tooltip\"),","            tt = {","                setTextFunction: this._setText,","                markerLabelFunction: this._tooltipLabelFunction,","                planarLabelFunction: this._planarLabelFunction,","                show: true,","                hideEvent: \"mouseout\",","                showEvent: \"mouseover\",","                markerEventHandler: function(e)","                {","                    var tt = this.get(\"tooltip\"),","                    msg = tt.markerLabelFunction.apply(this, [e.categoryItem, e.valueItem, e.index, e.series, e.seriesIndex]);","                    this._showTooltip(msg, e.x + 10, e.y + 10);","                },","                planarEventHandler: function(e)","                {","                    var tt = this.get(\"tooltip\"),","                        msg ,","                        categoryAxis = this.get(\"categoryAxis\");","                    msg = tt.planarLabelFunction.apply(this, [categoryAxis, e.valueItem, e.index, e.items, e.seriesIndex]);","                    this._showTooltip(msg, e.x + 10, e.y + 10);","                }","            };","        node = Y.one(node);","        node.set(\"id\", this.get(\"id\") + \"_tooltip\");","        node.setStyle(\"fontSize\", \"85%\");","        node.setStyle(\"opacity\", \"0.83\");","        node.setStyle(\"position\", \"absolute\");","        node.setStyle(\"paddingTop\", \"2px\");","        node.setStyle(\"paddingRight\", \"5px\");","        node.setStyle(\"paddingBottom\", \"4px\");","        node.setStyle(\"paddingLeft\", \"2px\");","        node.setStyle(\"backgroundColor\", \"#fff\");","        node.setStyle(\"border\", \"1px solid #dbdccc\");","        node.setStyle(\"pointerEvents\", \"none\");","        node.setStyle(\"zIndex\", 3);","        node.setStyle(\"whiteSpace\", \"noWrap\");","        node.setStyle(\"visibility\", \"hidden\");","        node.addClass(tooltipClass);","        tt.node = Y.one(node);","        return tt;","    },","","    /**","     * Formats tooltip text when `interactionType` is `planar`.","     *","     * @method _planarLabelFunction","     * @param {Axis} categoryAxis Reference to the categoryAxis of the chart.","     * @param {Array} valueItems Array of objects for each series that has a data point in the coordinate plane of the event.","     * Each object contains the following data:","     *  <dl>","     *      <dt>axis</dt><dd>The value axis of the series.</dd>","     *      <dt>key</dt><dd>The key for the series.</dd>","     *      <dt>value</dt><dd>The value for the series item.</dd>","     *      <dt>displayName</dt><dd>The display name of the series. (defaults to key if not provided)</dd>","     *  </dl>","     *  @param {Number} index The index of the item within its series.","     *  @param {Array} seriesArray Array of series instances for each value item.","     *  @param {Number} seriesIndex The index of the series in the `seriesCollection`.","     *  @return {String | HTML}","     * @private","     */","    _planarLabelFunction: function(categoryAxis, valueItems, index, seriesArray, seriesIndex)","    {","        var msg = DOCUMENT.createElement(\"div\"),","            valueItem,","            i = 0,","            len = seriesArray.length,","            axis,","            categoryValue,","            seriesValue,","            series;","        if(categoryAxis)","        {","            categoryValue = categoryAxis.get(\"labelFunction\").apply(this, [categoryAxis.getKeyValueAt(this.get(\"categoryKey\"), index), categoryAxis.get(\"labelFormat\")]);","            if(!Y_Lang.isObject(categoryValue))","            {","                categoryValue = DOCUMENT.createTextNode(categoryValue);","            }","            msg.appendChild(categoryValue);","        }","","        for(; i < len; ++i)","        {","            series = seriesArray[i];","            if(series.get(\"visible\"))","            {","                valueItem = valueItems[i];","                axis = valueItem.axis;","                seriesValue =  axis.get(\"labelFunction\").apply(this, [axis.getKeyValueAt(valueItem.key, index), axis.get(\"labelFormat\")]);","                msg.appendChild(DOCUMENT.createElement(\"br\"));","                msg.appendChild(DOCUMENT.createTextNode(valueItem.displayName));","                msg.appendChild(DOCUMENT.createTextNode(\": \"));","                if(!Y_Lang.isObject(seriesValue))","                {","                    seriesValue = DOCUMENT.createTextNode(seriesValue);","                }","                msg.appendChild(seriesValue);","            }","        }","        return msg;","    },","","    /**","     * Formats tooltip text when `interactionType` is `marker`.","     *","     * @method _tooltipLabelFunction","     * @param {Object} categoryItem An object containing the following:","     *  <dl>","     *      <dt>axis</dt><dd>The axis to which the category is bound.</dd>","     *      <dt>displayName</dt><dd>The display name set to the category (defaults to key if not provided)</dd>","     *      <dt>key</dt><dd>The key of the category.</dd>","     *      <dt>value</dt><dd>The value of the category</dd>","     *  </dl>","     * @param {Object} valueItem An object containing the following:","     *  <dl>","     *      <dt>axis</dt><dd>The axis to which the item's series is bound.</dd>","     *      <dt>displayName</dt><dd>The display name of the series. (defaults to key if not provided)</dd>","     *      <dt>key</dt><dd>The key for the series.</dd>","     *      <dt>value</dt><dd>The value for the series item.</dd>","     *  </dl>","     * @param {Number} itemIndex The index of the item within the series.","     * @param {CartesianSeries} series The `CartesianSeries` instance of the item.","     * @param {Number} seriesIndex The index of the series in the `seriesCollection`.","     * @return {String | HTML}","     * @private","     */","    _tooltipLabelFunction: function(categoryItem, valueItem, itemIndex, series, seriesIndex)","    {","        var msg = DOCUMENT.createElement(\"div\"),","            categoryValue = categoryItem.axis.get(\"labelFunction\").apply(this, [categoryItem.value, categoryItem.axis.get(\"labelFormat\")]),","            seriesValue = valueItem.axis.get(\"labelFunction\").apply(this, [valueItem.value, valueItem.axis.get(\"labelFormat\")]);","        msg.appendChild(DOCUMENT.createTextNode(categoryItem.displayName));","        msg.appendChild(DOCUMENT.createTextNode(\": \"));","        if(!Y_Lang.isObject(categoryValue))","        {","            categoryValue = DOCUMENT.createTextNode(categoryValue);","        }","        msg.appendChild(categoryValue);","        msg.appendChild(DOCUMENT.createElement(\"br\"));","        msg.appendChild(DOCUMENT.createTextNode(valueItem.displayName));","        msg.appendChild(DOCUMENT.createTextNode(\": \"));","        if(!Y_Lang.isObject(seriesValue))","        {","            seriesValue = DOCUMENT.createTextNode(seriesValue);","        }","        msg.appendChild(seriesValue);","        return msg;","    },","","    /**","     * Event handler for the tooltipChange.","     *","     * @method _tooltipChangeHandler","     * @param {Object} e Event object.","     * @private","     */","    _tooltipChangeHandler: function(e)","    {","        if(this.get(\"tooltip\"))","        {","            var tt = this.get(\"tooltip\"),","                node = tt.node,","                show = tt.show,","                cb = this.get(\"contentBox\");","            if(node && show)","            {","                if(!cb.contains(node))","                {","                    this._addTooltip();","                }","            }","        }","    },","","    /**","     * Updates the content of text field. This method writes a value into a text field using","     * `appendChild`. If the value is a `String`, it is converted to a `TextNode` first.","     *","     * @method _setText","     * @param label {HTMLElement} label to be updated","     * @param val {String} value with which to update the label","     * @private","     */","    _setText: function(textField, val)","    {","        textField.setContent(\"\");","        if(Y_Lang.isNumber(val))","        {","            val = val + \"\";","        }","        else if(!val)","        {","            val = \"\";","        }","        if(IS_STRING(val))","        {","            val = DOCUMENT.createTextNode(val);","        }","        textField.appendChild(val);","    },","","    /**","     * Returns all the keys contained in a  `dataProvider`.","     *","     * @method _getAllKeys","     * @param {Array} dp Collection of objects to be parsed.","     * @return Object","     */","    _getAllKeys: function(dp)","    {","        var i = 0,","            len = dp.length,","            item,","            key,","            keys = {};","        for(; i < len; ++i)","        {","            item = dp[i];","            for(key in item)","            {","                if(item.hasOwnProperty(key))","                {","                    keys[key] = true;","                }","            }","        }","        return keys;","    },","","    /**","     * Constructs seriesKeys if not explicitly specified.","     *","     * @method _buildSeriesKeys","     * @param {Array} dataProvider The dataProvider for the chart.","     * @return Array","     * @private","     */","    _buildSeriesKeys: function(dataProvider)","    {","        var allKeys,","            catKey = this.get(\"categoryKey\"),","            keys = [],","            i;","        if(this._seriesKeysExplicitlySet)","        {","            return this._seriesKeys;","        }","        allKeys = this._getAllKeys(dataProvider);","        for(i in allKeys)","        {","            if(allKeys.hasOwnProperty(i) && i != catKey)","            {","                keys.push(i);","            }","        }","        return keys;","    }","};","Y.ChartBase = ChartBase;","/**"," * The CartesianChart class creates a chart with horizontal and vertical axes."," *"," * @module charts"," * @submodule charts-base"," * @class CartesianChart"," * @extends ChartBase"," * @constructor"," */","Y.CartesianChart = Y.Base.create(\"cartesianChart\", Y.Widget, [Y.ChartBase], {","    /**","     * @method renderUI","     * @private","     */","    renderUI: function()","    {","        var bb = this.get(\"boundingBox\"),","            cb = this.get(\"contentBox\"),","            tt = this.get(\"tooltip\"),","            overlay,","            overlayClass = _getClassName(\"overlay\");","        //move the position = absolute logic to a class file","        bb.setStyle(\"position\", \"absolute\");","        cb.setStyle(\"position\", \"absolute\");","        this._addAxes();","        this._addGridlines();","        this._addSeries();","        if(tt && tt.show)","        {","            this._addTooltip();","        }","        //If there is a style definition. Force them to set.","        this.get(\"styles\");","        if(this.get(\"interactionType\") == \"planar\")","        {","            overlay = DOCUMENT.createElement(\"div\");","            this.get(\"contentBox\").appendChild(overlay);","            this._overlay = Y.one(overlay);","            this._overlay.set(\"id\", this.get(\"id\") + \"_overlay\");","            this._overlay.setStyle(\"position\", \"absolute\");","            this._overlay.setStyle(\"background\", \"#fff\");","            this._overlay.setStyle(\"opacity\", 0);","            this._overlay.addClass(overlayClass);","            this._overlay.setStyle(\"zIndex\", 4);","        }","        this._setAriaElements(bb, cb);","        this._redraw();","    },","","    /**","     * When `interactionType` is set to `planar`, listens for mouse move events and fires `planarEvent:mouseover` or `planarEvent:mouseout`","     * depending on the position of the mouse in relation to data points on the `Chart`.","     *","     * @method _planarEventDispatcher","     * @param {Object} e Event object.","     * @private","     */","    _planarEventDispatcher: function(e)","    {","        var graph = this.get(\"graph\"),","            bb = this.get(\"boundingBox\"),","            cb = graph.get(\"contentBox\"),","            isTouch = e && e.hasOwnProperty(\"changedTouches\"),","            pageX = isTouch ? e.changedTouches[0].pageX : e.pageX,","            pageY = isTouch ? e.changedTouches[0].pageY : e.pageY,","            posX = pageX - bb.getX(),","            posY = pageY - bb.getY(),","            offset = {","                x: pageX - cb.getX(),","                y: pageY - cb.getY()","            },","            sc = graph.get(\"seriesCollection\"),","            series,","            i = 0,","            index,","            oldIndex = this._selectedIndex,","            item,","            items = [],","            categoryItems = [],","            valueItems = [],","            direction = this.get(\"direction\"),","            hasMarkers,","            catAxis,","            valAxis,","            coord,","            //data columns and area data could be created on a graph level","            markerPlane,","            len,","            coords;","        e.halt(true);","        if(direction == \"horizontal\")","        {","            catAxis = \"x\";","            valAxis = \"y\";","        }","        else","        {","            valAxis = \"x\";","            catAxis = \"y\";","        }","        coord = offset[catAxis];","        if(sc)","        {","            len = sc.length;","            while(i < len && !markerPlane)","            {","                if(sc[i])","                {","                    markerPlane = sc[i].get(catAxis + \"MarkerPlane\");","                }","                i++;","            }","        }","        if(markerPlane)","        {","            len = markerPlane.length;","            for(i = 0; i < len; ++i)","            {","                if(coord <= markerPlane[i].end && coord >= markerPlane[i].start)","                {","                    index = i;","                    break;","                }","            }","            len = sc.length;","            for(i = 0; i < len; ++i)","            {","                series = sc[i];","                coords = series.get(valAxis + \"coords\");","                hasMarkers = series.get(\"markers\");","                if(hasMarkers && !isNaN(oldIndex) && oldIndex > -1)","                {","                    series.updateMarkerState(\"mouseout\", oldIndex);","                }","                if(coords && coords[index] > -1)","                {","                    if(hasMarkers && !isNaN(index) && index > -1)","                    {","                        series.updateMarkerState(\"mouseover\", index);","                    }","                    item = this.getSeriesItems(series, index);","                    categoryItems.push(item.category);","                    valueItems.push(item.value);","                    items.push(series);","                }","","            }","            this._selectedIndex = index;","","            /**","             * Broadcasts when `interactionType` is set to `planar` and a series' marker plane has received a mouseover event.","             *","             *","             * @event planarEvent:mouseover","             * @preventable false","             * @param {EventFacade} e Event facade with the following additional","             *   properties:","             *  <dl>","             *      <dt>categoryItem</dt><dd>An array of hashes, each containing information about the category `Axis` of each marker","             *      whose plane has been intersected.</dd>","             *      <dt>valueItem</dt><dd>An array of hashes, each containing information about the value `Axis` of each marker whose","             *      plane has been intersected.</dd>","             *      <dt>x</dt><dd>The x-coordinate of the mouse in relation to the Chart.</dd>","             *      <dt>y</dt><dd>The y-coordinate of the mouse in relation to the Chart.</dd>","             *      <dt>pageX</dt><dd>The x location of the event on the page (including scroll)</dd>","             *      <dt>pageY</dt><dd>The y location of the event on the page (including scroll)</dd>","             *      <dt>items</dt><dd>An array including all the series which contain a marker whose plane has been intersected.</dd>","             *      <dt>index</dt><dd>Index of the markers in their respective series.</dd>","             *      <dt>originEvent</dt><dd>Underlying dom event.</dd>","             *  </dl>","             */","            /**","             * Broadcasts when `interactionType` is set to `planar` and a series' marker plane has received a mouseout event.","             *","             * @event planarEvent:mouseout","             * @preventable false","             * @param {EventFacade} e","             */","            if(index > -1)","            {","                this.fire(\"planarEvent:mouseover\", {","                    categoryItem:categoryItems,","                    valueItem:valueItems,","                    x:posX,","                    y:posY,","                    pageX:pageX,","                    pageY:pageY,","                    items:items,","                    index:index,","                    originEvent:e","                });","            }","            else","            {","                this.fire(\"planarEvent:mouseout\");","            }","        }","    },","","    /**","     * Indicates the default series type for the chart.","     *","     * @property _type","     * @type {String}","     * @private","     */","    _type: \"combo\",","","    /**","     * Queue of axes instances that will be updated. This method is used internally to determine when all axes have been updated.","     *","     * @property _itemRenderQueue","     * @type Array","     * @private","     */","    _itemRenderQueue: null,","","    /**","     * Adds an `Axis` instance to the `_itemRenderQueue`.","     *","     * @method _addToAxesRenderQueue","     * @param {Axis} axis An `Axis` instance.","     * @private","     */","    _addToAxesRenderQueue: function(axis)","    {","        if(!this._itemRenderQueue)","        {","            this._itemRenderQueue = [];","        }","        if(Y.Array.indexOf(this._itemRenderQueue, axis) < 0)","        {","            this._itemRenderQueue.push(axis);","        }","    },","","    /**","     * Adds axis instance to the appropriate array based on position","     *","     * @method _addToAxesCollection","     * @param {String} position The position of the axis","     * @param {Axis} axis The `Axis` instance","     */","    _addToAxesCollection: function(position, axis)","    {","        var axesCollection = this.get(position + \"AxesCollection\");","        if(!axesCollection)","        {","            axesCollection = [];","            this.set(position + \"AxesCollection\", axesCollection);","        }","        axesCollection.push(axis);","    },","","    /**","     * Returns the default value for the `seriesCollection` attribute.","     *","     * @method _getDefaultSeriesCollection","     * @param {Array} val Array containing either `CartesianSeries` instances or objects containing data to construct series instances.","     * @return Array","     * @private","     */","    _getDefaultSeriesCollection: function()","    {","        var seriesCollection,","            dataProvider = this.get(\"dataProvider\");","        if(dataProvider)","        {","            seriesCollection = this._parseSeriesCollection();","        }","        return seriesCollection;","    },","","    /**","     * Parses and returns a series collection from an object and default properties.","     *","     * @method _parseSeriesCollection","     * @param {Object} val Object contain properties for series being set.","     * @return Object","     * @private","     */","    _parseSeriesCollection: function(val)","    {","        var dir = this.get(\"direction\"),","            sc = [],","            catAxis,","            valAxis,","            tempKeys = [],","            series,","            seriesKeys = this.get(\"seriesKeys\").concat(),","            i,","            index,","            l,","            type = this.get(\"type\"),","            key,","            catKey,","            seriesKey,","            graph,","            orphans = [],","            categoryKey = this.get(\"categoryKey\"),","            showMarkers = this.get(\"showMarkers\"),","            showAreaFill = this.get(\"showAreaFill\"),","            showLines = this.get(\"showLines\");","        val = val || [];","        if(dir == \"vertical\")","        {","            catAxis = \"yAxis\";","            catKey = \"yKey\";","            valAxis = \"xAxis\";","            seriesKey = \"xKey\";","        }","        else","        {","            catAxis = \"xAxis\";","            catKey = \"xKey\";","            valAxis = \"yAxis\";","            seriesKey = \"yKey\";","        }","        l = val.length;","        while(val && val.length > 0)","        {","            series = val.shift();","            key = this._getBaseAttribute(series, seriesKey);","            if(key)","            {","                index = Y.Array.indexOf(seriesKeys, key);","                if(index > -1)","                {","                    seriesKeys.splice(index, 1);","                    tempKeys.push(key);","                    sc.push(series);","                }","                else","                {","                    orphans.push(series);","                }","            }","            else","            {","                orphans.push(series);","            }","        }","        while(orphans.length > 0)","        {","            series = orphans.shift();","            if(seriesKeys.length > 0)","            {","                key = seriesKeys.shift();","                this._setBaseAttribute(series, seriesKey, key);","                tempKeys.push(key);","                sc.push(series);","            }","            else if(series instanceof Y.CartesianSeries)","            {","                series.destroy(true);","            }","        }","        if(seriesKeys.length > 0)","        {","            tempKeys = tempKeys.concat(seriesKeys);","        }","        l = tempKeys.length;","        for(i = 0; i < l; ++i)","        {","            series = sc[i] || {type:type};","            if(series instanceof Y.CartesianSeries)","            {","                this._parseSeriesAxes(series);","                continue;","            }","","            series[catKey] = series[catKey] || categoryKey;","            series[seriesKey] = series[seriesKey] || seriesKeys.shift();","            series[catAxis] = this._getCategoryAxis();","            series[valAxis] = this._getSeriesAxis(series[seriesKey]);","","            series.type = series.type || type;","            series.direction = series.direction || dir;","","            if((series.type == \"combo\" || series.type == \"stackedcombo\" || series.type == \"combospline\" || series.type == \"stackedcombospline\"))","            {","                if(showAreaFill !== null)","                {","                    series.showAreaFill = (series.showAreaFill !== null && series.showAreaFill !== undefined) ? series.showAreaFill : showAreaFill;","                }","                if(showMarkers !== null)","                {","                    series.showMarkers = (series.showMarkers !== null && series.showMarkers !== undefined) ? series.showMarkers : showMarkers;","                }","                if(showLines !== null)","                {","                    series.showLines = (series.showLines !== null && series.showLines !== undefined) ? series.showLines : showLines;","                }","            }","            sc[i] = series;","        }","        if(sc)","        {","            graph = this.get(\"graph\");","            graph.set(\"seriesCollection\", sc);","            sc = graph.get(\"seriesCollection\");","        }","        return sc;","    },","","    /**","     * Parse and sets the axes for a series instance.","     *","     * @method _parseSeriesAxes","     * @param {CartesianSeries} series A `CartesianSeries` instance.","     * @private","     */","    _parseSeriesAxes: function(series)","    {","        var axes = this.get(\"axes\"),","            xAxis = series.get(\"xAxis\"),","            yAxis = series.get(\"yAxis\"),","            YAxis = Y.Axis,","            axis;","        if(xAxis && !(xAxis instanceof YAxis) && Y_Lang.isString(xAxis) && axes.hasOwnProperty(xAxis))","        {","            axis = axes[xAxis];","            if(axis instanceof YAxis)","            {","                series.set(\"xAxis\", axis);","            }","        }","        if(yAxis && !(yAxis instanceof YAxis) && Y_Lang.isString(yAxis) && axes.hasOwnProperty(yAxis))","        {","            axis = axes[yAxis];","            if(axis instanceof YAxis)","            {","                series.set(\"yAxis\", axis);","            }","        }","","    },","","    /**","     * Returns the category axis instance for the chart.","     *","     * @method _getCategoryAxis","     * @return Axis","     * @private","     */","    _getCategoryAxis: function()","    {","        var axis,","            axes = this.get(\"axes\"),","            categoryAxisName = this.get(\"categoryAxisName\") || this.get(\"categoryKey\");","        axis = axes[categoryAxisName];","        return axis;","    },","","    /**","     * Returns the value axis for a series.","     *","     * @method _getSeriesAxis","     * @param {String} key The key value used to determine the axis instance.","     * @return Axis","     * @private","     */","    _getSeriesAxis:function(key, axisName)","    {","        var axes = this.get(\"axes\"),","            i,","            keys,","            axis;","        if(axes)","        {","            if(axisName && axes.hasOwnProperty(axisName))","            {","                axis = axes[axisName];","            }","            else","            {","                for(i in axes)","                {","                    if(axes.hasOwnProperty(i))","                    {","                        keys = axes[i].get(\"keys\");","                        if(keys && keys.hasOwnProperty(key))","                        {","                            axis = axes[i];","                            break;","                        }","                    }","                }","            }","        }","        return axis;","    },","","    /**","     * Gets an attribute from an object, using a getter for Base objects and a property for object","     * literals. Used for determining attributes from series/axis references which can be an actual class instance","     * or a hash of properties that will be used to create a class instance.","     *","     * @method _getBaseAttribute","     * @param {Object} item Object or instance in which the attribute resides.","     * @param {String} key Attribute whose value will be returned.","     * @return Object","     * @private","     */","    _getBaseAttribute: function(item, key)","    {","        if(item instanceof Y.Base)","        {","            return item.get(key);","        }","        if(item.hasOwnProperty(key))","        {","            return item[key];","        }","        return null;","    },","","    /**","     * Sets an attribute on an object, using a setter of Base objects and a property for object","     * literals. Used for setting attributes on a Base class, either directly or to be stored in an object literal","     * for use at instantiation.","     *","     * @method _setBaseAttribute","     * @param {Object} item Object or instance in which the attribute resides.","     * @param {String} key Attribute whose value will be assigned.","     * @param {Object} value Value to be assigned to the attribute.","     * @private","     */","    _setBaseAttribute: function(item, key, value)","    {","        if(item instanceof Y.Base)","        {","            item.set(key, value);","        }","        else","        {","            item[key] = value;","        }","    },","","    /**","     * Creates `Axis` instances.","     *","     * @method _setAxes","     * @param {Object} val Object containing `Axis` instances or objects in which to construct `Axis` instances.","     * @return Object","     * @private","     */","    _setAxes: function(val)","    {","        var hash = this._parseAxes(val),","            axes = {},","            axesAttrs = {","                edgeOffset: \"edgeOffset\",","                position: \"position\",","                overlapGraph:\"overlapGraph\",","                labelFunction:\"labelFunction\",","                labelFunctionScope:\"labelFunctionScope\",","                labelFormat:\"labelFormat\",","                appendLabelFunction: \"appendLabelFunction\",","                appendTitleFunction: \"appendTitleFunction\",","                maximum:\"maximum\",","                minimum:\"minimum\",","                roundingMethod:\"roundingMethod\",","                alwaysShowZero:\"alwaysShowZero\",","                title:\"title\",","                width:\"width\",","                height:\"height\"","            },","            dp = this.get(\"dataProvider\"),","            ai,","            i,","            pos,","            axis,","            axisPosition,","            dh,","            axisClass,","            config,","            axesCollection;","        for(i in hash)","        {","            if(hash.hasOwnProperty(i))","            {","                dh = hash[i];","                if(dh instanceof Y.Axis)","                {","                    axis = dh;","                }","                else","                {","                    axis = null;","                    config = {};","                    config.dataProvider = dh.dataProvider || dp;","                    config.keys = dh.keys;","","                    if(dh.hasOwnProperty(\"roundingUnit\"))","                    {","                        config.roundingUnit = dh.roundingUnit;","                    }","                    pos = dh.position;","                    if(dh.styles)","                    {","                        config.styles = dh.styles;","                    }","                    config.position = dh.position;","                    for(ai in axesAttrs)","                    {","                        if(axesAttrs.hasOwnProperty(ai) && dh.hasOwnProperty(ai))","                        {","                            config[ai] = dh[ai];","                        }","                    }","","                    //only check for existing axis if we constructed the default axes already","                    if(val)","                    {","                        axis = this.getAxisByKey(i);","                    }","","                    if(axis && axis instanceof Y.Axis)","                    {","                        axisPosition = axis.get(\"position\");","                        if(pos != axisPosition)","                        {","                            if(axisPosition != \"none\")","                            {","                                axesCollection = this.get(axisPosition + \"AxesCollection\");","                                axesCollection.splice(Y.Array.indexOf(axesCollection, axis), 1);","                            }","                            if(pos != \"none\")","                            {","                                this._addToAxesCollection(pos, axis);","                            }","                        }","                        axis.setAttrs(config);","                    }","                    else","                    {","                        axisClass = this._getAxisClass(dh.type);","                        axis = new axisClass(config);","                        axis.after(\"axisRendered\", Y.bind(this._itemRendered, this));","                    }","                }","","                if(axis)","                {","                    axesCollection = this.get(pos + \"AxesCollection\");","                    if(axesCollection && Y.Array.indexOf(axesCollection, axis) > 0)","                    {","                        axis.set(\"overlapGraph\", false);","                    }","                    axes[i] = axis;","                }","            }","        }","        return axes;","    },","","    /**","     * Adds axes to the chart.","     *","     * @method _addAxes","     * @private","     */","    _addAxes: function()","    {","        var axes = this.get(\"axes\"),","            i,","            axis,","            pos,","            w = this.get(\"width\"),","            h = this.get(\"height\"),","            node = Y.Node.one(this._parentNode);","        if(!this._axesCollection)","        {","            this._axesCollection = [];","        }","        for(i in axes)","        {","            if(axes.hasOwnProperty(i))","            {","                axis = axes[i];","                if(axis instanceof Y.Axis)","                {","                    if(!w)","                    {","                        this.set(\"width\", node.get(\"offsetWidth\"));","                        w = this.get(\"width\");","                    }","                    if(!h)","                    {","                        this.set(\"height\", node.get(\"offsetHeight\"));","                        h = this.get(\"height\");","                    }","                    this._addToAxesRenderQueue(axis);","                    pos = axis.get(\"position\");","                    if(!this.get(pos + \"AxesCollection\"))","                    {","                        this.set(pos + \"AxesCollection\", [axis]);","                    }","                    else","                    {","                        this.get(pos + \"AxesCollection\").push(axis);","                    }","                    this._axesCollection.push(axis);","                    if(axis.get(\"keys\").hasOwnProperty(this.get(\"categoryKey\")))","                    {","                        this.set(\"categoryAxis\", axis);","                    }","                    axis.render(this.get(\"contentBox\"));","                }","            }","        }","    },","","    /**","     * Renders the Graph.","     *","     * @method _addSeries","     * @private","     */","    _addSeries: function()","    {","        var graph = this.get(\"graph\"),","            sc = this.get(\"seriesCollection\");","        graph.render(this.get(\"contentBox\"));","","    },","","    /**","     * Adds gridlines to the chart.","     *","     * @method _addGridlines","     * @private","     */","    _addGridlines: function()","    {","        var graph = this.get(\"graph\"),","            hgl = this.get(\"horizontalGridlines\"),","            vgl = this.get(\"verticalGridlines\"),","            direction = this.get(\"direction\"),","            leftAxesCollection = this.get(\"leftAxesCollection\"),","            rightAxesCollection = this.get(\"rightAxesCollection\"),","            bottomAxesCollection = this.get(\"bottomAxesCollection\"),","            topAxesCollection = this.get(\"topAxesCollection\"),","            seriesAxesCollection,","            catAxis = this.get(\"categoryAxis\"),","            hAxis,","            vAxis;","        if(this._axesCollection)","        {","            seriesAxesCollection = this._axesCollection.concat();","            seriesAxesCollection.splice(Y.Array.indexOf(seriesAxesCollection, catAxis), 1);","        }","        if(hgl)","        {","            if(leftAxesCollection && leftAxesCollection[0])","            {","                hAxis = leftAxesCollection[0];","            }","            else if(rightAxesCollection && rightAxesCollection[0])","            {","                hAxis = rightAxesCollection[0];","            }","            else","            {","                hAxis = direction == \"horizontal\" ? catAxis : seriesAxesCollection[0];","            }","            if(!this._getBaseAttribute(hgl, \"axis\") && hAxis)","            {","                this._setBaseAttribute(hgl, \"axis\", hAxis);","            }","            if(this._getBaseAttribute(hgl, \"axis\"))","            {","                graph.set(\"horizontalGridlines\", hgl);","            }","        }","        if(vgl)","        {","            if(bottomAxesCollection && bottomAxesCollection[0])","            {","                vAxis = bottomAxesCollection[0];","            }","            else if (topAxesCollection && topAxesCollection[0])","            {","                vAxis = topAxesCollection[0];","            }","            else","            {","                vAxis = direction == \"vertical\" ? catAxis : seriesAxesCollection[0];","            }","            if(!this._getBaseAttribute(vgl, \"axis\") && vAxis)","            {","                this._setBaseAttribute(vgl, \"axis\", vAxis);","            }","            if(this._getBaseAttribute(vgl, \"axis\"))","            {","                graph.set(\"verticalGridlines\", vgl);","            }","        }","    },","","    /**","     * Default Function for the axes attribute.","     *","     * @method _getDefaultAxes","     * @return Object","     * @private","     */","    _getDefaultAxes: function()","    {","        var axes;","        if(this.get(\"dataProvider\"))","        {","            axes = this._parseAxes();","        }","        return axes;","    },","","    /**","     * Generates and returns a key-indexed object containing `Axis` instances or objects used to create `Axis` instances.","     *","     * @method _parseAxes","     * @param {Object} axes Object containing `Axis` instances or `Axis` attributes.","     * @return Object","     * @private","     */","    _parseAxes: function(axes)","    {","        var catKey = this.get(\"categoryKey\"),","            axis,","            attr,","            keys,","            newAxes = {},","            claimedKeys = [],","            categoryAxisName = this.get(\"categoryAxisName\") || this.get(\"categoryKey\"),","            valueAxisName = this.get(\"valueAxisName\"),","            seriesKeys = this.get(\"seriesKeys\").concat(),","            i,","            l,","            ii,","            ll,","            cIndex,","            direction = this.get(\"direction\"),","            seriesPosition,","            categoryPosition,","            valueAxes = [],","            seriesAxis = this.get(\"stacked\") ? \"stacked\" : \"numeric\";","        if(direction == \"vertical\")","        {","            seriesPosition = \"bottom\";","            categoryPosition = \"left\";","        }","        else","        {","            seriesPosition = \"left\";","            categoryPosition = \"bottom\";","        }","        if(axes)","        {","            for(i in axes)","            {","                if(axes.hasOwnProperty(i))","                {","                    axis = axes[i];","                    keys = this._getBaseAttribute(axis, \"keys\");","                    attr = this._getBaseAttribute(axis, \"type\");","                    if(attr == \"time\" || attr == \"category\")","                    {","                        categoryAxisName = i;","                        this.set(\"categoryAxisName\", i);","                        if(Y_Lang.isArray(keys) && keys.length > 0)","                        {","                            catKey = keys[0];","                            this.set(\"categoryKey\", catKey);","                        }","                        newAxes[i] = axis;","                    }","                    else if(i == categoryAxisName)","                    {","                        newAxes[i] = axis;","                    }","                    else","                    {","                        newAxes[i] = axis;","                        if(i != valueAxisName && keys && Y_Lang.isArray(keys))","                        {","                            ll = keys.length;","                            for(ii = 0; ii < ll; ++ii)","                            {","                                claimedKeys.push(keys[ii]);","                            }","                            valueAxes.push(newAxes[i]);","                        }","                        if(!(this._getBaseAttribute(newAxes[i], \"type\")))","                        {","                            this._setBaseAttribute(newAxes[i], \"type\", seriesAxis);","                        }","                        if(!(this._getBaseAttribute(newAxes[i], \"position\")))","                        {","                            this._setBaseAttribute(newAxes[i], \"position\", this._getDefaultAxisPosition(newAxes[i], valueAxes, seriesPosition));","                        }","                    }","                }","            }","        }","        cIndex = Y.Array.indexOf(seriesKeys, catKey);","        if(cIndex > -1)","        {","            seriesKeys.splice(cIndex, 1);","        }","        l = claimedKeys.length;","        for(i = 0; i < l; ++i)","        {","            cIndex = Y.Array.indexOf(seriesKeys, claimedKeys[i]);","            if(cIndex > -1)","            {","                seriesKeys.splice(cIndex, 1);","            }","        }","        if(!newAxes.hasOwnProperty(categoryAxisName))","        {","            newAxes[categoryAxisName] = {};","        }","        if(!(this._getBaseAttribute(newAxes[categoryAxisName], \"keys\")))","        {","            this._setBaseAttribute(newAxes[categoryAxisName], \"keys\", [catKey]);","        }","","        if(!(this._getBaseAttribute(newAxes[categoryAxisName], \"position\")))","        {","            this._setBaseAttribute(newAxes[categoryAxisName], \"position\", categoryPosition);","        }","","        if(!(this._getBaseAttribute(newAxes[categoryAxisName], \"type\")))","        {","            this._setBaseAttribute(newAxes[categoryAxisName], \"type\", this.get(\"categoryType\"));","        }","        if(!newAxes.hasOwnProperty(valueAxisName) && seriesKeys && seriesKeys.length > 0)","        {","            newAxes[valueAxisName] = {keys:seriesKeys};","            valueAxes.push(newAxes[valueAxisName]);","        }","        if(claimedKeys.length > 0)","        {","            if(seriesKeys.length > 0)","            {","                seriesKeys = claimedKeys.concat(seriesKeys);","            }","            else","            {","                seriesKeys = claimedKeys;","            }","        }","        if(newAxes.hasOwnProperty(valueAxisName))","        {","            if(!(this._getBaseAttribute(newAxes[valueAxisName], \"position\")))","            {","                this._setBaseAttribute(newAxes[valueAxisName], \"position\", this._getDefaultAxisPosition(newAxes[valueAxisName], valueAxes, seriesPosition));","            }","            this._setBaseAttribute(newAxes[valueAxisName], \"type\", seriesAxis);","            this._setBaseAttribute(newAxes[valueAxisName], \"keys\", seriesKeys);","        }","        if(!this._seriesKeysExplicitlySet)","        {","            this._seriesKeys = seriesKeys;","        }","        return newAxes;","    },","","    /**","     * Determines the position of an axis when one is not specified.","     *","     * @method _getDefaultAxisPosition","     * @param {Axis} axis `Axis` instance.","     * @param {Array} valueAxes Array of `Axis` instances.","     * @param {String} position Default position depending on the direction of the chart and type of axis.","     * @return String","     * @private","     */","    _getDefaultAxisPosition: function(axis, valueAxes, position)","    {","        var direction = this.get(\"direction\"),","            i = Y.Array.indexOf(valueAxes, axis);","","        if(valueAxes[i - 1] && valueAxes[i - 1].position)","        {","            if(direction == \"horizontal\")","            {","                if(valueAxes[i - 1].position == \"left\")","                {","                    position = \"right\";","                }","                else if(valueAxes[i - 1].position == \"right\")","                {","                    position = \"left\";","                }","            }","            else","            {","                if (valueAxes[i -1].position == \"bottom\")","                {","                    position = \"top\";","                }","                else","                {","                    position = \"bottom\";","                }","            }","        }","        return position;","    },","","","    /**","     * Returns an object literal containing a categoryItem and a valueItem for a given series index. Below is the structure of each:","     *","     * @method getSeriesItems","     * @param {CartesianSeries} series Reference to a series.","     * @param {Number} index Index of the specified item within a series.","     * @return Object An object literal containing the following:","     *","     *  <dl>","     *      <dt>categoryItem</dt><dd>Object containing the following data related to the category axis of the series.","     *  <dl>","     *      <dt>axis</dt><dd>Reference to the category axis of the series.</dd>","     *      <dt>key</dt><dd>Category key for the series.</dd>","     *      <dt>value</dt><dd>Value on the axis corresponding to the series index.</dd>","     *  </dl>","     *      </dd>","     *      <dt>valueItem</dt><dd>Object containing the following data related to the category axis of the series.","     *  <dl>","     *      <dt>axis</dt><dd>Reference to the value axis of the series.</dd>","     *      <dt>key</dt><dd>Value key for the series.</dd>","     *      <dt>value</dt><dd>Value on the axis corresponding to the series index.</dd>","     *  </dl>","     *      </dd>","     *  </dl>","     */","    getSeriesItems: function(series, index)","    {","        var xAxis = series.get(\"xAxis\"),","            yAxis = series.get(\"yAxis\"),","            xKey = series.get(\"xKey\"),","            yKey = series.get(\"yKey\"),","            categoryItem,","            valueItem;","        if(this.get(\"direction\") == \"vertical\")","        {","            categoryItem = {","                axis:yAxis,","                key:yKey,","                value:yAxis.getKeyValueAt(yKey, index)","            };","            valueItem = {","                axis:xAxis,","                key:xKey,","                value: xAxis.getKeyValueAt(xKey, index)","            };","        }","        else","        {","            valueItem = {","                axis:yAxis,","                key:yKey,","                value:yAxis.getKeyValueAt(yKey, index)","            };","            categoryItem = {","                axis:xAxis,","                key:xKey,","                value: xAxis.getKeyValueAt(xKey, index)","            };","        }","        categoryItem.displayName = series.get(\"categoryDisplayName\");","        valueItem.displayName = series.get(\"valueDisplayName\");","        categoryItem.value = categoryItem.axis.getKeyValueAt(categoryItem.key, index);","        valueItem.value = valueItem.axis.getKeyValueAt(valueItem.key, index);","        return {category:categoryItem, value:valueItem};","    },","","    /**","     * Handler for sizeChanged event.","     *","     * @method _sizeChanged","     * @param {Object} e Event object.","     * @private","     */","    _sizeChanged: function(e)","    {","        if(this._axesCollection)","        {","            var ac = this._axesCollection,","                i = 0,","                l = ac.length;","            for(; i < l; ++i)","            {","                this._addToAxesRenderQueue(ac[i]);","            }","            this._redraw();","        }","    },","","    /**","     * Returns the maximum distance in pixels that the extends outside the top bounds of all vertical axes.","     *","     * @method _getTopOverflow","     * @param {Array} set1 Collection of axes to check.","     * @param {Array} set2 Seconf collection of axes to check.","     * @param {Number} width Width of the axes","     * @return Number","     * @private","     */","    _getTopOverflow: function(set1, set2, height)","    {","        var i = 0,","            len,","            overflow = 0,","            axis;","        if(set1)","        {","            len = set1.length;","            for(; i < len; ++i)","            {","                axis = set1[i];","                overflow = Math.max(overflow, Math.abs(axis.getMaxLabelBounds().top) - (axis.getEdgeOffset(axis.get(\"styles\").majorTicks.count, height) * 0.5));","            }","        }","        if(set2)","        {","            i = 0;","            len = set2.length;","            for(; i < len; ++i)","            {","                axis = set2[i];","                overflow = Math.max(overflow, Math.abs(axis.getMaxLabelBounds().top) - (axis.getEdgeOffset(axis.get(\"styles\").majorTicks.count, height) * 0.5));","            }","        }","        return overflow;","    },","","    /**","     * Returns the maximum distance in pixels that the extends outside the right bounds of all horizontal axes.","     *","     * @method _getRightOverflow","     * @param {Array} set1 Collection of axes to check.","     * @param {Array} set2 Seconf collection of axes to check.","     * @param {Number} width Width of the axes","     * @return Number","     * @private","     */","    _getRightOverflow: function(set1, set2, width)","    {","        var i = 0,","            len,","            overflow = 0,","            axis;","        if(set1)","        {","            len = set1.length;","            for(; i < len; ++i)","            {","                axis = set1[i];","                overflow = Math.max(overflow, axis.getMaxLabelBounds().right - (axis.getEdgeOffset(axis.get(\"styles\").majorTicks.count, width) * 0.5));","            }","        }","        if(set2)","        {","            i = 0;","            len = set2.length;","            for(; i < len; ++i)","            {","                axis = set2[i];","                overflow = Math.max(overflow, axis.getMaxLabelBounds().right - (axis.getEdgeOffset(axis.get(\"styles\").majorTicks.count, width) * 0.5));","            }","        }","        return overflow;","    },","","    /**","     * Returns the maximum distance in pixels that the extends outside the left bounds of all horizontal axes.","     *","     * @method _getLeftOverflow","     * @param {Array} set1 Collection of axes to check.","     * @param {Array} set2 Seconf collection of axes to check.","     * @param {Number} width Width of the axes","     * @return Number","     * @private","     */","    _getLeftOverflow: function(set1, set2, width)","    {","        var i = 0,","            len,","            overflow = 0,","            axis;","        if(set1)","        {","            len = set1.length;","            for(; i < len; ++i)","            {","                axis = set1[i];","                overflow = Math.max(overflow, Math.abs(axis.getMinLabelBounds().left) - (axis.getEdgeOffset(axis.get(\"styles\").majorTicks.count, width) * 0.5));","            }","        }","        if(set2)","        {","            i = 0;","            len = set2.length;","            for(; i < len; ++i)","            {","                axis = set2[i];","                overflow = Math.max(overflow, Math.abs(axis.getMinLabelBounds().left) - (axis.getEdgeOffset(axis.get(\"styles\").majorTicks.count, width) * 0.5));","            }","        }","        return overflow;","    },","","    /**","     * Returns the maximum distance in pixels that the extends outside the bottom bounds of all vertical axes.","     *","     * @method _getBottomOverflow","     * @param {Array} set1 Collection of axes to check.","     * @param {Array} set2 Seconf collection of axes to check.","     * @param {Number} height Height of the axes","     * @return Number","     * @private","     */","    _getBottomOverflow: function(set1, set2, height)","    {","        var i = 0,","            len,","            overflow = 0,","            axis;","        if(set1)","        {","            len = set1.length;","            for(; i < len; ++i)","            {","                axis = set1[i];","                overflow = Math.max(overflow, axis.getMinLabelBounds().bottom - (axis.getEdgeOffset(axis.get(\"styles\").majorTicks.count, height) * 0.5));","            }","        }","        if(set2)","        {","            i = 0;","            len = set2.length;","            for(; i < len; ++i)","            {","                axis = set2[i];","                overflow = Math.max(overflow, axis.getMinLabelBounds().bottom - (axis.getEdgeOffset(axis.get(\"styles\").majorTicks.count, height) * 0.5));","            }","        }","        return overflow;","    },","","    /**","     * Redraws and position all the components of the chart instance.","     *","     * @method _redraw","     * @private","     */","    _redraw: function()","    {","        if(this._drawing)","        {","            this._callLater = true;","            return;","        }","        this._drawing = true;","        this._callLater = false;","        var w = this.get(\"width\"),","            h = this.get(\"height\"),","            leftPaneWidth = 0,","            rightPaneWidth = 0,","            topPaneHeight = 0,","            bottomPaneHeight = 0,","            leftAxesCollection = this.get(\"leftAxesCollection\"),","            rightAxesCollection = this.get(\"rightAxesCollection\"),","            topAxesCollection = this.get(\"topAxesCollection\"),","            bottomAxesCollection = this.get(\"bottomAxesCollection\"),","            i = 0,","            l,","            axis,","            graphOverflow = \"visible\",","            graph = this.get(\"graph\"),","            topOverflow,","            bottomOverflow,","            leftOverflow,","            rightOverflow,","            graphWidth,","            graphHeight,","            graphX,","            graphY,","            allowContentOverflow = this.get(\"allowContentOverflow\"),","            diff,","            rightAxesXCoords,","            leftAxesXCoords,","            topAxesYCoords,","            bottomAxesYCoords,","            graphRect = {};","        if(leftAxesCollection)","        {","            leftAxesXCoords = [];","            l = leftAxesCollection.length;","            for(i = l - 1; i > -1; --i)","            {","                leftAxesXCoords.unshift(leftPaneWidth);","                leftPaneWidth += leftAxesCollection[i].get(\"width\");","            }","        }","        if(rightAxesCollection)","        {","            rightAxesXCoords = [];","            l = rightAxesCollection.length;","            i = 0;","            for(i = l - 1; i > -1; --i)","            {","                rightPaneWidth += rightAxesCollection[i].get(\"width\");","                rightAxesXCoords.unshift(w - rightPaneWidth);","            }","        }","        if(topAxesCollection)","        {","            topAxesYCoords = [];","            l = topAxesCollection.length;","            for(i = l - 1; i > -1; --i)","            {","                topAxesYCoords.unshift(topPaneHeight);","                topPaneHeight += topAxesCollection[i].get(\"height\");","            }","        }","        if(bottomAxesCollection)","        {","            bottomAxesYCoords = [];","            l = bottomAxesCollection.length;","            for(i = l - 1; i > -1; --i)","            {","                bottomPaneHeight += bottomAxesCollection[i].get(\"height\");","                bottomAxesYCoords.unshift(h - bottomPaneHeight);","            }","        }","","        graphWidth = w - (leftPaneWidth + rightPaneWidth);","        graphHeight = h - (bottomPaneHeight + topPaneHeight);","        graphRect.left = leftPaneWidth;","        graphRect.top = topPaneHeight;","        graphRect.bottom = h - bottomPaneHeight;","        graphRect.right = w - rightPaneWidth;","        if(!allowContentOverflow)","        {","            topOverflow = this._getTopOverflow(leftAxesCollection, rightAxesCollection);","            bottomOverflow = this._getBottomOverflow(leftAxesCollection, rightAxesCollection);","            leftOverflow = this._getLeftOverflow(bottomAxesCollection, topAxesCollection);","            rightOverflow = this._getRightOverflow(bottomAxesCollection, topAxesCollection);","","            diff = topOverflow - topPaneHeight;","            if(diff > 0)","            {","                graphRect.top = topOverflow;","                if(topAxesYCoords)","                {","                    i = 0;","                    l = topAxesYCoords.length;","                    for(; i < l; ++i)","                    {","                        topAxesYCoords[i] += diff;","                    }","                }","            }","","            diff = bottomOverflow - bottomPaneHeight;","            if(diff > 0)","            {","                graphRect.bottom = h - bottomOverflow;","                if(bottomAxesYCoords)","                {","                    i = 0;","                    l = bottomAxesYCoords.length;","                    for(; i < l; ++i)","                    {","                        bottomAxesYCoords[i] -= diff;","                    }","                }","            }","","            diff = leftOverflow - leftPaneWidth;","            if(diff > 0)","            {","                graphRect.left = leftOverflow;","                if(leftAxesXCoords)","                {","                    i = 0;","                    l = leftAxesXCoords.length;","                    for(; i < l; ++i)","                    {","                        leftAxesXCoords[i] += diff;","                    }","                }","            }","","            diff = rightOverflow - rightPaneWidth;","            if(diff > 0)","            {","                graphRect.right = w - rightOverflow;","                if(rightAxesXCoords)","                {","                    i = 0;","                    l = rightAxesXCoords.length;","                    for(; i < l; ++i)","                    {","                        rightAxesXCoords[i] -= diff;","                    }","                }","            }","        }","        graphWidth = graphRect.right - graphRect.left;","        graphHeight = graphRect.bottom - graphRect.top;","        graphX = graphRect.left;","        graphY = graphRect.top;","        if(topAxesCollection)","        {","            l = topAxesCollection.length;","            i = 0;","            for(; i < l; i++)","            {","                axis = topAxesCollection[i];","                if(axis.get(\"width\") !== graphWidth)","                {","                    axis.set(\"width\", graphWidth);","                }","                axis.get(\"boundingBox\").setStyle(\"left\", graphX + \"px\");","                axis.get(\"boundingBox\").setStyle(\"top\", topAxesYCoords[i] + \"px\");","            }","            if(axis._hasDataOverflow())","            {","                graphOverflow = \"hidden\";","            }","        }","        if(bottomAxesCollection)","        {","            l = bottomAxesCollection.length;","            i = 0;","            for(; i < l; i++)","            {","                axis = bottomAxesCollection[i];","                if(axis.get(\"width\") !== graphWidth)","                {","                    axis.set(\"width\", graphWidth);","                }","                axis.get(\"boundingBox\").setStyle(\"left\", graphX + \"px\");","                axis.get(\"boundingBox\").setStyle(\"top\", bottomAxesYCoords[i] + \"px\");","            }","            if(axis._hasDataOverflow())","            {","                graphOverflow = \"hidden\";","            }","        }","        if(leftAxesCollection)","        {","            l = leftAxesCollection.length;","            i = 0;","            for(; i < l; ++i)","            {","                axis = leftAxesCollection[i];","                axis.get(\"boundingBox\").setStyle(\"top\", graphY + \"px\");","                axis.get(\"boundingBox\").setStyle(\"left\", leftAxesXCoords[i] + \"px\");","                if(axis.get(\"height\") !== graphHeight)","                {","                    axis.set(\"height\", graphHeight);","                }","            }","            if(axis._hasDataOverflow())","            {","                graphOverflow = \"hidden\";","            }","        }","        if(rightAxesCollection)","        {","            l = rightAxesCollection.length;","            i = 0;","            for(; i < l; ++i)","            {","                axis = rightAxesCollection[i];","                axis.get(\"boundingBox\").setStyle(\"top\", graphY + \"px\");","                axis.get(\"boundingBox\").setStyle(\"left\", rightAxesXCoords[i] + \"px\");","                if(axis.get(\"height\") !== graphHeight)","                {","                    axis.set(\"height\", graphHeight);","                }","            }","            if(axis._hasDataOverflow())","            {","                graphOverflow = \"hidden\";","            }","        }","        this._drawing = false;","        if(this._callLater)","        {","            this._redraw();","            return;","        }","        if(graph)","        {","            graph.get(\"boundingBox\").setStyle(\"left\", graphX + \"px\");","            graph.get(\"boundingBox\").setStyle(\"top\", graphY + \"px\");","            graph.set(\"width\", graphWidth);","            graph.set(\"height\", graphHeight);","            graph.get(\"boundingBox\").setStyle(\"overflow\", graphOverflow);","        }","","        if(this._overlay)","        {","            this._overlay.setStyle(\"left\", graphX + \"px\");","            this._overlay.setStyle(\"top\", graphY + \"px\");","            this._overlay.setStyle(\"width\", graphWidth + \"px\");","            this._overlay.setStyle(\"height\", graphHeight + \"px\");","        }","    },","","    /**","     * Destructor implementation for the CartesianChart class. Calls destroy on all axes, series and the Graph instance.","     * Removes the tooltip and overlay HTML elements.","     *","     * @method destructor","     * @protected","     */","    destructor: function()","    {","        var graph = this.get(\"graph\"),","            i = 0,","            len,","            seriesCollection = this.get(\"seriesCollection\"),","            axesCollection = this._axesCollection,","            tooltip = this.get(\"tooltip\").node;","        if(this._description)","        {","            this._description.empty();","            this._description.remove(true);","        }","        if(this._liveRegion)","        {","            this._liveRegion.empty();","            this._liveRegion.remove(true);","        }","        len = seriesCollection ? seriesCollection.length : 0;","        for(; i < len; ++i)","        {","            if(seriesCollection[i] instanceof Y.CartesianSeries)","            {","                seriesCollection[i].destroy(true);","            }","        }","        len = axesCollection ? axesCollection.length : 0;","        for(i = 0; i < len; ++i)","        {","            if(axesCollection[i] instanceof Y.Axis)","            {","                axesCollection[i].destroy(true);","            }","        }","        if(graph)","        {","            graph.destroy(true);","        }","        if(tooltip)","        {","            tooltip.empty();","            tooltip.remove(true);","        }","        if(this._overlay)","        {","            this._overlay.empty();","            this._overlay.remove(true);","        }","    },","","    /**","     * Returns the appropriate message based on the key press.","     *","     * @method _getAriaMessage","     * @param {Number} key The keycode that was pressed.","     * @return String","     */","    _getAriaMessage: function(key)","    {","        var msg = \"\",","            series,","            items,","            categoryItem,","            valueItem,","            seriesIndex = this._seriesIndex,","            itemIndex = this._itemIndex,","            seriesCollection = this.get(\"seriesCollection\"),","            len = seriesCollection.length,","            dataLength;","        if(key % 2 === 0)","        {","            if(len > 1)","            {","                if(key === 38)","                {","                    seriesIndex = seriesIndex < 1 ? len - 1 : seriesIndex - 1;","                }","                else if(key === 40)","                {","                    seriesIndex = seriesIndex >= len - 1 ? 0 : seriesIndex + 1;","                }","                this._itemIndex = -1;","            }","            else","            {","                seriesIndex = 0;","            }","            this._seriesIndex = seriesIndex;","            series = this.getSeries(parseInt(seriesIndex, 10));","            msg = series.get(\"valueDisplayName\") + \" series.\";","        }","        else","        {","            if(seriesIndex > -1)","            {","                msg = \"\";","                series = this.getSeries(parseInt(seriesIndex, 10));","            }","            else","            {","                seriesIndex = 0;","                this._seriesIndex = seriesIndex;","                series = this.getSeries(parseInt(seriesIndex, 10));","                msg = series.get(\"valueDisplayName\") + \" series.\";","            }","            dataLength = series._dataLength ? series._dataLength : 0;","            if(key === 37)","            {","                itemIndex = itemIndex > 0 ? itemIndex - 1 : dataLength - 1;","            }","            else if(key === 39)","            {","                itemIndex = itemIndex >= dataLength - 1 ? 0 : itemIndex + 1;","            }","            this._itemIndex = itemIndex;","            items = this.getSeriesItems(series, itemIndex);","            categoryItem = items.category;","            valueItem = items.value;","            if(categoryItem && valueItem && categoryItem.value && valueItem.value)","            {","                msg += categoryItem.displayName + \": \" + categoryItem.axis.formatLabel.apply(this, [categoryItem.value, categoryItem.axis.get(\"labelFormat\")]) + \", \";","                msg += valueItem.displayName + \": \" + valueItem.axis.formatLabel.apply(this, [valueItem.value, valueItem.axis.get(\"labelFormat\")]) + \", \";","            }","           else","            {","                msg += \"No data available.\";","            }","            msg += (itemIndex + 1) + \" of \" + dataLength + \". \";","        }","        return msg;","    }","}, {","    ATTRS: {","        /**","         * Indicates whether axis labels are allowed to overflow beyond the bounds of the chart's content box.","         *","         * @attribute allowContentOverflow","         * @type Boolean","         */","        allowContentOverflow: {","            value: false","        },","","        /**","         * Style object for the axes.","         *","         * @attribute axesStyles","         * @type Object","         * @private","         */","        axesStyles: {","            getter: function()","            {","                var axes = this.get(\"axes\"),","                    i,","                    styles = this._axesStyles;","                if(axes)","                {","                    for(i in axes)","                    {","                        if(axes.hasOwnProperty(i) && axes[i] instanceof Y.Axis)","                        {","                            if(!styles)","                            {","                                styles = {};","                            }","                            styles[i] = axes[i].get(\"styles\");","                        }","                    }","                }","                return styles;","            },","","            setter: function(val)","            {","                var axes = this.get(\"axes\"),","                    i;","                for(i in val)","                {","                    if(val.hasOwnProperty(i) && axes.hasOwnProperty(i))","                    {","                        this._setBaseAttribute(axes[i], \"styles\", val[i]);","                    }","                }","            }","        },","","        /**","         * Style object for the series","         *","         * @attribute seriesStyles","         * @type Object","         * @private","         */","        seriesStyles: {","            getter: function()","            {","                var styles = this._seriesStyles,","                    graph = this.get(\"graph\"),","                    dict,","                    i;","                if(graph)","                {","                    dict = graph.get(\"seriesDictionary\");","                    if(dict)","                    {","                        styles = {};","                        for(i in dict)","                        {","                            if(dict.hasOwnProperty(i))","                            {","                                styles[i] = dict[i].get(\"styles\");","                            }","                        }","                    }","                }","                return styles;","            },","","            setter: function(val)","            {","                var i,","                    l,","                    s;","","                if(Y_Lang.isArray(val))","                {","                    s = this.get(\"seriesCollection\");","                    i = 0;","                    l = val.length;","","                    for(; i < l; ++i)","                    {","                        this._setBaseAttribute(s[i], \"styles\", val[i]);","                    }","                }","                else","                {","                    for(i in val)","                    {","                        if(val.hasOwnProperty(i))","                        {","                            s = this.getSeries(i);","                            this._setBaseAttribute(s, \"styles\", val[i]);","                        }","                    }","                }","            }","        },","","        /**","         * Styles for the graph.","         *","         * @attribute graphStyles","         * @type Object","         * @private","         */","        graphStyles: {","            getter: function()","            {","                var graph = this.get(\"graph\");","                if(graph)","                {","                    return(graph.get(\"styles\"));","                }","                return this._graphStyles;","            },","","            setter: function(val)","            {","                var graph = this.get(\"graph\");","                this._setBaseAttribute(graph, \"styles\", val);","            }","","        },","","        /**","         * Style properties for the chart. Contains a key indexed hash of the following:","         *  <dl>","         *      <dt>series</dt><dd>A key indexed hash containing references to the `styles` attribute for each series in the chart.","         *      Specific style attributes vary depending on the series:","         *      <ul>","         *          <li><a href=\"AreaSeries.html#attr_styles\">AreaSeries</a></li>","         *          <li><a href=\"BarSeries.html#attr_styles\">BarSeries</a></li>","         *          <li><a href=\"ColumnSeries.html#attr_styles\">ColumnSeries</a></li>","         *          <li><a href=\"ComboSeries.html#attr_styles\">ComboSeries</a></li>","         *          <li><a href=\"LineSeries.html#attr_styles\">LineSeries</a></li>","         *          <li><a href=\"MarkerSeries.html#attr_styles\">MarkerSeries</a></li>","         *          <li><a href=\"SplineSeries.html#attr_styles\">SplineSeries</a></li>","         *      </ul>","         *      </dd>","         *      <dt>axes</dt><dd>A key indexed hash containing references to the `styles` attribute for each axes in the chart. Specific","         *      style attributes can be found in the <a href=\"Axis.html#attr_styles\">Axis</a> class.</dd>","         *      <dt>graph</dt><dd>A reference to the `styles` attribute in the chart. Specific style attributes can be found in the","         *      <a href=\"Graph.html#attr_styles\">Graph</a> class.</dd>","         *  </dl>","         *","         * @attribute styles","         * @type Object","         */","        styles: {","            getter: function()","            {","                var styles = {","                    axes: this.get(\"axesStyles\"),","                    series: this.get(\"seriesStyles\"),","                    graph: this.get(\"graphStyles\")","                };","                return styles;","            },","            setter: function(val)","            {","                if(val.hasOwnProperty(\"axes\"))","                {","                    if(this.get(\"axesStyles\"))","                    {","                        this.set(\"axesStyles\", val.axes);","                    }","                    else","                    {","                        this._axesStyles = val.axes;","                    }","                }","                if(val.hasOwnProperty(\"series\"))","                {","                    if(this.get(\"seriesStyles\"))","                    {","                        this.set(\"seriesStyles\", val.series);","                    }","                    else","                    {","                        this._seriesStyles = val.series;","                    }","                }","                if(val.hasOwnProperty(\"graph\"))","                {","                    this.set(\"graphStyles\", val.graph);","                }","            }","        },","","        /**","         * Axes to appear in the chart. This can be a key indexed hash of axis instances or object literals","         * used to construct the appropriate axes.","         *","         * @attribute axes","         * @type Object","         */","        axes: {","            valueFn: \"_getDefaultAxes\",","","            setter: function(val)","            {","                if(this.get(\"dataProvider\"))","                {","                    val = this._setAxes(val);","                }","                return val;","            }","        },","","        /**","         * Collection of series to appear on the chart. This can be an array of Series instances or object literals","         * used to construct the appropriate series.","         *","         * @attribute seriesCollection","         * @type Array","         */","        seriesCollection: {","            valueFn: \"_getDefaultSeriesCollection\",","","            setter: function(val)","            {","                if(this.get(\"dataProvider\"))","                {","                    val = this._parseSeriesCollection(val);","                }","                return val;","            }","        },","","        /**","         * Reference to the left-aligned axes for the chart.","         *","         * @attribute leftAxesCollection","         * @type Array","         * @private","         */","        leftAxesCollection: {},","","        /**","         * Reference to the bottom-aligned axes for the chart.","         *","         * @attribute bottomAxesCollection","         * @type Array","         * @private","         */","        bottomAxesCollection: {},","","        /**","         * Reference to the right-aligned axes for the chart.","         *","         * @attribute rightAxesCollection","         * @type Array","         * @private","         */","        rightAxesCollection: {},","","        /**","         * Reference to the top-aligned axes for the chart.","         *","         * @attribute topAxesCollection","         * @type Array","         * @private","         */","        topAxesCollection: {},","","        /**","         * Indicates whether or not the chart is stacked.","         *","         * @attribute stacked","         * @type Boolean","         */","        stacked: {","            value: false","        },","","        /**","         * Direction of chart's category axis when there is no series collection specified. Charts can","         * be horizontal or vertical. When the chart type is column, the chart is horizontal.","         * When the chart type is bar, the chart is vertical.","         *","         * @attribute direction","         * @type String","         */","        direction: {","            getter: function()","            {","                var type = this.get(\"type\");","                if(type == \"bar\")","                {","                    return \"vertical\";","                }","                else if(type == \"column\")","                {","                    return \"horizontal\";","                }","                return this._direction;","            },","","            setter: function(val)","            {","                this._direction = val;","                return this._direction;","            }","        },","","        /**","         * Indicates whether or not an area is filled in a combo chart.","         *","         * @attribute showAreaFill","         * @type Boolean","         */","        showAreaFill: {},","","        /**","         * Indicates whether to display markers in a combo chart.","         *","         * @attribute showMarkers","         * @type Boolean","         */","        showMarkers:{},","","        /**","         * Indicates whether to display lines in a combo chart.","         *","         * @attribute showLines","         * @type Boolean","         */","        showLines:{},","","        /**","         * Indicates the key value used to identify a category axis in the `axes` hash. If","         * not specified, the categoryKey attribute value will be used.","         *","         * @attribute categoryAxisName","         * @type String","         */","        categoryAxisName: {","        },","","        /**","         * Indicates the key value used to identify a the series axis when an axis not generated.","         *","         * @attribute valueAxisName","         * @type String","         */","        valueAxisName: {","            value: \"values\"","        },","","        /**","         * Reference to the horizontalGridlines for the chart.","         *","         * @attribute horizontalGridlines","         * @type Gridlines","         */","        horizontalGridlines: {","            getter: function()","            {","                var graph = this.get(\"graph\");","                if(graph)","                {","                    return graph.get(\"horizontalGridlines\");","                }","                return this._horizontalGridlines;","            },","            setter: function(val)","            {","                var graph = this.get(\"graph\");","                if(val && !Y_Lang.isObject(val))","                {","                    val = {};","                }","                if(graph)","                {","                    graph.set(\"horizontalGridlines\", val);","                }","                else","                {","                    this._horizontalGridlines = val;","                }","            }","        },","","        /**","         * Reference to the verticalGridlines for the chart.","         *","         * @attribute verticalGridlines","         * @type Gridlines","         */","        verticalGridlines: {","            getter: function()","            {","                var graph = this.get(\"graph\");","                if(graph)","                {","                    return graph.get(\"verticalGridlines\");","                }","                return this._verticalGridlines;","            },","            setter: function(val)","            {","                var graph = this.get(\"graph\");","                if(val && !Y_Lang.isObject(val))","                {","                    val = {};","                }","                if(graph)","                {","                    graph.set(\"verticalGridlines\", val);","                }","                else","                {","                    this._verticalGridlines = val;","                }","            }","        },","","        /**","         * Type of chart when there is no series collection specified.","         *","         * @attribute type","         * @type String","         */","        type: {","            getter: function()","            {","                if(this.get(\"stacked\"))","                {","                    return \"stacked\" + this._type;","                }","                return this._type;","            },","","            setter: function(val)","            {","                if(this._type == \"bar\")","                {","                    if(val != \"bar\")","                    {","                        this.set(\"direction\", \"horizontal\");","                    }","                }","                else","                {","                    if(val == \"bar\")","                    {","                        this.set(\"direction\", \"vertical\");","                    }","                }","                this._type = val;","                return this._type;","            }","        },","","        /**","         * Reference to the category axis used by the chart.","         *","         * @attribute categoryAxis","         * @type Axis","         */","        categoryAxis:{}","    }","});","/**"," * The PieChart class creates a pie chart"," *"," * @module charts"," * @submodule charts-base"," * @class PieChart"," * @extends ChartBase"," * @constructor"," */","Y.PieChart = Y.Base.create(\"pieChart\", Y.Widget, [Y.ChartBase], {","    /**","     * Calculates and returns a `seriesCollection`.","     *","     * @method _getSeriesCollection","     * @return Array","     * @private","     */","    _getSeriesCollection: function()","    {","        if(this._seriesCollection)","        {","            return this._seriesCollection;","        }","        var axes = this.get(\"axes\"),","            sc = [],","            seriesKeys,","            i = 0,","            l,","            type = this.get(\"type\"),","            key,","            catAxis = \"categoryAxis\",","            catKey = \"categoryKey\",","            valAxis = \"valueAxis\",","            seriesKey = \"valueKey\";","        if(axes)","        {","            seriesKeys = axes.values.get(\"keyCollection\");","            key = axes.category.get(\"keyCollection\")[0];","            l = seriesKeys.length;","            for(; i < l; ++i)","            {","                sc[i] = {type:type};","                sc[i][catAxis] = \"category\";","                sc[i][valAxis] = \"values\";","                sc[i][catKey] = key;","                sc[i][seriesKey] = seriesKeys[i];","            }","        }","        this._seriesCollection = sc;","        return sc;","    },","","    /**","     * Creates `Axis` instances.","     *","     * @method _parseAxes","     * @param {Object} val Object containing `Axis` instances or objects in which to construct `Axis` instances.","     * @return Object","     * @private","     */","    _parseAxes: function(hash)","    {","        if(!this._axes)","        {","            this._axes = {};","        }","        var i, pos, axis, dh, config, axisClass,","            type = this.get(\"type\"),","            w = this.get(\"width\"),","            h = this.get(\"height\"),","            node = Y.Node.one(this._parentNode);","        if(!w)","        {","            this.set(\"width\", node.get(\"offsetWidth\"));","            w = this.get(\"width\");","        }","        if(!h)","        {","            this.set(\"height\", node.get(\"offsetHeight\"));","            h = this.get(\"height\");","        }","        for(i in hash)","        {","            if(hash.hasOwnProperty(i))","            {","                dh = hash[i];","                pos = type == \"pie\" ? \"none\" : dh.position;","                axisClass = this._getAxisClass(dh.type);","                config = {dataProvider:this.get(\"dataProvider\")};","                if(dh.hasOwnProperty(\"roundingUnit\"))","                {","                    config.roundingUnit = dh.roundingUnit;","                }","                config.keys = dh.keys;","                config.width = w;","                config.height = h;","                config.position = pos;","                config.styles = dh.styles;","                axis = new axisClass(config);","                axis.on(\"axisRendered\", Y.bind(this._itemRendered, this));","                this._axes[i] = axis;","            }","        }","    },","","    /**","     * Adds axes to the chart.","     *","     * @method _addAxes","     * @private","     */","    _addAxes: function()","    {","        var axes = this.get(\"axes\"),","            i,","            axis,","            p;","        if(!axes)","        {","            this.set(\"axes\", this._getDefaultAxes());","            axes = this.get(\"axes\");","        }","        if(!this._axesCollection)","        {","            this._axesCollection = [];","        }","        for(i in axes)","        {","            if(axes.hasOwnProperty(i))","            {","                axis = axes[i];","                p = axis.get(\"position\");","                if(!this.get(p + \"AxesCollection\"))","                {","                    this.set(p + \"AxesCollection\", [axis]);","                }","                else","                {","                    this.get(p + \"AxesCollection\").push(axis);","                }","                this._axesCollection.push(axis);","            }","        }","    },","","    /**","     * Renders the Graph.","     *","     * @method _addSeries","     * @private","     */","    _addSeries: function()","    {","        var graph = this.get(\"graph\"),","            seriesCollection = this.get(\"seriesCollection\");","        this._parseSeriesAxes(seriesCollection);","        graph.set(\"showBackground\", false);","        graph.set(\"width\", this.get(\"width\"));","        graph.set(\"height\", this.get(\"height\"));","        graph.set(\"seriesCollection\", seriesCollection);","        this._seriesCollection = graph.get(\"seriesCollection\");","        graph.render(this.get(\"contentBox\"));","    },","","    /**","     * Parse and sets the axes for the chart.","     *","     * @method _parseSeriesAxes","     * @param {Array} c A collection `PieSeries` instance.","     * @private","     */","    _parseSeriesAxes: function(c)","    {","        var i = 0,","            len = c.length,","            s,","            axes = this.get(\"axes\"),","            axis;","        for(; i < len; ++i)","        {","            s = c[i];","            if(s)","            {","                //If series is an actual series instance,","                //replace axes attribute string ids with axes","                if(s instanceof Y.PieSeries)","                {","                    axis = s.get(\"categoryAxis\");","                    if(axis && !(axis instanceof Y.Axis))","                    {","                        s.set(\"categoryAxis\", axes[axis]);","                    }","                    axis = s.get(\"valueAxis\");","                    if(axis && !(axis instanceof Y.Axis))","                    {","                        s.set(\"valueAxis\", axes[axis]);","                    }","                    continue;","                }","                s.categoryAxis = axes.category;","                s.valueAxis = axes.values;","                if(!s.type)","                {","                    s.type = this.get(\"type\");","                }","            }","        }","    },","","    /**","     * Generates and returns a key-indexed object containing `Axis` instances or objects used to create `Axis` instances.","     *","     * @method _getDefaultAxes","     * @return Object","     * @private","     */","    _getDefaultAxes: function()","    {","        var catKey = this.get(\"categoryKey\"),","            seriesKeys = this.get(\"seriesKeys\").concat(),","            seriesAxis = \"numeric\";","        return {","            values:{","                keys:seriesKeys,","                type:seriesAxis","            },","            category:{","                keys:[catKey],","                type:this.get(\"categoryType\")","            }","        };","    },","","    /**","     * Returns an object literal containing a categoryItem and a valueItem for a given series index.","     *","     * @method getSeriesItem","     * @param series Reference to a series.","     * @param index Index of the specified item within a series.","     * @return Object","     */","    getSeriesItems: function(series, index)","    {","        var categoryItem = {","                axis: series.get(\"categoryAxis\"),","                key: series.get(\"categoryKey\"),","                displayName: series.get(\"categoryDisplayName\")","            },","            valueItem = {","                axis: series.get(\"valueAxis\"),","                key: series.get(\"valueKey\"),","                displayName: series.get(\"valueDisplayName\")","            };","        categoryItem.value = categoryItem.axis.getKeyValueAt(categoryItem.key, index);","        valueItem.value = valueItem.axis.getKeyValueAt(valueItem.key, index);","        return {category:categoryItem, value:valueItem};","    },","","    /**","     * Handler for sizeChanged event.","     *","     * @method _sizeChanged","     * @param {Object} e Event object.","     * @private","     */","    _sizeChanged: function(e)","    {","        this._redraw();","    },","","    /**","     * Redraws the chart instance.","     *","     * @method _redraw","     * @private","     */","    _redraw: function()","    {","        var graph = this.get(\"graph\"),","            w = this.get(\"width\"),","            h = this.get(\"height\"),","            dimension;","        if(graph)","        {","            dimension = Math.min(w, h);","            graph.set(\"width\", dimension);","            graph.set(\"height\", dimension);","        }","    },","","    /**","     * Formats tooltip text for a pie chart.","     *","     * @method _tooltipLabelFunction","     * @param {Object} categoryItem An object containing the following:","     *  <dl>","     *      <dt>axis</dt><dd>The axis to which the category is bound.</dd>","     *      <dt>displayName</dt><dd>The display name set to the category (defaults to key if not provided)</dd>","     *      <dt>key</dt><dd>The key of the category.</dd>","     *      <dt>value</dt><dd>The value of the category</dd>","     *  </dl>","     * @param {Object} valueItem An object containing the following:","     *  <dl>","     *      <dt>axis</dt><dd>The axis to which the item's series is bound.</dd>","     *      <dt>displayName</dt><dd>The display name of the series. (defaults to key if not provided)</dd>","     *      <dt>key</dt><dd>The key for the series.</dd>","     *      <dt>value</dt><dd>The value for the series item.</dd>","     *  </dl>","     * @param {Number} itemIndex The index of the item within the series.","     * @param {CartesianSeries} series The `PieSeries` instance of the item.","     * @param {Number} seriesIndex The index of the series in the `seriesCollection`.","     * @return {HTML}","     * @private","     */","    _tooltipLabelFunction: function(categoryItem, valueItem, itemIndex, series, seriesIndex)","    {","        var msg = DOCUMENT.createElement(\"div\"),","            total = series.getTotalValues(),","            pct = Math.round((valueItem.value / total) * 10000)/100;","        msg.appendChild(DOCUMENT.createTextNode(categoryItem.displayName +","        \": \" + categoryItem.axis.get(\"labelFunction\").apply(this, [categoryItem.value, categoryItem.axis.get(\"labelFormat\")])));","        msg.appendChild(DOCUMENT.createElement(\"br\"));","        msg.appendChild(DOCUMENT.createTextNode(valueItem.displayName +","        \": \" + valueItem.axis.get(\"labelFunction\").apply(this, [valueItem.value, valueItem.axis.get(\"labelFormat\")])));","        msg.appendChild(DOCUMENT.createElement(\"br\"));","        msg.appendChild(DOCUMENT.createTextNode(pct + \"%\"));","        return msg;","    },","","    /**","     * Returns the appropriate message based on the key press.","     *","     * @method _getAriaMessage","     * @param {Number} key The keycode that was pressed.","     * @return String","     */","    _getAriaMessage: function(key)","    {","        var msg = \"\",","            categoryItem,","            items,","            series,","            valueItem,","            seriesIndex = 0,","            itemIndex = this._itemIndex,","            seriesCollection = this.get(\"seriesCollection\"),","            len,","            total,","            pct,","            markers;","        series = this.getSeries(parseInt(seriesIndex, 10));","        markers = series.get(\"markers\");","        len = markers && markers.length ? markers.length : 0;","        if(key === 37)","        {","            itemIndex = itemIndex > 0 ? itemIndex - 1 : len - 1;","        }","        else if(key === 39)","        {","            itemIndex = itemIndex >= len - 1 ? 0 : itemIndex + 1;","        }","        this._itemIndex = itemIndex;","        items = this.getSeriesItems(series, itemIndex);","        categoryItem = items.category;","        valueItem = items.value;","        total = series.getTotalValues();","        pct = Math.round((valueItem.value / total) * 10000)/100;","        if(categoryItem && valueItem)","        {","            msg += categoryItem.displayName + \": \" + categoryItem.axis.formatLabel.apply(this, [categoryItem.value, categoryItem.axis.get(\"labelFormat\")]) + \", \";","            msg += valueItem.displayName + \": \" + valueItem.axis.formatLabel.apply(this, [valueItem.value, valueItem.axis.get(\"labelFormat\")]) + \", \";","            msg += \"Percent of total \" + valueItem.displayName + \": \" + pct + \"%,\";","        }","        else","        {","            msg += \"No data available,\";","        }","        msg += (itemIndex + 1) + \" of \" + len + \". \";","        return msg;","    }","}, {","    ATTRS: {","        /**","         * Sets the aria description for the chart.","         *","         * @attribute ariaDescription","         * @type String","         */","        ariaDescription: {","            value: \"Use the left and right keys to navigate through items.\",","","            setter: function(val)","            {","                if(this._description)","                {","                    this._description.setContent(\"\");","                    this._description.appendChild(DOCUMENT.createTextNode(val));","                }","                return val;","            }","        },","","        /**","         * Axes to appear in the chart.","         *","         * @attribute axes","         * @type Object","         */","        axes: {","            getter: function()","            {","                return this._axes;","            },","","            setter: function(val)","            {","                this._parseAxes(val);","            }","        },","","        /**","         * Collection of series to appear on the chart. This can be an array of Series instances or object literals","         * used to describe a Series instance.","         *","         * @attribute seriesCollection","         * @type Array","         */","        seriesCollection: {","            getter: function()","            {","                return this._getSeriesCollection();","            },","","            setter: function(val)","            {","                return this._setSeriesCollection(val);","            }","        },","","        /**","         * Type of chart when there is no series collection specified.","         *","         * @attribute type","         * @type String","         */","        type: {","            value: \"pie\"","        }","    }","});","","","}, '@VERSION@', {\"requires\": [\"dom\", \"datatype-number\", \"datatype-date\", \"event-custom\", \"event-mouseenter\", \"event-touch\", \"widget\", \"widget-position\", \"widget-stack\", \"graphics\"]});"];
_yuitest_coverage["build/charts-base/charts-base.js"].lines = {"1":0,"17":0,"41":0,"43":0,"46":0,"48":0,"57":0,"77":0,"79":0,"81":0,"82":0,"84":0,"85":0,"86":0,"87":0,"88":0,"90":0,"98":0,"99":0,"107":0,"121":0,"124":0,"126":0,"128":0,"132":0,"136":0,"141":0,"143":0,"147":0,"148":0,"149":0,"150":0,"151":0,"162":0,"163":0,"169":0,"173":0,"179":0,"183":0,"187":0,"196":0,"198":0,"201":0,"203":0,"212":0,"216":0,"220":0,"225":0,"227":0,"231":0,"232":0,"233":0,"234":0,"235":0,"246":0,"247":0,"256":0,"258":0,"261":0,"263":0,"272":0,"276":0,"277":0,"286":0,"288":0,"291":0,"293":0,"302":0,"306":0,"307":0,"316":0,"318":0,"321":0,"323":0,"332":0,"336":0,"337":0,"347":0,"349":0,"360":0,"361":0,"366":0,"378":0,"380":0,"400":0,"401":0,"416":0,"418":0,"420":0,"421":0,"423":0,"425":0,"429":0,"432":0,"444":0,"453":0,"454":0,"464":0,"466":0,"476":0,"492":0,"497":0,"498":0,"500":0,"503":0,"504":0,"505":0,"507":0,"508":0,"509":0,"511":0,"512":0,"513":0,"515":0,"516":0,"517":0,"532":0,"538":0,"550":0,"556":0,"558":0,"560":0,"562":0,"564":0,"577":0,"589":0,"596":0,"598":0,"600":0,"602":0,"606":0,"608":0,"620":0,"622":0,"627":0,"628":0,"630":0,"642":0,"651":0,"652":0,"653":0,"655":0,"657":0,"658":0,"659":0,"660":0,"674":0,"685":0,"687":0,"688":0,"690":0,"692":0,"694":0,"696":0,"697":0,"701":0,"702":0,"704":0,"705":0,"706":0,"707":0,"708":0,"720":0,"726":0,"728":0,"729":0,"731":0,"733":0,"734":0,"736":0,"738":0,"739":0,"743":0,"744":0,"746":0,"747":0,"761":0,"762":0,"764":0,"766":0,"768":0,"770":0,"772":0,"776":0,"778":0,"800":0,"808":0,"810":0,"812":0,"813":0,"817":0,"826":0,"828":0,"838":0,"854":0,"859":0,"860":0,"862":0,"865":0,"866":0,"867":0,"869":0,"870":0,"871":0,"873":0,"874":0,"875":0,"877":0,"878":0,"879":0,"894":0,"900":0,"912":0,"919":0,"921":0,"923":0,"925":0,"927":0,"940":0,"952":0,"959":0,"961":0,"963":0,"965":0,"969":0,"971":0,"983":0,"985":0,"990":0,"991":0,"993":0,"1005":0,"1014":0,"1015":0,"1016":0,"1018":0,"1020":0,"1021":0,"1022":0,"1023":0,"1037":0,"1048":0,"1050":0,"1052":0,"1054":0,"1056":0,"1058":0,"1059":0,"1061":0,"1063":0,"1067":0,"1068":0,"1070":0,"1071":0,"1072":0,"1073":0,"1074":0,"1075":0,"1076":0,"1088":0,"1094":0,"1096":0,"1098":0,"1100":0,"1101":0,"1103":0,"1105":0,"1109":0,"1110":0,"1112":0,"1113":0,"1127":0,"1128":0,"1130":0,"1132":0,"1134":0,"1136":0,"1138":0,"1142":0,"1144":0,"1156":0,"1159":0,"1170":0,"1175":0,"1177":0,"1179":0,"1180":0,"1184":0,"1193":0,"1195":0,"1205":0,"1221":0,"1226":0,"1227":0,"1229":0,"1232":0,"1233":0,"1234":0,"1236":0,"1237":0,"1238":0,"1240":0,"1241":0,"1242":0,"1244":0,"1245":0,"1246":0,"1258":0,"1264":0,"1266":0,"1268":0,"1270":0,"1272":0,"1286":0,"1292":0,"1305":0,"1317":0,"1324":0,"1326":0,"1328":0,"1330":0,"1334":0,"1336":0,"1348":0,"1350":0,"1355":0,"1356":0,"1358":0,"1370":0,"1379":0,"1380":0,"1381":0,"1383":0,"1385":0,"1386":0,"1387":0,"1388":0,"1402":0,"1413":0,"1415":0,"1417":0,"1419":0,"1421":0,"1423":0,"1424":0,"1428":0,"1430":0,"1431":0,"1432":0,"1433":0,"1434":0,"1435":0,"1436":0,"1448":0,"1455":0,"1457":0,"1458":0,"1460":0,"1462":0,"1463":0,"1467":0,"1468":0,"1470":0,"1471":0,"1485":0,"1486":0,"1488":0,"1490":0,"1492":0,"1496":0,"1498":0,"1510":0,"1511":0,"1522":0,"1527":0,"1529":0,"1531":0,"1534":0,"1543":0,"1545":0,"1555":0,"1571":0,"1576":0,"1577":0,"1578":0,"1581":0,"1582":0,"1583":0,"1585":0,"1586":0,"1587":0,"1589":0,"1590":0,"1591":0,"1593":0,"1594":0,"1595":0,"1607":0,"1614":0,"1616":0,"1618":0,"1620":0,"1622":0,"1636":0,"1642":0,"1655":0,"1667":0,"1674":0,"1676":0,"1678":0,"1680":0,"1684":0,"1686":0,"1698":0,"1700":0,"1705":0,"1706":0,"1708":0,"1720":0,"1729":0,"1730":0,"1731":0,"1733":0,"1735":0,"1736":0,"1737":0,"1738":0,"1752":0,"1762":0,"1764":0,"1765":0,"1769":0,"1771":0,"1772":0,"1774":0,"1776":0,"1778":0,"1780":0,"1781":0,"1785":0,"1788":0,"1789":0,"1790":0,"1791":0,"1792":0,"1804":0,"1810":0,"1812":0,"1813":0,"1817":0,"1819":0,"1820":0,"1822":0,"1824":0,"1826":0,"1828":0,"1829":0,"1833":0,"1836":0,"1837":0,"1851":0,"1852":0,"1854":0,"1858":0,"1860":0,"1862":0,"1864":0,"1866":0,"1868":0,"1872":0,"1875":0,"1897":0,"1905":0,"1907":0,"1909":0,"1910":0,"1913":0,"1926":0,"1954":0,"1956":0,"1969":0,"1970":0,"1982":0,"1983":0,"1985":0,"1987":0,"1992":0,"1994":0,"2008":0,"2010":0,"2020":0,"2029":0,"2035":0,"2037":0,"2038":0,"2039":0,"2040":0,"2042":0,"2044":0,"2046":0,"2047":0,"2051":0,"2062":0,"2068":0,"2069":0,"2070":0,"2071":0,"2072":0,"2074":0,"2078":0,"2080":0,"2081":0,"2082":0,"2083":0,"2084":0,"2097":0,"2152":0,"2164":0,"2169":0,"2170":0,"2171":0,"2173":0,"2203":0,"2204":0,"2217":0,"2219":0,"2222":0,"2223":0,"2225":0,"2226":0,"2228":0,"2229":0,"2232":0,"2237":0,"2255":0,"2257":0,"2258":0,"2260":0,"2261":0,"2262":0,"2264":0,"2288":0,"2289":0,"2290":0,"2291":0,"2292":0,"2297":0,"2298":0,"2299":0,"2300":0,"2301":0,"2302":0,"2303":0,"2304":0,"2305":0,"2307":0,"2311":0,"2312":0,"2313":0,"2315":0,"2316":0,"2317":0,"2322":0,"2324":0,"2325":0,"2326":0,"2327":0,"2328":0,"2329":0,"2330":0,"2331":0,"2333":0,"2335":0,"2337":0,"2338":0,"2339":0,"2340":0,"2341":0,"2342":0,"2343":0,"2344":0,"2346":0,"2348":0,"2349":0,"2350":0,"2352":0,"2353":0,"2355":0,"2357":0,"2358":0,"2360":0,"2362":0,"2364":0,"2368":0,"2369":0,"2371":0,"2375":0,"2376":0,"2389":0,"2398":0,"2399":0,"2400":0,"2402":0,"2403":0,"2405":0,"2410":0,"2411":0,"2413":0,"2416":0,"2417":0,"2428":0,"2432":0,"2434":0,"2435":0,"2437":0,"2439":0,"2440":0,"2442":0,"2444":0,"2456":0,"2462":0,"2464":0,"2469":0,"2470":0,"2472":0,"2473":0,"2474":0,"2475":0,"2476":0,"2478":0,"2480":0,"2482":0,"2485":0,"2486":0,"2488":0,"2490":0,"2493":0,"2494":0,"2495":0,"2496":0,"2498":0,"2500":0,"2501":0,"2503":0,"2505":0,"2506":0,"2521":0,"2529":0,"2531":0,"2535":0,"2536":0,"2537":0,"2539":0,"2541":0,"2543":0,"2546":0,"2547":0,"2548":0,"2549":0,"2551":0,"2553":0,"2556":0,"2567":0,"2569":0,"2571":0,"2576":0,"2578":0,"2589":0,"2591":0,"2594":0,"2596":0,"2597":0,"2598":0,"2599":0,"2602":0,"2614":0,"2617":0,"2619":0,"2623":0,"2636":0,"2642":0,"2644":0,"2648":0,"2650":0,"2663":0,"2667":0,"2669":0,"2673":0,"2675":0,"2689":0,"2690":0,"2692":0,"2696":0,"2698":0,"2710":0,"2714":0,"2716":0,"2720":0,"2733":0,"2739":0,"2743":0,"2745":0,"2749":0,"2754":0,"2756":0,"2769":0,"2777":0,"2779":0,"2780":0,"2781":0,"2782":0,"2786":0,"2787":0,"2789":0,"2791":0,"2795":0,"2796":0,"2797":0,"2798":0,"2799":0,"2800":0,"2801":0,"2803":0,"2807":0,"2809":0,"2810":0,"2811":0,"2815":0,"2816":0,"2818":0,"2820":0,"2839":0,"2841":0,"2842":0,"2843":0,"2844":0,"2845":0,"2856":0,"2867":0,"2880":0,"2885":0,"2886":0,"2887":0,"2888":0,"2889":0,"2890":0,"2891":0,"2892":0,"2893":0,"2894":0,"2895":0,"2896":0,"2897":0,"2898":0,"2910":0,"2912":0,"2913":0,"2915":0,"2916":0,"2917":0,"2930":0,"2935":0,"2937":0,"2939":0,"2940":0,"2941":0,"2942":0,"2945":0,"2947":0,"2971":0,"2972":0,"2974":0,"2976":0,"2978":0,"2980":0,"2982":0,"2984":0,"3004":0,"3006":0,"3008":0,"3013":0,"3014":0,"3033":0,"3035":0,"3037":0,"3042":0,"3043":0,"3058":0,"3063":0,"3064":0,"3079":0,"3084":0,"3085":0,"3120":0,"3122":0,"3123":0,"3125":0,"3128":0,"3143":0,"3145":0,"3146":0,"3148":0,"3151":0,"3172":0,"3173":0,"3175":0,"3177":0,"3235":0,"3250":0,"3252":0,"3254":0,"3270":0,"3292":0,"3297":0,"3298":0,"3332":0,"3353":0,"3374":0,"3442":0,"3449":0,"3450":0,"3451":0,"3452":0,"3453":0,"3454":0,"3455":0,"3456":0,"3465":0,"3466":0,"3467":0,"3468":0,"3469":0,"3470":0,"3471":0,"3483":0,"3486":0,"3488":0,"3490":0,"3492":0,"3496":0,"3498":0,"3585":0,"3599":0,"3603":0,"3605":0,"3606":0,"3608":0,"3621":0,"3626":0,"3628":0,"3629":0,"3631":0,"3632":0,"3643":0,"3645":0,"3646":0,"3648":0,"3650":0,"3653":0,"3665":0,"3666":0,"3668":0,"3669":0,"3683":0,"3685":0,"3687":0,"3689":0,"3701":0,"3702":0,"3704":0,"3706":0,"3717":0,"3723":0,"3725":0,"3726":0,"3727":0,"3729":0,"3731":0,"3732":0,"3734":0,"3736":0,"3737":0,"3741":0,"3742":0,"3753":0,"3756":0,"3758":0,"3760":0,"3762":0,"3764":0,"3778":0,"3779":0,"3781":0,"3783":0,"3785":0,"3787":0,"3801":0,"3815":0,"3819":0,"3820":0,"3821":0,"3833":0,"3834":0,"3848":0,"3850":0,"3852":0,"3864":0,"3876":0,"3891":0,"3895":0,"3897":0,"3898":0,"3900":0,"3904":0,"3906":0,"3907":0,"3911":0,"3913":0,"3915":0,"3919":0,"3920":0,"3959":0,"3973":0,"3987":0,"3989":0,"3991":0,"4006":0,"4010":0,"4012":0,"4014":0,"4016":0,"4018":0,"4022":0,"4023":0,"4037":0,"4039":0,"4041":0,"4056":0,"4057":0,"4059":0,"4061":0,"4065":0,"4066":0,"4082":0,"4098":0,"4111":0,"4113":0,"4115":0,"4128":0,"4131":0,"4133":0,"4135":0,"4138":0,"4154":0,"4156":0,"4159":0,"4161":0,"4189":0,"4191":0,"4193":0,"4215":0,"4227":0,"4229":0,"4231":0,"4243":0,"4248":0,"4250":0,"4251":0,"4253":0,"4256":0,"4280":0,"4293":0,"4298":0,"4300":0,"4301":0,"4305":0,"4307":0,"4309":0,"4311":0,"4323":0,"4332":0,"4334":0,"4336":0,"4337":0,"4339":0,"4340":0,"4342":0,"4344":0,"4346":0,"4348":0,"4350":0,"4351":0,"4355":0,"4356":0,"4357":0,"4360":0,"4362":0,"4364":0,"4366":0,"4370":0,"4372":0,"4374":0,"4376":0,"4378":0,"4382":0,"4385":0,"4386":0,"4389":0,"4403":0,"4418":0,"4420":0,"4422":0,"4423":0,"4425":0,"4427":0,"4428":0,"4432":0,"4434":0,"4436":0,"4438":0,"4441":0,"4443":0,"4447":0,"4450":0,"4452":0,"4454":0,"4455":0,"4456":0,"4457":0,"4458":0,"4460":0,"4462":0,"4464":0,"4465":0,"4466":0,"4467":0,"4471":0,"4473":0,"4477":0,"4480":0,"4482":0,"4484":0,"4485":0,"4486":0,"4487":0,"4491":0,"4493":0,"4497":0,"4502":0,"4503":0,"4504":0,"4505":0,"4510":0,"4512":0,"4514":0,"4516":0,"4520":0,"4521":0,"4527":0,"4529":0,"4531":0,"4535":0,"4538":0,"4540":0,"4542":0,"4543":0,"4544":0,"4548":0,"4549":0,"4554":0,"4558":0,"4560":0,"4562":0,"4564":0,"4567":0,"4568":0,"4570":0,"4572":0,"4574":0,"4576":0,"4578":0,"4579":0,"4580":0,"4582":0,"4584":0,"4585":0,"4589":0,"4590":0,"4592":0,"4593":0,"4594":0,"4598":0,"4599":0,"4601":0,"4603":0,"4604":0,"4609":0,"4610":0,"4612":0,"4614":0,"4616":0,"4617":0,"4618":0,"4620":0,"4622":0,"4626":0,"4627":0,"4632":0,"4634":0,"4635":0,"4636":0,"4637":0,"4638":0,"4639":0,"4641":0,"4643":0,"4645":0,"4647":0,"4649":0,"4651":0,"4655":0,"4657":0,"4659":0,"4661":0,"4662":0,"4666":0,"4668":0,"4672":0,"4674":0,"4678":0,"4679":0,"4693":0,"4698":0,"4700":0,"4702":0,"4704":0,"4706":0,"4710":0,"4711":0,"4713":0,"4715":0,"4717":0,"4732":0,"4733":0,"4735":0,"4737":0,"4738":0,"4753":0,"4754":0,"4756":0,"4758":0,"4773":0,"4774":0,"4776":0,"4778":0,"4793":0,"4794":0,"4795":0,"4809":0,"4812":0,"4814":0,"4816":0,"4817":0,"4818":0,"4819":0,"4821":0,"4823":0,"4827":0,"4839":0,"4841":0,"4844":0,"4847":0,"4857":0,"4869":0,"4871":0,"4873":0,"4876":0,"4878":0,"4879":0,"4880":0,"4882":0,"4884":0,"4885":0,"4887":0,"4889":0,"4891":0,"4895":0,"4899":0,"4901":0,"4905":0,"4907":0,"4909":0,"4913":0,"4916":0,"4917":0,"4918":0,"4920":0,"4922":0,"4924":0,"4926":0,"4930":0,"4942":0,"4944":0,"4947":0,"4949":0,"4964":0,"4965":0,"4982":0,"4983":0,"4996":0,"4997":0,"4999":0,"5001":0,"5005":0,"5006":0,"5019":0,"5020":0,"5022":0,"5024":0,"5028":0,"5029":0,"5050":0,"5051":0,"5053":0,"5055":0,"5070":0,"5081":0,"5082":0,"5084":0,"5086":0,"5118":0,"5123":0,"5124":0,"5125":0,"5127":0,"5131":0,"5133":0,"5147":0,"5152":0,"5154":0,"5155":0,"5157":0,"5161":0,"5162":0,"5164":0,"5166":0,"5168":0,"5170":0,"5174":0,"5176":0,"5178":0,"5183":0,"5186":0,"5188":0,"5201":0,"5207":0,"5209":0,"5210":0,"5212":0,"5216":0,"5217":0,"5219":0,"5221":0,"5223":0,"5225":0,"5229":0,"5231":0,"5233":0,"5238":0,"5241":0,"5243":0,"5244":0,"5257":0,"5259":0,"5261":0,"5263":0,"5266":0,"5270":0,"5282":0,"5284":0,"5287":0,"5289":0,"5301":0,"5338":0,"5339":0,"5353":0,"5358":0,"5360":0,"5362":0,"5364":0,"5365":0,"5366":0,"5368":0,"5369":0,"5382":0,"5388":0,"5390":0,"5392":0,"5394":0,"5395":0,"5396":0,"5398":0,"5399":0,"5400":0,"5412":0,"5414":0,"5416":0,"5417":0,"5419":0,"5421":0,"5434":0,"5448":0,"5449":0,"5451":0,"5453":0,"5455":0,"5457":0,"5471":0,"5484":0,"5486":0,"5488":0,"5490":0,"5504":0,"5507":0,"5509":0,"5513":0,"5515":0,"5527":0,"5529":0,"5541":0,"5544":0,"5548":0,"5558":0,"5562":0,"5574":0,"5582":0,"5584":0,"5587":0,"5595":0,"5597":0,"5598":0,"5599":0,"5600":0,"5601":0,"5604":0,"5606":0,"5607":0,"5608":0,"5611":0,"5612":0,"5613":0,"5614":0,"5615":0,"5616":0,"5618":0,"5620":0,"5621":0,"5623":0,"5625":0,"5626":0,"5630":0,"5631":0,"5635":0,"5648":0,"5653":0,"5654":0,"5656":0,"5657":0,"5658":0,"5661":0,"5663":0,"5666":0,"5669":0,"5678":0,"5680":0,"5698":0,"5700":0,"5704":0,"5716":0,"5732":0,"5734":0,"5735":0,"5736":0,"5740":0,"5742":0,"5744":0,"5746":0,"5748":0,"5749":0,"5751":0,"5752":0,"5754":0,"5755":0,"5757":0,"5761":0,"5765":0,"5767":0,"5771":0,"5774":0,"5775":0,"5776":0,"5778":0,"5780":0,"5781":0,"5782":0,"5785":0,"5786":0,"5797":0,"5814":0,"5816":0,"5817":0,"5818":0,"5822":0,"5824":0,"5826":0,"5828":0,"5830":0,"5831":0,"5833":0,"5834":0,"5836":0,"5837":0,"5839":0,"5843":0,"5847":0,"5849":0,"5853":0,"5856":0,"5857":0,"5858":0,"5860":0,"5862":0,"5863":0,"5864":0,"5867":0,"5868":0,"5884":0,"5896":0,"5898":0,"5899":0,"5901":0,"5903":0,"5905":0,"5906":0,"5907":0,"5909":0,"5912":0,"5913":0,"5915":0,"5916":0,"5932":0,"5935":0,"5937":0,"5938":0,"5940":0,"5954":0,"5957":0,"5959":0,"5960":0,"5962":0,"5978":0,"5990":0,"5992":0,"5993":0,"5995":0,"5998":0,"5999":0,"6001":0,"6002":0,"6003":0,"6006":0,"6007":0,"6009":0,"6010":0,"6015":0,"6024":0,"6026":0,"6043":0,"6044":0,"6046":0,"6048":0,"6049":0,"6061":0,"6063":0,"6075":0,"6077":0,"6079":0,"6103":0,"6105":0,"6106":0,"6110":0,"6111":0,"6113":0,"6114":0,"6119":0,"6121":0,"6122":0,"6123":0,"6124":0,"6126":0,"6127":0,"6129":0,"6131":0,"6132":0,"6134":0,"6136":0,"6138":0,"6142":0,"6147":0,"6149":0,"6153":0,"6155":0,"6161":0,"6164":0,"6165":0,"6166":0,"6168":0,"6179":0,"6181":0,"6183":0,"6198":0,"6203":0,"6204":0,"6206":0,"6207":0,"6208":0,"6209":0,"6210":0,"6211":0,"6212":0,"6214":0,"6231":0,"6232":0,"6233":0,"6242":0,"6243":0,"6245":0,"6247":0,"6248":0,"6249":0,"6250":0,"6253":0,"6254":0,"6256":0,"6258":0,"6260":0,"6262":0,"6265":0,"6277":0,"6290":0,"6291":0,"6299":0,"6301":0,"6305":0,"6310":0,"6311":0,"6315":0,"6316":0,"6319":0,"6329":0,"6330":0,"6332":0,"6333":0,"6335":0,"6347":0,"6349":0,"6363":0,"6365":0,"6367":0,"6381":0,"6382":0,"6386":0,"6387":0,"6389":0,"6390":0,"6391":0,"6392":0,"6394":0,"6396":0,"6398":0,"6399":0,"6400":0,"6401":0,"6405":0,"6407":0,"6408":0,"6410":0,"6411":0,"6412":0,"6423":0,"6425":0,"6427":0,"6443":0,"6447":0,"6448":0,"6449":0,"6451":0,"6452":0,"6453":0,"6454":0,"6455":0,"6456":0,"6457":0,"6459":0,"6461":0,"6462":0,"6466":0,"6467":0,"6469":0,"6470":0,"6481":0,"6483":0,"6485":0,"6507":0,"6508":0,"6509":0,"6510":0,"6511":0,"6515":0,"6516":0,"6517":0,"6519":0,"6520":0,"6521":0,"6522":0,"6523":0,"6524":0,"6525":0,"6527":0,"6529":0,"6530":0,"6531":0,"6532":0,"6533":0,"6534":0,"6535":0,"6537":0,"6538":0,"6539":0,"6540":0,"6541":0,"6542":0,"6543":0,"6548":0,"6550":0,"6551":0,"6555":0,"6556":0,"6560":0,"6561":0,"6582":0,"6586":0,"6588":0,"6589":0,"6590":0,"6591":0,"6592":0,"6593":0,"6597":0,"6598":0,"6599":0,"6600":0,"6601":0,"6602":0,"6604":0,"6605":0,"6606":0,"6622":0,"6624":0,"6626":0,"6627":0,"6629":0,"6632":0,"6648":0,"6650":0,"6652":0,"6653":0,"6657":0,"6658":0,"6660":0,"6672":0,"6693":0,"6695":0,"6698":0,"6699":0,"6700":0,"6701":0,"6703":0,"6704":0,"6705":0,"6706":0,"6710":0,"6711":0,"6712":0,"6713":0,"6715":0,"6717":0,"6718":0,"6719":0,"6720":0,"6721":0,"6725":0,"6728":0,"6729":0,"6730":0,"6731":0,"6733":0,"6734":0,"6735":0,"6737":0,"6738":0,"6739":0,"6741":0,"6742":0,"6743":0,"6744":0,"6746":0,"6748":0,"6749":0,"6750":0,"6752":0,"6753":0,"6754":0,"6755":0,"6757":0,"6758":0,"6759":0,"6761":0,"6763":0,"6764":0,"6765":0,"6767":0,"6769":0,"6770":0,"6771":0,"6774":0,"6775":0,"6776":0,"6777":0,"6780":0,"6781":0,"6782":0,"6794":0,"6798":0,"6799":0,"6808":0,"6810":0,"6814":0,"6818":0,"6821":0,"6839":0,"6841":0,"6843":0,"6862":0,"6864":0,"6865":0,"6866":0,"6868":0,"6869":0,"6871":0,"6883":0,"6885":0,"6887":0,"6889":0,"6891":0,"6893":0,"6894":0,"6896":0,"6897":0,"6898":0,"6900":0,"6901":0,"6903":0,"6905":0,"6907":0,"6909":0,"6912":0,"6913":0,"6914":0,"6916":0,"6942":0,"6944":0,"6946":0,"6959":0,"6975":0,"6976":0,"6977":0,"7011":0,"7013":0,"7015":0,"7016":0,"7017":0,"7018":0,"7020":0,"7022":0,"7024":0,"7025":0,"7027":0,"7030":0,"7034":0,"7036":0,"7037":0,"7052":0,"7055":0,"7056":0,"7057":0,"7058":0,"7059":0,"7070":0,"7072":0,"7073":0,"7075":0,"7077":0,"7081":0,"7083":0,"7095":0,"7101":0,"7103":0,"7105":0,"7106":0,"7108":0,"7111":0,"7112":0,"7120":0,"7121":0,"7122":0,"7124":0,"7126":0,"7128":0,"7130":0,"7132":0,"7134":0,"7135":0,"7136":0,"7148":0,"7152":0,"7154":0,"7155":0,"7157":0,"7158":0,"7160":0,"7174":0,"7175":0,"7177":0,"7178":0,"7180":0,"7195":0,"7197":0,"7205":0,"7206":0,"7207":0,"7208":0,"7209":0,"7210":0,"7211":0,"7212":0,"7213":0,"7228":0,"7230":0,"7232":0,"7245":0,"7246":0,"7259":0,"7261":0,"7262":0,"7263":0,"7265":0,"7267":0,"7269":0,"7272":0,"7285":0,"7286":0,"7289":0,"7290":0,"7292":0,"7293":0,"7295":0,"7296":0,"7298":0,"7299":0,"7301":0,"7312":0,"7313":0,"7322":0,"7324":0,"7333":0,"7335":0,"7337":0,"7376":0,"7378":0,"7380":0,"7382":0,"7384":0,"7386":0,"7387":0,"7391":0,"7392":0,"7394":0,"7395":0,"7396":0,"7397":0,"7399":0,"7400":0,"7401":0,"7403":0,"7406":0,"7407":0,"7408":0,"7410":0,"7411":0,"7412":0,"7413":0,"7414":0,"7415":0,"7417":0,"7418":0,"7420":0,"7421":0,"7422":0,"7423":0,"7424":0,"7425":0,"7426":0,"7428":0,"7429":0,"7431":0,"7432":0,"7434":0,"7435":0,"7437":0,"7439":0,"7440":0,"7441":0,"7442":0,"7446":0,"7447":0,"7448":0,"7449":0,"7450":0,"7452":0,"7454":0,"7456":0,"7458":0,"7462":0,"7464":0,"7467":0,"7468":0,"7469":0,"7471":0,"7482":0,"7504":0,"7527":0,"7528":0,"7529":0,"7533":0,"7544":0,"7587":0,"7588":0,"7589":0,"7590":0,"7601":0,"7603":0,"7605":0,"7606":0,"7608":0,"7610":0,"7611":0,"7613":0,"7614":0,"7615":0,"7616":0,"7617":0,"7619":0,"7622":0,"7623":0,"7624":0,"7626":0,"7629":0,"7630":0,"7631":0,"7633":0,"7636":0,"7648":0,"7649":0,"7650":0,"7662":0,"7663":0,"7664":0,"7685":0,"7686":0,"7688":0,"7701":0,"7702":0,"7704":0,"7718":0,"7724":0,"7726":0,"7728":0,"7729":0,"7730":0,"7732":0,"7734":0,"7735":0,"7736":0,"7747":0,"7749":0,"7753":0,"7765":0,"7767":0,"7778":0,"7812":0,"7813":0,"7814":0,"7815":0,"7816":0,"7818":0,"7820":0,"7822":0,"7823":0,"7824":0,"7826":0,"7828":0,"7830":0,"7831":0,"7832":0,"7834":0,"7838":0,"7840":0,"7842":0,"7846":0,"7848":0,"7849":0,"7850":0,"7851":0,"7853":0,"7854":0,"7855":0,"7856":0,"7857":0,"7870":0,"7873":0,"7875":0,"7876":0,"7878":0,"7891":0,"7894":0,"7896":0,"7897":0,"7899":0,"7910":0,"7913":0,"7915":0,"7917":0,"7919":0,"7920":0,"7922":0,"7923":0,"7924":0,"7925":0,"7927":0,"7929":0,"7930":0,"7932":0,"7936":0,"7937":0,"7962":0,"8017":0,"8025":0,"8026":0,"8028":0,"8030":0,"8031":0,"8043":0,"8054":0,"8055":0,"8066":0,"8068":0,"8070":0,"8072":0,"8074":0,"8076":0,"8078":0,"8080":0,"8082":0,"8084":0,"8086":0,"8087":0,"8088":0,"8089":0,"8090":0,"8091":0,"8093":0,"8095":0,"8096":0,"8098":0,"8101":0,"8103":0,"8104":0,"8106":0,"8108":0,"8109":0,"8111":0,"8113":0,"8114":0,"8200":0,"8205":0,"8206":0,"8219":0,"8224":0,"8225":0,"8241":0,"8246":0,"8248":0,"8252":0,"8254":0,"8270":0,"8275":0,"8277":0,"8281":0,"8283":0,"8342":0,"8382":0,"8396":0,"8437":0,"8452":0,"8493":0,"8494":0,"8496":0,"8498":0,"8510":0,"8511":0,"8513":0,"8515":0,"8538":0,"8540":0,"8544":0,"8550":0,"8551":0,"8567":0,"8577":0,"8591":0,"8593":0,"8595":0,"8596":0,"8610":0,"8611":0,"8671":0,"8679":0,"8693":0,"8695":0,"8697":0,"8711":0,"8712":0,"8774":0,"8784":0,"8845":0,"8855":0,"8856":0,"8884":0,"8894":0,"8895":0,"8924":0,"8938":0,"8941":0,"8943":0,"8944":0,"8948":0,"8949":0,"8951":0,"8964":0,"8966":0,"8984":0,"8985":0,"8986":0,"8987":0,"8988":0,"8989":0,"8990":0,"8991":0,"8993":0,"8994":0,"8995":0,"8996":0,"8998":0,"9000":0,"9002":0,"9004":0,"9005":0,"9007":0,"9008":0,"9010":0,"9074":0,"9088":0,"9091":0,"9093":0,"9094":0,"9098":0,"9099":0,"9101":0,"9114":0,"9116":0,"9134":0,"9135":0,"9136":0,"9137":0,"9138":0,"9139":0,"9140":0,"9141":0,"9143":0,"9144":0,"9145":0,"9146":0,"9148":0,"9150":0,"9152":0,"9154":0,"9155":0,"9157":0,"9158":0,"9160":0,"9232":0,"9242":0,"9256":0,"9258":0,"9260":0,"9274":0,"9275":0,"9324":0,"9334":0,"9377":0,"9387":0,"9388":0,"9419":0,"9429":0,"9431":0,"9433":0,"9435":0,"9437":0,"9439":0,"9452":0,"9456":0,"9458":0,"9460":0,"9462":0,"9464":0,"9466":0,"9467":0,"9469":0,"9470":0,"9471":0,"9473":0,"9474":0,"9476":0,"9493":0,"9494":0,"9495":0,"9496":0,"9497":0,"9583":0,"9587":0,"9620":0,"9624":0,"9647":0,"9651":0,"9690":0,"9700":0,"9701":0,"9713":0,"9715":0,"9717":0,"9719":0,"9721":0,"9723":0,"9764":0,"9774":0,"9776":0,"9778":0,"9780":0,"9782":0,"9784":0,"9814":0,"9824":0,"9826":0,"9828":0,"9830":0,"9832":0,"9834":0,"9873":0,"9883":0,"9884":0,"9911":0,"9921":0,"9922":0,"9934":0,"9961":0,"9970":0,"9972":0,"9974":0,"10005":0,"10007":0,"10009":0,"10011":0,"10013":0,"10014":0,"10016":0,"10017":0,"10018":0,"10020":0,"10022":0,"10023":0,"10024":0,"10025":0,"10027":0,"10028":0,"10029":0,"10034":0,"10035":0,"10037":0,"10038":0,"10039":0,"10041":0,"10042":0,"10044":0,"10046":0,"10048":0,"10049":0,"10051":0,"10052":0,"10054":0,"10056":0,"10057":0,"10059":0,"10060":0,"10062":0,"10064":0,"10065":0,"10066":0,"10070":0,"10071":0,"10076":0,"10078":0,"10079":0,"10080":0,"10081":0,"10083":0,"10085":0,"10086":0,"10087":0,"10090":0,"10092":0,"10093":0,"10095":0,"10096":0,"10097":0,"10098":0,"10102":0,"10103":0,"10104":0,"10105":0,"10106":0,"10108":0,"10110":0,"10112":0,"10114":0,"10117":0,"10119":0,"10122":0,"10124":0,"10135":0,"10149":0,"10151":0,"10159":0,"10160":0,"10161":0,"10162":0,"10163":0,"10164":0,"10165":0,"10166":0,"10167":0,"10168":0,"10170":0,"10174":0,"10176":0,"10178":0,"10182":0,"10184":0,"10197":0,"10220":0,"10221":0,"10222":0,"10301":0,"10311":0,"10313":0,"10316":0,"10347":0,"10349":0,"10351":0,"10353":0,"10355":0,"10356":0,"10358":0,"10359":0,"10360":0,"10362":0,"10364":0,"10365":0,"10366":0,"10367":0,"10369":0,"10370":0,"10371":0,"10376":0,"10377":0,"10379":0,"10380":0,"10381":0,"10383":0,"10384":0,"10385":0,"10387":0,"10389":0,"10390":0,"10392":0,"10393":0,"10395":0,"10397":0,"10398":0,"10400":0,"10401":0,"10402":0,"10404":0,"10406":0,"10407":0,"10411":0,"10412":0,"10417":0,"10419":0,"10420":0,"10421":0,"10423":0,"10425":0,"10426":0,"10427":0,"10428":0,"10431":0,"10433":0,"10434":0,"10436":0,"10437":0,"10438":0,"10439":0,"10443":0,"10444":0,"10445":0,"10446":0,"10447":0,"10449":0,"10451":0,"10453":0,"10455":0,"10458":0,"10460":0,"10463":0,"10465":0,"10476":0,"10491":0,"10493":0,"10501":0,"10502":0,"10503":0,"10504":0,"10505":0,"10506":0,"10507":0,"10509":0,"10513":0,"10515":0,"10517":0,"10521":0,"10523":0,"10537":0,"10560":0,"10561":0,"10562":0,"10653":0,"10680":0,"10683":0,"10685":0,"10686":0,"10688":0,"10689":0,"10691":0,"10693":0,"10694":0,"10695":0,"10696":0,"10697":0,"10698":0,"10699":0,"10700":0,"10701":0,"10702":0,"10703":0,"10704":0,"10705":0,"10732":0,"10734":0,"10736":0,"10737":0,"10739":0,"10741":0,"10742":0,"10744":0,"10745":0,"10746":0,"10757":0,"10758":0,"10770":0,"10771":0,"10772":0,"10784":0,"10785":0,"10786":0,"10807":0,"10809":0,"10822":0,"10824":0,"10836":0,"10839":0,"10841":0,"10842":0,"10844":0,"10845":0,"10847":0,"10848":0,"10849":0,"10850":0,"10851":0,"10853":0,"10857":0,"10870":0,"10904":0,"10906":0,"10908":0,"10909":0,"10911":0,"10915":0,"10916":0,"10917":0,"10918":0,"10920":0,"10921":0,"10922":0,"10924":0,"10926":0,"10927":0,"10929":0,"10933":0,"10935":0,"10937":0,"10939":0,"10941":0,"10943":0,"10945":0,"10947":0,"10949":0,"10951":0,"10953":0,"10955":0,"10956":0,"10957":0,"10958":0,"10959":0,"10978":0,"10979":0,"10981":0,"10984":0,"10998":0,"11017":0,"11019":0,"11020":0,"11021":0,"11022":0,"11024":0,"11025":0,"11029":0,"11030":0,"11033":0,"11034":0,"11035":0,"11036":0,"11037":0,"11038":0,"11039":0,"11040":0,"11054":0,"11056":0,"11061":0,"11062":0,"11063":0,"11064":0,"11065":0,"11081":0,"11084":0,"11085":0,"11086":0,"11087":0,"11098":0,"11101":0,"11103":0,"11104":0,"11106":0,"11109":0,"11121":0,"11136":0,"11137":0,"11138":0,"11188":0,"11196":0,"11197":0,"11199":0,"11201":0,"11202":0,"11245":0,"11261":0,"11277":0,"11292":0,"11305":0,"11306":0,"11311":0,"11324":0,"11325":0,"11330":0,"11384":0,"11402":0,"11403":0,"11405":0,"11417":0,"11419":0,"11431":0,"11446":0,"11448":0,"11450":0,"11451":0,"11455":0,"11456":0,"11457":0,"11459":0,"11464":0,"11466":0,"11467":0,"11468":0,"11469":0,"11474":0,"11476":0,"11478":0,"11494":0,"11495":0,"11510":0,"11511":0,"11524":0,"11531":0,"11575":0,"11582":0,"11583":0,"11584":0,"11585":0,"11586":0,"11587":0,"11596":0,"11605":0,"11607":0,"11608":0,"11609":0,"11610":0,"11611":0,"11612":0,"11613":0,"11614":0,"11615":0,"11616":0,"11618":0,"11620":0,"11621":0,"11623":0,"11626":0,"11628":0,"11630":0,"11632":0,"11654":0,"11656":0,"11658":0,"11660":0,"11672":0,"11674":0,"11676":0,"11678":0,"11691":0,"11693":0,"11695":0,"11725":0,"11727":0,"11729":0,"11733":0,"11734":0,"11735":0,"11736":0,"11738":0,"11739":0,"11741":0,"11742":0,"11744":0,"11746":0,"11747":0,"11749":0,"11750":0,"11751":0,"11764":0,"11769":0,"11771":0,"11773":0,"11774":0,"11776":0,"11778":0,"11779":0,"11780":0,"11781":0,"11782":0,"11783":0,"11784":0,"11797":0,"11803":0,"11804":0,"11806":0,"11808":0,"11809":0,"11810":0,"11811":0,"11812":0,"11813":0,"11814":0,"11815":0,"11816":0,"11817":0,"11818":0,"11820":0,"11892":0,"11893":0,"11895":0,"11899":0,"11901":0,"11913":0,"11918":0,"11938":0,"11940":0,"11941":0,"11942":0,"11943":0,"11944":0,"11956":0,"11963":0,"11965":0,"11967":0,"11969":0,"11970":0,"11972":0,"11973":0,"11976":0,"11978":0,"11980":0,"11982":0,"11984":0,"11986":0,"11988":0,"11999":0,"12001":0,"12002":0,"12004":0,"12008":0,"12009":0,"12010":0,"12011":0,"12012":0,"12013":0,"12014":0,"12016":0,"12017":0,"12019":0,"12020":0,"12023":0,"12024":0,"12026":0,"12039":0,"12042":0,"12044":0,"12046":0,"12048":0,"12049":0,"12051":0,"12053":0,"12067":0,"12079":0,"12090":0,"12092":0,"12093":0,"12095":0,"12097":0,"12098":0,"12100":0,"12102":0,"12103":0,"12118":0,"12119":0,"12133":0,"12134":0,"12157":0,"12162":0,"12163":0,"12190":0,"12206":0,"12207":0,"12209":0,"12211":0,"12213":0,"12214":0,"12215":0,"12217":0,"12219":0,"12220":0,"12237":0,"12238":0,"12240":0,"12242":0,"12244":0,"12245":0,"12246":0,"12248":0,"12250":0,"12251":0,"12266":0,"12268":0,"12269":0,"12270":0,"12272":0,"12288":0,"12290":0,"12291":0,"12292":0,"12294":0,"12310":0,"12312":0,"12313":0,"12314":0,"12316":0,"12367":0,"12369":0,"12381":0,"12382":0,"12384":0,"12386":0,"12391":0,"12392":0,"12394":0,"12396":0,"12411":0,"12416":0,"12417":0,"12418":0,"12433":0,"12434":0,"12436":0,"12438":0,"12453":0,"12455":0,"12456":0,"12458":0,"12537":0,"12614":0,"12624":0,"12626":0,"12628":0,"12641":0,"12642":0,"12644":0,"12657":0,"12661":0,"12662":0,"12664":0,"12676":0,"12678":0,"12680":0,"12682":0,"12686":0,"12689":0,"12704":0,"12706":0,"12708":0,"12710":0,"12721":0,"12724":0,"12726":0,"12728":0,"12760":0,"12762":0,"12769":0,"12771":0,"12772":0,"12774":0,"12776":0,"12778":0,"12780":0,"12801":0,"12813":0,"12845":0,"12846":0,"12847":0,"12848":0,"12857":0,"12861":0,"12862":0,"12863":0,"12864":0,"12865":0,"12867":0,"12869":0,"12881":0,"12884":0,"12885":0,"12886":0,"12887":0,"12888":0,"12889":0,"12890":0,"12891":0,"12892":0,"12893":0,"12894":0,"12895":0,"12896":0,"12897":0,"12898":0,"12899":0,"12911":0,"12914":0,"12915":0,"12916":0,"12917":0,"12918":0,"12919":0,"12928":0,"12937":0,"12938":0,"12939":0,"12940":0,"12941":0,"12950":0,"12951":0,"12954":0,"12956":0,"12957":0,"12958":0,"12959":0,"12962":0,"12965":0,"12966":0,"12967":0,"12969":0,"12971":0,"12972":0,"12973":0,"12975":0,"12976":0,"12982":0,"12983":0,"12984":0,"12985":0,"12986":0,"12987":0,"12990":0,"12992":0,"12994":0,"12998":0,"12999":0,"13002":0,"13004":0,"13005":0,"13006":0,"13008":0,"13009":0,"13014":0,"13015":0,"13018":0,"13020":0,"13024":0,"13026":0,"13028":0,"13030":0,"13032":0,"13033":0,"13035":0,"13038":0,"13053":0,"13066":0,"13068":0,"13070":0,"13072":0,"13074":0,"13075":0,"13170":0,"13194":0,"13198":0,"13199":0,"13200":0,"13202":0,"13203":0,"13205":0,"13206":0,"13208":0,"13210":0,"13212":0,"13213":0,"13215":0,"13217":0,"13219":0,"13235":0,"13236":0,"13238":0,"13242":0,"13257":0,"13259":0,"13261":0,"13262":0,"13263":0,"13264":0,"13265":0,"13278":0,"13283":0,"13285":0,"13286":0,"13297":0,"13299":0,"13300":0,"13301":0,"13302":0,"13303":0,"13314":0,"13318":0,"13320":0,"13322":0,"13323":0,"13324":0,"13337":0,"13351":0,"13353":0,"13354":0,"13355":0,"13357":0,"13359":0,"13361":0,"13365":0,"13367":0,"13369":0,"13372":0,"13374":0,"13386":0,"13397":0,"13399":0,"13403":0,"13406":0,"13407":0,"13410":0,"13411":0,"13412":0,"13413":0,"13414":0,"13415":0,"13416":0,"13417":0,"13418":0,"13419":0,"13420":0,"13421":0,"13422":0,"13423":0,"13424":0,"13425":0,"13426":0,"13427":0,"13451":0,"13459":0,"13461":0,"13462":0,"13464":0,"13466":0,"13469":0,"13471":0,"13472":0,"13474":0,"13475":0,"13476":0,"13477":0,"13478":0,"13479":0,"13480":0,"13482":0,"13484":0,"13487":0,"13516":0,"13519":0,"13520":0,"13521":0,"13523":0,"13525":0,"13526":0,"13527":0,"13528":0,"13529":0,"13531":0,"13533":0,"13534":0,"13546":0,"13548":0,"13552":0,"13554":0,"13556":0,"13573":0,"13574":0,"13576":0,"13578":0,"13580":0,"13582":0,"13584":0,"13586":0,"13598":0,"13603":0,"13605":0,"13606":0,"13608":0,"13610":0,"13614":0,"13627":0,"13631":0,"13633":0,"13635":0,"13636":0,"13638":0,"13640":0,"13643":0,"13646":0,"13656":0,"13663":0,"13669":0,"13670":0,"13671":0,"13672":0,"13673":0,"13674":0,"13676":0,"13679":0,"13680":0,"13682":0,"13683":0,"13684":0,"13685":0,"13686":0,"13687":0,"13688":0,"13689":0,"13690":0,"13692":0,"13693":0,"13706":0,"13736":0,"13737":0,"13739":0,"13740":0,"13744":0,"13745":0,"13747":0,"13748":0,"13750":0,"13751":0,"13753":0,"13755":0,"13757":0,"13760":0,"13762":0,"13763":0,"13765":0,"13767":0,"13768":0,"13771":0,"13772":0,"13774":0,"13775":0,"13776":0,"13777":0,"13779":0,"13781":0,"13783":0,"13785":0,"13787":0,"13788":0,"13789":0,"13790":0,"13794":0,"13825":0,"13827":0,"13841":0,"13873":0,"13875":0,"13877":0,"13879":0,"13892":0,"13893":0,"13895":0,"13896":0,"13898":0,"13911":0,"13913":0,"13915":0,"13917":0,"13930":0,"13950":0,"13951":0,"13953":0,"13954":0,"13955":0,"13956":0,"13960":0,"13961":0,"13962":0,"13963":0,"13965":0,"13966":0,"13968":0,"13969":0,"13970":0,"13972":0,"13973":0,"13975":0,"13976":0,"13977":0,"13981":0,"13986":0,"13989":0,"13991":0,"13992":0,"13994":0,"13995":0,"13996":0,"13997":0,"13999":0,"14001":0,"14004":0,"14006":0,"14008":0,"14009":0,"14011":0,"14012":0,"14014":0,"14015":0,"14018":0,"14019":0,"14020":0,"14021":0,"14023":0,"14024":0,"14026":0,"14028":0,"14030":0,"14032":0,"14034":0,"14036":0,"14038":0,"14041":0,"14043":0,"14045":0,"14046":0,"14047":0,"14049":0,"14061":0,"14066":0,"14068":0,"14069":0,"14071":0,"14074":0,"14076":0,"14077":0,"14079":0,"14094":0,"14097":0,"14098":0,"14111":0,"14115":0,"14117":0,"14119":0,"14123":0,"14125":0,"14127":0,"14128":0,"14130":0,"14131":0,"14137":0,"14153":0,"14155":0,"14157":0,"14159":0,"14161":0,"14177":0,"14179":0,"14183":0,"14197":0,"14226":0,"14228":0,"14230":0,"14231":0,"14233":0,"14237":0,"14238":0,"14239":0,"14240":0,"14242":0,"14244":0,"14246":0,"14247":0,"14249":0,"14251":0,"14252":0,"14254":0,"14256":0,"14261":0,"14263":0,"14266":0,"14268":0,"14269":0,"14271":0,"14273":0,"14274":0,"14276":0,"14278":0,"14281":0,"14285":0,"14286":0,"14287":0,"14291":0,"14293":0,"14294":0,"14296":0,"14298":0,"14302":0,"14313":0,"14320":0,"14322":0,"14324":0,"14326":0,"14328":0,"14329":0,"14331":0,"14333":0,"14334":0,"14336":0,"14338":0,"14339":0,"14341":0,"14342":0,"14343":0,"14345":0,"14349":0,"14351":0,"14352":0,"14354":0,"14356":0,"14370":0,"14372":0,"14384":0,"14396":0,"14398":0,"14399":0,"14401":0,"14403":0,"14405":0,"14407":0,"14409":0,"14413":0,"14415":0,"14417":0,"14419":0,"14421":0,"14424":0,"14426":0,"14428":0,"14430":0,"14432":0,"14436":0,"14438":0,"14440":0,"14442":0,"14444":0,"14458":0,"14459":0,"14461":0,"14463":0,"14476":0,"14495":0,"14497":0,"14498":0,"14502":0,"14503":0,"14505":0,"14507":0,"14509":0,"14511":0,"14512":0,"14513":0,"14514":0,"14516":0,"14517":0,"14518":0,"14520":0,"14521":0,"14523":0,"14525":0,"14527":0,"14531":0,"14532":0,"14534":0,"14535":0,"14537":0,"14539":0,"14541":0,"14543":0,"14545":0,"14547":0,"14553":0,"14554":0,"14556":0,"14558":0,"14559":0,"14561":0,"14562":0,"14564":0,"14567":0,"14569":0,"14571":0,"14573":0,"14576":0,"14578":0,"14581":0,"14583":0,"14585":0,"14587":0,"14588":0,"14590":0,"14592":0,"14594":0,"14598":0,"14601":0,"14603":0,"14605":0,"14607":0,"14608":0,"14610":0,"14612":0,"14614":0,"14629":0,"14632":0,"14634":0,"14636":0,"14638":0,"14640":0,"14642":0,"14647":0,"14649":0,"14653":0,"14657":0,"14688":0,"14694":0,"14696":0,"14701":0,"14709":0,"14714":0,"14720":0,"14721":0,"14722":0,"14723":0,"14724":0,"14736":0,"14738":0,"14741":0,"14743":0,"14745":0,"14761":0,"14765":0,"14767":0,"14768":0,"14770":0,"14771":0,"14774":0,"14776":0,"14777":0,"14778":0,"14780":0,"14781":0,"14784":0,"14799":0,"14803":0,"14805":0,"14806":0,"14808":0,"14809":0,"14812":0,"14814":0,"14815":0,"14816":0,"14818":0,"14819":0,"14822":0,"14837":0,"14841":0,"14843":0,"14844":0,"14846":0,"14847":0,"14850":0,"14852":0,"14853":0,"14854":0,"14856":0,"14857":0,"14860":0,"14875":0,"14879":0,"14881":0,"14882":0,"14884":0,"14885":0,"14888":0,"14890":0,"14891":0,"14892":0,"14894":0,"14895":0,"14898":0,"14909":0,"14911":0,"14912":0,"14914":0,"14915":0,"14916":0,"14946":0,"14948":0,"14949":0,"14950":0,"14952":0,"14953":0,"14956":0,"14958":0,"14959":0,"14960":0,"14961":0,"14963":0,"14964":0,"14967":0,"14969":0,"14970":0,"14971":0,"14973":0,"14974":0,"14977":0,"14979":0,"14980":0,"14981":0,"14983":0,"14984":0,"14988":0,"14989":0,"14990":0,"14991":0,"14992":0,"14993":0,"14994":0,"14996":0,"14997":0,"14998":0,"14999":0,"15001":0,"15002":0,"15004":0,"15005":0,"15007":0,"15008":0,"15009":0,"15011":0,"15016":0,"15017":0,"15019":0,"15020":0,"15022":0,"15023":0,"15024":0,"15026":0,"15031":0,"15032":0,"15034":0,"15035":0,"15037":0,"15038":0,"15039":0,"15041":0,"15046":0,"15047":0,"15049":0,"15050":0,"15052":0,"15053":0,"15054":0,"15056":0,"15061":0,"15062":0,"15063":0,"15064":0,"15065":0,"15067":0,"15068":0,"15069":0,"15071":0,"15072":0,"15074":0,"15076":0,"15077":0,"15079":0,"15081":0,"15084":0,"15086":0,"15087":0,"15088":0,"15090":0,"15091":0,"15093":0,"15095":0,"15096":0,"15098":0,"15100":0,"15103":0,"15105":0,"15106":0,"15107":0,"15109":0,"15110":0,"15111":0,"15112":0,"15114":0,"15117":0,"15119":0,"15122":0,"15124":0,"15125":0,"15126":0,"15128":0,"15129":0,"15130":0,"15131":0,"15133":0,"15136":0,"15138":0,"15141":0,"15142":0,"15144":0,"15145":0,"15147":0,"15149":0,"15150":0,"15151":0,"15152":0,"15153":0,"15156":0,"15158":0,"15159":0,"15160":0,"15161":0,"15174":0,"15180":0,"15182":0,"15183":0,"15185":0,"15187":0,"15188":0,"15190":0,"15191":0,"15193":0,"15195":0,"15198":0,"15199":0,"15201":0,"15203":0,"15206":0,"15208":0,"15210":0,"15212":0,"15213":0,"15215":0,"15217":0,"15218":0,"15231":0,"15241":0,"15243":0,"15245":0,"15247":0,"15249":0,"15251":0,"15253":0,"15257":0,"15259":0,"15260":0,"15261":0,"15265":0,"15267":0,"15268":0,"15272":0,"15273":0,"15274":0,"15275":0,"15277":0,"15278":0,"15280":0,"15282":0,"15284":0,"15286":0,"15287":0,"15288":0,"15289":0,"15290":0,"15292":0,"15293":0,"15297":0,"15299":0,"15301":0,"15325":0,"15328":0,"15330":0,"15332":0,"15334":0,"15336":0,"15338":0,"15342":0,"15347":0,"15349":0,"15351":0,"15353":0,"15369":0,"15373":0,"15375":0,"15376":0,"15378":0,"15379":0,"15381":0,"15383":0,"15388":0,"15393":0,"15397":0,"15399":0,"15400":0,"15401":0,"15403":0,"15405":0,"15410":0,"15412":0,"15414":0,"15415":0,"15432":0,"15433":0,"15435":0,"15437":0,"15442":0,"15443":0,"15475":0,"15480":0,"15484":0,"15486":0,"15488":0,"15492":0,"15495":0,"15497":0,"15499":0,"15503":0,"15506":0,"15508":0,"15525":0,"15527":0,"15529":0,"15545":0,"15547":0,"15549":0,"15610":0,"15611":0,"15613":0,"15615":0,"15617":0,"15619":0,"15624":0,"15625":0,"15682":0,"15683":0,"15685":0,"15687":0,"15691":0,"15692":0,"15694":0,"15696":0,"15698":0,"15702":0,"15716":0,"15717":0,"15719":0,"15721":0,"15725":0,"15726":0,"15728":0,"15730":0,"15732":0,"15736":0,"15750":0,"15752":0,"15754":0,"15759":0,"15761":0,"15763":0,"15768":0,"15770":0,"15773":0,"15774":0,"15796":0,"15806":0,"15808":0,"15810":0,"15821":0,"15823":0,"15824":0,"15825":0,"15826":0,"15828":0,"15829":0,"15830":0,"15831":0,"15832":0,"15835":0,"15836":0,"15849":0,"15851":0,"15853":0,"15858":0,"15860":0,"15861":0,"15863":0,"15865":0,"15866":0,"15868":0,"15870":0,"15872":0,"15873":0,"15874":0,"15875":0,"15876":0,"15878":0,"15880":0,"15881":0,"15882":0,"15883":0,"15884":0,"15885":0,"15886":0,"15887":0,"15900":0,"15904":0,"15906":0,"15907":0,"15909":0,"15911":0,"15913":0,"15915":0,"15917":0,"15918":0,"15919":0,"15921":0,"15925":0,"15927":0,"15940":0,"15942":0,"15943":0,"15944":0,"15945":0,"15946":0,"15947":0,"15948":0,"15960":0,"15965":0,"15967":0,"15968":0,"15972":0,"15974":0,"15975":0,"15977":0,"15979":0,"15980":0,"15982":0,"15984":0,"15986":0,"15987":0,"15988":0,"15990":0,"16005":0,"16008":0,"16030":0,"16040":0,"16041":0,"16042":0,"16054":0,"16065":0,"16069":0,"16071":0,"16072":0,"16073":0,"16103":0,"16106":0,"16108":0,"16109":0,"16111":0,"16112":0,"16113":0,"16125":0,"16137":0,"16138":0,"16139":0,"16140":0,"16142":0,"16144":0,"16146":0,"16148":0,"16149":0,"16150":0,"16151":0,"16152":0,"16153":0,"16154":0,"16156":0,"16157":0,"16158":0,"16162":0,"16164":0,"16165":0,"16180":0,"16182":0,"16183":0,"16185":0,"16198":0,"16203":0,"16217":0,"16222":0};
_yuitest_coverage["build/charts-base/charts-base.js"].functions = {"ShapeGroup:41":0,"_draw:55":0,"_getRadiusCollection:119":0,"getter:134":0,"setter:160":0,"getter:167":0,"setter:171":0,"getter:177":0,"setter:181":0,"CircleGroup:196":0,"drawShape:210":0,"getter:218":0,"RectGroup:256":0,"drawShape:270":0,"DiamondGroup:286":0,"drawShape:300":0,"EllipseGroup:316":0,"drawShape:330":0,"Renderer:347":0,"getter:358":0,"setter:364":0,"_setStyles:398":0,"(anonymous 2):421":0,"_mergeStyles:414":0,"_getDefaultStyles:442":0,"_getDefaultMargins:474":0,"setTickOffsets:490":0,"drawTick:530":0,"getLineStart:548":0,"getLabelPoint:575":0,"updateMaxLabelSize:587":0,"getExplicitlySized:618":0,"positionTitle:640":0,"positionLabel:672":0,"_setRotationCoords:718":0,"_getTransformOrigin:759":0,"setCalculatedSize:798":0,"_getDefaultMargins:836":0,"setTickOffsets:852":0,"drawTick:892":0,"getLineStart:910":0,"getLabelPoint:938":0,"updateMaxLabelSize:950":0,"getExplicitlySized:981":0,"positionTitle:1003":0,"positionLabel:1035":0,"_setRotationCoords:1086":0,"_getTransformOrigin:1125":0,"offsetNodeForTick:1154":0,"setCalculatedSize:1168":0,"_getDefaultMargins:1203":0,"setTickOffsets:1219":0,"getLineStart:1256":0,"drawTick:1284":0,"getLabelPoint:1303":0,"updateMaxLabelSize:1315":0,"getExplicitlySized:1346":0,"positionTitle:1368":0,"positionLabel:1400":0,"_setRotationCoords:1446":0,"_getTransformOrigin:1483":0,"offsetNodeForTick:1508":0,"setCalculatedSize:1520":0,"_getDefaultMargins:1553":0,"setTickOffsets:1569":0,"getLineStart:1605":0,"drawTick:1634":0,"getLabelPoint:1653":0,"updateMaxLabelSize:1665":0,"getExplicitlySized:1696":0,"positionTitle:1718":0,"positionLabel:1750":0,"_setRotationCoords:1802":0,"_getTransformOrigin:1849":0,"setCalculatedSize:1895":0,"_dataChangeHandler:1952":0,"_positionChangeHandler:1967":0,"_updateGraphic:1980":0,"_updateHandler:2006":0,"renderUI:2018":0,"syncUI:2027":0,"_setCanvas:2060":0,"_getDefaultStyles:2095":0,"_handleSizeChange:2162":0,"drawLine:2201":0,"_getTextRotationProps:2215":0,"_drawAxis:2253":0,"_setTotalTitleSize:2387":0,"_updatePathElement:2426":0,"_setTitle:2454":0,"getLabel:2519":0,"_createLabelCache:2565":0,"_clearLabelCache:2587":0,"getLineEnd:2612":0,"getLength:2634":0,"getFirstPoint:2661":0,"getNextPoint:2687":0,"getLastPoint:2708":0,"getPosition:2731":0,"_rotate:2767":0,"_simulateRotateWithTransformOrigin:2837":0,"getMaxLabelBounds:2854":0,"getMinLabelBounds:2865":0,"_getLabelBounds:2878":0,"_removeChildren:2908":0,"destructor:2928":0,"_setText:2969":0,"getter:3002":0,"setter:3011":0,"getter:3031":0,"setter:3040":0,"getter:3056":0,"setter:3061":0,"getter:3077":0,"setter:3082":0,"getter:3118":0,"getter:3141":0,"setter:3170":0,"getter:3233":0,"getter:3248":0,"validator:3268":0,"getter:3290":0,"setter:3295":0,"value:3330":0,"valueFn:3351":0,"valueFn:3372":0,"initializer:3447":0,"bindUI:3463":0,"_dataProviderChangeHandler:3481":0,"addKey:3583":0,"_getKeyArray:3597":0,"_setDataByKey:3619":0,"_updateTotalData:3641":0,"removeKey:3663":0,"getKeyValueAt:3681":0,"getDataByKey:3699":0,"_updateMinAndMax:3715":0,"getTotalMajorUnits:3751":0,"getMajorUnitDistance:3776":0,"getEdgeOffset:3799":0,"getLabelByIndex:3813":0,"_keyChangeHandler:3831":0,"_hasDataOverflow:3846":0,"getMinimumValue:3862":0,"getMaximumValue:3874":0,"setter:3889":0,"getter:3957":0,"setter:3971":0,"getter:3985":0,"getter:4004":0,"setter:4020":0,"getter:4035":0,"getter:4054":0,"setter:4063":0,"getter:4080":0,"getter:4096":0,"getter:4109":0,"getter:4126":0,"NumericAxis:4154":0,"value:4187":0,"formatLabel:4225":0,"getTotalByKey:4241":0,"_getMinimumUnit:4278":0,"_getNiceNumber:4291":0,"_updateMinAndMax:4321":0,"_roundMinAndMax:4401":0,"getLabelByIndex:4691":0,"_roundToNearest:4730":0,"_roundUpToNearest:4751":0,"_roundDownToNearest:4771":0,"_roundToPrecision:4791":0,"_hasDataOverflow:4807":0,"StackedAxis:4839":0,"_updateMinAndMax:4855":0,"TimeAxis:4942":0,"getter:4962":0,"getter:4980":0,"getter:4994":0,"setter:5003":0,"getter:5017":0,"setter:5026":0,"value:5048":0,"formatLabel:5079":0,"getLabelByIndex:5116":0,"_getKeyArray:5145":0,"_setDataByKey:5199":0,"_getNumber:5255":0,"CategoryAxis:5282":0,"formatLabel:5299":0,"_updateMinAndMax:5336":0,"_getKeyArray:5351":0,"_setDataByKey:5380":0,"getDataByKey:5410":0,"getTotalMajorUnits:5432":0,"getMajorUnitDistance:5446":0,"getEdgeOffset:5469":0,"getKeyValueAt:5482":0,"getLabelByIndex:5502":0,"getMinimumValue:5525":0,"getMaximumValue:5539":0,"CurveUtil:5558":0,"getCurveControlPoints:5572":0,"getControlPoints:5646":0,"StackingUtil:5678":0,"_stackCoordinates:5696":0,"_stackXCoords:5714":0,"_stackYCoords:5795":0,"_cleanXNaN:5882":0,"_getPreviousValidCoordValue:5930":0,"_getNextValidCoordValue:5952":0,"_cleanYNaN:5976":0,"Lines:6024":0,"_getGraphic:6041":0,"_toggleVisible:6059":0,"drawLines:6073":0,"drawSpline:6177":0,"drawDashedLine:6229":0,"_getLineDefaults:6275":0,"getter:6303":0,"setter:6308":0,"Fills:6299":0,"_getPath:6327":0,"_toggleVisible:6345":0,"drawFill:6361":0,"drawAreaSpline:6421":0,"drawStackedAreaSpline:6479":0,"_getClosingPoints:6580":0,"_getHighestValidOrder:6620":0,"_getCoordsByOrderAndIndex:6646":0,"_getStackedClosingPoints:6670":0,"_getAreaDefaults:6792":0,"getter:6812":0,"Plots:6808":0,"drawPlots:6837":0,"_getGroupShape:6940":0,"_getPlotDefaults:6957":0,"getMarker:7009":0,"_createMarker:7050":0,"_createMarkerCache:7068":0,"_createGroupMarker:7093":0,"_toggleVisible:7146":0,"_clearMarkerCache:7172":0,"updateMarkerState:7193":0,"_getItemColor:7226":0,"_setStyles:7243":0,"_parseMarkerStyles:7257":0,"_getState:7283":0,"Histogram:7322":0,"drawSeries:7331":0,"_getPlotDefaults:7502":0,"render:7585":0,"(anonymous 3):7615":0,"(anonymous 4):7622":0,"(anonymous 5):7629":0,"addListeners:7599":0,"_xAxisChangeHandler:7646":0,"_yAxisChangeHandler:7660":0,"_xDataChangeHandler:7683":0,"_yDataChangeHandler:7699":0,"_updateAxisData:7716":0,"validate:7745":0,"_setCanvas:7763":0,"setAreaData:7776":0,"_getFirstValidIndex:7868":0,"_getLastValidIndex:7889":0,"draw:7908":0,"_getDefaultStyles:7960":0,"_getDefaultColor:8015":0,"_handleVisibleChange:8041":0,"getTotalValues:8052":0,"destructor:8064":0,"getter:8198":0,"setter:8203":0,"getter:8217":0,"setter:8222":0,"getter:8239":0,"setter:8244":0,"getter:8268":0,"setter:8273":0,"getter:8340":0,"setter:8380":0,"setter:8394":0,"getter:8435":0,"getter:8450":0,"getter:8492":0,"getter:8509":0,"getter:8536":0,"setter:8548":0,"drawSeries:8575":0,"_setStyles:8589":0,"_getDefaultStyles:8608":0,"drawSeries:8677":0,"_setStyles:8691":0,"_getDefaultStyles:8709":0,"drawSeries:8782":0,"setAreaData:8853":0,"setAreaData:8892":0,"_getMarkerDimensions:8936":0,"updateMarkerState:8962":0,"_getMarkerDimensions:9086":0,"updateMarkerState:9112":0,"drawSeries:9240":0,"_setStyles:9254":0,"_getDefaultStyles:9272":0,"drawSeries:9332":0,"drawSeries:9385":0,"drawSeries:9427":0,"_toggleVisible:9450":0,"_getDefaultStyles:9491":0,"getter:9581":0,"setter:9585":0,"getter:9618":0,"setter:9622":0,"getter:9645":0,"setter:9649":0,"setAreaData:9698":0,"drawSeries:9711":0,"drawSeries:9772":0,"drawSeries:9822":0,"setAreaData:9881":0,"setAreaData:9919":0,"drawSeries:9932":0,"drawSeries:9968":0,"updateMarkerState:10147":0,"_getPlotDefaults:10195":0,"drawSeries:10309":0,"updateMarkerState:10489":0,"_getPlotDefaults:10535":0,"_setMap:10678":0,"addListeners:10730":0,"validate:10755":0,"_categoryAxisChangeHandler:10768":0,"_valueAxisChangeHandler:10782":0,"_categoryDataChangeHandler:10805":0,"_valueDataChangeHandler:10820":0,"draw:10834":0,"drawPlots:10868":0,"_addHotspot:10996":0,"updateMarkerState:11052":0,"_createMarker:11079":0,"_clearMarkerCache:11096":0,"_getPlotDefaults:11119":0,"_getDefaultColor:11186":0,"validator:11243":0,"validator:11259":0,"validator:11275":0,"validator:11290":0,"setter:11303":0,"getter:11309":0,"setter:11322":0,"getter:11328":0,"remove:11400":0,"draw:11415":0,"_drawGridlines:11429":0,"_horizontalLine:11492":0,"_verticalLine:11508":0,"_getDefaultStyles:11522":0,"bindUI:11580":0,"syncUI:11594":0,"getSeriesByIndex:11652":0,"getSeriesByKey:11670":0,"addDispatcher:11689":0,"_parseSeriesCollection:11723":0,"_addSeries:11762":0,"_createSeries:11795":0,"_getSeries:11890":0,"_markerEventHandler:11911":0,"_updateStyles:11936":0,"_sizeChangeHandler:11954":0,"_drawSeries:11997":0,"_drawingCompleteHandler:12037":0,"_getDefaultStyles:12065":0,"destructor:12088":0,"setter:12116":0,"setter:12131":0,"getter:12155":0,"setter:12160":0,"getter:12188":0,"setter:12204":0,"setter:12235":0,"getter:12264":0,"getter:12286":0,"getter:12308":0,"ChartBase:12367":0,"valueFn:12379":0,"setter:12389":0,"getter:12409":0,"setter:12414":0,"setter:12431":0,"setter:12451":0,"setter:12535":0,"_groupMarkersChangeHandler:12622":0,"_itemRendered:12639":0,"(anonymous 6):12661":0,"_getGraph:12655":0,"getSeries:12674":0,"getAxisByKey:12702":0,"getCategoryAxis:12719":0,"_setDataValues:12758":0,"_setSeriesCollection:12799":0,"_getAxisClass:12811":0,"initializer:12843":0,"renderUI:12855":0,"_setAriaElements:12879":0,"_getAriaOffscreenNode:12909":0,"syncUI:12926":0,"(anonymous 7):12950":0,"(anonymous 8):12971":0,"(anonymous 9):13004":0,"bindUI:12935":0,"_markerEventDispatcher:13051":0,"_dataProviderChangeHandler:13192":0,"toggleTooltip:13233":0,"_showTooltip:13255":0,"_positionTooltip:13276":0,"hideTooltip:13295":0,"_addTooltip:13312":0,"_updateTooltip:13335":0,"markerEventHandler:13395":0,"planarEventHandler:13401":0,"_getTooltip:13384":0,"_planarLabelFunction:13449":0,"_tooltipLabelFunction:13514":0,"_tooltipChangeHandler:13544":0,"_setText:13571":0,"_getAllKeys:13596":0,"_buildSeriesKeys:13625":0,"renderUI:13661":0,"_planarEventDispatcher:13704":0,"_addToAxesRenderQueue:13871":0,"_addToAxesCollection:13890":0,"_getDefaultSeriesCollection:13909":0,"_parseSeriesCollection:13928":0,"_parseSeriesAxes:14059":0,"_getCategoryAxis:14092":0,"_getSeriesAxis:14109":0,"_getBaseAttribute:14151":0,"_setBaseAttribute:14175":0,"_setAxes:14195":0,"_addAxes:14311":0,"_addSeries:14368":0,"_addGridlines:14382":0,"_getDefaultAxes:14456":0,"_parseAxes:14474":0,"_getDefaultAxisPosition:14627":0,"getSeriesItems:14686":0,"_sizeChanged:14734":0,"_getTopOverflow:14759":0,"_getRightOverflow:14797":0,"_getLeftOverflow:14835":0,"_getBottomOverflow:14873":0,"_redraw:14907":0,"destructor:15172":0,"_getAriaMessage:15229":0,"getter:15323":0,"setter:15345":0,"getter:15367":0,"setter:15391":0,"getter:15430":0,"setter:15440":0,"getter:15473":0,"setter:15482":0,"setter:15523":0,"setter:15543":0,"getter:15608":0,"setter:15622":0,"getter:15680":0,"setter:15689":0,"getter:15714":0,"setter:15723":0,"getter:15748":0,"setter:15757":0,"_getSeriesCollection:15804":0,"_parseAxes:15847":0,"_addAxes:15898":0,"_addSeries:15938":0,"_parseSeriesAxes:15958":0,"_getDefaultAxes:16003":0,"getSeriesItems:16028":0,"_sizeChanged:16052":0,"_redraw:16063":0,"_tooltipLabelFunction:16101":0,"_getAriaMessage:16123":0,"setter:16178":0,"getter:16196":0,"setter:16201":0,"getter:16215":0,"setter:16220":0,"(anonymous 1):1":0};
_yuitest_coverage["build/charts-base/charts-base.js"].coveredLines = 3961;
_yuitest_coverage["build/charts-base/charts-base.js"].coveredFunctions = 489;
_yuitest_coverline("build/charts-base/charts-base.js", 1);
YUI.add('charts-base', function (Y, NAME) {

/**
 * The Charts widget provides an api for displaying data
 * graphically.
 *
 * @module charts
 * @main charts
 */

/**
 * The charts-base submodule contains the core functionality for the charts module.
 *
 * @module charts
 * @submodule charts-base
 */
_yuitest_coverfunc("build/charts-base/charts-base.js", "(anonymous 1)", 1);
_yuitest_coverline("build/charts-base/charts-base.js", 17);
var CONFIG = Y.config,
    WINDOW = CONFIG.win,
    DOCUMENT = CONFIG.doc,
    Y_Lang = Y.Lang,
    IS_STRING = Y_Lang.isString,
    Y_DOM = Y.DOM,
    LeftAxisLayout,
    RightAxisLayout,
    BottomAxisLayout,
    TopAxisLayout,
    _getClassName = Y.ClassNameManager.getClassName,
    SERIES_MARKER = _getClassName("seriesmarker"),
    ShapeGroup,
    CircleGroup,
    RectGroup,
    EllipseGroup,
    DiamondGroup;

/**
 * Abstract class for creating groups of shapes with the same styles and dimensions.
 *
 * @class ShapeGroup
 * @constructor
 */
 _yuitest_coverline("build/charts-base/charts-base.js", 41);
ShapeGroup = function(cfg)
 {
    _yuitest_coverfunc("build/charts-base/charts-base.js", "ShapeGroup", 41);
_yuitest_coverline("build/charts-base/charts-base.js", 43);
ShapeGroup.superclass.constructor.apply(this, arguments);
 };

 _yuitest_coverline("build/charts-base/charts-base.js", 46);
ShapeGroup.NAME = "shapeGroup";

 _yuitest_coverline("build/charts-base/charts-base.js", 48);
Y.extend(ShapeGroup, Y.Path, {
    /**
     * Updates the shape.
     *
     * @method _draw
     * @private
     */
    _draw: function()
    {
        _yuitest_coverfunc("build/charts-base/charts-base.js", "_draw", 55);
_yuitest_coverline("build/charts-base/charts-base.js", 57);
var xvalues = this.get("xvalues"),
            yvalues = this.get("yvalues"),
            x,
            y,
            xRad,
            yRad,
            i = 0,
            len,
            attrs = [],
            dimensions = this.get("dimensions"),
            width = dimensions.width,
            height = dimensions.height,
            radius = dimensions.radius,
            yRadius = dimensions.yRadius,
            id = this.get("id"),
            className = this.node.className,
            widthIsArray = Y_Lang.isArray(width),
            heightIsArray = Y_Lang.isArray(height),
            radiusIsArray = Y_Lang.isArray(radius),
            yRadiusIsArray = Y_Lang.isArray(yRadius);
        _yuitest_coverline("build/charts-base/charts-base.js", 77);
if(xvalues && yvalues && xvalues.length > 0)
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 79);
this.clear();

            _yuitest_coverline("build/charts-base/charts-base.js", 81);
len = xvalues.length;
            _yuitest_coverline("build/charts-base/charts-base.js", 82);
for(; i < len; ++i)
            {
                _yuitest_coverline("build/charts-base/charts-base.js", 84);
x = xvalues[i];
                _yuitest_coverline("build/charts-base/charts-base.js", 85);
y = yvalues[i];
                _yuitest_coverline("build/charts-base/charts-base.js", 86);
xRad = radiusIsArray ? radius[i] : radius;
                _yuitest_coverline("build/charts-base/charts-base.js", 87);
yRad = yRadiusIsArray ? yRadius[i] : yRadius;
                _yuitest_coverline("build/charts-base/charts-base.js", 88);
if(!isNaN(x) && !isNaN(y) && !isNaN(xRad))
                {
                    _yuitest_coverline("build/charts-base/charts-base.js", 90);
this.drawShape({
                        x: x,
                        y: y,
                        width: widthIsArray ? width[i] : width,
                        height: heightIsArray ? height[i] : height,
                        radius: xRad,
                        yRadius: yRad
                    });
                    _yuitest_coverline("build/charts-base/charts-base.js", 98);
this.closePath();
                    _yuitest_coverline("build/charts-base/charts-base.js", 99);
attrs[i] = {
                        id: id + "_" + i,
                        className: className,
                        coords: (x - this._left) + ", " + (y - this._top)  + ", " + radius,
                        shape: "circle"
                    };
                }
            }
            _yuitest_coverline("build/charts-base/charts-base.js", 107);
this._closePath();
        }
    },

    /**
     * Parses and array of lengths into radii
     *
     * @method _getRadiusCollection
     * @param {Array} val Array of lengths
     * @return Array
     * @private
     */
    _getRadiusCollection: function(val)
    {
        _yuitest_coverfunc("build/charts-base/charts-base.js", "_getRadiusCollection", 119);
_yuitest_coverline("build/charts-base/charts-base.js", 121);
var i = 0,
            len = val.length,
            radii = [];
        _yuitest_coverline("build/charts-base/charts-base.js", 124);
for(; i < len; ++i)
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 126);
radii[i] = val[i] * 0.5;
        }
        _yuitest_coverline("build/charts-base/charts-base.js", 128);
return radii;
    }
 });

_yuitest_coverline("build/charts-base/charts-base.js", 132);
ShapeGroup.ATTRS = Y.merge(Y.Path.ATTRS, {
    dimensions: {
        getter: function()
        {
            _yuitest_coverfunc("build/charts-base/charts-base.js", "getter", 134);
_yuitest_coverline("build/charts-base/charts-base.js", 136);
var dimensions = this._dimensions,
                radius,
                yRadius,
                width,
                height;
            _yuitest_coverline("build/charts-base/charts-base.js", 141);
if(dimensions.hasOwnProperty("radius"))
            {
                _yuitest_coverline("build/charts-base/charts-base.js", 143);
return dimensions;
            }
            else
            {
                _yuitest_coverline("build/charts-base/charts-base.js", 147);
width = dimensions.width;
                _yuitest_coverline("build/charts-base/charts-base.js", 148);
height = dimensions.height;
                _yuitest_coverline("build/charts-base/charts-base.js", 149);
radius = Y_Lang.isArray(width) ? this._getRadiusCollection(width) : (width * 0.5);
                _yuitest_coverline("build/charts-base/charts-base.js", 150);
yRadius = Y_Lang.isArray(height) ? this._getRadiusCollection(height) : (height * 0.5);
                _yuitest_coverline("build/charts-base/charts-base.js", 151);
return {
                    width: width,
                    height: height,
                    radius: radius,
                    yRadius: yRadius
                };
            }
        },

        setter: function(val)
        {
            _yuitest_coverfunc("build/charts-base/charts-base.js", "setter", 160);
_yuitest_coverline("build/charts-base/charts-base.js", 162);
this._dimensions = val;
            _yuitest_coverline("build/charts-base/charts-base.js", 163);
return val;
        }
    },
    xvalues: {
        getter: function()
        {
            _yuitest_coverfunc("build/charts-base/charts-base.js", "getter", 167);
_yuitest_coverline("build/charts-base/charts-base.js", 169);
return this._xvalues;
        },
        setter: function(val)
        {
            _yuitest_coverfunc("build/charts-base/charts-base.js", "setter", 171);
_yuitest_coverline("build/charts-base/charts-base.js", 173);
this._xvalues = val;
        }
    },
    yvalues: {
        getter: function()
        {
            _yuitest_coverfunc("build/charts-base/charts-base.js", "getter", 177);
_yuitest_coverline("build/charts-base/charts-base.js", 179);
return this._yvalues;
        },
        setter: function(val)
        {
            _yuitest_coverfunc("build/charts-base/charts-base.js", "setter", 181);
_yuitest_coverline("build/charts-base/charts-base.js", 183);
this._yvalues = val;
        }
    }
});
_yuitest_coverline("build/charts-base/charts-base.js", 187);
Y.ShapeGroup = ShapeGroup;
/**
 * Abstract class for creating groups of circles with the same styles and dimensions.
 *
 * @module charts
 * @submodule charts-base
 * @class CircleGroup
 * @constructor
 */
 _yuitest_coverline("build/charts-base/charts-base.js", 196);
CircleGroup = function(cfg)
 {
    _yuitest_coverfunc("build/charts-base/charts-base.js", "CircleGroup", 196);
_yuitest_coverline("build/charts-base/charts-base.js", 198);
CircleGroup.superclass.constructor.apply(this, arguments);
 };

 _yuitest_coverline("build/charts-base/charts-base.js", 201);
CircleGroup.NAME = "circleGroup";

 _yuitest_coverline("build/charts-base/charts-base.js", 203);
Y.extend(CircleGroup, Y.ShapeGroup, {
    /**
     * Algorithm for drawing shape.
     *
     * @method drawShape
     * @param {Object} cfg Parameters used to draw the shape.
     */
    drawShape: function(cfg)
    {
        _yuitest_coverfunc("build/charts-base/charts-base.js", "drawShape", 210);
_yuitest_coverline("build/charts-base/charts-base.js", 212);
this.drawCircle(cfg.x, cfg.y, cfg.radius);
    }
 });

_yuitest_coverline("build/charts-base/charts-base.js", 216);
CircleGroup.ATTRS = Y.merge(Y.ShapeGroup.ATTRS, {
    dimensions: {
        getter: function()
        {
            _yuitest_coverfunc("build/charts-base/charts-base.js", "getter", 218);
_yuitest_coverline("build/charts-base/charts-base.js", 220);
var dimensions = this._dimensions,
                radius,
                yRadius,
                width,
                height;
            _yuitest_coverline("build/charts-base/charts-base.js", 225);
if(dimensions.hasOwnProperty("radius"))
            {
                _yuitest_coverline("build/charts-base/charts-base.js", 227);
return dimensions;
            }
            else
            {
                _yuitest_coverline("build/charts-base/charts-base.js", 231);
width = dimensions.width;
                _yuitest_coverline("build/charts-base/charts-base.js", 232);
height = dimensions.height;
                _yuitest_coverline("build/charts-base/charts-base.js", 233);
radius = Y_Lang.isArray(width) ? this._getRadiusCollection(width) : (width * 0.5);
                _yuitest_coverline("build/charts-base/charts-base.js", 234);
yRadius = radius;
                _yuitest_coverline("build/charts-base/charts-base.js", 235);
return {
                    width: width,
                    height: height,
                    radius: radius,
                    yRadius: yRadius
                };
            }
        }
    }
});

_yuitest_coverline("build/charts-base/charts-base.js", 246);
CircleGroup.ATTRS = Y.ShapeGroup.ATTRS;
_yuitest_coverline("build/charts-base/charts-base.js", 247);
Y.CircleGroup = CircleGroup;
/**
 * Abstract class for creating groups of rects with the same styles and dimensions.
 *
 * @module charts
 * @submodule charts-base
 * @class GroupRect
 * @constructor
 */
 _yuitest_coverline("build/charts-base/charts-base.js", 256);
RectGroup = function(cfg)
 {
    _yuitest_coverfunc("build/charts-base/charts-base.js", "RectGroup", 256);
_yuitest_coverline("build/charts-base/charts-base.js", 258);
RectGroup.superclass.constructor.apply(this, arguments);
 };

 _yuitest_coverline("build/charts-base/charts-base.js", 261);
RectGroup.NAME = "rectGroup";

 _yuitest_coverline("build/charts-base/charts-base.js", 263);
Y.extend(RectGroup, Y.ShapeGroup, {
    /**
     * Updates the rect.
     *
     * @method _draw
     * @private
     */
    drawShape: function(cfg)
    {
        _yuitest_coverfunc("build/charts-base/charts-base.js", "drawShape", 270);
_yuitest_coverline("build/charts-base/charts-base.js", 272);
this.drawRect(cfg.x, cfg.y, cfg.width, cfg.height);
    }
 });

_yuitest_coverline("build/charts-base/charts-base.js", 276);
RectGroup.ATTRS = Y.ShapeGroup.ATTRS;
_yuitest_coverline("build/charts-base/charts-base.js", 277);
Y.RectGroup = RectGroup;
/**
 * Abstract class for creating groups of diamonds with the same styles and dimensions.
 *
 * @module charts
 * @submodule charts-base
 * @class GroupDiamond
 * @constructor
 */
 _yuitest_coverline("build/charts-base/charts-base.js", 286);
DiamondGroup = function(cfg)
 {
    _yuitest_coverfunc("build/charts-base/charts-base.js", "DiamondGroup", 286);
_yuitest_coverline("build/charts-base/charts-base.js", 288);
DiamondGroup.superclass.constructor.apply(this, arguments);
 };

 _yuitest_coverline("build/charts-base/charts-base.js", 291);
DiamondGroup.NAME = "diamondGroup";

 _yuitest_coverline("build/charts-base/charts-base.js", 293);
Y.extend(DiamondGroup, Y.ShapeGroup, {
    /**
     * Updates the diamond.
     *
     * @method _draw
     * @private
     */
    drawShape: function(cfg)
    {
        _yuitest_coverfunc("build/charts-base/charts-base.js", "drawShape", 300);
_yuitest_coverline("build/charts-base/charts-base.js", 302);
this.drawDiamond(cfg.x, cfg.y, cfg.width, cfg.height);
    }
 });

_yuitest_coverline("build/charts-base/charts-base.js", 306);
DiamondGroup.ATTRS = Y.ShapeGroup.ATTRS;
_yuitest_coverline("build/charts-base/charts-base.js", 307);
Y.DiamondGroup = DiamondGroup;
/**
 * Abstract class for creating groups of diamonds with the same styles and dimensions.
 *
 * @module charts
 * @submodule charts-base
 * @class EllipseGroup
 * @constructor
 */
 _yuitest_coverline("build/charts-base/charts-base.js", 316);
EllipseGroup = function(cfg)
 {
    _yuitest_coverfunc("build/charts-base/charts-base.js", "EllipseGroup", 316);
_yuitest_coverline("build/charts-base/charts-base.js", 318);
EllipseGroup.superclass.constructor.apply(this, arguments);
 };

 _yuitest_coverline("build/charts-base/charts-base.js", 321);
EllipseGroup.NAME = "diamondGroup";

 _yuitest_coverline("build/charts-base/charts-base.js", 323);
Y.extend(EllipseGroup, Y.ShapeGroup, {
    /**
     * Updates the diamond.
     *
     * @method _draw
     * @private
     */
    drawShape: function(cfg)
    {
        _yuitest_coverfunc("build/charts-base/charts-base.js", "drawShape", 330);
_yuitest_coverline("build/charts-base/charts-base.js", 332);
this.drawEllipse(cfg.x, cfg.y, cfg.width, cfg.height);
    }
 });

_yuitest_coverline("build/charts-base/charts-base.js", 336);
EllipseGroup.ATTRS = Y.ShapeGroup.ATTRS;
_yuitest_coverline("build/charts-base/charts-base.js", 337);
Y.EllipseGroup = EllipseGroup;
/**
 * The Renderer class is a base class for chart components that use the `styles`
 * attribute.
 *
 * @module charts
 * @submodule charts-base
 * @class Renderer
 * @constructor
 */
_yuitest_coverline("build/charts-base/charts-base.js", 347);
function Renderer(){}

_yuitest_coverline("build/charts-base/charts-base.js", 349);
Renderer.ATTRS = {
        /**
         * Style properties for class
         *
         * @attribute styles
         * @type Object
         */
        styles:
        {
            getter: function()
            {
                _yuitest_coverfunc("build/charts-base/charts-base.js", "getter", 358);
_yuitest_coverline("build/charts-base/charts-base.js", 360);
this._styles = this._styles || this._getDefaultStyles();
                _yuitest_coverline("build/charts-base/charts-base.js", 361);
return this._styles;
            },

            setter: function(val)
            {
                _yuitest_coverfunc("build/charts-base/charts-base.js", "setter", 364);
_yuitest_coverline("build/charts-base/charts-base.js", 366);
this._styles = this._setStyles(val);
            }
        },

        /**
         * The graphic in which drawings will be rendered.
         *
         * @attribute graphic
         * @type Graphic
         */
        graphic: {}
};
_yuitest_coverline("build/charts-base/charts-base.js", 378);
Renderer.NAME = "renderer";

_yuitest_coverline("build/charts-base/charts-base.js", 380);
Renderer.prototype = {
    /**
     * Storage for `styles` attribute.
     *
     * @property _styles
     * @type Object
     * @private
     */
	_styles: null,

    /**
     * Method used by `styles` setter.
     *
     * @method _setStyles
     * @param {Object} newStyles Hash of properties to update.
     * @return Object
     * @protected
     */
	_setStyles: function(newstyles)
	{
		_yuitest_coverfunc("build/charts-base/charts-base.js", "_setStyles", 398);
_yuitest_coverline("build/charts-base/charts-base.js", 400);
var styles = this.get("styles");
        _yuitest_coverline("build/charts-base/charts-base.js", 401);
return this._mergeStyles(newstyles, styles);
	},

    /**
     * Merges to object literals so that only specified properties are
     * overwritten.
     *
     * @method _mergeStyles
     * @param {Object} a Hash of new styles
     * @param {Object} b Hash of original styles
     * @return Object
     * @protected
     */
    _mergeStyles: function(a, b)
    {
        _yuitest_coverfunc("build/charts-base/charts-base.js", "_mergeStyles", 414);
_yuitest_coverline("build/charts-base/charts-base.js", 416);
if(!b)
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 418);
b = {};
        }
        _yuitest_coverline("build/charts-base/charts-base.js", 420);
var newstyles = Y.merge(b, {});
        _yuitest_coverline("build/charts-base/charts-base.js", 421);
Y.Object.each(a, function(value, key, a)
        {
            _yuitest_coverfunc("build/charts-base/charts-base.js", "(anonymous 2)", 421);
_yuitest_coverline("build/charts-base/charts-base.js", 423);
if(b.hasOwnProperty(key) && Y_Lang.isObject(value) && !Y_Lang.isFunction(value) && !Y_Lang.isArray(value))
            {
                _yuitest_coverline("build/charts-base/charts-base.js", 425);
newstyles[key] = this._mergeStyles(value, b[key]);
            }
            else
            {
                _yuitest_coverline("build/charts-base/charts-base.js", 429);
newstyles[key] = value;
            }
        }, this);
        _yuitest_coverline("build/charts-base/charts-base.js", 432);
return newstyles;
    },

    /**
     * Gets the default value for the `styles` attribute.
     *
     * @method _getDefaultStyles
     * @return Object
     * @protected
     */
    _getDefaultStyles: function()
    {
        _yuitest_coverfunc("build/charts-base/charts-base.js", "_getDefaultStyles", 442);
_yuitest_coverline("build/charts-base/charts-base.js", 444);
return {padding:{
            top:0,
            right: 0,
            bottom: 0,
            left: 0
        }};
    }
};

_yuitest_coverline("build/charts-base/charts-base.js", 453);
Y.augment(Renderer, Y.Attribute);
_yuitest_coverline("build/charts-base/charts-base.js", 454);
Y.Renderer = Renderer;

/**
 * Algorithmic strategy for rendering a left axis.
 *
 * @module charts
 * @submodule charts-base
 * @class LeftAxisLayout
 * @constructor
 */
_yuitest_coverline("build/charts-base/charts-base.js", 464);
LeftAxisLayout = function() {};

_yuitest_coverline("build/charts-base/charts-base.js", 466);
LeftAxisLayout.prototype = {
    /**
     *  Default margins for text fields.
     *
     *  @private
     *  @method _getDefaultMargins
     *  @return Object
     */
    _getDefaultMargins: function()
    {
        _yuitest_coverfunc("build/charts-base/charts-base.js", "_getDefaultMargins", 474);
_yuitest_coverline("build/charts-base/charts-base.js", 476);
return {
            top: 0,
            left: 0,
            right: 4,
            bottom: 0
        };
    },

    /**
     * Sets the length of the tick on either side of the axis line.
     *
     * @method setTickOffset
     * @protected
     */
    setTickOffsets: function()
    {
        _yuitest_coverfunc("build/charts-base/charts-base.js", "setTickOffsets", 490);
_yuitest_coverline("build/charts-base/charts-base.js", 492);
var host = this,
            majorTicks = host.get("styles").majorTicks,
            tickLength = majorTicks.length,
            halfTick = tickLength * 0.5,
            display = majorTicks.display;
        _yuitest_coverline("build/charts-base/charts-base.js", 497);
host.set("topTickOffset",  0);
        _yuitest_coverline("build/charts-base/charts-base.js", 498);
host.set("bottomTickOffset",  0);

        _yuitest_coverline("build/charts-base/charts-base.js", 500);
switch(display)
        {
            case "inside" :
                _yuitest_coverline("build/charts-base/charts-base.js", 503);
host.set("rightTickOffset",  tickLength);
                _yuitest_coverline("build/charts-base/charts-base.js", 504);
host.set("leftTickOffset", 0);
            _yuitest_coverline("build/charts-base/charts-base.js", 505);
break;
            case "outside" :
                _yuitest_coverline("build/charts-base/charts-base.js", 507);
host.set("rightTickOffset", 0);
                _yuitest_coverline("build/charts-base/charts-base.js", 508);
host.set("leftTickOffset",  tickLength);
            _yuitest_coverline("build/charts-base/charts-base.js", 509);
break;
            case "cross":
                _yuitest_coverline("build/charts-base/charts-base.js", 511);
host.set("rightTickOffset", halfTick);
                _yuitest_coverline("build/charts-base/charts-base.js", 512);
host.set("leftTickOffset",  halfTick);
            _yuitest_coverline("build/charts-base/charts-base.js", 513);
break;
            default:
                _yuitest_coverline("build/charts-base/charts-base.js", 515);
host.set("rightTickOffset", 0);
                _yuitest_coverline("build/charts-base/charts-base.js", 516);
host.set("leftTickOffset", 0);
            _yuitest_coverline("build/charts-base/charts-base.js", 517);
break;
        }
    },

    /**
     * Draws a tick
     *
     * @method drawTick
     * @param {Path} path reference to the path `Path` element in which to draw the tick.
     * @param {Object} pt Point on the axis in which the tick will intersect.
     * @param {Object} tickStyle Hash of properties to apply to the tick.
     * @protected
     */
    drawTick: function(path, pt, tickStyles)
    {
        _yuitest_coverfunc("build/charts-base/charts-base.js", "drawTick", 530);
_yuitest_coverline("build/charts-base/charts-base.js", 532);
var host = this,
            style = host.get("styles"),
            padding = style.padding,
            tickLength = tickStyles.length,
            start = {x:padding.left, y:pt.y},
            end = {x:tickLength + padding.left, y:pt.y};
        _yuitest_coverline("build/charts-base/charts-base.js", 538);
host.drawLine(path, start, end);
    },

    /**
     * Calculates the coordinates for the first point on an axis.
     *
     * @method getLineStart
     * @return {Object}
     * @protected
     */
    getLineStart: function()
    {
        _yuitest_coverfunc("build/charts-base/charts-base.js", "getLineStart", 548);
_yuitest_coverline("build/charts-base/charts-base.js", 550);
var style = this.get("styles"),
            padding = style.padding,
            majorTicks = style.majorTicks,
            tickLength = majorTicks.length,
            display = majorTicks.display,
            pt = {x:padding.left, y:0};
        _yuitest_coverline("build/charts-base/charts-base.js", 556);
if(display === "outside")
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 558);
pt.x += tickLength;
        }
        else {_yuitest_coverline("build/charts-base/charts-base.js", 560);
if(display === "cross")
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 562);
pt.x += tickLength/2;
        }}
        _yuitest_coverline("build/charts-base/charts-base.js", 564);
return pt;
    },

    /**
     * Calculates the point for a label.
     *
     * @method getLabelPoint
     * @param {Object} point Point on the axis in which the tick will intersect.
     * @return {Object}
     * @protected
     */
    getLabelPoint: function(point)
    {
        _yuitest_coverfunc("build/charts-base/charts-base.js", "getLabelPoint", 575);
_yuitest_coverline("build/charts-base/charts-base.js", 577);
return {x:point.x - this.get("leftTickOffset"), y:point.y};
    },

    /**
     * Updates the value for the `maxLabelSize` for use in calculating total size.
     *
     * @method updateMaxLabelSize
     * @param {HTMLElement} label to measure
     * @protected
     */
    updateMaxLabelSize: function(labelWidth, labelHeight)
    {
        _yuitest_coverfunc("build/charts-base/charts-base.js", "updateMaxLabelSize", 587);
_yuitest_coverline("build/charts-base/charts-base.js", 589);
var host = this,
            props = this._labelRotationProps,
            rot = props.rot,
            absRot = props.absRot,
            sinRadians = props.sinRadians,
            cosRadians = props.cosRadians,
            max;
        _yuitest_coverline("build/charts-base/charts-base.js", 596);
if(rot === 0)
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 598);
max = labelWidth;
        }
        else {_yuitest_coverline("build/charts-base/charts-base.js", 600);
if(absRot === 90)
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 602);
max = labelHeight;
        }
        else
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 606);
max = (cosRadians * labelWidth) + (sinRadians * labelHeight);
        }}
        _yuitest_coverline("build/charts-base/charts-base.js", 608);
host._maxLabelSize = Math.max(host._maxLabelSize, max);
    },

    /**
     * Determines the available label width when the axis width has been explicitly set.
     *
     * @method getExplicitlySized
     * @return Boolean
     * @protected
     */
    getExplicitlySized: function(styles)
    {
        _yuitest_coverfunc("build/charts-base/charts-base.js", "getExplicitlySized", 618);
_yuitest_coverline("build/charts-base/charts-base.js", 620);
if(this._explicitWidth)
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 622);
var host = this,
                w = host._explicitWidth,
                totalTitleSize = host._totalTitleSize,
                leftTickOffset = host.get("leftTickOffset"),
                margin = styles.label.margin.right;
            _yuitest_coverline("build/charts-base/charts-base.js", 627);
host._maxLabelSize =  w - (leftTickOffset + margin + totalTitleSize);
            _yuitest_coverline("build/charts-base/charts-base.js", 628);
return true;
        }
        _yuitest_coverline("build/charts-base/charts-base.js", 630);
return false;
    },

    /**
     * Rotate and position title.
     *
     * @method positionTitle
     * @param {HTMLElement} label to rotate position
     * @protected
     */
    positionTitle: function(label)
    {
        _yuitest_coverfunc("build/charts-base/charts-base.js", "positionTitle", 640);
_yuitest_coverline("build/charts-base/charts-base.js", 642);
var host = this,
            bounds = host._titleBounds,
            margin = host.get("styles").title.margin,
            props = host._titleRotationProps,
            w = bounds.right - bounds.left,
            labelWidth = label.offsetWidth,
            labelHeight = label.offsetHeight,
            x = (labelWidth * -0.5) + (w * 0.5),
            y = (host.get("height") * 0.5) - (labelHeight * 0.5);
        _yuitest_coverline("build/charts-base/charts-base.js", 651);
props.labelWidth = labelWidth;
        _yuitest_coverline("build/charts-base/charts-base.js", 652);
props.labelHeight = labelHeight;
        _yuitest_coverline("build/charts-base/charts-base.js", 653);
if(margin && margin.left)
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 655);
x += margin.left;
        }
        _yuitest_coverline("build/charts-base/charts-base.js", 657);
props.x = x;
        _yuitest_coverline("build/charts-base/charts-base.js", 658);
props.y = y;
        _yuitest_coverline("build/charts-base/charts-base.js", 659);
props.transformOrigin = [0.5, 0.5];
        _yuitest_coverline("build/charts-base/charts-base.js", 660);
host._rotate(label, props);
    },

    /**
     * Rotate and position labels.
     *
     * @method positionLabel
     * @param {HTMLElement} label to rotate position
     * @param {Object} pt hash containing the x and y coordinates in which the label will be positioned
     * against.
     * @protected
     */
    positionLabel: function(label, pt, styles, i)
    {
        _yuitest_coverfunc("build/charts-base/charts-base.js", "positionLabel", 672);
_yuitest_coverline("build/charts-base/charts-base.js", 674);
var host = this,
            tickOffset = host.get("leftTickOffset"),
            totalTitleSize = this._totalTitleSize,
            leftOffset = pt.x + totalTitleSize - tickOffset,
            topOffset = pt.y,
            props = this._labelRotationProps,
            rot = props.rot,
            absRot = props.absRot,
            maxLabelSize = host._maxLabelSize,
            labelWidth = this._labelWidths[i],
            labelHeight = this._labelHeights[i];
        _yuitest_coverline("build/charts-base/charts-base.js", 685);
if(rot === 0)
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 687);
leftOffset -= labelWidth;
            _yuitest_coverline("build/charts-base/charts-base.js", 688);
topOffset -= labelHeight * 0.5;
        }
        else {_yuitest_coverline("build/charts-base/charts-base.js", 690);
if(rot === 90)
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 692);
leftOffset -= labelWidth * 0.5;
        }
        else {_yuitest_coverline("build/charts-base/charts-base.js", 694);
if(rot === -90)
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 696);
leftOffset -= labelWidth * 0.5;
            _yuitest_coverline("build/charts-base/charts-base.js", 697);
topOffset -= labelHeight;
        }
        else
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 701);
leftOffset -= labelWidth + (labelHeight * absRot/360);
            _yuitest_coverline("build/charts-base/charts-base.js", 702);
topOffset -= labelHeight * 0.5;
        }}}
        _yuitest_coverline("build/charts-base/charts-base.js", 704);
props.labelWidth = labelWidth;
        _yuitest_coverline("build/charts-base/charts-base.js", 705);
props.labelHeight = labelHeight;
        _yuitest_coverline("build/charts-base/charts-base.js", 706);
props.x = Math.round(maxLabelSize + leftOffset);
        _yuitest_coverline("build/charts-base/charts-base.js", 707);
props.y = Math.round(topOffset);
        _yuitest_coverline("build/charts-base/charts-base.js", 708);
this._rotate(label, props);
    },

    /**
     * Adjusts the coordinates of an axis label based on the rotation.
     *
     * @method _setRotationCoords
     * @param {Object} props Coordinates, dimension and rotation properties of the label.
     * @protected
     */
    _setRotationCoords: function(props)
    {
        _yuitest_coverfunc("build/charts-base/charts-base.js", "_setRotationCoords", 718);
_yuitest_coverline("build/charts-base/charts-base.js", 720);
var rot = props.rot,
            absRot = props.absRot,
            leftOffset,
            topOffset,
            labelWidth = props.labelWidth,
            labelHeight = props.labelHeight;
        _yuitest_coverline("build/charts-base/charts-base.js", 726);
if(rot === 0)
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 728);
leftOffset = labelWidth;
            _yuitest_coverline("build/charts-base/charts-base.js", 729);
topOffset = labelHeight * 0.5;
        }
        else {_yuitest_coverline("build/charts-base/charts-base.js", 731);
if(rot === 90)
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 733);
topOffset = 0;
            _yuitest_coverline("build/charts-base/charts-base.js", 734);
leftOffset = labelWidth * 0.5;
        }
        else {_yuitest_coverline("build/charts-base/charts-base.js", 736);
if(rot === -90)
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 738);
leftOffset = labelWidth * 0.5;
            _yuitest_coverline("build/charts-base/charts-base.js", 739);
topOffset = labelHeight;
        }
        else
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 743);
leftOffset = labelWidth + (labelHeight * absRot/360);
            _yuitest_coverline("build/charts-base/charts-base.js", 744);
topOffset = labelHeight * 0.5;
        }}}
        _yuitest_coverline("build/charts-base/charts-base.js", 746);
props.x -= leftOffset;
        _yuitest_coverline("build/charts-base/charts-base.js", 747);
props.y -= topOffset;
    },

    /**
     * Returns the transformOrigin to use for an axis label based on the position of the axis
     * and the rotation of the label.
     *
     * @method _getTransformOrigin
     * @param {Number} rot The rotation (in degrees) of the label.
     * @return Array
     * @protected
     */
    _getTransformOrigin: function(rot)
    {
        _yuitest_coverfunc("build/charts-base/charts-base.js", "_getTransformOrigin", 759);
_yuitest_coverline("build/charts-base/charts-base.js", 761);
var transformOrigin;
        _yuitest_coverline("build/charts-base/charts-base.js", 762);
if(rot === 0)
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 764);
transformOrigin = [0, 0];
        }
        else {_yuitest_coverline("build/charts-base/charts-base.js", 766);
if(rot === 90)
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 768);
transformOrigin = [0.5, 0];
        }
        else {_yuitest_coverline("build/charts-base/charts-base.js", 770);
if(rot === -90)
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 772);
transformOrigin = [0.5, 1];
        }
        else
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 776);
transformOrigin = [1, 0.5];
        }}}
        _yuitest_coverline("build/charts-base/charts-base.js", 778);
return transformOrigin;
    },

    /**
     * Adjust the position of the Axis widget's content box for internal axes.
     *
     * @method offsetNodeForTick
     * @param {Node} cb Content box of the Axis.
     * @protected
     */
    offsetNodeForTick: function(cb)
    {
    },

    /**
     * Sets the width of the axis based on its contents.
     *
     * @method setCalculatedSize
     * @protected
     */
    setCalculatedSize: function()
    {
        _yuitest_coverfunc("build/charts-base/charts-base.js", "setCalculatedSize", 798);
_yuitest_coverline("build/charts-base/charts-base.js", 800);
var host = this,
            graphic = this.get("graphic"),
            style = host.get("styles"),
            label = style.label,
            tickOffset = host.get("leftTickOffset"),
            max = host._maxLabelSize,
            totalTitleSize = this._totalTitleSize,
            ttl = Math.round(totalTitleSize + tickOffset + max + label.margin.right);
        _yuitest_coverline("build/charts-base/charts-base.js", 808);
if(this._explicitWidth)
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 810);
ttl = this._explicitWidth;
        }
        _yuitest_coverline("build/charts-base/charts-base.js", 812);
this.set("calculatedWidth", ttl);
        _yuitest_coverline("build/charts-base/charts-base.js", 813);
graphic.set("x", ttl - tickOffset);
    }
};

_yuitest_coverline("build/charts-base/charts-base.js", 817);
Y.LeftAxisLayout = LeftAxisLayout;
/**
 * RightAxisLayout contains algorithms for rendering a right axis.
 *
 * @module charts
 * @submodule charts-base
 * @class RightAxisLayout
 * @constructor
 */
_yuitest_coverline("build/charts-base/charts-base.js", 826);
RightAxisLayout = function(){};

_yuitest_coverline("build/charts-base/charts-base.js", 828);
RightAxisLayout.prototype = {
    /**
     *  Default margins for text fields.
     *
     *  @private
     *  @method _getDefaultMargins
     *  @return Object
     */
    _getDefaultMargins: function()
    {
        _yuitest_coverfunc("build/charts-base/charts-base.js", "_getDefaultMargins", 836);
_yuitest_coverline("build/charts-base/charts-base.js", 838);
return {
            top: 0,
            left: 4,
            right: 0,
            bottom: 0
        };
    },

    /**
     * Sets the length of the tick on either side of the axis line.
     *
     * @method setTickOffset
     * @protected
     */
    setTickOffsets: function()
    {
        _yuitest_coverfunc("build/charts-base/charts-base.js", "setTickOffsets", 852);
_yuitest_coverline("build/charts-base/charts-base.js", 854);
var host = this,
            majorTicks = host.get("styles").majorTicks,
            tickLength = majorTicks.length,
            halfTick = tickLength * 0.5,
            display = majorTicks.display;
        _yuitest_coverline("build/charts-base/charts-base.js", 859);
host.set("topTickOffset",  0);
        _yuitest_coverline("build/charts-base/charts-base.js", 860);
host.set("bottomTickOffset",  0);

        _yuitest_coverline("build/charts-base/charts-base.js", 862);
switch(display)
        {
            case "inside" :
                _yuitest_coverline("build/charts-base/charts-base.js", 865);
host.set("leftTickOffset", tickLength);
                _yuitest_coverline("build/charts-base/charts-base.js", 866);
host.set("rightTickOffset", 0);
            _yuitest_coverline("build/charts-base/charts-base.js", 867);
break;
            case "outside" :
                _yuitest_coverline("build/charts-base/charts-base.js", 869);
host.set("leftTickOffset", 0);
                _yuitest_coverline("build/charts-base/charts-base.js", 870);
host.set("rightTickOffset", tickLength);
            _yuitest_coverline("build/charts-base/charts-base.js", 871);
break;
            case "cross" :
                _yuitest_coverline("build/charts-base/charts-base.js", 873);
host.set("rightTickOffset", halfTick);
                _yuitest_coverline("build/charts-base/charts-base.js", 874);
host.set("leftTickOffset", halfTick);
            _yuitest_coverline("build/charts-base/charts-base.js", 875);
break;
            default:
                _yuitest_coverline("build/charts-base/charts-base.js", 877);
host.set("leftTickOffset", 0);
                _yuitest_coverline("build/charts-base/charts-base.js", 878);
host.set("rightTickOffset", 0);
            _yuitest_coverline("build/charts-base/charts-base.js", 879);
break;
        }
    },

    /**
     * Draws a tick
     *
     * @method drawTick
     * @param {Path} path reference to the path `Path` element in which to draw the tick.
     * @param {Object} pt Point on the axis in which the tick will intersect.
     * @param {Object) tickStyle Hash of properties to apply to the tick.
     * @protected
     */
    drawTick: function(path, pt, tickStyles)
    {
        _yuitest_coverfunc("build/charts-base/charts-base.js", "drawTick", 892);
_yuitest_coverline("build/charts-base/charts-base.js", 894);
var host = this,
            style = host.get("styles"),
            padding = style.padding,
            tickLength = tickStyles.length,
            start = {x:padding.left, y:pt.y},
            end = {x:padding.left + tickLength, y:pt.y};
        _yuitest_coverline("build/charts-base/charts-base.js", 900);
host.drawLine(path, start, end);
    },

    /**
     * Calculates the coordinates for the first point on an axis.
     *
     * @method getLineStart
     * @return {Object}
     * @protected
     */
    getLineStart: function()
    {
        _yuitest_coverfunc("build/charts-base/charts-base.js", "getLineStart", 910);
_yuitest_coverline("build/charts-base/charts-base.js", 912);
var host = this,
            style = host.get("styles"),
            padding = style.padding,
            majorTicks = style.majorTicks,
            tickLength = majorTicks.length,
            display = majorTicks.display,
            pt = {x:padding.left, y:padding.top};
        _yuitest_coverline("build/charts-base/charts-base.js", 919);
if(display === "inside")
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 921);
pt.x += tickLength;
        }
        else {_yuitest_coverline("build/charts-base/charts-base.js", 923);
if(display === "cross")
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 925);
pt.x += tickLength/2;
        }}
        _yuitest_coverline("build/charts-base/charts-base.js", 927);
return pt;
    },

    /**
     * Calculates the point for a label.
     *
     * @method getLabelPoint
     * @param {Object} point Point on the axis in which the tick will intersect.
     * @return {Object}
     * @protected
     */
    getLabelPoint: function(point)
    {
        _yuitest_coverfunc("build/charts-base/charts-base.js", "getLabelPoint", 938);
_yuitest_coverline("build/charts-base/charts-base.js", 940);
return {x:point.x + this.get("rightTickOffset"), y:point.y};
    },

    /**
     * Updates the value for the `maxLabelSize` for use in calculating total size.
     *
     * @method updateMaxLabelSize
     * @param {HTMLElement} label to measure
     * @protected
     */
    updateMaxLabelSize: function(labelWidth, labelHeight)
    {
        _yuitest_coverfunc("build/charts-base/charts-base.js", "updateMaxLabelSize", 950);
_yuitest_coverline("build/charts-base/charts-base.js", 952);
var host = this,
            props = this._labelRotationProps,
            rot = props.rot,
            absRot = props.absRot,
            sinRadians = props.sinRadians,
            cosRadians = props.cosRadians,
            max;
        _yuitest_coverline("build/charts-base/charts-base.js", 959);
if(rot === 0)
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 961);
max = labelWidth;
        }
        else {_yuitest_coverline("build/charts-base/charts-base.js", 963);
if(absRot === 90)
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 965);
max = labelHeight;
        }
        else
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 969);
max = (cosRadians * labelWidth) + (sinRadians * labelHeight);
        }}
        _yuitest_coverline("build/charts-base/charts-base.js", 971);
host._maxLabelSize = Math.max(host._maxLabelSize, max);
    },

    /**
     * Determines the available label width when the axis width has been explicitly set.
     *
     * @method getExplicitlySized
     * @return Boolean
     * @protected
     */
    getExplicitlySized: function(styles)
    {
        _yuitest_coverfunc("build/charts-base/charts-base.js", "getExplicitlySized", 981);
_yuitest_coverline("build/charts-base/charts-base.js", 983);
if(this._explicitWidth)
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 985);
var host = this,
                w = host._explicitWidth,
                totalTitleSize = this._totalTitleSize,
                rightTickOffset = host.get("rightTickOffset"),
                margin = styles.label.margin.right;
            _yuitest_coverline("build/charts-base/charts-base.js", 990);
host._maxLabelSize =  w - (rightTickOffset + margin + totalTitleSize);
            _yuitest_coverline("build/charts-base/charts-base.js", 991);
return true;
        }
        _yuitest_coverline("build/charts-base/charts-base.js", 993);
return false;
    },

    /**
     * Rotate and position title.
     *
     * @method positionTitle
     * @param {HTMLElement} label to rotate position
     * @protected
     */
    positionTitle: function(label)
    {
        _yuitest_coverfunc("build/charts-base/charts-base.js", "positionTitle", 1003);
_yuitest_coverline("build/charts-base/charts-base.js", 1005);
var host = this,
            bounds = host._titleBounds,
            margin = host.get("styles").title.margin,
            props = host._titleRotationProps,
            labelWidth = label.offsetWidth,
            labelHeight = label.offsetHeight,
            w = bounds.right - bounds.left,
            x = this.get("width") - (labelWidth * 0.5) - (w * 0.5),
            y = (host.get("height") * 0.5) - (labelHeight * 0.5);
        _yuitest_coverline("build/charts-base/charts-base.js", 1014);
props.labelWidth = labelWidth;
        _yuitest_coverline("build/charts-base/charts-base.js", 1015);
props.labelHeight = labelHeight;
        _yuitest_coverline("build/charts-base/charts-base.js", 1016);
if(margin && margin.right)
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 1018);
x -= margin.left;
        }
        _yuitest_coverline("build/charts-base/charts-base.js", 1020);
props.x = x;
        _yuitest_coverline("build/charts-base/charts-base.js", 1021);
props.y = y;
        _yuitest_coverline("build/charts-base/charts-base.js", 1022);
props.transformOrigin = [0.5, 0.5];
        _yuitest_coverline("build/charts-base/charts-base.js", 1023);
host._rotate(label, props);
    },

    /**
     * Rotate and position labels.
     *
     * @method positionLabel
     * @param {HTMLElement} label to rotate position
     * @param {Object} pt hash containing the x and y coordinates in which the label will be positioned
     * against.
     * @protected
     */
    positionLabel: function(label, pt, styles, i)
    {
        _yuitest_coverfunc("build/charts-base/charts-base.js", "positionLabel", 1035);
_yuitest_coverline("build/charts-base/charts-base.js", 1037);
var host = this,
            tickOffset = host.get("rightTickOffset"),
            labelStyles = styles.label,
            margin = 0,
            leftOffset = pt.x,
            topOffset = pt.y,
            props = this._labelRotationProps,
            rot = props.rot,
            absRot = props.absRot,
            labelWidth = this._labelWidths[i],
            labelHeight = this._labelHeights[i];
        _yuitest_coverline("build/charts-base/charts-base.js", 1048);
if(labelStyles.margin && labelStyles.margin.left)
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 1050);
margin = labelStyles.margin.left;
        }
        _yuitest_coverline("build/charts-base/charts-base.js", 1052);
if(rot === 0)
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 1054);
topOffset -= labelHeight * 0.5;
        }
        else {_yuitest_coverline("build/charts-base/charts-base.js", 1056);
if(rot === 90)
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 1058);
leftOffset -= labelWidth * 0.5;
            _yuitest_coverline("build/charts-base/charts-base.js", 1059);
topOffset -= labelHeight;
        }
        else {_yuitest_coverline("build/charts-base/charts-base.js", 1061);
if(rot === -90)
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 1063);
leftOffset -= labelWidth * 0.5;
        }
        else
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 1067);
topOffset -= labelHeight * 0.5;
            _yuitest_coverline("build/charts-base/charts-base.js", 1068);
leftOffset += labelHeight/2 * absRot/90;
        }}}
        _yuitest_coverline("build/charts-base/charts-base.js", 1070);
leftOffset += margin;
        _yuitest_coverline("build/charts-base/charts-base.js", 1071);
leftOffset += tickOffset;
        _yuitest_coverline("build/charts-base/charts-base.js", 1072);
props.labelWidth = labelWidth;
        _yuitest_coverline("build/charts-base/charts-base.js", 1073);
props.labelHeight = labelHeight;
        _yuitest_coverline("build/charts-base/charts-base.js", 1074);
props.x = Math.round(leftOffset);
        _yuitest_coverline("build/charts-base/charts-base.js", 1075);
props.y = Math.round(topOffset);
        _yuitest_coverline("build/charts-base/charts-base.js", 1076);
this._rotate(label, props);
    },

    /**
     * Adjusts the coordinates of an axis label based on the rotation.
     *
     * @method _setRotationCoords
     * @param {Object} props Coordinates, dimension and rotation properties of the label.
     * @protected
     */
    _setRotationCoords: function(props)
    {
        _yuitest_coverfunc("build/charts-base/charts-base.js", "_setRotationCoords", 1086);
_yuitest_coverline("build/charts-base/charts-base.js", 1088);
var rot = props.rot,
            absRot = props.absRot,
            leftOffset = 0,
            topOffset = 0,
            labelWidth = props.labelWidth,
            labelHeight = props.labelHeight;
        _yuitest_coverline("build/charts-base/charts-base.js", 1094);
if(rot === 0)
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 1096);
topOffset = labelHeight * 0.5;
        }
        else {_yuitest_coverline("build/charts-base/charts-base.js", 1098);
if(rot === 90)
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 1100);
leftOffset = labelWidth * 0.5;
            _yuitest_coverline("build/charts-base/charts-base.js", 1101);
topOffset = labelHeight;
        }
        else {_yuitest_coverline("build/charts-base/charts-base.js", 1103);
if(rot === -90)
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 1105);
leftOffset = labelWidth * 0.5;
        }
        else
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 1109);
topOffset = labelHeight * 0.5;
            _yuitest_coverline("build/charts-base/charts-base.js", 1110);
leftOffset = labelHeight/2 * absRot/90;
        }}}
        _yuitest_coverline("build/charts-base/charts-base.js", 1112);
props.x -= leftOffset;
        _yuitest_coverline("build/charts-base/charts-base.js", 1113);
props.y -= topOffset;
    },

    /**
     * Returns the transformOrigin to use for an axis label based on the position of the axis
     * and the rotation of the label.
     *
     * @method _getTransformOrigin
     * @param {Number} rot The rotation (in degrees) of the label.
     * @return Array
     * @protected
     */
    _getTransformOrigin: function(rot)
    {
        _yuitest_coverfunc("build/charts-base/charts-base.js", "_getTransformOrigin", 1125);
_yuitest_coverline("build/charts-base/charts-base.js", 1127);
var transformOrigin;
        _yuitest_coverline("build/charts-base/charts-base.js", 1128);
if(rot === 0)
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 1130);
transformOrigin = [0, 0];
        }
        else {_yuitest_coverline("build/charts-base/charts-base.js", 1132);
if(rot === 90)
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 1134);
transformOrigin = [0.5, 1];
        }
        else {_yuitest_coverline("build/charts-base/charts-base.js", 1136);
if(rot === -90)
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 1138);
transformOrigin = [0.5, 0];
        }
        else
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 1142);
transformOrigin = [0, 0.5];
        }}}
        _yuitest_coverline("build/charts-base/charts-base.js", 1144);
return transformOrigin;
    },

    /**
     * Adjusts position for inner ticks.
     *
     * @method offsetNodeForTick
     * @param {Node} cb contentBox of the axis
     * @protected
     */
    offsetNodeForTick: function(cb)
    {
        _yuitest_coverfunc("build/charts-base/charts-base.js", "offsetNodeForTick", 1154);
_yuitest_coverline("build/charts-base/charts-base.js", 1156);
var host = this,
            tickOffset = host.get("leftTickOffset"),
            offset = 0 - tickOffset;
        _yuitest_coverline("build/charts-base/charts-base.js", 1159);
cb.setStyle("left", offset);
    },

    /**
     * Assigns a height based on the size of the contents.
     *
     * @method setCalculatedSize
     * @protected
     */
    setCalculatedSize: function()
    {
        _yuitest_coverfunc("build/charts-base/charts-base.js", "setCalculatedSize", 1168);
_yuitest_coverline("build/charts-base/charts-base.js", 1170);
var host = this,
            styles = host.get("styles"),
            labelStyle = styles.label,
            totalTitleSize = this._totalTitleSize,
            ttl = Math.round(host.get("rightTickOffset") + host._maxLabelSize + totalTitleSize + labelStyle.margin.left);
        _yuitest_coverline("build/charts-base/charts-base.js", 1175);
if(this._explicitWidth)
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 1177);
ttl = this._explicitWidth;
        }
        _yuitest_coverline("build/charts-base/charts-base.js", 1179);
host.set("calculatedWidth", ttl);
        _yuitest_coverline("build/charts-base/charts-base.js", 1180);
host.get("contentBox").setStyle("width", ttl);
    }
};

_yuitest_coverline("build/charts-base/charts-base.js", 1184);
Y.RightAxisLayout = RightAxisLayout;
/**
 * Contains algorithms for rendering a bottom axis.
 *
 * @module charts
 * @submodule charts-base
 * @class BottomAxisLayout
 * @Constructor
 */
_yuitest_coverline("build/charts-base/charts-base.js", 1193);
BottomAxisLayout = function(){};

_yuitest_coverline("build/charts-base/charts-base.js", 1195);
BottomAxisLayout.prototype = {
    /**
     *  Default margins for text fields.
     *
     *  @private
     *  @method _getDefaultMargins
     *  @return Object
     */
    _getDefaultMargins: function()
    {
        _yuitest_coverfunc("build/charts-base/charts-base.js", "_getDefaultMargins", 1203);
_yuitest_coverline("build/charts-base/charts-base.js", 1205);
return {
            top: 4,
            left: 0,
            right: 0,
            bottom: 0
        };
    },

    /**
     * Sets the length of the tick on either side of the axis line.
     *
     * @method setTickOffsets
     * @protected
     */
    setTickOffsets: function()
    {
        _yuitest_coverfunc("build/charts-base/charts-base.js", "setTickOffsets", 1219);
_yuitest_coverline("build/charts-base/charts-base.js", 1221);
var host = this,
            majorTicks = host.get("styles").majorTicks,
            tickLength = majorTicks.length,
            halfTick = tickLength * 0.5,
            display = majorTicks.display;
        _yuitest_coverline("build/charts-base/charts-base.js", 1226);
host.set("leftTickOffset",  0);
        _yuitest_coverline("build/charts-base/charts-base.js", 1227);
host.set("rightTickOffset",  0);

        _yuitest_coverline("build/charts-base/charts-base.js", 1229);
switch(display)
        {
            case "inside" :
                _yuitest_coverline("build/charts-base/charts-base.js", 1232);
host.set("topTickOffset", tickLength);
                _yuitest_coverline("build/charts-base/charts-base.js", 1233);
host.set("bottomTickOffset", 0);
            _yuitest_coverline("build/charts-base/charts-base.js", 1234);
break;
            case "outside" :
                _yuitest_coverline("build/charts-base/charts-base.js", 1236);
host.set("topTickOffset", 0);
                _yuitest_coverline("build/charts-base/charts-base.js", 1237);
host.set("bottomTickOffset", tickLength);
            _yuitest_coverline("build/charts-base/charts-base.js", 1238);
break;
            case "cross":
                _yuitest_coverline("build/charts-base/charts-base.js", 1240);
host.set("topTickOffset",  halfTick);
                _yuitest_coverline("build/charts-base/charts-base.js", 1241);
host.set("bottomTickOffset",  halfTick);
            _yuitest_coverline("build/charts-base/charts-base.js", 1242);
break;
            default:
                _yuitest_coverline("build/charts-base/charts-base.js", 1244);
host.set("topTickOffset", 0);
                _yuitest_coverline("build/charts-base/charts-base.js", 1245);
host.set("bottomTickOffset", 0);
            _yuitest_coverline("build/charts-base/charts-base.js", 1246);
break;
        }
    },

    /**
     * Calculates the coordinates for the first point on an axis.
     *
     * @method getLineStart
     * @protected
     */
    getLineStart: function()
    {
        _yuitest_coverfunc("build/charts-base/charts-base.js", "getLineStart", 1256);
_yuitest_coverline("build/charts-base/charts-base.js", 1258);
var style = this.get("styles"),
            padding = style.padding,
            majorTicks = style.majorTicks,
            tickLength = majorTicks.length,
            display = majorTicks.display,
            pt = {x:0, y:padding.top};
        _yuitest_coverline("build/charts-base/charts-base.js", 1264);
if(display === "inside")
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 1266);
pt.y += tickLength;
        }
        else {_yuitest_coverline("build/charts-base/charts-base.js", 1268);
if(display === "cross")
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 1270);
pt.y += tickLength/2;
        }}
        _yuitest_coverline("build/charts-base/charts-base.js", 1272);
return pt;
    },

    /**
     * Draws a tick
     *
     * @method drawTick
     * @param {Path} path reference to the path `Path` element in which to draw the tick.
     * @param {Object} pt hash containing x and y coordinates
     * @param {Object} tickStyles hash of properties used to draw the tick
     * @protected
     */
    drawTick: function(path, pt, tickStyles)
    {
        _yuitest_coverfunc("build/charts-base/charts-base.js", "drawTick", 1284);
_yuitest_coverline("build/charts-base/charts-base.js", 1286);
var host = this,
            style = host.get("styles"),
            padding = style.padding,
            tickLength = tickStyles.length,
            start = {x:pt.x, y:padding.top},
            end = {x:pt.x, y:tickLength + padding.top};
        _yuitest_coverline("build/charts-base/charts-base.js", 1292);
host.drawLine(path, start, end);
    },

    /**
     * Calculates the point for a label.
     *
     * @method getLabelPoint
     * @param {Object} pt Object containing x and y coordinates
     * @return Object
     * @protected
     */
    getLabelPoint: function(point)
    {
        _yuitest_coverfunc("build/charts-base/charts-base.js", "getLabelPoint", 1303);
_yuitest_coverline("build/charts-base/charts-base.js", 1305);
return {x:point.x, y:point.y + this.get("bottomTickOffset")};
    },

    /**
     * Updates the value for the `maxLabelSize` for use in calculating total size.
     *
     * @method updateMaxLabelSize
     * @param {HTMLElement} label to measure
     * @protected
     */
    updateMaxLabelSize: function(labelWidth, labelHeight)
    {
        _yuitest_coverfunc("build/charts-base/charts-base.js", "updateMaxLabelSize", 1315);
_yuitest_coverline("build/charts-base/charts-base.js", 1317);
var host = this,
            props = this._labelRotationProps,
            rot = props.rot,
            absRot = props.absRot,
            sinRadians = props.sinRadians,
            cosRadians = props.cosRadians,
            max;
        _yuitest_coverline("build/charts-base/charts-base.js", 1324);
if(rot === 0)
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 1326);
max = labelHeight;
        }
        else {_yuitest_coverline("build/charts-base/charts-base.js", 1328);
if(absRot === 90)
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 1330);
max = labelWidth;
        }
        else
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 1334);
max = (sinRadians * labelWidth) + (cosRadians * labelHeight);
        }}
        _yuitest_coverline("build/charts-base/charts-base.js", 1336);
host._maxLabelSize = Math.max(host._maxLabelSize, max);
    },

    /**
     * Determines the available label height when the axis width has been explicitly set.
     *
     * @method getExplicitlySized
     * @return Boolean
     * @protected
     */
    getExplicitlySized: function(styles)
    {
        _yuitest_coverfunc("build/charts-base/charts-base.js", "getExplicitlySized", 1346);
_yuitest_coverline("build/charts-base/charts-base.js", 1348);
if(this._explicitHeight)
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 1350);
var host = this,
                h = host._explicitHeight,
                totalTitleSize = host._totalTitleSize,
                bottomTickOffset = host.get("bottomTickOffset"),
                margin = styles.label.margin.right;
            _yuitest_coverline("build/charts-base/charts-base.js", 1355);
host._maxLabelSize =  h - (bottomTickOffset + margin + totalTitleSize);
            _yuitest_coverline("build/charts-base/charts-base.js", 1356);
return true;
        }
        _yuitest_coverline("build/charts-base/charts-base.js", 1358);
return false;
    },

    /**
     * Rotate and position title.
     *
     * @method positionTitle
     * @param {HTMLElement} label to rotate position
     * @protected
     */
    positionTitle: function(label)
    {
        _yuitest_coverfunc("build/charts-base/charts-base.js", "positionTitle", 1368);
_yuitest_coverline("build/charts-base/charts-base.js", 1370);
var host = this,
            bounds = host._titleBounds,
            margin = host.get("styles").title.margin,
            props = host._titleRotationProps,
            h = bounds.bottom - bounds.top,
            labelWidth = label.offsetWidth,
            labelHeight = label.offsetHeight,
            x = (host.get("width") * 0.5) - (labelWidth * 0.5),
            y = host.get("height") - labelHeight/2 - h/2;
        _yuitest_coverline("build/charts-base/charts-base.js", 1379);
props.labelWidth = labelWidth;
        _yuitest_coverline("build/charts-base/charts-base.js", 1380);
props.labelHeight = labelHeight;
        _yuitest_coverline("build/charts-base/charts-base.js", 1381);
if(margin && margin.bottom)
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 1383);
y -= margin.bottom;
        }
        _yuitest_coverline("build/charts-base/charts-base.js", 1385);
props.x = x;
        _yuitest_coverline("build/charts-base/charts-base.js", 1386);
props.y = y;
        _yuitest_coverline("build/charts-base/charts-base.js", 1387);
props.transformOrigin = [0.5, 0.5];
        _yuitest_coverline("build/charts-base/charts-base.js", 1388);
host._rotate(label, props);
    },

    /**
     * Rotate and position labels.
     *
     * @method positionLabel
     * @param {HTMLElement} label to rotate position
     * @param {Object} pt hash containing the x and y coordinates in which the label will be positioned
     * against.
     * @protected
     */
    positionLabel: function(label, pt, styles, i)
    {
        _yuitest_coverfunc("build/charts-base/charts-base.js", "positionLabel", 1400);
_yuitest_coverline("build/charts-base/charts-base.js", 1402);
var host = this,
            tickOffset = host.get("bottomTickOffset"),
            labelStyles = styles.label,
            margin = 0,
            props = host._labelRotationProps,
            rot = props.rot,
            absRot = props.absRot,
            leftOffset = Math.round(pt.x),
            topOffset = Math.round(pt.y),
            labelWidth = host._labelWidths[i],
            labelHeight = host._labelHeights[i];
        _yuitest_coverline("build/charts-base/charts-base.js", 1413);
if(labelStyles.margin && labelStyles.margin.top)
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 1415);
margin = labelStyles.margin.top;
        }
        _yuitest_coverline("build/charts-base/charts-base.js", 1417);
if(rot > 0)
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 1419);
topOffset -= labelHeight/2 * rot/90;
        }
        else {_yuitest_coverline("build/charts-base/charts-base.js", 1421);
if(rot < 0)
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 1423);
leftOffset -= labelWidth;
            _yuitest_coverline("build/charts-base/charts-base.js", 1424);
topOffset -= labelHeight/2 * absRot/90;
        }
        else
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 1428);
leftOffset -= labelWidth * 0.5;
        }}
        _yuitest_coverline("build/charts-base/charts-base.js", 1430);
topOffset += margin;
        _yuitest_coverline("build/charts-base/charts-base.js", 1431);
topOffset += tickOffset;
        _yuitest_coverline("build/charts-base/charts-base.js", 1432);
props.labelWidth = labelWidth;
        _yuitest_coverline("build/charts-base/charts-base.js", 1433);
props.labelHeight = labelHeight;
        _yuitest_coverline("build/charts-base/charts-base.js", 1434);
props.x = leftOffset;
        _yuitest_coverline("build/charts-base/charts-base.js", 1435);
props.y = topOffset;
        _yuitest_coverline("build/charts-base/charts-base.js", 1436);
host._rotate(label, props);
    },

    /**
     * Adjusts the coordinates of an axis label based on the rotation.
     *
     * @method _setRotationCoords
     * @param {Object} props Coordinates, dimension and rotation properties of the label.
     * @protected
     */
    _setRotationCoords: function(props)
    {
        _yuitest_coverfunc("build/charts-base/charts-base.js", "_setRotationCoords", 1446);
_yuitest_coverline("build/charts-base/charts-base.js", 1448);
var rot = props.rot,
            absRot = props.absRot,
            labelWidth = props.labelWidth,
            labelHeight = props.labelHeight,
            leftOffset,
            topOffset;

        _yuitest_coverline("build/charts-base/charts-base.js", 1455);
if(rot > 0)
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 1457);
leftOffset = 0;
            _yuitest_coverline("build/charts-base/charts-base.js", 1458);
topOffset = labelHeight/2 * rot/90;
        }
        else {_yuitest_coverline("build/charts-base/charts-base.js", 1460);
if(rot < 0)
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 1462);
leftOffset = labelWidth;
            _yuitest_coverline("build/charts-base/charts-base.js", 1463);
topOffset = labelHeight/2 * absRot/90;
        }
        else
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 1467);
leftOffset = labelWidth * 0.5;
            _yuitest_coverline("build/charts-base/charts-base.js", 1468);
topOffset = 0;
        }}
        _yuitest_coverline("build/charts-base/charts-base.js", 1470);
props.x -= leftOffset;
        _yuitest_coverline("build/charts-base/charts-base.js", 1471);
props.y -= topOffset;
    },

    /**
     * Returns the transformOrigin to use for an axis label based on the position of the axis
     * and the rotation of the label.
     *
     * @method _getTransformOrigin
     * @param {Number} rot The rotation (in degrees) of the label.
     * @return Array
     * @protected
     */
    _getTransformOrigin: function(rot)
    {
        _yuitest_coverfunc("build/charts-base/charts-base.js", "_getTransformOrigin", 1483);
_yuitest_coverline("build/charts-base/charts-base.js", 1485);
var transformOrigin;
        _yuitest_coverline("build/charts-base/charts-base.js", 1486);
if(rot > 0)
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 1488);
transformOrigin = [0, 0.5];
        }
        else {_yuitest_coverline("build/charts-base/charts-base.js", 1490);
if(rot < 0)
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 1492);
transformOrigin = [1, 0.5];
        }
        else
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 1496);
transformOrigin = [0, 0];
        }}
        _yuitest_coverline("build/charts-base/charts-base.js", 1498);
return transformOrigin;
    },

    /**
     * Adjusts position for inner ticks.
     *
     * @method offsetNodeForTick
     * @param {Node} cb contentBox of the axis
     * @protected
     */
    offsetNodeForTick: function(cb)
    {
        _yuitest_coverfunc("build/charts-base/charts-base.js", "offsetNodeForTick", 1508);
_yuitest_coverline("build/charts-base/charts-base.js", 1510);
var host = this;
        _yuitest_coverline("build/charts-base/charts-base.js", 1511);
host.get("contentBox").setStyle("top", 0 - host.get("topTickOffset"));
    },

    /**
     * Assigns a height based on the size of the contents.
     *
     * @method setCalculatedSize
     * @protected
     */
    setCalculatedSize: function()
    {
        _yuitest_coverfunc("build/charts-base/charts-base.js", "setCalculatedSize", 1520);
_yuitest_coverline("build/charts-base/charts-base.js", 1522);
var host = this,
            styles = host.get("styles"),
            labelStyle = styles.label,
            totalTitleSize = host._totalTitleSize,
            ttl = Math.round(host.get("bottomTickOffset") + host._maxLabelSize + labelStyle.margin.top + totalTitleSize);
        _yuitest_coverline("build/charts-base/charts-base.js", 1527);
if(host._explicitHeight)
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 1529);
ttl = host._explicitHeight;
        }
        _yuitest_coverline("build/charts-base/charts-base.js", 1531);
host.set("calculatedHeight", ttl);
    }
};
_yuitest_coverline("build/charts-base/charts-base.js", 1534);
Y.BottomAxisLayout = BottomAxisLayout;
/**
 * Contains algorithms for rendering a top axis.
 *
 * @module charts
 * @submodule charts-base
 * @class TopAxisLayout
 * @constructor
 */
_yuitest_coverline("build/charts-base/charts-base.js", 1543);
TopAxisLayout = function(){};

_yuitest_coverline("build/charts-base/charts-base.js", 1545);
TopAxisLayout.prototype = {
    /**
     *  Default margins for text fields.
     *
     *  @private
     *  @method _getDefaultMargins
     *  @return Object
     */
    _getDefaultMargins: function()
    {
        _yuitest_coverfunc("build/charts-base/charts-base.js", "_getDefaultMargins", 1553);
_yuitest_coverline("build/charts-base/charts-base.js", 1555);
return {
            top: 0,
            left: 0,
            right: 0,
            bottom: 4
        };
    },

    /**
     * Sets the length of the tick on either side of the axis line.
     *
     * @method setTickOffsets
     * @protected
     */
    setTickOffsets: function()
    {
        _yuitest_coverfunc("build/charts-base/charts-base.js", "setTickOffsets", 1569);
_yuitest_coverline("build/charts-base/charts-base.js", 1571);
var host = this,
            majorTicks = host.get("styles").majorTicks,
            tickLength = majorTicks.length,
            halfTick = tickLength * 0.5,
            display = majorTicks.display;
        _yuitest_coverline("build/charts-base/charts-base.js", 1576);
host.set("leftTickOffset",  0);
        _yuitest_coverline("build/charts-base/charts-base.js", 1577);
host.set("rightTickOffset",  0);
        _yuitest_coverline("build/charts-base/charts-base.js", 1578);
switch(display)
        {
            case "inside" :
                _yuitest_coverline("build/charts-base/charts-base.js", 1581);
host.set("bottomTickOffset", tickLength);
                _yuitest_coverline("build/charts-base/charts-base.js", 1582);
host.set("topTickOffset", 0);
            _yuitest_coverline("build/charts-base/charts-base.js", 1583);
break;
            case "outside" :
                _yuitest_coverline("build/charts-base/charts-base.js", 1585);
host.set("bottomTickOffset", 0);
                _yuitest_coverline("build/charts-base/charts-base.js", 1586);
host.set("topTickOffset",  tickLength);
            _yuitest_coverline("build/charts-base/charts-base.js", 1587);
break;
            case "cross" :
                _yuitest_coverline("build/charts-base/charts-base.js", 1589);
host.set("topTickOffset", halfTick);
                _yuitest_coverline("build/charts-base/charts-base.js", 1590);
host.set("bottomTickOffset", halfTick);
            _yuitest_coverline("build/charts-base/charts-base.js", 1591);
break;
            default:
                _yuitest_coverline("build/charts-base/charts-base.js", 1593);
host.set("topTickOffset", 0);
                _yuitest_coverline("build/charts-base/charts-base.js", 1594);
host.set("bottomTickOffset", 0);
            _yuitest_coverline("build/charts-base/charts-base.js", 1595);
break;
        }
    },

    /**
     * Calculates the coordinates for the first point on an axis.
     *
     * @method getLineStart
     * @protected
     */
    getLineStart: function()
    {
        _yuitest_coverfunc("build/charts-base/charts-base.js", "getLineStart", 1605);
_yuitest_coverline("build/charts-base/charts-base.js", 1607);
var host = this,
            style = host.get("styles"),
            padding = style.padding,
            majorTicks = style.majorTicks,
            tickLength = majorTicks.length,
            display = majorTicks.display,
            pt = {x:0, y:padding.top};
        _yuitest_coverline("build/charts-base/charts-base.js", 1614);
if(display === "outside")
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 1616);
pt.y += tickLength;
        }
        else {_yuitest_coverline("build/charts-base/charts-base.js", 1618);
if(display === "cross")
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 1620);
pt.y += tickLength/2;
        }}
        _yuitest_coverline("build/charts-base/charts-base.js", 1622);
return pt;
    },

    /**
     * Draws a tick
     *
     * @method drawTick
     * @param {Path} path reference to the path `Path` element in which to draw the tick.
     * @param {Object} pt hash containing x and y coordinates
     * @param {Object} tickStyles hash of properties used to draw the tick
     * @protected
     */
    drawTick: function(path, pt, tickStyles)
    {
        _yuitest_coverfunc("build/charts-base/charts-base.js", "drawTick", 1634);
_yuitest_coverline("build/charts-base/charts-base.js", 1636);
var host = this,
            style = host.get("styles"),
            padding = style.padding,
            tickLength = tickStyles.length,
            start = {x:pt.x, y:padding.top},
            end = {x:pt.x, y:tickLength + padding.top};
        _yuitest_coverline("build/charts-base/charts-base.js", 1642);
host.drawLine(path, start, end);
    },

    /**
     * Calculates the point for a label.
     *
     * @method getLabelPoint
     * @param {Object} pt hash containing x and y coordinates
     * @return Object
     * @protected
     */
    getLabelPoint: function(pt)
    {
        _yuitest_coverfunc("build/charts-base/charts-base.js", "getLabelPoint", 1653);
_yuitest_coverline("build/charts-base/charts-base.js", 1655);
return {x:pt.x, y:pt.y - this.get("topTickOffset")};
    },

    /**
     * Updates the value for the `maxLabelSize` for use in calculating total size.
     *
     * @method updateMaxLabelSize
     * @param {HTMLElement} label to measure
     * @protected
     */
    updateMaxLabelSize: function(labelWidth, labelHeight)
    {
        _yuitest_coverfunc("build/charts-base/charts-base.js", "updateMaxLabelSize", 1665);
_yuitest_coverline("build/charts-base/charts-base.js", 1667);
var host = this,
            props = this._labelRotationProps,
            rot = props.rot,
            absRot = props.absRot,
            sinRadians = props.sinRadians,
            cosRadians = props.cosRadians,
            max;
        _yuitest_coverline("build/charts-base/charts-base.js", 1674);
if(rot === 0)
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 1676);
max = labelHeight;
        }
        else {_yuitest_coverline("build/charts-base/charts-base.js", 1678);
if(absRot === 90)
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 1680);
max = labelWidth;
        }
        else
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 1684);
max = (sinRadians * labelWidth) + (cosRadians * labelHeight);
        }}
        _yuitest_coverline("build/charts-base/charts-base.js", 1686);
host._maxLabelSize = Math.max(host._maxLabelSize, max);
    },

    /**
     * Determines the available label height when the axis width has been explicitly set.
     *
     * @method getExplicitlySized
     * @return Boolean
     * @protected
     */
    getExplicitlySized: function(styles)
    {
        _yuitest_coverfunc("build/charts-base/charts-base.js", "getExplicitlySized", 1696);
_yuitest_coverline("build/charts-base/charts-base.js", 1698);
if(this._explicitHeight)
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 1700);
var host = this,
                h = host._explicitHeight,
                totalTitleSize = host._totalTitleSize,
                topTickOffset = host.get("topTickOffset"),
                margin = styles.label.margin.right;
            _yuitest_coverline("build/charts-base/charts-base.js", 1705);
host._maxLabelSize =  h - (topTickOffset + margin + totalTitleSize);
            _yuitest_coverline("build/charts-base/charts-base.js", 1706);
return true;
        }
        _yuitest_coverline("build/charts-base/charts-base.js", 1708);
return false;
    },

    /**
     * Rotate and position title.
     *
     * @method positionTitle
     * @param {HTMLElement} label to rotate position
     * @protected
     */
    positionTitle: function(label)
    {
        _yuitest_coverfunc("build/charts-base/charts-base.js", "positionTitle", 1718);
_yuitest_coverline("build/charts-base/charts-base.js", 1720);
var host = this,
            bounds = host._titleBounds,
            margin = host.get("styles").title.margin,
            props = host._titleRotationProps,
            labelWidth = label.offsetWidth,
            labelHeight = label.offsetHeight,
            h = bounds.bottom - bounds.top,
            x = (host.get("width") * 0.5) - (labelWidth * 0.5),
            y = h/2 - labelHeight/2;
        _yuitest_coverline("build/charts-base/charts-base.js", 1729);
props.labelWidth = labelWidth;
        _yuitest_coverline("build/charts-base/charts-base.js", 1730);
props.labelHeight = labelHeight;
        _yuitest_coverline("build/charts-base/charts-base.js", 1731);
if(margin && margin.top)
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 1733);
y += margin.top;
        }
        _yuitest_coverline("build/charts-base/charts-base.js", 1735);
props.x = x;
        _yuitest_coverline("build/charts-base/charts-base.js", 1736);
props.y = y;
        _yuitest_coverline("build/charts-base/charts-base.js", 1737);
props.transformOrigin = [0.5, 0.5];
        _yuitest_coverline("build/charts-base/charts-base.js", 1738);
host._rotate(label, props);
    },

    /**
     * Rotate and position labels.
     *
     * @method positionLabel
     * @param {HTMLElement} label to rotate position
     * @param {Object} pt hash containing the x and y coordinates in which the label will be positioned
     * against.
     * @protected
     */
    positionLabel: function(label, pt, styles, i)
    {
        _yuitest_coverfunc("build/charts-base/charts-base.js", "positionLabel", 1750);
_yuitest_coverline("build/charts-base/charts-base.js", 1752);
var host = this,
            totalTitleSize = this._totalTitleSize,
            maxLabelSize = host._maxLabelSize,
            leftOffset = pt.x,
            topOffset = pt.y + totalTitleSize + maxLabelSize,
            props = this._labelRotationProps,
            rot = props.rot,
            absRot = props.absRot,
            labelWidth = this._labelWidths[i],
            labelHeight = this._labelHeights[i];
        _yuitest_coverline("build/charts-base/charts-base.js", 1762);
if(rot === 0)
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 1764);
leftOffset -= labelWidth * 0.5;
            _yuitest_coverline("build/charts-base/charts-base.js", 1765);
topOffset -= labelHeight;
        }
        else
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 1769);
if(rot === 90)
            {
                _yuitest_coverline("build/charts-base/charts-base.js", 1771);
leftOffset -= labelWidth;
                _yuitest_coverline("build/charts-base/charts-base.js", 1772);
topOffset -= (labelHeight * 0.5);
            }
            else {_yuitest_coverline("build/charts-base/charts-base.js", 1774);
if (rot === -90)
            {
                _yuitest_coverline("build/charts-base/charts-base.js", 1776);
topOffset -= (labelHeight * 0.5);
            }
            else {_yuitest_coverline("build/charts-base/charts-base.js", 1778);
if(rot > 0)
            {
                _yuitest_coverline("build/charts-base/charts-base.js", 1780);
leftOffset -= labelWidth;
                _yuitest_coverline("build/charts-base/charts-base.js", 1781);
topOffset -= labelHeight - (labelHeight * rot/180);
            }
            else
            {
                _yuitest_coverline("build/charts-base/charts-base.js", 1785);
topOffset -= labelHeight - (labelHeight * absRot/180);
            }}}
        }
        _yuitest_coverline("build/charts-base/charts-base.js", 1788);
props.x = Math.round(leftOffset);
        _yuitest_coverline("build/charts-base/charts-base.js", 1789);
props.y = Math.round(topOffset);
        _yuitest_coverline("build/charts-base/charts-base.js", 1790);
props.labelWidth = labelWidth;
        _yuitest_coverline("build/charts-base/charts-base.js", 1791);
props.labelHeight = labelHeight;
        _yuitest_coverline("build/charts-base/charts-base.js", 1792);
this._rotate(label, props);
    },

    /**
     * Adjusts the coordinates of an axis label based on the rotation.
     *
     * @method _setRotationCoords
     * @param {Object} props Coordinates, dimension and rotation properties of the label.
     * @protected
     */
    _setRotationCoords: function(props)
    {
        _yuitest_coverfunc("build/charts-base/charts-base.js", "_setRotationCoords", 1802);
_yuitest_coverline("build/charts-base/charts-base.js", 1804);
var rot = props.rot,
            absRot = props.absRot,
            labelWidth = props.labelWidth,
            labelHeight = props.labelHeight,
            leftOffset,
            topOffset;
        _yuitest_coverline("build/charts-base/charts-base.js", 1810);
if(rot === 0)
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 1812);
leftOffset = labelWidth * 0.5;
            _yuitest_coverline("build/charts-base/charts-base.js", 1813);
topOffset = labelHeight;
        }
        else
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 1817);
if(rot === 90)
            {
                _yuitest_coverline("build/charts-base/charts-base.js", 1819);
leftOffset = labelWidth;
                _yuitest_coverline("build/charts-base/charts-base.js", 1820);
topOffset = (labelHeight * 0.5);
            }
            else {_yuitest_coverline("build/charts-base/charts-base.js", 1822);
if (rot === -90)
            {
                _yuitest_coverline("build/charts-base/charts-base.js", 1824);
topOffset = (labelHeight * 0.5);
            }
            else {_yuitest_coverline("build/charts-base/charts-base.js", 1826);
if(rot > 0)
            {
                _yuitest_coverline("build/charts-base/charts-base.js", 1828);
leftOffset = labelWidth;
                _yuitest_coverline("build/charts-base/charts-base.js", 1829);
topOffset = labelHeight - (labelHeight * rot/180);
            }
            else
            {
                _yuitest_coverline("build/charts-base/charts-base.js", 1833);
topOffset = labelHeight - (labelHeight * absRot/180);
            }}}
        }
        _yuitest_coverline("build/charts-base/charts-base.js", 1836);
props.x -= leftOffset;
        _yuitest_coverline("build/charts-base/charts-base.js", 1837);
props.y -= topOffset;
    },

    /**
     * Returns the transformOrigin to use for an axis label based on the position of the axis
     * and the rotation of the label.
     *
     * @method _getTransformOrigin
     * @param {Number} rot The rotation (in degrees) of the label.
     * @return Array
     * @protected
     */
    _getTransformOrigin: function(rot)
    {
        _yuitest_coverfunc("build/charts-base/charts-base.js", "_getTransformOrigin", 1849);
_yuitest_coverline("build/charts-base/charts-base.js", 1851);
var transformOrigin;
        _yuitest_coverline("build/charts-base/charts-base.js", 1852);
if(rot === 0)
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 1854);
transformOrigin = [0, 0];
        }
        else
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 1858);
if(rot === 90)
            {
                _yuitest_coverline("build/charts-base/charts-base.js", 1860);
transformOrigin = [1, 0.5];
            }
            else {_yuitest_coverline("build/charts-base/charts-base.js", 1862);
if (rot === -90)
            {
                _yuitest_coverline("build/charts-base/charts-base.js", 1864);
transformOrigin = [0, 0.5];
            }
            else {_yuitest_coverline("build/charts-base/charts-base.js", 1866);
if(rot > 0)
            {
                _yuitest_coverline("build/charts-base/charts-base.js", 1868);
transformOrigin = [1, 0.5];
            }
            else
            {
                _yuitest_coverline("build/charts-base/charts-base.js", 1872);
transformOrigin = [0, 0.5];
            }}}
        }
        _yuitest_coverline("build/charts-base/charts-base.js", 1875);
return transformOrigin;
    },

    /**
     * Adjusts position for inner ticks.
     *
     * @method offsetNodeForTick
     * @param {Node} cb contentBox of the axis
     * @protected
     */
    offsetNodeForTick: function(cb)
    {
    },

    /**
     * Assigns a height based on the size of the contents.
     *
     * @method setCalculatedSize
     * @protected
     */
    setCalculatedSize: function()
    {
        _yuitest_coverfunc("build/charts-base/charts-base.js", "setCalculatedSize", 1895);
_yuitest_coverline("build/charts-base/charts-base.js", 1897);
var host = this,
            graphic = host.get("graphic"),
            styles = host.get("styles"),
            labelMargin = styles.label.margin,
            totalLabelSize = labelMargin.bottom + host._maxLabelSize,
            totalTitleSize = host._totalTitleSize,
            topTickOffset = this.get("topTickOffset"),
            ttl = Math.round(topTickOffset + totalLabelSize + totalTitleSize);
        _yuitest_coverline("build/charts-base/charts-base.js", 1905);
if(this._explicitHeight)
        {
           _yuitest_coverline("build/charts-base/charts-base.js", 1907);
ttl = this._explicitWidth;
        }
        _yuitest_coverline("build/charts-base/charts-base.js", 1909);
host.set("calculatedHeight", ttl);
        _yuitest_coverline("build/charts-base/charts-base.js", 1910);
graphic.set("y", ttl - topTickOffset);
    }
};
_yuitest_coverline("build/charts-base/charts-base.js", 1913);
Y.TopAxisLayout = TopAxisLayout;

/**
 * The Axis class. Generates axes for a chart.
 *
 * @module charts
 * @submodule charts-base
 * @class Axis
 * @extends Widget
 * @uses Renderer
 * @constructor
 * @param {Object} config (optional) Configuration parameters for the Chart.
 */
_yuitest_coverline("build/charts-base/charts-base.js", 1926);
Y.Axis = Y.Base.create("axis", Y.Widget, [Y.Renderer], {
    /**
     * Storage for calculatedWidth value.
     *
     * @property _calculatedWidth
     * @type Number
     * @private
     */
    _calculatedWidth: 0,

    /**
     * Storage for calculatedHeight value.
     *
     * @property _calculatedHeight
     * @type Number
     * @private
     */
    _calculatedHeight: 0,

    /**
     * Handles change to the dataProvider
     *
     * @method _dataChangeHandler
     * @param {Object} e Event object
     * @private
     */
    _dataChangeHandler: function(e)
    {
        _yuitest_coverfunc("build/charts-base/charts-base.js", "_dataChangeHandler", 1952);
_yuitest_coverline("build/charts-base/charts-base.js", 1954);
if(this.get("rendered"))
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 1956);
this._drawAxis();
        }
    },

    /**
     * Handles change to the position attribute
     *
     * @method _positionChangeHandler
     * @param {Object} e Event object
     * @private
     */
    _positionChangeHandler: function(e)
    {
        _yuitest_coverfunc("build/charts-base/charts-base.js", "_positionChangeHandler", 1967);
_yuitest_coverline("build/charts-base/charts-base.js", 1969);
this._updateGraphic(e.newVal);
        _yuitest_coverline("build/charts-base/charts-base.js", 1970);
this._updateHandler();
    },

    /**
     * Updates the the Graphic instance
     *
     * @method _updateGraphic
     * @param {String} position Position of axis
     * @private
     */
    _updateGraphic: function(position)
    {
        _yuitest_coverfunc("build/charts-base/charts-base.js", "_updateGraphic", 1980);
_yuitest_coverline("build/charts-base/charts-base.js", 1982);
var graphic = this.get("graphic");
        _yuitest_coverline("build/charts-base/charts-base.js", 1983);
if(position == "none")
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 1985);
if(graphic)
            {
                _yuitest_coverline("build/charts-base/charts-base.js", 1987);
graphic.destroy();
            }
        }
        else
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 1992);
if(!graphic)
            {
                _yuitest_coverline("build/charts-base/charts-base.js", 1994);
this._setCanvas();
            }
        }
    },

    /**
     * Handles changes to axis.
     *
     * @method _updateHandler
     * @param {Object} e Event object
     * @private
     */
    _updateHandler: function(e)
    {
        _yuitest_coverfunc("build/charts-base/charts-base.js", "_updateHandler", 2006);
_yuitest_coverline("build/charts-base/charts-base.js", 2008);
if(this.get("rendered"))
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 2010);
this._drawAxis();
        }
    },

    /**
     * @method renderUI
     * @private
     */
    renderUI: function()
    {
        _yuitest_coverfunc("build/charts-base/charts-base.js", "renderUI", 2018);
_yuitest_coverline("build/charts-base/charts-base.js", 2020);
this._updateGraphic(this.get("position"));
    },

    /**
     * @method syncUI
     * @private
     */
    syncUI: function()
    {
        _yuitest_coverfunc("build/charts-base/charts-base.js", "syncUI", 2027);
_yuitest_coverline("build/charts-base/charts-base.js", 2029);
var layout = this._layout,
            defaultMargins,
            styles,
            label,
            title,
            i;
        _yuitest_coverline("build/charts-base/charts-base.js", 2035);
if(layout)
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 2037);
defaultMargins = layout._getDefaultMargins();
            _yuitest_coverline("build/charts-base/charts-base.js", 2038);
styles = this.get("styles");
            _yuitest_coverline("build/charts-base/charts-base.js", 2039);
label = styles.label.margin;
            _yuitest_coverline("build/charts-base/charts-base.js", 2040);
title =styles.title.margin;
            //need to defaultMargins method to the layout classes.
            _yuitest_coverline("build/charts-base/charts-base.js", 2042);
for(i in defaultMargins)
            {
                _yuitest_coverline("build/charts-base/charts-base.js", 2044);
if(defaultMargins.hasOwnProperty(i))
                {
                    _yuitest_coverline("build/charts-base/charts-base.js", 2046);
label[i] = label[i] === undefined ? defaultMargins[i] : label[i];
                    _yuitest_coverline("build/charts-base/charts-base.js", 2047);
title[i] = title[i] === undefined ? defaultMargins[i] : title[i];
                }
            }
        }
        _yuitest_coverline("build/charts-base/charts-base.js", 2051);
this._drawAxis();
    },

    /**
     * Creates a graphic instance to be used for the axis line and ticks.
     *
     * @method _setCanvas
     * @private
     */
    _setCanvas: function()
    {
        _yuitest_coverfunc("build/charts-base/charts-base.js", "_setCanvas", 2060);
_yuitest_coverline("build/charts-base/charts-base.js", 2062);
var cb = this.get("contentBox"),
            bb = this.get("boundingBox"),
            p = this.get("position"),
            pn = this._parentNode,
            w = this.get("width"),
            h = this.get("height");
        _yuitest_coverline("build/charts-base/charts-base.js", 2068);
bb.setStyle("position", "absolute");
        _yuitest_coverline("build/charts-base/charts-base.js", 2069);
bb.setStyle("zIndex", 2);
        _yuitest_coverline("build/charts-base/charts-base.js", 2070);
w = w ? w + "px" : pn.getStyle("width");
        _yuitest_coverline("build/charts-base/charts-base.js", 2071);
h = h ? h + "px" : pn.getStyle("height");
        _yuitest_coverline("build/charts-base/charts-base.js", 2072);
if(p === "top" || p === "bottom")
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 2074);
cb.setStyle("width", w);
        }
        else
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 2078);
cb.setStyle("height", h);
        }
        _yuitest_coverline("build/charts-base/charts-base.js", 2080);
cb.setStyle("position", "relative");
        _yuitest_coverline("build/charts-base/charts-base.js", 2081);
cb.setStyle("left", "0px");
        _yuitest_coverline("build/charts-base/charts-base.js", 2082);
cb.setStyle("top", "0px");
        _yuitest_coverline("build/charts-base/charts-base.js", 2083);
this.set("graphic", new Y.Graphic());
        _yuitest_coverline("build/charts-base/charts-base.js", 2084);
this.get("graphic").render(cb);
    },

    /**
     * Gets the default value for the `styles` attribute. Overrides
     * base implementation.
     *
     * @method _getDefaultStyles
     * @return Object
     * @protected
     */
    _getDefaultStyles: function()
    {
        _yuitest_coverfunc("build/charts-base/charts-base.js", "_getDefaultStyles", 2095);
_yuitest_coverline("build/charts-base/charts-base.js", 2097);
var axisstyles = {
            majorTicks: {
                display:"inside",
                length:4,
                color:"#dad8c9",
                weight:1,
                alpha:1
            },
            minorTicks: {
                display:"none",
                length:2,
                color:"#dad8c9",
                weight:1
            },
            line: {
                weight:1,
                color:"#dad8c9",
                alpha:1
            },
            majorUnit: {
                determinant:"count",
                count:11,
                distance:75
            },
            top: "0px",
            left: "0px",
            width: "100px",
            height: "100px",
            label: {
                color:"#808080",
                alpha: 1,
                fontSize:"85%",
                rotation: 0,
                margin: {
                    top: undefined,
                    right: undefined,
                    bottom: undefined,
                    left: undefined
                }
            },
            title: {
                color:"#808080",
                alpha: 1,
                fontSize:"85%",
                rotation: undefined,
                margin: {
                    top: undefined,
                    right: undefined,
                    bottom: undefined,
                    left: undefined
                }
            },
            hideOverlappingLabelTicks: false
        };

        _yuitest_coverline("build/charts-base/charts-base.js", 2152);
return Y.merge(Y.Renderer.prototype._getDefaultStyles(), axisstyles);
    },

    /**
     * Updates the axis when the size changes.
     *
     * @method _handleSizeChange
     * @param {Object} e Event object.
     * @private
     */
    _handleSizeChange: function(e)
    {
        _yuitest_coverfunc("build/charts-base/charts-base.js", "_handleSizeChange", 2162);
_yuitest_coverline("build/charts-base/charts-base.js", 2164);
var attrName = e.attrName,
            pos = this.get("position"),
            vert = pos == "left" || pos == "right",
            cb = this.get("contentBox"),
            hor = pos == "bottom" || pos == "top";
        _yuitest_coverline("build/charts-base/charts-base.js", 2169);
cb.setStyle("width", this.get("width"));
        _yuitest_coverline("build/charts-base/charts-base.js", 2170);
cb.setStyle("height", this.get("height"));
        _yuitest_coverline("build/charts-base/charts-base.js", 2171);
if((hor && attrName == "width") || (vert && attrName == "height"))
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 2173);
this._drawAxis();
        }
    },

    /**
     * Maps key values to classes containing layout algorithms
     *
     * @property _layoutClasses
     * @type Object
     * @private
     */
    _layoutClasses:
    {
        top : TopAxisLayout,
        bottom: BottomAxisLayout,
        left: LeftAxisLayout,
        right : RightAxisLayout
    },

    /**
     * Draws a line segment between 2 points
     *
     * @method drawLine
     * @param {Object} startPoint x and y coordinates for the start point of the line segment
     * @param {Object} endPoint x and y coordinates for the for the end point of the line segment
     * @param {Object} line styles (weight, color and alpha to be applied to the line segment)
     * @private
     */
    drawLine: function(path, startPoint, endPoint)
    {
        _yuitest_coverfunc("build/charts-base/charts-base.js", "drawLine", 2201);
_yuitest_coverline("build/charts-base/charts-base.js", 2203);
path.moveTo(startPoint.x, startPoint.y);
        _yuitest_coverline("build/charts-base/charts-base.js", 2204);
path.lineTo(endPoint.x, endPoint.y);
    },

    /**
     * Generates the properties necessary for rotating and positioning a text field.
     *
     * @method _getTextRotationProps
     * @param {Object} styles properties for the text field
     * @return Object
     * @private
     */
    _getTextRotationProps: function(styles)
    {
        _yuitest_coverfunc("build/charts-base/charts-base.js", "_getTextRotationProps", 2215);
_yuitest_coverline("build/charts-base/charts-base.js", 2217);
if(styles.rotation === undefined)
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 2219);
switch(this.get("position"))
            {
                case "left" :
                    _yuitest_coverline("build/charts-base/charts-base.js", 2222);
styles.rotation = -90;
                _yuitest_coverline("build/charts-base/charts-base.js", 2223);
break;
                case "right" :
                    _yuitest_coverline("build/charts-base/charts-base.js", 2225);
styles.rotation = 90;
                _yuitest_coverline("build/charts-base/charts-base.js", 2226);
break;
                default :
                    _yuitest_coverline("build/charts-base/charts-base.js", 2228);
styles.rotation = 0;
                _yuitest_coverline("build/charts-base/charts-base.js", 2229);
break;
            }
        }
        _yuitest_coverline("build/charts-base/charts-base.js", 2232);
var rot =  Math.min(90, Math.max(-90, styles.rotation)),
            absRot = Math.abs(rot),
            radCon = Math.PI/180,
            sinRadians = parseFloat(parseFloat(Math.sin(absRot * radCon)).toFixed(8)),
            cosRadians = parseFloat(parseFloat(Math.cos(absRot * radCon)).toFixed(8));
        _yuitest_coverline("build/charts-base/charts-base.js", 2237);
return {
            rot: rot,
            absRot: absRot,
            radCon: radCon,
            sinRadians: sinRadians,
            cosRadians: cosRadians,
            textAlpha: styles.alpha
        };
    },

    /**
     * Draws an axis.
     *
     * @method _drawAxis
     * @private
     */
    _drawAxis: function ()
    {
        _yuitest_coverfunc("build/charts-base/charts-base.js", "_drawAxis", 2253);
_yuitest_coverline("build/charts-base/charts-base.js", 2255);
if(this._drawing)
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 2257);
this._callLater = true;
            _yuitest_coverline("build/charts-base/charts-base.js", 2258);
return;
        }
        _yuitest_coverline("build/charts-base/charts-base.js", 2260);
this._drawing = true;
        _yuitest_coverline("build/charts-base/charts-base.js", 2261);
this._callLater = false;
        _yuitest_coverline("build/charts-base/charts-base.js", 2262);
if(this._layout)
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 2264);
var styles = this.get("styles"),
                line = styles.line,
                labelStyles = styles.label,
                majorTickStyles = styles.majorTicks,
                drawTicks = majorTickStyles.display != "none",
                tickPoint,
                majorUnit = styles.majorUnit,
                len,
                majorUnitDistance,
                i = 0,
                layout = this._layout,
                layoutLength,
                position,
                lineStart,
                label,
                labelWidth,
                labelHeight,
                labelFunction = this.get("labelFunction"),
                labelFunctionScope = this.get("labelFunctionScope"),
                labelFormat = this.get("labelFormat"),
                graphic = this.get("graphic"),
                path = this.get("path"),
                tickPath,
                explicitlySized;
            _yuitest_coverline("build/charts-base/charts-base.js", 2288);
this._labelWidths = [];
            _yuitest_coverline("build/charts-base/charts-base.js", 2289);
this._labelHeights = [];
            _yuitest_coverline("build/charts-base/charts-base.js", 2290);
graphic.set("autoDraw", false);
            _yuitest_coverline("build/charts-base/charts-base.js", 2291);
path.clear();
            _yuitest_coverline("build/charts-base/charts-base.js", 2292);
path.set("stroke", {
                weight: line.weight,
                color: line.color,
                opacity: line.alpha
            });
            _yuitest_coverline("build/charts-base/charts-base.js", 2297);
this._labelRotationProps = this._getTextRotationProps(labelStyles);
            _yuitest_coverline("build/charts-base/charts-base.js", 2298);
this._labelRotationProps.transformOrigin = layout._getTransformOrigin(this._labelRotationProps.rot);
            _yuitest_coverline("build/charts-base/charts-base.js", 2299);
layout.setTickOffsets.apply(this);
            _yuitest_coverline("build/charts-base/charts-base.js", 2300);
layoutLength = this.getLength();
            _yuitest_coverline("build/charts-base/charts-base.js", 2301);
lineStart = layout.getLineStart.apply(this);
            _yuitest_coverline("build/charts-base/charts-base.js", 2302);
len = this.getTotalMajorUnits(majorUnit);
            _yuitest_coverline("build/charts-base/charts-base.js", 2303);
majorUnitDistance = this.getMajorUnitDistance(len, layoutLength, majorUnit);
            _yuitest_coverline("build/charts-base/charts-base.js", 2304);
this.set("edgeOffset", this.getEdgeOffset(len, layoutLength) * 0.5);
            _yuitest_coverline("build/charts-base/charts-base.js", 2305);
if(len < 1)
            {
                _yuitest_coverline("build/charts-base/charts-base.js", 2307);
this._clearLabelCache();
            }
            else
            {
                _yuitest_coverline("build/charts-base/charts-base.js", 2311);
tickPoint = this.getFirstPoint(lineStart);
                _yuitest_coverline("build/charts-base/charts-base.js", 2312);
this.drawLine(path, lineStart, this.getLineEnd(tickPoint));
                _yuitest_coverline("build/charts-base/charts-base.js", 2313);
if(drawTicks)
                {
                    _yuitest_coverline("build/charts-base/charts-base.js", 2315);
tickPath = this.get("tickPath");
                    _yuitest_coverline("build/charts-base/charts-base.js", 2316);
tickPath.clear();
                    _yuitest_coverline("build/charts-base/charts-base.js", 2317);
tickPath.set("stroke", {
                        weight: majorTickStyles.weight,
                        color: majorTickStyles.color,
                        opacity: majorTickStyles.alpha
                    });
                   _yuitest_coverline("build/charts-base/charts-base.js", 2322);
layout.drawTick.apply(this, [tickPath, tickPoint, majorTickStyles]);
                }
                _yuitest_coverline("build/charts-base/charts-base.js", 2324);
this._createLabelCache();
                _yuitest_coverline("build/charts-base/charts-base.js", 2325);
this._tickPoints = [];
                _yuitest_coverline("build/charts-base/charts-base.js", 2326);
this._maxLabelSize = 0;
                _yuitest_coverline("build/charts-base/charts-base.js", 2327);
this._totalTitleSize = 0;
                _yuitest_coverline("build/charts-base/charts-base.js", 2328);
this._titleSize = 0;
                _yuitest_coverline("build/charts-base/charts-base.js", 2329);
this._setTitle();
                _yuitest_coverline("build/charts-base/charts-base.js", 2330);
explicitlySized = layout.getExplicitlySized.apply(this, [styles]);
                _yuitest_coverline("build/charts-base/charts-base.js", 2331);
for(; i < len; ++i)
                {
                    _yuitest_coverline("build/charts-base/charts-base.js", 2333);
if(drawTicks)
                    {
                        _yuitest_coverline("build/charts-base/charts-base.js", 2335);
layout.drawTick.apply(this, [tickPath, tickPoint, majorTickStyles]);
                    }
                    _yuitest_coverline("build/charts-base/charts-base.js", 2337);
position = this.getPosition(tickPoint);
                    _yuitest_coverline("build/charts-base/charts-base.js", 2338);
label = this.getLabel(tickPoint, labelStyles);
                    _yuitest_coverline("build/charts-base/charts-base.js", 2339);
this._labels.push(label);
                    _yuitest_coverline("build/charts-base/charts-base.js", 2340);
this._tickPoints.push({x:tickPoint.x, y:tickPoint.y});
                    _yuitest_coverline("build/charts-base/charts-base.js", 2341);
this.get("appendLabelFunction")(label, labelFunction.apply(labelFunctionScope, [this.getLabelByIndex(i, len), labelFormat]));
                    _yuitest_coverline("build/charts-base/charts-base.js", 2342);
labelWidth = Math.round(label.offsetWidth);
                    _yuitest_coverline("build/charts-base/charts-base.js", 2343);
labelHeight = Math.round(label.offsetHeight);
                    _yuitest_coverline("build/charts-base/charts-base.js", 2344);
if(!explicitlySized)
                    {
                        _yuitest_coverline("build/charts-base/charts-base.js", 2346);
this._layout.updateMaxLabelSize.apply(this, [labelWidth, labelHeight]);
                    }
                    _yuitest_coverline("build/charts-base/charts-base.js", 2348);
this._labelWidths.push(labelWidth);
                    _yuitest_coverline("build/charts-base/charts-base.js", 2349);
this._labelHeights.push(labelHeight);
                    _yuitest_coverline("build/charts-base/charts-base.js", 2350);
tickPoint = this.getNextPoint(tickPoint, majorUnitDistance);
                }
                _yuitest_coverline("build/charts-base/charts-base.js", 2352);
this._clearLabelCache();
                _yuitest_coverline("build/charts-base/charts-base.js", 2353);
if(this.get("overlapGraph"))
                {
                   _yuitest_coverline("build/charts-base/charts-base.js", 2355);
layout.offsetNodeForTick.apply(this, [this.get("contentBox")]);
                }
                _yuitest_coverline("build/charts-base/charts-base.js", 2357);
layout.setCalculatedSize.apply(this);
                _yuitest_coverline("build/charts-base/charts-base.js", 2358);
if(this._titleTextField)
                {
                    _yuitest_coverline("build/charts-base/charts-base.js", 2360);
this._layout.positionTitle.apply(this, [this._titleTextField]);
                }
                _yuitest_coverline("build/charts-base/charts-base.js", 2362);
for(i = 0; i < len; ++i)
                {
                    _yuitest_coverline("build/charts-base/charts-base.js", 2364);
layout.positionLabel.apply(this, [this.get("labels")[i], this._tickPoints[i], styles, i]);
                }
            }
        }
        _yuitest_coverline("build/charts-base/charts-base.js", 2368);
this._drawing = false;
        _yuitest_coverline("build/charts-base/charts-base.js", 2369);
if(this._callLater)
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 2371);
this._drawAxis();
        }
        else
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 2375);
this._updatePathElement();
            _yuitest_coverline("build/charts-base/charts-base.js", 2376);
this.fire("axisRendered");
        }
    },

    /**
     * Calculates and sets the total size of a title.
     *
     * @method _setTotalTitleSize
     * @param {Object} styles Properties for the title field.
     * @private
     */
    _setTotalTitleSize: function(styles)
    {
        _yuitest_coverfunc("build/charts-base/charts-base.js", "_setTotalTitleSize", 2387);
_yuitest_coverline("build/charts-base/charts-base.js", 2389);
var title = this._titleTextField,
            w = title.offsetWidth,
            h = title.offsetHeight,
            rot = this._titleRotationProps.rot,
            bounds,
            size,
            margin = styles.margin,
            position = this.get("position"),
            matrix = new Y.Matrix();
        _yuitest_coverline("build/charts-base/charts-base.js", 2398);
matrix.rotate(rot);
        _yuitest_coverline("build/charts-base/charts-base.js", 2399);
bounds = matrix.getContentRect(w, h);
        _yuitest_coverline("build/charts-base/charts-base.js", 2400);
if(position == "left" || position == "right")
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 2402);
size = bounds.right - bounds.left;
            _yuitest_coverline("build/charts-base/charts-base.js", 2403);
if(margin)
            {
                _yuitest_coverline("build/charts-base/charts-base.js", 2405);
size += margin.left + margin.right;
            }
        }
        else
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 2410);
size = bounds.bottom - bounds.top;
            _yuitest_coverline("build/charts-base/charts-base.js", 2411);
if(margin)
            {
                _yuitest_coverline("build/charts-base/charts-base.js", 2413);
size += margin.top + margin.bottom;
            }
        }
        _yuitest_coverline("build/charts-base/charts-base.js", 2416);
this._titleBounds = bounds;
        _yuitest_coverline("build/charts-base/charts-base.js", 2417);
this._totalTitleSize = size;
    },

    /**
     *  Updates path.
     *
     *  @method _updatePathElement
     *  @private
     */
    _updatePathElement: function()
    {
        _yuitest_coverfunc("build/charts-base/charts-base.js", "_updatePathElement", 2426);
_yuitest_coverline("build/charts-base/charts-base.js", 2428);
var path = this._path,
            tickPath = this._tickPath,
            redrawGraphic = false,
            graphic = this.get("graphic");
        _yuitest_coverline("build/charts-base/charts-base.js", 2432);
if(path)
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 2434);
redrawGraphic = true;
            _yuitest_coverline("build/charts-base/charts-base.js", 2435);
path.end();
        }
        _yuitest_coverline("build/charts-base/charts-base.js", 2437);
if(tickPath)
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 2439);
redrawGraphic = true;
            _yuitest_coverline("build/charts-base/charts-base.js", 2440);
tickPath.end();
        }
        _yuitest_coverline("build/charts-base/charts-base.js", 2442);
if(redrawGraphic)
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 2444);
graphic._redraw();
        }
    },

    /**
     * Updates the content and style properties for a title field.
     *
     * @method _updateTitle
     * @private
     */
    _setTitle: function()
    {
        _yuitest_coverfunc("build/charts-base/charts-base.js", "_setTitle", 2454);
_yuitest_coverline("build/charts-base/charts-base.js", 2456);
var i,
            styles,
            customStyles,
            title = this.get("title"),
            titleTextField = this._titleTextField,
            parentNode;
        _yuitest_coverline("build/charts-base/charts-base.js", 2462);
if(title !== null && title !== undefined)
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 2464);
customStyles = {
                    rotation: "rotation",
                    margin: "margin",
                    alpha: "alpha"
            };
            _yuitest_coverline("build/charts-base/charts-base.js", 2469);
styles = this.get("styles").title;
            _yuitest_coverline("build/charts-base/charts-base.js", 2470);
if(!titleTextField)
            {
                _yuitest_coverline("build/charts-base/charts-base.js", 2472);
titleTextField = DOCUMENT.createElement('span');
                _yuitest_coverline("build/charts-base/charts-base.js", 2473);
titleTextField.style.display = "block";
                _yuitest_coverline("build/charts-base/charts-base.js", 2474);
titleTextField.style.whiteSpace = "nowrap";
                _yuitest_coverline("build/charts-base/charts-base.js", 2475);
titleTextField.setAttribute("class", "axisTitle");
                _yuitest_coverline("build/charts-base/charts-base.js", 2476);
this.get("contentBox").append(titleTextField);
            }
            else {_yuitest_coverline("build/charts-base/charts-base.js", 2478);
if(!DOCUMENT.createElementNS)
            {
                _yuitest_coverline("build/charts-base/charts-base.js", 2480);
if(titleTextField.style.filter)
                {
                    _yuitest_coverline("build/charts-base/charts-base.js", 2482);
titleTextField.style.filter = null;
                }
            }}
            _yuitest_coverline("build/charts-base/charts-base.js", 2485);
titleTextField.style.position = "absolute";
            _yuitest_coverline("build/charts-base/charts-base.js", 2486);
for(i in styles)
            {
                _yuitest_coverline("build/charts-base/charts-base.js", 2488);
if(styles.hasOwnProperty(i) && !customStyles.hasOwnProperty(i))
                {
                    _yuitest_coverline("build/charts-base/charts-base.js", 2490);
titleTextField.style[i] = styles[i];
                }
            }
            _yuitest_coverline("build/charts-base/charts-base.js", 2493);
this.get("appendTitleFunction")(titleTextField, title);
            _yuitest_coverline("build/charts-base/charts-base.js", 2494);
this._titleTextField = titleTextField;
            _yuitest_coverline("build/charts-base/charts-base.js", 2495);
this._titleRotationProps = this._getTextRotationProps(styles);
            _yuitest_coverline("build/charts-base/charts-base.js", 2496);
this._setTotalTitleSize(styles);
        }
        else {_yuitest_coverline("build/charts-base/charts-base.js", 2498);
if(titleTextField)
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 2500);
parentNode = titleTextField.parentNode;
            _yuitest_coverline("build/charts-base/charts-base.js", 2501);
if(parentNode)
            {
                _yuitest_coverline("build/charts-base/charts-base.js", 2503);
parentNode.removeChild(titleTextField);
            }
            _yuitest_coverline("build/charts-base/charts-base.js", 2505);
this._titleTextField = null;
            _yuitest_coverline("build/charts-base/charts-base.js", 2506);
this._totalTitleSize = 0;
        }}
    },

    /**
     * Creates or updates an axis label.
     *
     * @method getLabel
     * @param {Object} pt x and y coordinates for the label
     * @param {Object} styles styles applied to label
     * @return HTMLElement
     * @private
     */
    getLabel: function(pt, styles)
    {
        _yuitest_coverfunc("build/charts-base/charts-base.js", "getLabel", 2519);
_yuitest_coverline("build/charts-base/charts-base.js", 2521);
var i,
            label,
            labelCache = this._labelCache,
            customStyles = {
                rotation: "rotation",
                margin: "margin",
                alpha: "alpha"
            };
        _yuitest_coverline("build/charts-base/charts-base.js", 2529);
if(labelCache && labelCache.length > 0)
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 2531);
label = labelCache.shift();
        }
        else
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 2535);
label = DOCUMENT.createElement("span");
            _yuitest_coverline("build/charts-base/charts-base.js", 2536);
label.className = Y.Lang.trim([label.className, "axisLabel"].join(' '));
            _yuitest_coverline("build/charts-base/charts-base.js", 2537);
this.get("contentBox").append(label);
        }
        _yuitest_coverline("build/charts-base/charts-base.js", 2539);
if(!DOCUMENT.createElementNS)
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 2541);
if(label.style.filter)
            {
                _yuitest_coverline("build/charts-base/charts-base.js", 2543);
label.style.filter = null;
            }
        }
        _yuitest_coverline("build/charts-base/charts-base.js", 2546);
label.style.display = "block";
        _yuitest_coverline("build/charts-base/charts-base.js", 2547);
label.style.whiteSpace = "nowrap";
        _yuitest_coverline("build/charts-base/charts-base.js", 2548);
label.style.position = "absolute";
        _yuitest_coverline("build/charts-base/charts-base.js", 2549);
for(i in styles)
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 2551);
if(styles.hasOwnProperty(i) && !customStyles.hasOwnProperty(i))
            {
                _yuitest_coverline("build/charts-base/charts-base.js", 2553);
label.style[i] = styles[i];
            }
        }
        _yuitest_coverline("build/charts-base/charts-base.js", 2556);
return label;
    },

    /**
     * Creates a cache of labels that can be re-used when the axis redraws.
     *
     * @method _createLabelCache
     * @private
     */
    _createLabelCache: function()
    {
        _yuitest_coverfunc("build/charts-base/charts-base.js", "_createLabelCache", 2565);
_yuitest_coverline("build/charts-base/charts-base.js", 2567);
if(this._labels)
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 2569);
while(this._labels.length > 0)
            {
                _yuitest_coverline("build/charts-base/charts-base.js", 2571);
this._labelCache.push(this._labels.shift());
            }
        }
        else
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 2576);
this._clearLabelCache();
        }
        _yuitest_coverline("build/charts-base/charts-base.js", 2578);
this._labels = [];
    },

    /**
     * Removes axis labels from the dom and clears the label cache.
     *
     * @method _clearLabelCache
     * @private
     */
    _clearLabelCache: function()
    {
        _yuitest_coverfunc("build/charts-base/charts-base.js", "_clearLabelCache", 2587);
_yuitest_coverline("build/charts-base/charts-base.js", 2589);
if(this._labelCache)
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 2591);
var len = this._labelCache.length,
                i = 0,
                label;
            _yuitest_coverline("build/charts-base/charts-base.js", 2594);
for(; i < len; ++i)
            {
                _yuitest_coverline("build/charts-base/charts-base.js", 2596);
label = this._labelCache[i];
                _yuitest_coverline("build/charts-base/charts-base.js", 2597);
this._removeChildren(label);
                _yuitest_coverline("build/charts-base/charts-base.js", 2598);
Y.Event.purgeElement(label, true);
                _yuitest_coverline("build/charts-base/charts-base.js", 2599);
label.parentNode.removeChild(label);
            }
        }
        _yuitest_coverline("build/charts-base/charts-base.js", 2602);
this._labelCache = [];
    },

    /**
     * Gets the end point of an axis.
     *
     * @method getLineEnd
     * @return Object
     * @private
     */
    getLineEnd: function(pt)
    {
        _yuitest_coverfunc("build/charts-base/charts-base.js", "getLineEnd", 2612);
_yuitest_coverline("build/charts-base/charts-base.js", 2614);
var w = this.get("width"),
            h = this.get("height"),
            pos = this.get("position");
        _yuitest_coverline("build/charts-base/charts-base.js", 2617);
if(pos === "top" || pos === "bottom")
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 2619);
return {x:w, y:pt.y};
        }
        else
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 2623);
return {x:pt.x, y:h};
        }
    },

    /**
     * Calcuates the width or height of an axis depending on its direction.
     *
     * @method getLength
     * @return Number
     * @private
     */
    getLength: function()
    {
        _yuitest_coverfunc("build/charts-base/charts-base.js", "getLength", 2634);
_yuitest_coverline("build/charts-base/charts-base.js", 2636);
var l,
            style = this.get("styles"),
            padding = style.padding,
            w = this.get("width"),
            h = this.get("height"),
            pos = this.get("position");
        _yuitest_coverline("build/charts-base/charts-base.js", 2642);
if(pos === "top" || pos === "bottom")
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 2644);
l = w - (padding.left + padding.right);
        }
        else
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 2648);
l = h - (padding.top + padding.bottom);
        }
        _yuitest_coverline("build/charts-base/charts-base.js", 2650);
return l;
    },

    /**
     * Gets the position of the first point on an axis.
     *
     * @method getFirstPoint
     * @param {Object} pt Object containing x and y coordinates.
     * @return Object
     * @private
     */
    getFirstPoint:function(pt)
    {
        _yuitest_coverfunc("build/charts-base/charts-base.js", "getFirstPoint", 2661);
_yuitest_coverline("build/charts-base/charts-base.js", 2663);
var style = this.get("styles"),
            pos = this.get("position"),
            padding = style.padding,
            np = {x:pt.x, y:pt.y};
        _yuitest_coverline("build/charts-base/charts-base.js", 2667);
if(pos === "top" || pos === "bottom")
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 2669);
np.x += padding.left + this.get("edgeOffset");
        }
        else
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 2673);
np.y += this.get("height") - (padding.top + this.get("edgeOffset"));
        }
        _yuitest_coverline("build/charts-base/charts-base.js", 2675);
return np;
    },

    /**
     * Gets the position of the next point on an axis.
     *
     * @method getNextPoint
     * @param {Object} point Object containing x and y coordinates.
     * @param {Number} majorUnitDistance Distance in pixels between ticks.
     * @return Object
     * @private
     */
    getNextPoint: function(point, majorUnitDistance)
    {
        _yuitest_coverfunc("build/charts-base/charts-base.js", "getNextPoint", 2687);
_yuitest_coverline("build/charts-base/charts-base.js", 2689);
var pos = this.get("position");
        _yuitest_coverline("build/charts-base/charts-base.js", 2690);
if(pos === "top" || pos === "bottom")
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 2692);
point.x = point.x + majorUnitDistance;
        }
        else
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 2696);
point.y = point.y - majorUnitDistance;
        }
        _yuitest_coverline("build/charts-base/charts-base.js", 2698);
return point;
    },

    /**
     * Calculates the placement of last tick on an axis.
     *
     * @method getLastPoint
     * @return Object
     * @private
     */
    getLastPoint: function()
    {
        _yuitest_coverfunc("build/charts-base/charts-base.js", "getLastPoint", 2708);
_yuitest_coverline("build/charts-base/charts-base.js", 2710);
var style = this.get("styles"),
            padding = style.padding,
            w = this.get("width"),
            pos = this.get("position");
        _yuitest_coverline("build/charts-base/charts-base.js", 2714);
if(pos === "top" || pos === "bottom")
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 2716);
return {x:w - padding.right, y:padding.top};
        }
        else
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 2720);
return {x:padding.left, y:padding.top};
        }
    },

    /**
     * Calculates position on the axis.
     *
     * @method getPosition
     * @param {Object} point contains x and y values
     * @private
     */
    getPosition: function(point)
    {
        _yuitest_coverfunc("build/charts-base/charts-base.js", "getPosition", 2731);
_yuitest_coverline("build/charts-base/charts-base.js", 2733);
var p,
            h = this.get("height"),
            style = this.get("styles"),
            padding = style.padding,
            pos = this.get("position"),
            dataType = this.get("dataType");
        _yuitest_coverline("build/charts-base/charts-base.js", 2739);
if(pos === "left" || pos === "right")
        {
            //Numeric data on a vertical axis is displayed from bottom to top.
            //Categorical and Timeline data is displayed from top to bottom.
            _yuitest_coverline("build/charts-base/charts-base.js", 2743);
if(dataType === "numeric")
            {
                _yuitest_coverline("build/charts-base/charts-base.js", 2745);
p = (h - (padding.top + padding.bottom)) - (point.y - padding.top);
            }
            else
            {
                _yuitest_coverline("build/charts-base/charts-base.js", 2749);
p = point.y - padding.top;
            }
        }
        else
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 2754);
p = point.x - padding.left;
        }
        _yuitest_coverline("build/charts-base/charts-base.js", 2756);
return p;
    },

    /**
     * Rotates and positions a text field.
     *
     * @method _rotate
     * @param {HTMLElement} label text field to rotate and position
     * @param {Object} props properties to be applied to the text field.
     * @private
     */
    _rotate: function(label, props)
    {
        _yuitest_coverfunc("build/charts-base/charts-base.js", "_rotate", 2767);
_yuitest_coverline("build/charts-base/charts-base.js", 2769);
var rot = props.rot,
            x = props.x,
            y = props.y,
            filterString,
            textAlpha,
            matrix = new Y.Matrix(),
            transformOrigin = props.transformOrigin || [0, 0],
            offsetRect;
        _yuitest_coverline("build/charts-base/charts-base.js", 2777);
if(DOCUMENT.createElementNS)
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 2779);
matrix.translate(x, y);
            _yuitest_coverline("build/charts-base/charts-base.js", 2780);
matrix.rotate(rot);
            _yuitest_coverline("build/charts-base/charts-base.js", 2781);
Y_DOM.setStyle(label, "transformOrigin", (transformOrigin[0] * 100) + "% " + (transformOrigin[1] * 100) + "%");
            _yuitest_coverline("build/charts-base/charts-base.js", 2782);
Y_DOM.setStyle(label, "transform", matrix.toCSSText());
        }
        else
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 2786);
textAlpha = props.textAlpha;
            _yuitest_coverline("build/charts-base/charts-base.js", 2787);
if(Y_Lang.isNumber(textAlpha) && textAlpha < 1 && textAlpha > -1 && !isNaN(textAlpha))
            {
                _yuitest_coverline("build/charts-base/charts-base.js", 2789);
filterString = "progid:DXImageTransform.Microsoft.Alpha(Opacity=" + Math.round(textAlpha * 100) + ")";
            }
            _yuitest_coverline("build/charts-base/charts-base.js", 2791);
if(rot !== 0)
            {
                //ms filters kind of, sort of uses a transformOrigin of 0, 0.
                //we'll translate the difference to create a true 0, 0 origin.
                _yuitest_coverline("build/charts-base/charts-base.js", 2795);
matrix.rotate(rot);
                _yuitest_coverline("build/charts-base/charts-base.js", 2796);
offsetRect = matrix.getContentRect(props.labelWidth, props.labelHeight);
                _yuitest_coverline("build/charts-base/charts-base.js", 2797);
matrix.init();
                _yuitest_coverline("build/charts-base/charts-base.js", 2798);
matrix.translate(offsetRect.left, offsetRect.top);
                _yuitest_coverline("build/charts-base/charts-base.js", 2799);
matrix.translate(x, y);
                _yuitest_coverline("build/charts-base/charts-base.js", 2800);
this._simulateRotateWithTransformOrigin(matrix, rot, transformOrigin, props.labelWidth, props.labelHeight);
                _yuitest_coverline("build/charts-base/charts-base.js", 2801);
if(filterString)
                {
                    _yuitest_coverline("build/charts-base/charts-base.js", 2803);
filterString += " ";
                }
                else
                {
                    _yuitest_coverline("build/charts-base/charts-base.js", 2807);
filterString = "";
                }
                _yuitest_coverline("build/charts-base/charts-base.js", 2809);
filterString += matrix.toFilterText();
                _yuitest_coverline("build/charts-base/charts-base.js", 2810);
label.style.left = matrix.dx + "px";
                _yuitest_coverline("build/charts-base/charts-base.js", 2811);
label.style.top = matrix.dy + "px";
            }
            else
            {
                _yuitest_coverline("build/charts-base/charts-base.js", 2815);
label.style.left = x + "px";
                _yuitest_coverline("build/charts-base/charts-base.js", 2816);
label.style.top = y + "px";
            }
            _yuitest_coverline("build/charts-base/charts-base.js", 2818);
if(filterString)
            {
                _yuitest_coverline("build/charts-base/charts-base.js", 2820);
label.style.filter = filterString;
            }
        }
    },

    /**
     * Simulates a rotation with a specified transformOrigin.
     *
     * @method _simulateTransformOrigin
     * @param {Matrix} matrix Reference to a `Matrix` instance.
     * @param {Number} rot The rotation (in degrees) that will be performed on a matrix.
     * @param {Array} transformOrigin An array represeniting the origin in which to perform the transform. The first
     * index represents the x origin and the second index represents the y origin.
     * @param {Number} w The width of the object that will be transformed.
     * @param {Number} h The height of the object that will be transformed.
     * @private
     */
    _simulateRotateWithTransformOrigin: function(matrix, rot, transformOrigin, w, h)
    {
        _yuitest_coverfunc("build/charts-base/charts-base.js", "_simulateRotateWithTransformOrigin", 2837);
_yuitest_coverline("build/charts-base/charts-base.js", 2839);
var transformX = transformOrigin[0] * w,
            transformY = transformOrigin[1] * h;
        _yuitest_coverline("build/charts-base/charts-base.js", 2841);
transformX = !isNaN(transformX) ? transformX : 0;
        _yuitest_coverline("build/charts-base/charts-base.js", 2842);
transformY = !isNaN(transformY) ? transformY : 0;
        _yuitest_coverline("build/charts-base/charts-base.js", 2843);
matrix.translate(transformX, transformY);
        _yuitest_coverline("build/charts-base/charts-base.js", 2844);
matrix.rotate(rot);
        _yuitest_coverline("build/charts-base/charts-base.js", 2845);
matrix.translate(-transformX, -transformY);
    },

    /**
     * Returns the coordinates (top, right, bottom, left) for the bounding box of the last label.
     *
     * @method getMaxLabelBounds
     * @return Object
     */
    getMaxLabelBounds: function()
    {
        _yuitest_coverfunc("build/charts-base/charts-base.js", "getMaxLabelBounds", 2854);
_yuitest_coverline("build/charts-base/charts-base.js", 2856);
return this._getLabelBounds(this.getMaximumValue());
    },

    /**
     * Returns the coordinates (top, right, bottom, left) for the bounding box of the first label.
     *
     * @method getMinLabelBounds
     * @return Object
     */
    getMinLabelBounds: function()
    {
        _yuitest_coverfunc("build/charts-base/charts-base.js", "getMinLabelBounds", 2865);
_yuitest_coverline("build/charts-base/charts-base.js", 2867);
return this._getLabelBounds(this.getMinimumValue());
    },

    /**
     * Returns the coordinates (top, right, bottom, left) for the bounding box of a label.
     *
     * @method _getLabelBounds
     * @param {String} Value of the label
     * @return Object
     * @private
     */
    _getLabelBounds: function(val)
    {
        _yuitest_coverfunc("build/charts-base/charts-base.js", "_getLabelBounds", 2878);
_yuitest_coverline("build/charts-base/charts-base.js", 2880);
var layout = this._layout,
            labelStyles = this.get("styles").label,
            matrix = new Y.Matrix(),
            label,
            props = this._getTextRotationProps(labelStyles);
            _yuitest_coverline("build/charts-base/charts-base.js", 2885);
props.transformOrigin = layout._getTransformOrigin(props.rot);
        _yuitest_coverline("build/charts-base/charts-base.js", 2886);
label = this.getLabel({x: 0, y: 0}, labelStyles);
        _yuitest_coverline("build/charts-base/charts-base.js", 2887);
this.get("appendLabelFunction")(label, this.get("labelFunction").apply(this, [val, this.get("labelFormat")]));
        _yuitest_coverline("build/charts-base/charts-base.js", 2888);
props.labelWidth = label.offsetWidth;
        _yuitest_coverline("build/charts-base/charts-base.js", 2889);
props.labelHeight = label.offsetHeight;
        _yuitest_coverline("build/charts-base/charts-base.js", 2890);
this._removeChildren(label);
        _yuitest_coverline("build/charts-base/charts-base.js", 2891);
Y.Event.purgeElement(label, true);
        _yuitest_coverline("build/charts-base/charts-base.js", 2892);
label.parentNode.removeChild(label);
        _yuitest_coverline("build/charts-base/charts-base.js", 2893);
props.x = 0;
        _yuitest_coverline("build/charts-base/charts-base.js", 2894);
props.y = 0;
        _yuitest_coverline("build/charts-base/charts-base.js", 2895);
layout._setRotationCoords(props);
        _yuitest_coverline("build/charts-base/charts-base.js", 2896);
matrix.translate(props.x, props.y);
        _yuitest_coverline("build/charts-base/charts-base.js", 2897);
this._simulateRotateWithTransformOrigin(matrix, props.rot, props.transformOrigin, props.labelWidth, props.labelHeight);
        _yuitest_coverline("build/charts-base/charts-base.js", 2898);
return matrix.getContentRect(props.labelWidth, props.labelHeight);
    },

    /**
     * Removes all DOM elements from an HTML element. Used to clear out labels during detruction
     * phase.
     *
     * @method _removeChildren
     * @private
     */
    _removeChildren: function(node)
    {
        _yuitest_coverfunc("build/charts-base/charts-base.js", "_removeChildren", 2908);
_yuitest_coverline("build/charts-base/charts-base.js", 2910);
if(node.hasChildNodes())
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 2912);
var child;
            _yuitest_coverline("build/charts-base/charts-base.js", 2913);
while(node.firstChild)
            {
                _yuitest_coverline("build/charts-base/charts-base.js", 2915);
child = node.firstChild;
                _yuitest_coverline("build/charts-base/charts-base.js", 2916);
this._removeChildren(child);
                _yuitest_coverline("build/charts-base/charts-base.js", 2917);
node.removeChild(child);
            }
        }
    },

    /**
     * Destructor implementation Axis class. Removes all labels and the Graphic instance from the widget.
     *
     * @method destructor
     * @protected
     */
    destructor: function()
    {
        _yuitest_coverfunc("build/charts-base/charts-base.js", "destructor", 2928);
_yuitest_coverline("build/charts-base/charts-base.js", 2930);
var cb = this.get("contentBox").getDOMNode(),
            labels = this.get("labels"),
            graphic = this.get("graphic"),
            label,
            len = labels ? labels.length : 0;
        _yuitest_coverline("build/charts-base/charts-base.js", 2935);
if(len > 0)
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 2937);
while(labels.length > 0)
            {
                _yuitest_coverline("build/charts-base/charts-base.js", 2939);
label = labels.shift();
                _yuitest_coverline("build/charts-base/charts-base.js", 2940);
this._removeChildren(label);
                _yuitest_coverline("build/charts-base/charts-base.js", 2941);
cb.removeChild(label);
                _yuitest_coverline("build/charts-base/charts-base.js", 2942);
label = null;
            }
        }
        _yuitest_coverline("build/charts-base/charts-base.js", 2945);
if(graphic)
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 2947);
graphic.destroy();
        }
    },

    /**
     * Length in pixels of largest text bounding box. Used to calculate the height of the axis.
     *
     * @property maxLabelSize
     * @type Number
     * @protected
     */
    _maxLabelSize: 0,

    /**
     * Updates the content of text field. This method writes a value into a text field using
     * `appendChild`. If the value is a `String`, it is converted to a `TextNode` first.
     *
     * @method _setText
     * @param label {HTMLElement} label to be updated
     * @param val {String} value with which to update the label
     * @private
     */
    _setText: function(textField, val)
    {
        _yuitest_coverfunc("build/charts-base/charts-base.js", "_setText", 2969);
_yuitest_coverline("build/charts-base/charts-base.js", 2971);
textField.innerHTML = "";
        _yuitest_coverline("build/charts-base/charts-base.js", 2972);
if(Y_Lang.isNumber(val))
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 2974);
val = val + "";
        }
        else {_yuitest_coverline("build/charts-base/charts-base.js", 2976);
if(!val)
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 2978);
val = "";
        }}
        _yuitest_coverline("build/charts-base/charts-base.js", 2980);
if(IS_STRING(val))
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 2982);
val = DOCUMENT.createTextNode(val);
        }
        _yuitest_coverline("build/charts-base/charts-base.js", 2984);
textField.appendChild(val);
    }
}, {
    ATTRS:
    {
        /**
         * When set, defines the width of a vertical axis instance. By default, vertical axes automatically size based
         * on their contents. When the width attribute is set, the axis will not calculate its width. When the width
         * attribute is explicitly set, axis labels will postion themselves off of the the inner edge of the axis and the
         * title, if present, will position itself off of the outer edge. If a specified width is less than the sum of
         * the axis' contents, excess content will overflow.
         *
         * @attribute width
         * @type Number
         */
        width: {
            lazyAdd: false,

            getter: function()
            {
                _yuitest_coverfunc("build/charts-base/charts-base.js", "getter", 3002);
_yuitest_coverline("build/charts-base/charts-base.js", 3004);
if(this._explicitWidth)
                {
                    _yuitest_coverline("build/charts-base/charts-base.js", 3006);
return this._explicitWidth;
                }
                _yuitest_coverline("build/charts-base/charts-base.js", 3008);
return this._calculatedWidth;
            },

            setter: function(val)
            {
                _yuitest_coverfunc("build/charts-base/charts-base.js", "setter", 3011);
_yuitest_coverline("build/charts-base/charts-base.js", 3013);
this._explicitWidth = val;
                _yuitest_coverline("build/charts-base/charts-base.js", 3014);
return val;
            }
        },

        /**
         * When set, defines the height of a horizontal axis instance. By default, horizontal axes automatically size based
         * on their contents. When the height attribute is set, the axis will not calculate its height. When the height
         * attribute is explicitly set, axis labels will postion themselves off of the the inner edge of the axis and the
         * title, if present, will position itself off of the outer edge. If a specified height is less than the sum of
         * the axis' contents, excess content will overflow.
         *
         * @attribute height
         * @type Number
         */
        height: {
            lazyAdd: false,

            getter: function()
            {
                _yuitest_coverfunc("build/charts-base/charts-base.js", "getter", 3031);
_yuitest_coverline("build/charts-base/charts-base.js", 3033);
if(this._explicitHeight)
                {
                    _yuitest_coverline("build/charts-base/charts-base.js", 3035);
return this._explicitHeight;
                }
                _yuitest_coverline("build/charts-base/charts-base.js", 3037);
return this._calculatedHeight;
            },

            setter: function(val)
            {
                _yuitest_coverfunc("build/charts-base/charts-base.js", "setter", 3040);
_yuitest_coverline("build/charts-base/charts-base.js", 3042);
this._explicitHeight = val;
                _yuitest_coverline("build/charts-base/charts-base.js", 3043);
return val;
            }
        },

        /**
         * Calculated value of an axis' width. By default, the value is used internally for vertical axes. If the `width`
         * attribute is explicitly set, this value will be ignored.
         *
         * @attribute calculatedWidth
         * @type Number
         * @private
         */
        calculatedWidth: {
            getter: function()
            {
                _yuitest_coverfunc("build/charts-base/charts-base.js", "getter", 3056);
_yuitest_coverline("build/charts-base/charts-base.js", 3058);
return this._calculatedWidth;
            },

            setter: function(val)
            {
                _yuitest_coverfunc("build/charts-base/charts-base.js", "setter", 3061);
_yuitest_coverline("build/charts-base/charts-base.js", 3063);
this._calculatedWidth = val;
                _yuitest_coverline("build/charts-base/charts-base.js", 3064);
return val;
            }
        },

        /**
         * Calculated value of an axis' height. By default, the value is used internally for horizontal axes. If the `height`
         * attribute is explicitly set, this value will be ignored.
         *
         * @attribute calculatedHeight
         * @type Number
         * @private
         */
        calculatedHeight: {
            getter: function()
            {
                _yuitest_coverfunc("build/charts-base/charts-base.js", "getter", 3077);
_yuitest_coverline("build/charts-base/charts-base.js", 3079);
return this._calculatedHeight;
            },

            setter: function(val)
            {
                _yuitest_coverfunc("build/charts-base/charts-base.js", "setter", 3082);
_yuitest_coverline("build/charts-base/charts-base.js", 3084);
this._calculatedHeight = val;
                _yuitest_coverline("build/charts-base/charts-base.js", 3085);
return val;
            }
        },

        /**
         * Difference betweend the first/last tick and edge of axis.
         *
         * @attribute edgeOffset
         * @type Number
         * @protected
         */
        edgeOffset:
        {
            value: 0
        },

        /**
         * The graphic in which the axis line and ticks will be rendered.
         *
         * @attribute graphic
         * @type Graphic
         */
        graphic: {},

        /**
         *  @attribute path
         *  @type Shape
         *  @readOnly
         *  @private
         */
        path: {
            readOnly: true,

            getter: function()
            {
                _yuitest_coverfunc("build/charts-base/charts-base.js", "getter", 3118);
_yuitest_coverline("build/charts-base/charts-base.js", 3120);
if(!this._path)
                {
                    _yuitest_coverline("build/charts-base/charts-base.js", 3122);
var graphic = this.get("graphic");
                    _yuitest_coverline("build/charts-base/charts-base.js", 3123);
if(graphic)
                    {
                        _yuitest_coverline("build/charts-base/charts-base.js", 3125);
this._path = graphic.addShape({type:"path"});
                    }
                }
                _yuitest_coverline("build/charts-base/charts-base.js", 3128);
return this._path;
            }
        },

        /**
         *  @attribute tickPath
         *  @type Shape
         *  @readOnly
         *  @private
         */
        tickPath: {
            readOnly: true,

            getter: function()
            {
                _yuitest_coverfunc("build/charts-base/charts-base.js", "getter", 3141);
_yuitest_coverline("build/charts-base/charts-base.js", 3143);
if(!this._tickPath)
                {
                    _yuitest_coverline("build/charts-base/charts-base.js", 3145);
var graphic = this.get("graphic");
                    _yuitest_coverline("build/charts-base/charts-base.js", 3146);
if(graphic)
                    {
                        _yuitest_coverline("build/charts-base/charts-base.js", 3148);
this._tickPath = graphic.addShape({type:"path"});
                    }
                }
                _yuitest_coverline("build/charts-base/charts-base.js", 3151);
return this._tickPath;
            }
        },

        /**
         * Contains the contents of the axis.
         *
         * @attribute node
         * @type HTMLElement
         */
        node: {},

        /**
         * Direction of the axis.
         *
         * @attribute position
         * @type String
         */
        position: {
            setter: function(val)
            {
                _yuitest_coverfunc("build/charts-base/charts-base.js", "setter", 3170);
_yuitest_coverline("build/charts-base/charts-base.js", 3172);
var layoutClass = this._layoutClasses[val];
                _yuitest_coverline("build/charts-base/charts-base.js", 3173);
if(val && val != "none")
                {
                    _yuitest_coverline("build/charts-base/charts-base.js", 3175);
this._layout = new layoutClass();
                }
                _yuitest_coverline("build/charts-base/charts-base.js", 3177);
return val;
            }
        },

        /**
         * Distance determined by the tick styles used to calculate the distance between the axis
         * line in relation to the top of the axis.
         *
         * @attribute topTickOffset
         * @type Number
         */
        topTickOffset: {
            value: 0
        },

        /**
         * Distance determined by the tick styles used to calculate the distance between the axis
         * line in relation to the bottom of the axis.
         *
         * @attribute bottomTickOffset
         * @type Number
         */
        bottomTickOffset: {
            value: 0
        },

        /**
         * Distance determined by the tick styles used to calculate the distance between the axis
         * line in relation to the left of the axis.
         *
         * @attribute leftTickOffset
         * @type Number
         */
        leftTickOffset: {
            value: 0
        },

        /**
         * Distance determined by the tick styles used to calculate the distance between the axis
         * line in relation to the right side of the axis.
         *
         * @attribute rightTickOffset
         * @type Number
         */
        rightTickOffset: {
            value: 0
        },

        /**
         * Collection of labels used to render the axis.
         *
         * @attribute labels
         * @type Array
         */
        labels: {
            readOnly: true,
            getter: function()
            {
                _yuitest_coverfunc("build/charts-base/charts-base.js", "getter", 3233);
_yuitest_coverline("build/charts-base/charts-base.js", 3235);
return this._labels;
            }
        },

        /**
         * Collection of points used for placement of labels and ticks along the axis.
         *
         * @attribute tickPoints
         * @type Array
         */
        tickPoints: {
            readOnly: true,

            getter: function()
            {
                _yuitest_coverfunc("build/charts-base/charts-base.js", "getter", 3248);
_yuitest_coverline("build/charts-base/charts-base.js", 3250);
if(this.get("position") == "none")
                {
                    _yuitest_coverline("build/charts-base/charts-base.js", 3252);
return this.get("styles").majorUnit.count;
                }
                _yuitest_coverline("build/charts-base/charts-base.js", 3254);
return this._tickPoints;
            }
        },

        /**
         * Indicates whether the axis overlaps the graph. If an axis is the inner most axis on a given
         * position and the tick position is inside or cross, the axis will need to overlap the graph.
         *
         * @attribute overlapGraph
         * @type Boolean
         */
        overlapGraph: {
            value:true,

            validator: function(val)
            {
                _yuitest_coverfunc("build/charts-base/charts-base.js", "validator", 3268);
_yuitest_coverline("build/charts-base/charts-base.js", 3270);
return Y_Lang.isBoolean(val);
            }
        },

        /**
         * Object which should have by the labelFunction
         *
         * @attribute labelFunctionScope
         * @type Object
         */
        labelFunctionScope: {},

        /**
         * Length in pixels of largest text bounding box. Used to calculate the height of the axis.
         *
         * @attribute maxLabelSize
         * @type Number
         * @protected
         */
        maxLabelSize: {
            getter: function()
            {
                _yuitest_coverfunc("build/charts-base/charts-base.js", "getter", 3290);
_yuitest_coverline("build/charts-base/charts-base.js", 3292);
return this._maxLabelSize;
            },

            setter: function(val)
            {
                _yuitest_coverfunc("build/charts-base/charts-base.js", "setter", 3295);
_yuitest_coverline("build/charts-base/charts-base.js", 3297);
this._maxLabelSize = val;
                _yuitest_coverline("build/charts-base/charts-base.js", 3298);
return val;
            }
        },

        /**
         *  Title for the axis. When specified, the title will display. The position of the title is determined by the axis position.
         *  <dl>
         *      <dt>top</dt><dd>Appears above the axis and it labels. The default rotation is 0.</dd>
         *      <dt>right</dt><dd>Appears to the right of the axis and its labels. The default rotation is 90.</dd>
         *      <dt>bottom</dt><dd>Appears below the axis and its labels. The default rotation is 0.</dd>
         *      <dt>left</dt><dd>Appears to the left of the axis and its labels. The default rotation is -90.</dd>
         *  </dl>
         *
         *  @attribute title
         *  @type String
         */
        title: {
            value: null
        },

        /**
         * Method used for formatting a label. This attribute allows for the default label formatting method to overridden.
         * The method use would need to implement the arguments below and return a `String` or `HTMLElement`.
         * <dl>
         *      <dt>val</dt><dd>Label to be formatted. (`String`)</dd>
         *      <dt>format</dt><dd>Template for formatting label. (optional)</dd>
         * </dl>
         *
         * @attribute labelFunction
         * @type Function
         */
        labelFunction: {
            value: function(val, format)
            {
                _yuitest_coverfunc("build/charts-base/charts-base.js", "value", 3330);
_yuitest_coverline("build/charts-base/charts-base.js", 3332);
return val;
            }
        },

        /**
         * Function used to append an axis value to an axis label. This function has the following signature:
         *  <dl>
         *      <dt>textField</dt><dd>The axis label to be appended. (`HTMLElement`)</dd>
         *      <dt>val</dt><dd>The value to attach to the text field. This method will accept an `HTMLELement`
         *      or a `String`. This method does not use (`HTMLElement` | `String`)</dd>
         *  </dl>
         * The default method appends a value to the `HTMLElement` using the `appendChild` method. If the given
         * value is a `String`, the method will convert the the value to a `textNode` before appending to the
         * `HTMLElement`. This method will not convert an `HTMLString` to an `HTMLElement`.
         *
         * @attribute appendLabelFunction
         * @type Function
         */
        appendLabelFunction: {
            valueFn: function()
            {
                _yuitest_coverfunc("build/charts-base/charts-base.js", "valueFn", 3351);
_yuitest_coverline("build/charts-base/charts-base.js", 3353);
return this._setText;
            }
        },

        /**
         * Function used to append a title value to the title object. This function has the following signature:
         *  <dl>
         *      <dt>textField</dt><dd>The title text field to be appended. (`HTMLElement`)</dd>
         *      <dt>val</dt><dd>The value to attach to the text field. This method will accept an `HTMLELement`
         *      or a `String`. This method does not use (`HTMLElement` | `String`)</dd>
         *  </dl>
         * The default method appends a value to the `HTMLElement` using the `appendChild` method. If the given
         * value is a `String`, the method will convert the the value to a `textNode` before appending to the
         * `HTMLElement` element. This method will not convert an `HTMLString` to an `HTMLElement`.
         *
         * @attribute appendTitleFunction
         * @type Function
         */
        appendTitleFunction: {
            valueFn: function()
            {
                _yuitest_coverfunc("build/charts-base/charts-base.js", "valueFn", 3372);
_yuitest_coverline("build/charts-base/charts-base.js", 3374);
return this._setText;
            }
        }

        /**
         * Style properties used for drawing an axis. This attribute is inherited from `Renderer`. Below are the default values:
         *  <dl>
         *      <dt>majorTicks</dt><dd>Properties used for drawing ticks.
         *          <dl>
         *              <dt>display</dt><dd>Position of the tick. Possible values are `inside`, `outside`, `cross` and `none`.
         *              The default value is `inside`.</dd>
         *              <dt>length</dt><dd>The length (in pixels) of the tick. The default value is 4.</dd>
         *              <dt>color</dt><dd>The color of the tick. The default value is `#dad8c9`</dd>
         *              <dt>weight</dt><dd>Number indicating the width of the tick. The default value is 1.</dd>
         *              <dt>alpha</dt><dd>Number from 0 to 1 indicating the opacity of the tick. The default value is 1.</dd>
         *          </dl>
         *      </dd>
         *      <dt>line</dt><dd>Properties used for drawing the axis line.
         *          <dl>
         *              <dt>weight</dt><dd>Number indicating the width of the axis line. The default value is 1.</dd>
         *              <dt>color</dt><dd>The color of the axis line. The default value is `#dad8c9`.</dd>
         *              <dt>alpha</dt><dd>Number from 0 to 1 indicating the opacity of the tick. The default value is 1.</dd>
         *          </dl>
         *      </dd>
         *      <dt>majorUnit</dt><dd>Properties used to calculate the `majorUnit` for the axis.
         *          <dl>
         *              <dt>determinant</dt><dd>The algorithm used for calculating distance between ticks. The possible options are
         *              `count` and `distance`. If the `determinant` is `count`, the axis ticks will spaced so that a specified number
         *              of ticks appear on the axis. If the `determinant` is `distance`, the axis ticks will spaced out according to
         *              the specified distance. The default value is `count`.</dd>
         *              <dt>count</dt><dd>Number of ticks to appear on the axis when the `determinant` is `count`. The default value is 11.</dd>
         *              <dt>distance</dt><dd>The distance (in pixels) between ticks when the `determinant` is `distance`. The default
         *              value is 75.</dd>
         *          </dl>
         *      </dd>
         *      <dt>label</dt><dd>Properties and styles applied to the axis labels.
         *          <dl>
         *              <dt>color</dt><dd>The color of the labels. The default value is `#808080`.</dd>
         *              <dt>alpha</dt><dd>Number between 0 and 1 indicating the opacity of the labels. The default value is 1.</dd>
         *              <dt>fontSize</dt><dd>The font-size of the labels. The default value is 85%</dd>
         *              <dt>rotation</dt><dd>The rotation, in degrees (between -90 and 90) of the labels. The default value is 0.</dd>
         *              <dt>margin</dt><dd>The distance between the label and the axis/tick. Depending on the position of the `Axis`,
         *              only one of the properties used.
         *                  <dl>
         *                      <dt>top</dt><dd>Pixel value used for an axis with a `position` of `bottom`. The default value is 4.</dd>
         *                      <dt>right</dt><dd>Pixel value used for an axis with a `position` of `left`. The default value is 4.</dd>
         *                      <dt>bottom</dt><dd>Pixel value used for an axis with a `position` of `top`. The default value is 4.</dd>
         *                      <dt>left</dt><dd>Pixel value used for an axis with a `position` of `right`. The default value is 4.</dd>
         *                  </dl>
         *              </dd>
         *          </dl>
         *      </dd>
         *  </dl>
         *
         * @attribute styles
         * @type Object
         */
    }
});
/**
 * AxisType is an abstract class that manages the data for an axis.
 *
 * @module charts
 * @submodule charts-base
 * @class AxisType
 * @constructor
 * @extends Axis
 */
_yuitest_coverline("build/charts-base/charts-base.js", 3442);
Y.AxisType = Y.Base.create("baseAxis", Y.Axis, [], {
    /**
     * @method initializer
     * @private
     */
    initializer: function()
    {
        _yuitest_coverfunc("build/charts-base/charts-base.js", "initializer", 3447);
_yuitest_coverline("build/charts-base/charts-base.js", 3449);
this.after("dataReady", Y.bind(this._dataChangeHandler, this));
        _yuitest_coverline("build/charts-base/charts-base.js", 3450);
this.after("dataUpdate", Y.bind(this._dataChangeHandler, this));
        _yuitest_coverline("build/charts-base/charts-base.js", 3451);
this.after("minimumChange", Y.bind(this._keyChangeHandler, this));
        _yuitest_coverline("build/charts-base/charts-base.js", 3452);
this.after("maximumChange", Y.bind(this._keyChangeHandler, this));
        _yuitest_coverline("build/charts-base/charts-base.js", 3453);
this.after("keysChange", this._keyChangeHandler);
        _yuitest_coverline("build/charts-base/charts-base.js", 3454);
this.after("dataProviderChange", this._dataProviderChangeHandler);
        _yuitest_coverline("build/charts-base/charts-base.js", 3455);
this.after("alwaysShowZeroChange", this._keyChangeHandler);
        _yuitest_coverline("build/charts-base/charts-base.js", 3456);
this.after("roundingMethodChange", this._keyChangeHandler);
    },

    /**
     * @method bindUI
     * @private
     */
    bindUI: function()
    {
        _yuitest_coverfunc("build/charts-base/charts-base.js", "bindUI", 3463);
_yuitest_coverline("build/charts-base/charts-base.js", 3465);
this.after("stylesChange", this._updateHandler);
        _yuitest_coverline("build/charts-base/charts-base.js", 3466);
this.after("overlapGraphChange", this._updateHandler);
        _yuitest_coverline("build/charts-base/charts-base.js", 3467);
this.after("positionChange", this._positionChangeHandler);
        _yuitest_coverline("build/charts-base/charts-base.js", 3468);
this.after("widthChange", this._handleSizeChange);
        _yuitest_coverline("build/charts-base/charts-base.js", 3469);
this.after("heightChange", this._handleSizeChange);
        _yuitest_coverline("build/charts-base/charts-base.js", 3470);
this.after("calculatedWidthChange", this._handleSizeChange);
        _yuitest_coverline("build/charts-base/charts-base.js", 3471);
this.after("calculatedHeightChange", this._handleSizeChange);
    },

    /**
     * Handles changes to `dataProvider`.
     *
     * @method _dataProviderChangeHandler
     * @param {Object} e Event object.
     * @private
     */
    _dataProviderChangeHandler: function(e)
    {
        _yuitest_coverfunc("build/charts-base/charts-base.js", "_dataProviderChangeHandler", 3481);
_yuitest_coverline("build/charts-base/charts-base.js", 3483);
var keyCollection = this.get("keyCollection").concat(),
            keys = this.get("keys"),
            i;
        _yuitest_coverline("build/charts-base/charts-base.js", 3486);
if(keys)
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 3488);
for(i in keys)
            {
                _yuitest_coverline("build/charts-base/charts-base.js", 3490);
if(keys.hasOwnProperty(i))
                {
                    _yuitest_coverline("build/charts-base/charts-base.js", 3492);
delete keys[i];
                }
            }
        }
        _yuitest_coverline("build/charts-base/charts-base.js", 3496);
if(keyCollection && keyCollection.length)
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 3498);
this.set("keys", keyCollection);
        }
    },

    /**
     * Constant used to generate unique id.
     *
     * @property GUID
     * @type String
     * @private
     */
    GUID: "yuibaseaxis",

    /**
     * Type of data used in `Axis`.
     *
     * @property _type
     * @type String
     * @readOnly
     * @private
     */
    _type: null,

    /**
     * Storage for `setMaximum` attribute.
     *
     * @property _setMaximum
     * @type Object
     * @private
     */
    _setMaximum: null,

    /**
     * Storage for `dataMaximum` attribute.
     *
     * @property _dataMaximum
     * @type Object
     * @private
     */
    _dataMaximum: null,

    /**
     * Storage for `setMinimum` attribute.
     *
     * @property _setMinimum
     * @type Object
     * @private
     */
    _setMinimum: null,

    /**
     * Reference to data array.
     *
     * @property _data
     * @type Array
     * @private
     */
    _data: null,

    /**
     * Indicates whether the all data is up to date.
     *
     * @property _updateTotalDataFlag
     * @type Boolean
     * @private
     */
    _updateTotalDataFlag: true,

    /**
     * Storage for `dataReady` attribute.
     *
     * @property _dataReady
     * @type Boolean
     * @readOnly
     * @private
     */
    _dataReady: false,

    /**
     * Adds an array to the key hash.
     *
     * @method addKey
     * @param value Indicates what key to use in retrieving
     * the array.
     */
    addKey: function (value)
	{
        _yuitest_coverfunc("build/charts-base/charts-base.js", "addKey", 3583);
_yuitest_coverline("build/charts-base/charts-base.js", 3585);
this.set("keys", value);
	},

    /**
     * Gets an array of values based on a key.
     *
     * @method _getKeyArray
     * @param {String} key Value key associated with the data array.
     * @param {Array} data Array in which the data resides.
     * @return Array
     * @private
     */
    _getKeyArray: function(key, data)
    {
        _yuitest_coverfunc("build/charts-base/charts-base.js", "_getKeyArray", 3597);
_yuitest_coverline("build/charts-base/charts-base.js", 3599);
var i = 0,
            obj,
            keyArray = [],
            len = data.length;
        _yuitest_coverline("build/charts-base/charts-base.js", 3603);
for(; i < len; ++i)
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 3605);
obj = data[i];
            _yuitest_coverline("build/charts-base/charts-base.js", 3606);
keyArray[i] = obj[key];
        }
        _yuitest_coverline("build/charts-base/charts-base.js", 3608);
return keyArray;
    },

    /**
     * Sets data by key
     *
     * @method _setDataByKey
     * @param {String} key Key value to use.
     * @param {Array} data Array to use.
     * @private
     */
    _setDataByKey: function(key, data)
    {
        _yuitest_coverfunc("build/charts-base/charts-base.js", "_setDataByKey", 3619);
_yuitest_coverline("build/charts-base/charts-base.js", 3621);
var i,
            obj,
            arr = [],
            dv = this._dataClone.concat(),
            len = dv.length;
        _yuitest_coverline("build/charts-base/charts-base.js", 3626);
for(i = 0; i < len; ++i)
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 3628);
obj = dv[i];
            _yuitest_coverline("build/charts-base/charts-base.js", 3629);
arr[i] = obj[key];
        }
        _yuitest_coverline("build/charts-base/charts-base.js", 3631);
this.get("keys")[key] = arr;
        _yuitest_coverline("build/charts-base/charts-base.js", 3632);
this._updateTotalDataFlag = true;
    },

    /**
     * Updates the total data array.
     *
     * @method _updateTotalData
     * @private
     */
    _updateTotalData: function()
    {
		_yuitest_coverfunc("build/charts-base/charts-base.js", "_updateTotalData", 3641);
_yuitest_coverline("build/charts-base/charts-base.js", 3643);
var keys = this.get("keys"),
            i;
        _yuitest_coverline("build/charts-base/charts-base.js", 3645);
this._data = [];
        _yuitest_coverline("build/charts-base/charts-base.js", 3646);
for(i in keys)
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 3648);
if(keys.hasOwnProperty(i))
            {
                _yuitest_coverline("build/charts-base/charts-base.js", 3650);
this._data = this._data.concat(keys[i]);
            }
        }
        _yuitest_coverline("build/charts-base/charts-base.js", 3653);
this._updateTotalDataFlag = false;
    },

    /**
     * Removes an array from the key hash.
     *
     * @method removeKey
     * @param {String} value Indicates what key to use in removing from
     * the hash.
     */
    removeKey: function(value)
    {
        _yuitest_coverfunc("build/charts-base/charts-base.js", "removeKey", 3663);
_yuitest_coverline("build/charts-base/charts-base.js", 3665);
var keys = this.get("keys");
        _yuitest_coverline("build/charts-base/charts-base.js", 3666);
if(keys.hasOwnProperty(value))
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 3668);
delete keys[value];
            _yuitest_coverline("build/charts-base/charts-base.js", 3669);
this._keyChangeHandler();
        }
    },

    /**
     * Returns a value based of a key value and an index.
     *
     * @method getKeyValueAt
     * @param {String} key value used to look up the correct array
     * @param {Number} index within the array
     * @return Number
     */
    getKeyValueAt: function(key, index)
    {
        _yuitest_coverfunc("build/charts-base/charts-base.js", "getKeyValueAt", 3681);
_yuitest_coverline("build/charts-base/charts-base.js", 3683);
var value = NaN,
            keys = this.get("keys");
        _yuitest_coverline("build/charts-base/charts-base.js", 3685);
if(keys[key] && Y_Lang.isNumber(parseFloat(keys[key][index])))
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 3687);
value = keys[key][index];
        }
        _yuitest_coverline("build/charts-base/charts-base.js", 3689);
return parseFloat(value);
    },

    /**
     * Returns an array of values based on an identifier key.
     *
     * @method getDataByKey
     * @param {String} value value used to identify the array
     * @return Object
     */
    getDataByKey: function (value)
    {
        _yuitest_coverfunc("build/charts-base/charts-base.js", "getDataByKey", 3699);
_yuitest_coverline("build/charts-base/charts-base.js", 3701);
var keys = this.get("keys");
        _yuitest_coverline("build/charts-base/charts-base.js", 3702);
if(keys[value])
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 3704);
return keys[value];
        }
        _yuitest_coverline("build/charts-base/charts-base.js", 3706);
return null;
    },

    /**
     * Calculates the maximum and minimum values for the `Axis`.
     *
     * @method _updateMinAndMax
     * @private
     */
    _updateMinAndMax: function()
    {
        _yuitest_coverfunc("build/charts-base/charts-base.js", "_updateMinAndMax", 3715);
_yuitest_coverline("build/charts-base/charts-base.js", 3717);
var data = this.get("data"),
            max = 0,
            min = 0,
            len,
            num,
            i;
        _yuitest_coverline("build/charts-base/charts-base.js", 3723);
if(data && data.length && data.length > 0)
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 3725);
len = data.length;
            _yuitest_coverline("build/charts-base/charts-base.js", 3726);
max = min = data[0];
            _yuitest_coverline("build/charts-base/charts-base.js", 3727);
if(len > 1)
            {
                _yuitest_coverline("build/charts-base/charts-base.js", 3729);
for(i = 1; i < len; i++)
                {
                    _yuitest_coverline("build/charts-base/charts-base.js", 3731);
num = data[i];
                    _yuitest_coverline("build/charts-base/charts-base.js", 3732);
if(isNaN(num))
                    {
                        _yuitest_coverline("build/charts-base/charts-base.js", 3734);
continue;
                    }
                    _yuitest_coverline("build/charts-base/charts-base.js", 3736);
max = Math.max(num, max);
                    _yuitest_coverline("build/charts-base/charts-base.js", 3737);
min = Math.min(num, min);
                }
            }
        }
        _yuitest_coverline("build/charts-base/charts-base.js", 3741);
this._dataMaximum = max;
        _yuitest_coverline("build/charts-base/charts-base.js", 3742);
this._dataMinimum = min;
    },

    /**
     * Returns the total number of majorUnits that will appear on an axis.
     *
     * @method getTotalMajorUnits
     * @return Number
     */
    getTotalMajorUnits: function()
    {
        _yuitest_coverfunc("build/charts-base/charts-base.js", "getTotalMajorUnits", 3751);
_yuitest_coverline("build/charts-base/charts-base.js", 3753);
var units,
            majorUnit = this.get("styles").majorUnit,
            len = this.get("length");
        _yuitest_coverline("build/charts-base/charts-base.js", 3756);
if(majorUnit.determinant === "count")
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 3758);
units = majorUnit.count;
        }
        else {_yuitest_coverline("build/charts-base/charts-base.js", 3760);
if(majorUnit.determinant === "distance")
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 3762);
units = (len/majorUnit.distance) + 1;
        }}
        _yuitest_coverline("build/charts-base/charts-base.js", 3764);
return units;
    },

    /**
     * Returns the distance between major units on an axis.
     *
     * @method getMajorUnitDistance
     * @param {Number} len Number of ticks
     * @param {Number} uiLen Size of the axis.
     * @param {Object} majorUnit Hash of properties used to determine the majorUnit
     * @return Number
     */
    getMajorUnitDistance: function(len, uiLen, majorUnit)
    {
        _yuitest_coverfunc("build/charts-base/charts-base.js", "getMajorUnitDistance", 3776);
_yuitest_coverline("build/charts-base/charts-base.js", 3778);
var dist;
        _yuitest_coverline("build/charts-base/charts-base.js", 3779);
if(majorUnit.determinant === "count")
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 3781);
dist = uiLen/(len - 1);
        }
        else {_yuitest_coverline("build/charts-base/charts-base.js", 3783);
if(majorUnit.determinant === "distance")
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 3785);
dist = majorUnit.distance;
        }}
        _yuitest_coverline("build/charts-base/charts-base.js", 3787);
return dist;
    },

    /**
     * Gets the distance that the first and last ticks are offset from there respective
     * edges.
     *
     * @method getEdgeOffset
     * @param {Number} ct Number of ticks on the axis.
     * @param {Number} l Length (in pixels) of the axis.
     * @return Number
     */
    getEdgeOffset: function(ct, l)
    {
        _yuitest_coverfunc("build/charts-base/charts-base.js", "getEdgeOffset", 3799);
_yuitest_coverline("build/charts-base/charts-base.js", 3801);
return 0;
    },

    /**
     * Calculates and returns a value based on the number of labels and the index of
     * the current label.
     *
     * @method getLabelByIndex
     * @param {Number} i Index of the label.
     * @param {Number} l Total number of labels.
     * @return String
     */
    getLabelByIndex: function(i, l)
    {
        _yuitest_coverfunc("build/charts-base/charts-base.js", "getLabelByIndex", 3813);
_yuitest_coverline("build/charts-base/charts-base.js", 3815);
var min = this.get("minimum"),
            max = this.get("maximum"),
            increm = (max - min)/(l-1),
            label;
            _yuitest_coverline("build/charts-base/charts-base.js", 3819);
l -= 1;
        _yuitest_coverline("build/charts-base/charts-base.js", 3820);
label = min + (i * increm);
        _yuitest_coverline("build/charts-base/charts-base.js", 3821);
return label;
    },

    /**
     * Updates the `Axis` after a change in keys.
     *
     * @method _keyChangeHandler
     * @param {Object} e Event object.
     * @private
     */
    _keyChangeHandler: function(e)
    {
        _yuitest_coverfunc("build/charts-base/charts-base.js", "_keyChangeHandler", 3831);
_yuitest_coverline("build/charts-base/charts-base.js", 3833);
this._updateMinAndMax();
        _yuitest_coverline("build/charts-base/charts-base.js", 3834);
this.fire("dataUpdate");
    },

    /**
     * Checks to see if data extends beyond the range of the axis. If so,
     * that data will need to be hidden. This method is internal, temporary and subject
     * to removal in the future.
     *
     * @method _hasDataOverflow
     * @protected
     * @return Boolean
     */
    _hasDataOverflow: function()
    {
        _yuitest_coverfunc("build/charts-base/charts-base.js", "_hasDataOverflow", 3846);
_yuitest_coverline("build/charts-base/charts-base.js", 3848);
if(this.get("setMin") || this.get("setMax"))
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 3850);
return true;
        }
        _yuitest_coverline("build/charts-base/charts-base.js", 3852);
return false;
    },

    /**
     * Returns a string corresponding to the first label on an
     * axis.
     *
     * @method getMinimumValue
     * @return String
     */
    getMinimumValue: function()
    {
        _yuitest_coverfunc("build/charts-base/charts-base.js", "getMinimumValue", 3862);
_yuitest_coverline("build/charts-base/charts-base.js", 3864);
return this.get("minimum");
    },

    /**
     * Returns a string corresponding to the last label on an
     * axis.
     *
     * @method getMaximumValue
     * @return String
     */
    getMaximumValue: function()
    {
        _yuitest_coverfunc("build/charts-base/charts-base.js", "getMaximumValue", 3874);
_yuitest_coverline("build/charts-base/charts-base.js", 3876);
return this.get("maximum");
    }
}, {
    ATTRS: {
        /**
         * Hash of array identifed by a string value.
         *
         * @attribute keys
         * @type Object
         */
        keys: {
            value: {},

            setter: function(val)
            {
                _yuitest_coverfunc("build/charts-base/charts-base.js", "setter", 3889);
_yuitest_coverline("build/charts-base/charts-base.js", 3891);
var keys = {},
                    i,
                    len,
                    data = this.get("dataProvider");
                _yuitest_coverline("build/charts-base/charts-base.js", 3895);
if(Y_Lang.isArray(val))
                {
                    _yuitest_coverline("build/charts-base/charts-base.js", 3897);
len = val.length;
                    _yuitest_coverline("build/charts-base/charts-base.js", 3898);
for(i = 0; i < len; ++i)
                    {
                        _yuitest_coverline("build/charts-base/charts-base.js", 3900);
keys[val[i]] = this._getKeyArray(val[i], data);
                    }

                }
                else {_yuitest_coverline("build/charts-base/charts-base.js", 3904);
if(Y_Lang.isString(val))
                {
                    _yuitest_coverline("build/charts-base/charts-base.js", 3906);
keys = this.get("keys");
                    _yuitest_coverline("build/charts-base/charts-base.js", 3907);
keys[val] = this._getKeyArray(val, data);
                }
                else
                {
                    _yuitest_coverline("build/charts-base/charts-base.js", 3911);
for(i in val)
                    {
                        _yuitest_coverline("build/charts-base/charts-base.js", 3913);
if(val.hasOwnProperty(i))
                        {
                            _yuitest_coverline("build/charts-base/charts-base.js", 3915);
keys[i] = this._getKeyArray(i, data);
                        }
                    }
                }}
                _yuitest_coverline("build/charts-base/charts-base.js", 3919);
this._updateTotalDataFlag = true;
                _yuitest_coverline("build/charts-base/charts-base.js", 3920);
return keys;
            }
        },

        /**
         *Indicates how to round unit values.
         *  <dl>
         *      <dt>niceNumber</dt><dd>Units will be smoothed based on the number of ticks and data range.</dd>
         *      <dt>auto</dt><dd>If the range is greater than 1, the units will be rounded.</dd>
         *      <dt>numeric value</dt><dd>Units will be equal to the numeric value.</dd>
         *      <dt>null</dt><dd>No rounding will occur.</dd>
         *  </dl>
         *
         * @attribute roundingMethod
         * @type String
         * @default niceNumber
         */
        roundingMethod: {
            value: "niceNumber"
        },

        /**
         *Returns the type of axis data
         *  <dl>
         *      <dt>time</dt><dd>Manages time data</dd>
         *      <dt>stacked</dt><dd>Manages stacked numeric data</dd>
         *      <dt>numeric</dt><dd>Manages numeric data</dd>
         *      <dt>category</dt><dd>Manages categorical data</dd>
         *  </dl>
         *
         * @attribute type
         * @type String
         */
        type:
        {
            readOnly: true,

            getter: function ()
            {
                _yuitest_coverfunc("build/charts-base/charts-base.js", "getter", 3957);
_yuitest_coverline("build/charts-base/charts-base.js", 3959);
return this._type;
            }
        },

        /**
         * Instance of `ChartDataProvider` that the class uses
         * to build its own data.
         *
         * @attribute dataProvider
         * @type Array
         */
        dataProvider:{
            setter: function (value)
            {
                _yuitest_coverfunc("build/charts-base/charts-base.js", "setter", 3971);
_yuitest_coverline("build/charts-base/charts-base.js", 3973);
return value;
            }
        },

        /**
         * The maximum value contained in the `data` array. Used for
         * `maximum` when `autoMax` is true.
         *
         * @attribute dataMaximum
         * @type Number
         */
        dataMaximum: {
            getter: function ()
            {
                _yuitest_coverfunc("build/charts-base/charts-base.js", "getter", 3985);
_yuitest_coverline("build/charts-base/charts-base.js", 3987);
if(!this._dataMaximum)
                {
                    _yuitest_coverline("build/charts-base/charts-base.js", 3989);
this._updateMinAndMax();
                }
                _yuitest_coverline("build/charts-base/charts-base.js", 3991);
return this._dataMaximum;
            }
        },

        /**
         * The maximum value that will appear on an axis.
         *
         * @attribute maximum
         * @type Number
         */
        maximum: {
            lazyAdd: false,

            getter: function ()
            {
                _yuitest_coverfunc("build/charts-base/charts-base.js", "getter", 4004);
_yuitest_coverline("build/charts-base/charts-base.js", 4006);
var max = this.get("dataMaximum"),
                    min = this.get("minimum");
                //If all values are zero, force a range so that the Axis and related series
                //will still render.
                _yuitest_coverline("build/charts-base/charts-base.js", 4010);
if(min === 0 && max === 0)
                {
                    _yuitest_coverline("build/charts-base/charts-base.js", 4012);
max = 10;
                }
                _yuitest_coverline("build/charts-base/charts-base.js", 4014);
if(Y_Lang.isNumber(this._setMaximum))
                {
                    _yuitest_coverline("build/charts-base/charts-base.js", 4016);
max = this._setMaximum;
                }
                _yuitest_coverline("build/charts-base/charts-base.js", 4018);
return parseFloat(max);
            },
            setter: function (value)
            {
                _yuitest_coverfunc("build/charts-base/charts-base.js", "setter", 4020);
_yuitest_coverline("build/charts-base/charts-base.js", 4022);
this._setMaximum = parseFloat(value);
                _yuitest_coverline("build/charts-base/charts-base.js", 4023);
return value;
            }
        },

        /**
         * The minimum value contained in the `data` array. Used for
         * `minimum` when `autoMin` is true.
         *
         * @attribute dataMinimum
         * @type Number
         */
        dataMinimum: {
            getter: function ()
            {
                _yuitest_coverfunc("build/charts-base/charts-base.js", "getter", 4035);
_yuitest_coverline("build/charts-base/charts-base.js", 4037);
if(!this._dataMinimum)
                {
                    _yuitest_coverline("build/charts-base/charts-base.js", 4039);
this._updateMinAndMax();
                }
                _yuitest_coverline("build/charts-base/charts-base.js", 4041);
return this._dataMinimum;
            }
        },

        /**
         * The minimum value that will appear on an axis.
         *
         * @attribute minimum
         * @type Number
         */
        minimum: {
            lazyAdd: false,

            getter: function ()
            {
                _yuitest_coverfunc("build/charts-base/charts-base.js", "getter", 4054);
_yuitest_coverline("build/charts-base/charts-base.js", 4056);
var min = this.get("dataMinimum");
                _yuitest_coverline("build/charts-base/charts-base.js", 4057);
if(Y_Lang.isNumber(this._setMinimum))
                {
                    _yuitest_coverline("build/charts-base/charts-base.js", 4059);
min = this._setMinimum;
                }
                _yuitest_coverline("build/charts-base/charts-base.js", 4061);
return parseFloat(min);
            },
            setter: function(val)
            {
                _yuitest_coverfunc("build/charts-base/charts-base.js", "setter", 4063);
_yuitest_coverline("build/charts-base/charts-base.js", 4065);
this._setMinimum = parseFloat(val);
                _yuitest_coverline("build/charts-base/charts-base.js", 4066);
return val;
            }
        },

        /**
         * Determines whether the maximum is calculated or explicitly
         * set by the user.
         *
         * @attribute setMax
         * @type Boolean
         */
        setMax: {
            readOnly: true,

            getter: function()
            {
                _yuitest_coverfunc("build/charts-base/charts-base.js", "getter", 4080);
_yuitest_coverline("build/charts-base/charts-base.js", 4082);
return Y_Lang.isNumber(this._setMaximum);
            }
        },

        /**
         * Determines whether the minimum is calculated or explicitly
         * set by the user.
         *
         * @attribute setMin
         * @type Boolean
         */
        setMin: {
            readOnly: true,

            getter: function()
            {
                _yuitest_coverfunc("build/charts-base/charts-base.js", "getter", 4096);
_yuitest_coverline("build/charts-base/charts-base.js", 4098);
return Y_Lang.isNumber(this._setMinimum);
            }
        },

        /**
         * Array of axis data
         *
         * @attribute data
         * @type Array
         */
        data: {
            getter: function ()
            {
                _yuitest_coverfunc("build/charts-base/charts-base.js", "getter", 4109);
_yuitest_coverline("build/charts-base/charts-base.js", 4111);
if(!this._data || this._updateTotalDataFlag)
                {
                    _yuitest_coverline("build/charts-base/charts-base.js", 4113);
this._updateTotalData();
                }
                _yuitest_coverline("build/charts-base/charts-base.js", 4115);
return this._data;
            }
        },

        /**
         * Array containing all the keys in the axis.

         * @attribute keyCollection
         * @type Array
         */
        keyCollection: {
            getter: function()
            {
                _yuitest_coverfunc("build/charts-base/charts-base.js", "getter", 4126);
_yuitest_coverline("build/charts-base/charts-base.js", 4128);
var keys = this.get("keys"),
                    i,
                    col = [];
                _yuitest_coverline("build/charts-base/charts-base.js", 4131);
for(i in keys)
                {
                    _yuitest_coverline("build/charts-base/charts-base.js", 4133);
if(keys.hasOwnProperty(i))
                    {
                        _yuitest_coverline("build/charts-base/charts-base.js", 4135);
col.push(i);
                    }
                }
                _yuitest_coverline("build/charts-base/charts-base.js", 4138);
return col;
            },
            readOnly: true
        }
    }
});
/**
 * NumericAxis manages numeric data on an axis.
 *
 * @module charts
 * @submodule charts-base
 * @class NumericAxis
 * @constructor
 * @param {Object} config (optional) Configuration parameters for the Chart.
 * @extends AxisType
 */
_yuitest_coverline("build/charts-base/charts-base.js", 4154);
function NumericAxis(config)
{
	_yuitest_coverfunc("build/charts-base/charts-base.js", "NumericAxis", 4154);
_yuitest_coverline("build/charts-base/charts-base.js", 4156);
NumericAxis.superclass.constructor.apply(this, arguments);
}

_yuitest_coverline("build/charts-base/charts-base.js", 4159);
NumericAxis.NAME = "numericAxis";

_yuitest_coverline("build/charts-base/charts-base.js", 4161);
NumericAxis.ATTRS = {
    /**
     * Indicates whether 0 should always be displayed.
     *
     * @attribute alwaysShowZero
     * @type Boolean
     */
	alwaysShowZero: {
	    value: true
	},

    /**
     * Method used for formatting a label. This attribute allows for the default label formatting method to overridden.
     * The method use would need to implement the arguments below and return a `String` or an `HTMLElement`. The default
     * implementation of the method returns a `String`. The output of this method will be rendered to the DOM using
     * `appendChild`. If you override the `labelFunction` method and return an html string, you will also need to override
     * the Axis' `appendLabelFunction` to accept html as a `String`.
     * <dl>
     *      <dt>val</dt><dd>Label to be formatted. (`String`)</dd>
     *      <dt>format</dt><dd>Object containing properties used to format the label. (optional)</dd>
     * </dl>
     *
     * @attribute labelFunction
     * @type Function
     */
    labelFunction: {
        value: function(val, format)
        {
            _yuitest_coverfunc("build/charts-base/charts-base.js", "value", 4187);
_yuitest_coverline("build/charts-base/charts-base.js", 4189);
if(format)
            {
                _yuitest_coverline("build/charts-base/charts-base.js", 4191);
return Y.DataType.Number.format(val, format);
            }
            _yuitest_coverline("build/charts-base/charts-base.js", 4193);
return val;
        }
    },

    /**
     * Object containing properties used by the `labelFunction` to format a
     * label.
     *
     * @attribute labelFormat
     * @type Object
     */
    labelFormat: {
        value: {
            prefix: "",
            thousandsSeparator: "",
            decimalSeparator: "",
            decimalPlaces: "0",
            suffix: ""
        }
    }
};

_yuitest_coverline("build/charts-base/charts-base.js", 4215);
Y.extend(NumericAxis, Y.AxisType,
{
    /**
     * Formats a label based on the axis type and optionally specified format.
     *
     * @method formatLabel
     * @param {Object} value
     * @param {Object} format Pattern used to format the value.
     * @return String
     */
    formatLabel: function(val, format)
    {
        _yuitest_coverfunc("build/charts-base/charts-base.js", "formatLabel", 4225);
_yuitest_coverline("build/charts-base/charts-base.js", 4227);
if(format)
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 4229);
return Y.DataType.Number.format(val, format);
        }
        _yuitest_coverline("build/charts-base/charts-base.js", 4231);
return val;
    },

    /**
     * Returns the sum of all values per key.
     *
     * @method getTotalByKey
     * @param {String} key The identifier for the array whose values will be calculated.
     * @return Number
     */
    getTotalByKey: function(key)
    {
        _yuitest_coverfunc("build/charts-base/charts-base.js", "getTotalByKey", 4241);
_yuitest_coverline("build/charts-base/charts-base.js", 4243);
var total = 0,
            values = this.getDataByKey(key),
            i = 0,
            val,
            len = values ? values.length : 0;
        _yuitest_coverline("build/charts-base/charts-base.js", 4248);
for(; i < len; ++i)
        {
           _yuitest_coverline("build/charts-base/charts-base.js", 4250);
val = parseFloat(values[i]);
           _yuitest_coverline("build/charts-base/charts-base.js", 4251);
if(!isNaN(val))
           {
                _yuitest_coverline("build/charts-base/charts-base.js", 4253);
total += val;
           }
        }
        _yuitest_coverline("build/charts-base/charts-base.js", 4256);
return total;
    },

    /**
     * Type of data used in `Axis`.
     *
     * @property _type
     * @readOnly
     * @private
     */
    _type: "numeric",

    /**
     * Helper method for getting a `roundingUnit` when calculating the minimum and maximum values.
     *
     * @method _getMinimumUnit
     * @param {Number} max Maximum number
     * @param {Number} min Minimum number
     * @param {Number} units Number of units on the axis
     * @return Number
     * @private
     */
    _getMinimumUnit:function(max, min, units)
    {
        _yuitest_coverfunc("build/charts-base/charts-base.js", "_getMinimumUnit", 4278);
_yuitest_coverline("build/charts-base/charts-base.js", 4280);
return this._getNiceNumber(Math.ceil((max - min)/units));
    },

    /**
     * Calculates a nice rounding unit based on the range.
     *
     * @method _getNiceNumber
     * @param {Number} roundingUnit The calculated rounding unit.
     * @return Number
     * @private
     */
    _getNiceNumber: function(roundingUnit)
    {
        _yuitest_coverfunc("build/charts-base/charts-base.js", "_getNiceNumber", 4291);
_yuitest_coverline("build/charts-base/charts-base.js", 4293);
var tempMajorUnit = roundingUnit,
            order = Math.ceil(Math.log(tempMajorUnit) * 0.4342944819032518),
            roundedMajorUnit = Math.pow(10, order),
            roundedDiff;

        _yuitest_coverline("build/charts-base/charts-base.js", 4298);
if (roundedMajorUnit / 2 >= tempMajorUnit)
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 4300);
roundedDiff = Math.floor((roundedMajorUnit / 2 - tempMajorUnit) / (Math.pow(10,order-1)/2));
            _yuitest_coverline("build/charts-base/charts-base.js", 4301);
tempMajorUnit = roundedMajorUnit/2 - roundedDiff*Math.pow(10,order-1)/2;
        }
        else
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 4305);
tempMajorUnit = roundedMajorUnit;
        }
        _yuitest_coverline("build/charts-base/charts-base.js", 4307);
if(!isNaN(tempMajorUnit))
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 4309);
return tempMajorUnit;
        }
        _yuitest_coverline("build/charts-base/charts-base.js", 4311);
return roundingUnit;

    },

    /**
     * Calculates the maximum and minimum values for the `Axis`.
     *
     * @method _updateMinAndMax
     * @private
     */
    _updateMinAndMax: function()
    {
        _yuitest_coverfunc("build/charts-base/charts-base.js", "_updateMinAndMax", 4321);
_yuitest_coverline("build/charts-base/charts-base.js", 4323);
var data = this.get("data"),
            max,
            min,
            len,
            num,
            i = 0,
            key,
            setMax = this.get("setMax"),
            setMin = this.get("setMin");
        _yuitest_coverline("build/charts-base/charts-base.js", 4332);
if(!setMax || !setMin)
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 4334);
if(data && data.length && data.length > 0)
            {
                _yuitest_coverline("build/charts-base/charts-base.js", 4336);
len = data.length;
                _yuitest_coverline("build/charts-base/charts-base.js", 4337);
for(; i < len; i++)
                {
                    _yuitest_coverline("build/charts-base/charts-base.js", 4339);
num = data[i];
                    _yuitest_coverline("build/charts-base/charts-base.js", 4340);
if(isNaN(num))
                    {
                        _yuitest_coverline("build/charts-base/charts-base.js", 4342);
if(Y_Lang.isObject(num))
                        {
                            _yuitest_coverline("build/charts-base/charts-base.js", 4344);
min = max = 0;
                            //hloc values
                            _yuitest_coverline("build/charts-base/charts-base.js", 4346);
for(key in num)
                            {
                               _yuitest_coverline("build/charts-base/charts-base.js", 4348);
if(num.hasOwnProperty(key))
                               {
                                    _yuitest_coverline("build/charts-base/charts-base.js", 4350);
max = Math.max(num[key], max);
                                    _yuitest_coverline("build/charts-base/charts-base.js", 4351);
min = Math.min(num[key], min);
                               }
                            }
                        }
                        _yuitest_coverline("build/charts-base/charts-base.js", 4355);
max = setMax ? this._setMaximum : max;
                        _yuitest_coverline("build/charts-base/charts-base.js", 4356);
min = setMin ? this._setMinimum : min;
                        _yuitest_coverline("build/charts-base/charts-base.js", 4357);
continue;
                    }

                    _yuitest_coverline("build/charts-base/charts-base.js", 4360);
if(setMin)
                    {
                        _yuitest_coverline("build/charts-base/charts-base.js", 4362);
min = this._setMinimum;
                    }
                    else {_yuitest_coverline("build/charts-base/charts-base.js", 4364);
if(min === undefined)
                    {
                        _yuitest_coverline("build/charts-base/charts-base.js", 4366);
min = num;
                    }
                    else
                    {
                        _yuitest_coverline("build/charts-base/charts-base.js", 4370);
min = Math.min(num, min);
                    }}
                    _yuitest_coverline("build/charts-base/charts-base.js", 4372);
if(setMax)
                    {
                        _yuitest_coverline("build/charts-base/charts-base.js", 4374);
max = this._setMaximum;
                    }
                    else {_yuitest_coverline("build/charts-base/charts-base.js", 4376);
if(max === undefined)
                    {
                        _yuitest_coverline("build/charts-base/charts-base.js", 4378);
max = num;
                    }
                    else
                    {
                        _yuitest_coverline("build/charts-base/charts-base.js", 4382);
max = Math.max(num, max);
                    }}

                    _yuitest_coverline("build/charts-base/charts-base.js", 4385);
this._actualMaximum = max;
                    _yuitest_coverline("build/charts-base/charts-base.js", 4386);
this._actualMinimum = min;
                }
            }
            _yuitest_coverline("build/charts-base/charts-base.js", 4389);
this._roundMinAndMax(min, max, setMin, setMax);
        }
    },

    /**
     * Rounds the mimimum and maximum values based on the `roundingUnit` attribute.
     *
     * @method _roundMinAndMax
     * @param {Number} min Minimum value
     * @param {Number} max Maximum value
     * @private
     */
    _roundMinAndMax: function(min, max, setMin, setMax)
    {
        _yuitest_coverfunc("build/charts-base/charts-base.js", "_roundMinAndMax", 4401);
_yuitest_coverline("build/charts-base/charts-base.js", 4403);
var roundingUnit,
            minimumRange,
            minGreaterThanZero = min >= 0,
            maxGreaterThanZero = max > 0,
            dataRangeGreater,
            maxRound,
            minRound,
            topTicks,
            botTicks,
            tempMax,
            tempMin,
            units = this.getTotalMajorUnits() - 1,
            alwaysShowZero = this.get("alwaysShowZero"),
            roundingMethod = this.get("roundingMethod"),
            useIntegers = (max - min)/units >= 1;
        _yuitest_coverline("build/charts-base/charts-base.js", 4418);
if(roundingMethod)
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 4420);
if(roundingMethod == "niceNumber")
            {
                _yuitest_coverline("build/charts-base/charts-base.js", 4422);
roundingUnit = this._getMinimumUnit(max, min, units);
                _yuitest_coverline("build/charts-base/charts-base.js", 4423);
if(minGreaterThanZero && maxGreaterThanZero)
                {
                    _yuitest_coverline("build/charts-base/charts-base.js", 4425);
if((alwaysShowZero || min < roundingUnit) && !setMin)
                    {
                        _yuitest_coverline("build/charts-base/charts-base.js", 4427);
min = 0;
                        _yuitest_coverline("build/charts-base/charts-base.js", 4428);
roundingUnit = this._getMinimumUnit(max, min, units);
                    }
                    else
                    {
                       _yuitest_coverline("build/charts-base/charts-base.js", 4432);
min = this._roundDownToNearest(min, roundingUnit);
                    }
                    _yuitest_coverline("build/charts-base/charts-base.js", 4434);
if(setMax)
                    {
                        _yuitest_coverline("build/charts-base/charts-base.js", 4436);
if(!alwaysShowZero)
                        {
                            _yuitest_coverline("build/charts-base/charts-base.js", 4438);
min = max - (roundingUnit * units);
                        }
                    }
                    else {_yuitest_coverline("build/charts-base/charts-base.js", 4441);
if(setMin)
                    {
                        _yuitest_coverline("build/charts-base/charts-base.js", 4443);
max = min + (roundingUnit * units);
                    }
                    else
                    {
                        _yuitest_coverline("build/charts-base/charts-base.js", 4447);
max = this._roundUpToNearest(max, roundingUnit);
                    }}
                }
                else {_yuitest_coverline("build/charts-base/charts-base.js", 4450);
if(maxGreaterThanZero && !minGreaterThanZero)
                {
                    _yuitest_coverline("build/charts-base/charts-base.js", 4452);
if(alwaysShowZero)
                    {
                        _yuitest_coverline("build/charts-base/charts-base.js", 4454);
topTicks = Math.round(units/((-1 * min)/max + 1));
                        _yuitest_coverline("build/charts-base/charts-base.js", 4455);
topTicks = Math.max(Math.min(topTicks, units - 1), 1);
                        _yuitest_coverline("build/charts-base/charts-base.js", 4456);
botTicks = units - topTicks;
                        _yuitest_coverline("build/charts-base/charts-base.js", 4457);
tempMax = Math.ceil( max/topTicks );
                        _yuitest_coverline("build/charts-base/charts-base.js", 4458);
tempMin = Math.floor( min/botTicks ) * -1;

                        _yuitest_coverline("build/charts-base/charts-base.js", 4460);
if(setMin)
                        {
                            _yuitest_coverline("build/charts-base/charts-base.js", 4462);
while(tempMin < tempMax && botTicks >= 0)
                            {
                                _yuitest_coverline("build/charts-base/charts-base.js", 4464);
botTicks--;
                                _yuitest_coverline("build/charts-base/charts-base.js", 4465);
topTicks++;
                                _yuitest_coverline("build/charts-base/charts-base.js", 4466);
tempMax = Math.ceil( max/topTicks );
                                _yuitest_coverline("build/charts-base/charts-base.js", 4467);
tempMin = Math.floor( min/botTicks ) * -1;
                            }
                            //if there are any bottom ticks left calcualate the maximum by multiplying by the tempMin value
                            //if not, it's impossible to ensure that a zero is shown. skip it
                            _yuitest_coverline("build/charts-base/charts-base.js", 4471);
if(botTicks > 0)
                            {
                                _yuitest_coverline("build/charts-base/charts-base.js", 4473);
max = tempMin * topTicks;
                            }
                            else
                            {
                                _yuitest_coverline("build/charts-base/charts-base.js", 4477);
max = min + (roundingUnit * units);
                            }
                        }
                        else {_yuitest_coverline("build/charts-base/charts-base.js", 4480);
if(setMax)
                        {
                            _yuitest_coverline("build/charts-base/charts-base.js", 4482);
while(tempMax < tempMin && topTicks >= 0)
                            {
                                _yuitest_coverline("build/charts-base/charts-base.js", 4484);
botTicks++;
                                _yuitest_coverline("build/charts-base/charts-base.js", 4485);
topTicks--;
                                _yuitest_coverline("build/charts-base/charts-base.js", 4486);
tempMin = Math.floor( min/botTicks ) * -1;
                                _yuitest_coverline("build/charts-base/charts-base.js", 4487);
tempMax = Math.ceil( max/topTicks );
                            }
                            //if there are any top ticks left calcualate the minimum by multiplying by the tempMax value
                            //if not, it's impossible to ensure that a zero is shown. skip it
                            _yuitest_coverline("build/charts-base/charts-base.js", 4491);
if(topTicks > 0)
                            {
                                _yuitest_coverline("build/charts-base/charts-base.js", 4493);
min = tempMax * botTicks * -1;
                            }
                            else
                            {
                                _yuitest_coverline("build/charts-base/charts-base.js", 4497);
min = max - (roundingUnit * units);
                            }
                        }
                        else
                        {
                            _yuitest_coverline("build/charts-base/charts-base.js", 4502);
roundingUnit = Math.max(tempMax, tempMin);
                            _yuitest_coverline("build/charts-base/charts-base.js", 4503);
roundingUnit = this._getNiceNumber(roundingUnit);
                            _yuitest_coverline("build/charts-base/charts-base.js", 4504);
max = roundingUnit * topTicks;
                            _yuitest_coverline("build/charts-base/charts-base.js", 4505);
min = roundingUnit * botTicks * -1;
                        }}
                    }
                    else
                    {
                        _yuitest_coverline("build/charts-base/charts-base.js", 4510);
if(setMax)
                        {
                            _yuitest_coverline("build/charts-base/charts-base.js", 4512);
min = max - (roundingUnit * units);
                        }
                        else {_yuitest_coverline("build/charts-base/charts-base.js", 4514);
if(setMin)
                        {
                            _yuitest_coverline("build/charts-base/charts-base.js", 4516);
max = min + (roundingUnit * units);
                        }
                        else
                        {
                            _yuitest_coverline("build/charts-base/charts-base.js", 4520);
min = this._roundDownToNearest(min, roundingUnit);
                            _yuitest_coverline("build/charts-base/charts-base.js", 4521);
max = this._roundUpToNearest(max, roundingUnit);
                        }}
                    }
                }
                else
                {
                    _yuitest_coverline("build/charts-base/charts-base.js", 4527);
if(setMin)
                    {
                        _yuitest_coverline("build/charts-base/charts-base.js", 4529);
if(alwaysShowZero)
                        {
                            _yuitest_coverline("build/charts-base/charts-base.js", 4531);
max = 0;
                        }
                        else
                        {
                            _yuitest_coverline("build/charts-base/charts-base.js", 4535);
max = min + (roundingUnit * units);
                        }
                    }
                    else {_yuitest_coverline("build/charts-base/charts-base.js", 4538);
if(!setMax)
                    {
                        _yuitest_coverline("build/charts-base/charts-base.js", 4540);
if(alwaysShowZero || max === 0 || max + roundingUnit > 0)
                        {
                            _yuitest_coverline("build/charts-base/charts-base.js", 4542);
max = 0;
                            _yuitest_coverline("build/charts-base/charts-base.js", 4543);
roundingUnit = this._getMinimumUnit(max, min, units);
                            _yuitest_coverline("build/charts-base/charts-base.js", 4544);
min = max - (roundingUnit * units);
                        }
                        else
                        {
                            _yuitest_coverline("build/charts-base/charts-base.js", 4548);
min = this._roundDownToNearest(min, roundingUnit);
                            _yuitest_coverline("build/charts-base/charts-base.js", 4549);
max = this._roundUpToNearest(max, roundingUnit);
                        }
                    }
                    else
                    {
                        _yuitest_coverline("build/charts-base/charts-base.js", 4554);
min = max - (roundingUnit * units);
                    }}
                }}
            }
            else {_yuitest_coverline("build/charts-base/charts-base.js", 4558);
if(roundingMethod == "auto")
            {
                _yuitest_coverline("build/charts-base/charts-base.js", 4560);
if(minGreaterThanZero && maxGreaterThanZero)
                {
                    _yuitest_coverline("build/charts-base/charts-base.js", 4562);
if((alwaysShowZero || min < (max-min)/units) && !setMin)
                    {
                        _yuitest_coverline("build/charts-base/charts-base.js", 4564);
min = 0;
                    }

                    _yuitest_coverline("build/charts-base/charts-base.js", 4567);
roundingUnit = (max - min)/units;
                    _yuitest_coverline("build/charts-base/charts-base.js", 4568);
if(useIntegers)
                    {
                        _yuitest_coverline("build/charts-base/charts-base.js", 4570);
roundingUnit = Math.ceil(roundingUnit);
                    }
                    _yuitest_coverline("build/charts-base/charts-base.js", 4572);
max = min + (roundingUnit * units);
                }
                else {_yuitest_coverline("build/charts-base/charts-base.js", 4574);
if(maxGreaterThanZero && !minGreaterThanZero)
                {
                    _yuitest_coverline("build/charts-base/charts-base.js", 4576);
if(alwaysShowZero)
                    {
                        _yuitest_coverline("build/charts-base/charts-base.js", 4578);
topTicks = Math.round( units / ( (-1 * min) /max + 1) );
                        _yuitest_coverline("build/charts-base/charts-base.js", 4579);
topTicks = Math.max(Math.min(topTicks, units - 1), 1);
                        _yuitest_coverline("build/charts-base/charts-base.js", 4580);
botTicks = units - topTicks;

                        _yuitest_coverline("build/charts-base/charts-base.js", 4582);
if(useIntegers)
                        {
                            _yuitest_coverline("build/charts-base/charts-base.js", 4584);
tempMax = Math.ceil( max/topTicks );
                            _yuitest_coverline("build/charts-base/charts-base.js", 4585);
tempMin = Math.floor( min/botTicks ) * -1;
                        }
                        else
                        {
                            _yuitest_coverline("build/charts-base/charts-base.js", 4589);
tempMax = max/topTicks;
                            _yuitest_coverline("build/charts-base/charts-base.js", 4590);
tempMin = min/botTicks * -1;
                        }
                        _yuitest_coverline("build/charts-base/charts-base.js", 4592);
roundingUnit = Math.max(tempMax, tempMin);
                        _yuitest_coverline("build/charts-base/charts-base.js", 4593);
max = roundingUnit * topTicks;
                        _yuitest_coverline("build/charts-base/charts-base.js", 4594);
min = roundingUnit * botTicks * -1;
                    }
                    else
                    {
                        _yuitest_coverline("build/charts-base/charts-base.js", 4598);
roundingUnit = (max - min)/units;
                        _yuitest_coverline("build/charts-base/charts-base.js", 4599);
if(useIntegers)
                        {
                            _yuitest_coverline("build/charts-base/charts-base.js", 4601);
roundingUnit = Math.ceil(roundingUnit);
                        }
                        _yuitest_coverline("build/charts-base/charts-base.js", 4603);
min = this._roundDownToNearest(min, roundingUnit);
                        _yuitest_coverline("build/charts-base/charts-base.js", 4604);
max = this._roundUpToNearest(max, roundingUnit);
                    }
                }
                else
                {
                    _yuitest_coverline("build/charts-base/charts-base.js", 4609);
roundingUnit = (max - min)/units;
                    _yuitest_coverline("build/charts-base/charts-base.js", 4610);
if(useIntegers)
                    {
                        _yuitest_coverline("build/charts-base/charts-base.js", 4612);
roundingUnit = Math.ceil(roundingUnit);
                    }
                    _yuitest_coverline("build/charts-base/charts-base.js", 4614);
if(alwaysShowZero || max === 0 || max + roundingUnit > 0)
                    {
                        _yuitest_coverline("build/charts-base/charts-base.js", 4616);
max = 0;
                        _yuitest_coverline("build/charts-base/charts-base.js", 4617);
roundingUnit = (max - min)/units;
                        _yuitest_coverline("build/charts-base/charts-base.js", 4618);
if(useIntegers)
                        {
                            _yuitest_coverline("build/charts-base/charts-base.js", 4620);
Math.ceil(roundingUnit);
                        }
                        _yuitest_coverline("build/charts-base/charts-base.js", 4622);
min = max - (roundingUnit * units);
                    }
                    else
                    {
                        _yuitest_coverline("build/charts-base/charts-base.js", 4626);
min = this._roundDownToNearest(min, roundingUnit);
                        _yuitest_coverline("build/charts-base/charts-base.js", 4627);
max = this._roundUpToNearest(max, roundingUnit);
                    }

                }}
            }
            else {_yuitest_coverline("build/charts-base/charts-base.js", 4632);
if(!isNaN(roundingMethod) && isFinite(roundingMethod))
            {
                _yuitest_coverline("build/charts-base/charts-base.js", 4634);
roundingUnit = roundingMethod;
                _yuitest_coverline("build/charts-base/charts-base.js", 4635);
minimumRange = roundingUnit * units;
                _yuitest_coverline("build/charts-base/charts-base.js", 4636);
dataRangeGreater = (max - min) > minimumRange;
                _yuitest_coverline("build/charts-base/charts-base.js", 4637);
minRound = this._roundDownToNearest(min, roundingUnit);
                _yuitest_coverline("build/charts-base/charts-base.js", 4638);
maxRound = this._roundUpToNearest(max, roundingUnit);
                _yuitest_coverline("build/charts-base/charts-base.js", 4639);
if(setMax)
                {
                    _yuitest_coverline("build/charts-base/charts-base.js", 4641);
min = max - minimumRange;
                }
                else {_yuitest_coverline("build/charts-base/charts-base.js", 4643);
if(setMin)
                {
                    _yuitest_coverline("build/charts-base/charts-base.js", 4645);
max = min + minimumRange;
                }
                else {_yuitest_coverline("build/charts-base/charts-base.js", 4647);
if(minGreaterThanZero && maxGreaterThanZero)
                {
                    _yuitest_coverline("build/charts-base/charts-base.js", 4649);
if(alwaysShowZero || minRound <= 0)
                    {
                        _yuitest_coverline("build/charts-base/charts-base.js", 4651);
min = 0;
                    }
                    else
                    {
                        _yuitest_coverline("build/charts-base/charts-base.js", 4655);
min = minRound;
                    }
                    _yuitest_coverline("build/charts-base/charts-base.js", 4657);
max = min + minimumRange;
                }
                else {_yuitest_coverline("build/charts-base/charts-base.js", 4659);
if(maxGreaterThanZero && !minGreaterThanZero)
                {
                    _yuitest_coverline("build/charts-base/charts-base.js", 4661);
min = minRound;
                    _yuitest_coverline("build/charts-base/charts-base.js", 4662);
max = maxRound;
                }
                else
                {
                    _yuitest_coverline("build/charts-base/charts-base.js", 4666);
if(alwaysShowZero || maxRound >= 0)
                    {
                        _yuitest_coverline("build/charts-base/charts-base.js", 4668);
max = 0;
                    }
                    else
                    {
                        _yuitest_coverline("build/charts-base/charts-base.js", 4672);
max = maxRound;
                    }
                    _yuitest_coverline("build/charts-base/charts-base.js", 4674);
min = max - minimumRange;
                }}}}
            }}}
        }
        _yuitest_coverline("build/charts-base/charts-base.js", 4678);
this._dataMaximum = max;
        _yuitest_coverline("build/charts-base/charts-base.js", 4679);
this._dataMinimum = min;
    },

    /**
     * Calculates and returns a value based on the number of labels and the index of
     * the current label.
     *
     * @method getLabelByIndex
     * @param {Number} i Index of the label.
     * @param {Number} l Total number of labels.
     * @return String
     */
    getLabelByIndex: function(i, l)
    {
        _yuitest_coverfunc("build/charts-base/charts-base.js", "getLabelByIndex", 4691);
_yuitest_coverline("build/charts-base/charts-base.js", 4693);
var min = this.get("minimum"),
            max = this.get("maximum"),
            increm = (max - min)/(l-1),
            label,
            roundingMethod = this.get("roundingMethod");
            _yuitest_coverline("build/charts-base/charts-base.js", 4698);
l -= 1;
        //respect the min and max. calculate all other labels.
        _yuitest_coverline("build/charts-base/charts-base.js", 4700);
if(i === 0)
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 4702);
label = min;
        }
        else {_yuitest_coverline("build/charts-base/charts-base.js", 4704);
if(i === l)
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 4706);
label = max;
        }
        else
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 4710);
label = (i * increm);
            _yuitest_coverline("build/charts-base/charts-base.js", 4711);
if(roundingMethod == "niceNumber")
            {
                _yuitest_coverline("build/charts-base/charts-base.js", 4713);
label = this._roundToNearest(label, increm);
            }
            _yuitest_coverline("build/charts-base/charts-base.js", 4715);
label += min;
        }}
        _yuitest_coverline("build/charts-base/charts-base.js", 4717);
return parseFloat(label);
    },

    /**
     * Rounds a Number to the nearest multiple of an input. For example, by rounding
     * 16 to the nearest 10, you will receive 20. Similar to the built-in function Math.round().
     *
     * @method _roundToNearest
     * @param {Number} number Number to round
     * @param {Number} nearest Multiple to round towards.
     * @return Number
     * @private
     */
    _roundToNearest: function(number, nearest)
    {
        _yuitest_coverfunc("build/charts-base/charts-base.js", "_roundToNearest", 4730);
_yuitest_coverline("build/charts-base/charts-base.js", 4732);
nearest = nearest || 1;
        _yuitest_coverline("build/charts-base/charts-base.js", 4733);
if(nearest === 0)
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 4735);
return number;
        }
        _yuitest_coverline("build/charts-base/charts-base.js", 4737);
var roundedNumber = Math.round(this._roundToPrecision(number / nearest, 10)) * nearest;
        _yuitest_coverline("build/charts-base/charts-base.js", 4738);
return this._roundToPrecision(roundedNumber, 10);
    },

    /**
     * Rounds a Number up to the nearest multiple of an input. For example, by rounding
     * 16 up to the nearest 10, you will receive 20. Similar to the built-in function Math.ceil().
     *
     * @method _roundUpToNearest
     * @param {Number} number Number to round
     * @param {Number} nearest Multiple to round towards.
     * @return Number
     * @private
     */
    _roundUpToNearest: function(number, nearest)
    {
        _yuitest_coverfunc("build/charts-base/charts-base.js", "_roundUpToNearest", 4751);
_yuitest_coverline("build/charts-base/charts-base.js", 4753);
nearest = nearest || 1;
        _yuitest_coverline("build/charts-base/charts-base.js", 4754);
if(nearest === 0)
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 4756);
return number;
        }
        _yuitest_coverline("build/charts-base/charts-base.js", 4758);
return Math.ceil(this._roundToPrecision(number / nearest, 10)) * nearest;
    },

    /**
     * Rounds a Number down to the nearest multiple of an input. For example, by rounding
     * 16 down to the nearest 10, you will receive 10. Similar to the built-in function Math.floor().
     *
     * @method _roundDownToNearest
     * @param {Number} number Number to round
     * @param {Number} nearest Multiple to round towards.
     * @return Number
     * @private
     */
    _roundDownToNearest: function(number, nearest)
    {
        _yuitest_coverfunc("build/charts-base/charts-base.js", "_roundDownToNearest", 4771);
_yuitest_coverline("build/charts-base/charts-base.js", 4773);
nearest = nearest || 1;
        _yuitest_coverline("build/charts-base/charts-base.js", 4774);
if(nearest === 0)
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 4776);
return number;
        }
        _yuitest_coverline("build/charts-base/charts-base.js", 4778);
return Math.floor(this._roundToPrecision(number / nearest, 10)) * nearest;
    },

    /**
     * Rounds a number to a certain level of precision. Useful for limiting the number of
     * decimal places on a fractional number.
     *
     * @method _roundToPrecision
     * @param {Number} number Number to round
     * @param {Number} precision Multiple to round towards.
     * @return Number
     * @private
     */
    _roundToPrecision: function(number, precision)
    {
        _yuitest_coverfunc("build/charts-base/charts-base.js", "_roundToPrecision", 4791);
_yuitest_coverline("build/charts-base/charts-base.js", 4793);
precision = precision || 0;
        _yuitest_coverline("build/charts-base/charts-base.js", 4794);
var decimalPlaces = Math.pow(10, precision);
        _yuitest_coverline("build/charts-base/charts-base.js", 4795);
return Math.round(decimalPlaces * number) / decimalPlaces;
    },

    /**
     * Checks to see if data extends beyond the range of the axis. If so,
     * that data will need to be hidden. This method is internal, temporary and subject
     * to removal in the future.
     *
     * @method _hasDataOverflow
     * @protected
     * @return Boolean
     */
    _hasDataOverflow: function()
    {
        _yuitest_coverfunc("build/charts-base/charts-base.js", "_hasDataOverflow", 4807);
_yuitest_coverline("build/charts-base/charts-base.js", 4809);
var roundingMethod,
            min,
            max;
        _yuitest_coverline("build/charts-base/charts-base.js", 4812);
if(this.get("setMin") || this.get("setMax"))
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 4814);
return true;
        }
        _yuitest_coverline("build/charts-base/charts-base.js", 4816);
roundingMethod = this.get("roundingMethod");
        _yuitest_coverline("build/charts-base/charts-base.js", 4817);
min = this._actualMinimum;
        _yuitest_coverline("build/charts-base/charts-base.js", 4818);
max = this._actualMaximum;
        _yuitest_coverline("build/charts-base/charts-base.js", 4819);
if(Y_Lang.isNumber(roundingMethod) && ((Y_Lang.isNumber(max) && max > this._dataMaximum) || (Y_Lang.isNumber(min) && min < this._dataMinimum)))
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 4821);
return true;
        }
        _yuitest_coverline("build/charts-base/charts-base.js", 4823);
return false;
    }
});

_yuitest_coverline("build/charts-base/charts-base.js", 4827);
Y.NumericAxis = NumericAxis;

/**
 * StackedAxis manages stacked numeric data on an axis.
 *
 * @module charts
 * @submodule charts-base
 * @class StackedAxis
 * @constructor
 * @param {Object} config (optional) Configuration parameters for the Chart.
 * @extends NumericAxis
 */
_yuitest_coverline("build/charts-base/charts-base.js", 4839);
function StackedAxis(config)
{
	_yuitest_coverfunc("build/charts-base/charts-base.js", "StackedAxis", 4839);
_yuitest_coverline("build/charts-base/charts-base.js", 4841);
StackedAxis.superclass.constructor.apply(this, arguments);
}

_yuitest_coverline("build/charts-base/charts-base.js", 4844);
StackedAxis.NAME = "stackedAxis";


_yuitest_coverline("build/charts-base/charts-base.js", 4847);
Y.extend(StackedAxis, Y.NumericAxis,
{
    /**
     * Calculates the maximum and minimum values for the `Axis`.
     *
     * @method _updateMinAndMax
     * @private
     */
    _updateMinAndMax: function()
    {
        _yuitest_coverfunc("build/charts-base/charts-base.js", "_updateMinAndMax", 4855);
_yuitest_coverline("build/charts-base/charts-base.js", 4857);
var max = 0,
            min = 0,
            pos = 0,
            neg = 0,
            len = 0,
            i = 0,
            key,
            num,
            keys = this.get("keys"),
            setMin = this.get("setMin"),
            setMax = this.get("setMax");

        _yuitest_coverline("build/charts-base/charts-base.js", 4869);
for(key in keys)
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 4871);
if(keys.hasOwnProperty(key))
            {
                _yuitest_coverline("build/charts-base/charts-base.js", 4873);
len = Math.max(len, keys[key].length);
            }
        }
        _yuitest_coverline("build/charts-base/charts-base.js", 4876);
for(; i < len; ++i)
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 4878);
pos = 0;
            _yuitest_coverline("build/charts-base/charts-base.js", 4879);
neg = 0;
            _yuitest_coverline("build/charts-base/charts-base.js", 4880);
for(key in keys)
            {
                _yuitest_coverline("build/charts-base/charts-base.js", 4882);
if(keys.hasOwnProperty(key))
                {
                    _yuitest_coverline("build/charts-base/charts-base.js", 4884);
num = keys[key][i];
                    _yuitest_coverline("build/charts-base/charts-base.js", 4885);
if(isNaN(num))
                    {
                        _yuitest_coverline("build/charts-base/charts-base.js", 4887);
continue;
                    }
                    _yuitest_coverline("build/charts-base/charts-base.js", 4889);
if(num >= 0)
                    {
                        _yuitest_coverline("build/charts-base/charts-base.js", 4891);
pos += num;
                    }
                    else
                    {
                        _yuitest_coverline("build/charts-base/charts-base.js", 4895);
neg += num;
                    }
                }
            }
            _yuitest_coverline("build/charts-base/charts-base.js", 4899);
if(pos > 0)
            {
                _yuitest_coverline("build/charts-base/charts-base.js", 4901);
max = Math.max(max, pos);
            }
            else
            {
                _yuitest_coverline("build/charts-base/charts-base.js", 4905);
max = Math.max(max, neg);
            }
            _yuitest_coverline("build/charts-base/charts-base.js", 4907);
if(neg < 0)
            {
                _yuitest_coverline("build/charts-base/charts-base.js", 4909);
min = Math.min(min, neg);
            }
            else
            {
                _yuitest_coverline("build/charts-base/charts-base.js", 4913);
min = Math.min(min, pos);
            }
        }
        _yuitest_coverline("build/charts-base/charts-base.js", 4916);
this._actualMaximum = max;
        _yuitest_coverline("build/charts-base/charts-base.js", 4917);
this._actualMinimum = min;
        _yuitest_coverline("build/charts-base/charts-base.js", 4918);
if(setMax)
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 4920);
max = this._setMaximum;
        }
        _yuitest_coverline("build/charts-base/charts-base.js", 4922);
if(setMin)
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 4924);
min = this._setMinimum;
        }
        _yuitest_coverline("build/charts-base/charts-base.js", 4926);
this._roundMinAndMax(min, max, setMin, setMax);
    }
});

_yuitest_coverline("build/charts-base/charts-base.js", 4930);
Y.StackedAxis = StackedAxis;

/**
 * TimeAxis manages time data on an axis.
 *
 * @module charts
 * @submodule charts-base
 * @class TimeAxis
 * @constructor
 * @param {Object} config (optional) Configuration parameters for the Chart.
 * @extends AxisType
 */
_yuitest_coverline("build/charts-base/charts-base.js", 4942);
function TimeAxis(config)
{
	_yuitest_coverfunc("build/charts-base/charts-base.js", "TimeAxis", 4942);
_yuitest_coverline("build/charts-base/charts-base.js", 4944);
TimeAxis.superclass.constructor.apply(this, arguments);
}

_yuitest_coverline("build/charts-base/charts-base.js", 4947);
TimeAxis.NAME = "timeAxis";

_yuitest_coverline("build/charts-base/charts-base.js", 4949);
TimeAxis.ATTRS =
{
    /**
     * Indicates whether the maximum is calculated or explicitly set.
     *
     * @attribute setMax
     * @readOnly
     * @type Boolean
     * @private
     */
    setMax: {
        readOnly: true,

        getter: function()
        {
            _yuitest_coverfunc("build/charts-base/charts-base.js", "getter", 4962);
_yuitest_coverline("build/charts-base/charts-base.js", 4964);
var max = this._getNumber(this._setMaximum);
            _yuitest_coverline("build/charts-base/charts-base.js", 4965);
return (Y_Lang.isNumber(max));
        }
    },

    /**
     * Indicates whether the minimum is calculated or explicitly set.
     *
     * @attribute setMin
     * @readOnly
     * @type Boolean
     * @private
     */
    setMin: {
        readOnly: true,

        getter: function()
        {
            _yuitest_coverfunc("build/charts-base/charts-base.js", "getter", 4980);
_yuitest_coverline("build/charts-base/charts-base.js", 4982);
var min = this._getNumber(this._setMinimum);
            _yuitest_coverline("build/charts-base/charts-base.js", 4983);
return (Y_Lang.isNumber(min));
        }
    },

    /**
     * The maximum value that will appear on an axis. Unless explicitly set, this value is calculated by the `Axis`.
     *
     * @attribute maximum
     * @type Number
     */
    maximum: {
        getter: function ()
        {
            _yuitest_coverfunc("build/charts-base/charts-base.js", "getter", 4994);
_yuitest_coverline("build/charts-base/charts-base.js", 4996);
var max = this._getNumber(this._setMaximum);
            _yuitest_coverline("build/charts-base/charts-base.js", 4997);
if(!Y_Lang.isNumber(max))
            {
                _yuitest_coverline("build/charts-base/charts-base.js", 4999);
max = this._getNumber(this.get("dataMaximum"));
            }
            _yuitest_coverline("build/charts-base/charts-base.js", 5001);
return parseFloat(max);
        },
        setter: function (value)
        {
            _yuitest_coverfunc("build/charts-base/charts-base.js", "setter", 5003);
_yuitest_coverline("build/charts-base/charts-base.js", 5005);
this._setMaximum = this._getNumber(value);
            _yuitest_coverline("build/charts-base/charts-base.js", 5006);
return value;
        }
    },

    /**
     * The minimum value that will appear on an axis. Unless explicitly set, this value is calculated by the `Axis`.
     *
     * @attribute minimum
     * @type Number
     */
    minimum: {
        getter: function ()
        {
            _yuitest_coverfunc("build/charts-base/charts-base.js", "getter", 5017);
_yuitest_coverline("build/charts-base/charts-base.js", 5019);
var min = this._getNumber(this._setMinimum);
            _yuitest_coverline("build/charts-base/charts-base.js", 5020);
if(!Y_Lang.isNumber(min))
            {
                _yuitest_coverline("build/charts-base/charts-base.js", 5022);
min = this._getNumber(this.get("dataMinimum"));
            }
            _yuitest_coverline("build/charts-base/charts-base.js", 5024);
return parseFloat(min);
        },
        setter: function (value)
        {
            _yuitest_coverfunc("build/charts-base/charts-base.js", "setter", 5026);
_yuitest_coverline("build/charts-base/charts-base.js", 5028);
this._setMinimum = this._getNumber(value);
            _yuitest_coverline("build/charts-base/charts-base.js", 5029);
return value;
        }
    },

    /**
     * Method used for formatting a label. This attribute allows for the default label formatting method to overridden.
     * The method use would need to implement the arguments below and return a `String` or an `HTMLElement`. The default
     * implementation of the method returns a `String`. The output of this method will be rendered to the DOM using
     * `appendChild`. If you override the `labelFunction` method and return an html string, you will also need to override
     * the Axis' `appendLabelFunction` to accept html as a `String`.
     * <dl>
     *      <dt>val</dt><dd>Label to be formatted. (`String`)</dd>
     *      <dt>format</dt><dd>STRFTime string used to format the label. (optional)</dd>
     * </dl>
     *
     * @attribute labelFunction
     * @type Function
     */
    labelFunction: {
        value: function(val, format)
        {
            _yuitest_coverfunc("build/charts-base/charts-base.js", "value", 5048);
_yuitest_coverline("build/charts-base/charts-base.js", 5050);
val = Y.DataType.Date.parse(val);
            _yuitest_coverline("build/charts-base/charts-base.js", 5051);
if(format)
            {
                _yuitest_coverline("build/charts-base/charts-base.js", 5053);
return Y.DataType.Date.format(val, {format:format});
            }
            _yuitest_coverline("build/charts-base/charts-base.js", 5055);
return val;
        }
    },

    /**
     * Pattern used by the `labelFunction` to format a label.
     *
     * @attribute labelFormat
     * @type String
     */
    labelFormat: {
        value: "%b %d, %y"
    }
};

_yuitest_coverline("build/charts-base/charts-base.js", 5070);
Y.extend(TimeAxis, Y.AxisType, {
    /**
     * Formats a label based on the axis type and optionally specified format.
     *
     * @method formatLabel
     * @param {Object} value
     * @param {Object} format Pattern used to format the value.
     * @return String
     */
    formatLabel: function(val, format)
    {
        _yuitest_coverfunc("build/charts-base/charts-base.js", "formatLabel", 5079);
_yuitest_coverline("build/charts-base/charts-base.js", 5081);
val = Y.DataType.Date.parse(val);
        _yuitest_coverline("build/charts-base/charts-base.js", 5082);
if(format)
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 5084);
return Y.DataType.Date.format(val, {format:format});
        }
        _yuitest_coverline("build/charts-base/charts-base.js", 5086);
return val;
    },

    /**
     * Constant used to generate unique id.
     *
     * @property GUID
     * @type String
     * @private
     */
    GUID: "yuitimeaxis",

    /**
     * Type of data used in `Axis`.
     *
     * @property _dataType
     * @readOnly
     * @private
     */
    _dataType: "time",

    /**
     * Calculates and returns a value based on the number of labels and the index of
     * the current label.
     *
     * @method getLabelByIndex
     * @param {Number} i Index of the label.
     * @param {Number} l Total number of labels.
     * @return String
     */
    getLabelByIndex: function(i, l)
    {
        _yuitest_coverfunc("build/charts-base/charts-base.js", "getLabelByIndex", 5116);
_yuitest_coverline("build/charts-base/charts-base.js", 5118);
var min = this.get("minimum"),
            max = this.get("maximum"),
            position = this.get("position"),
            increm,
            label;
            _yuitest_coverline("build/charts-base/charts-base.js", 5123);
l -= 1;
        _yuitest_coverline("build/charts-base/charts-base.js", 5124);
increm = ((max - min)/l) * i;
        _yuitest_coverline("build/charts-base/charts-base.js", 5125);
if(position == "bottom" || position == "top")
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 5127);
label = min + increm;
        }
        else
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 5131);
label = max - increm;
        }
        _yuitest_coverline("build/charts-base/charts-base.js", 5133);
return label;
    },

    /**
     * Gets an array of values based on a key.
     *
     * @method _getKeyArray
     * @param {String} key Value key associated with the data array.
     * @param {Array} data Array in which the data resides.
     * @return Array
     * @private
     */
    _getKeyArray: function(key, data)
    {
        _yuitest_coverfunc("build/charts-base/charts-base.js", "_getKeyArray", 5145);
_yuitest_coverline("build/charts-base/charts-base.js", 5147);
var obj,
            keyArray = [],
            i = 0,
            val,
            len = data.length;
        _yuitest_coverline("build/charts-base/charts-base.js", 5152);
for(; i < len; ++i)
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 5154);
obj = data[i][key];
            _yuitest_coverline("build/charts-base/charts-base.js", 5155);
if(Y_Lang.isDate(obj))
            {
                _yuitest_coverline("build/charts-base/charts-base.js", 5157);
val = obj.valueOf();
            }
            else
            {
                _yuitest_coverline("build/charts-base/charts-base.js", 5161);
val = new Date(obj);
                _yuitest_coverline("build/charts-base/charts-base.js", 5162);
if(Y_Lang.isDate(val))
                {
                    _yuitest_coverline("build/charts-base/charts-base.js", 5164);
val = val.valueOf();
                }
                else {_yuitest_coverline("build/charts-base/charts-base.js", 5166);
if(!Y_Lang.isNumber(obj))
                {
                    _yuitest_coverline("build/charts-base/charts-base.js", 5168);
if(Y_Lang.isNumber(parseFloat(obj)))
                    {
                        _yuitest_coverline("build/charts-base/charts-base.js", 5170);
val = parseFloat(obj);
                    }
                    else
                    {
                        _yuitest_coverline("build/charts-base/charts-base.js", 5174);
if(typeof obj != "string")
                        {
                            _yuitest_coverline("build/charts-base/charts-base.js", 5176);
obj = obj;
                        }
                        _yuitest_coverline("build/charts-base/charts-base.js", 5178);
val = new Date(obj).valueOf();
                    }
                }
                else
                {
                    _yuitest_coverline("build/charts-base/charts-base.js", 5183);
val = obj;
                }}
            }
            _yuitest_coverline("build/charts-base/charts-base.js", 5186);
keyArray[i] = val;
        }
        _yuitest_coverline("build/charts-base/charts-base.js", 5188);
return keyArray;
    },

    /**
     * Sets data by key
     *
     * @method _setDataByKey
     * @param {String} key Key value to use.
     * @param {Array} data Array to use.
     * @private
     */
    _setDataByKey: function(key, data)
    {
        _yuitest_coverfunc("build/charts-base/charts-base.js", "_setDataByKey", 5199);
_yuitest_coverline("build/charts-base/charts-base.js", 5201);
var obj,
            arr = [],
            dv = this._dataClone.concat(),
            i,
            val,
            len = dv.length;
        _yuitest_coverline("build/charts-base/charts-base.js", 5207);
for(i = 0; i < len; ++i)
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 5209);
obj = dv[i][key];
            _yuitest_coverline("build/charts-base/charts-base.js", 5210);
if(Y_Lang.isDate(obj))
            {
                _yuitest_coverline("build/charts-base/charts-base.js", 5212);
val = obj.valueOf();
            }
            else
            {
                _yuitest_coverline("build/charts-base/charts-base.js", 5216);
val = new Date(obj);
                _yuitest_coverline("build/charts-base/charts-base.js", 5217);
if(Y_Lang.isDate(val))
                {
                    _yuitest_coverline("build/charts-base/charts-base.js", 5219);
val = val.valueOf();
                }
                else {_yuitest_coverline("build/charts-base/charts-base.js", 5221);
if(!Y_Lang.isNumber(obj))
                {
                    _yuitest_coverline("build/charts-base/charts-base.js", 5223);
if(Y_Lang.isNumber(parseFloat(obj)))
                    {
                        _yuitest_coverline("build/charts-base/charts-base.js", 5225);
val = parseFloat(obj);
                    }
                    else
                    {
                        _yuitest_coverline("build/charts-base/charts-base.js", 5229);
if(typeof obj != "string")
                        {
                            _yuitest_coverline("build/charts-base/charts-base.js", 5231);
obj = obj.toString();
                        }
                        _yuitest_coverline("build/charts-base/charts-base.js", 5233);
val = new Date(obj).valueOf();
                    }
                }
                else
                {
                    _yuitest_coverline("build/charts-base/charts-base.js", 5238);
val = obj;
                }}
            }
            _yuitest_coverline("build/charts-base/charts-base.js", 5241);
arr[i] = val;
        }
        _yuitest_coverline("build/charts-base/charts-base.js", 5243);
this.get("keys")[key] = arr;
        _yuitest_coverline("build/charts-base/charts-base.js", 5244);
this._updateTotalDataFlag = true;
    },

    /**
     * Parses value into a number.
     *
     * @method _getNumber
     * @param val {Object} Value to parse into a number
     * @return Number
     * @private
     */
    _getNumber: function(val)
    {
        _yuitest_coverfunc("build/charts-base/charts-base.js", "_getNumber", 5255);
_yuitest_coverline("build/charts-base/charts-base.js", 5257);
if(Y_Lang.isDate(val))
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 5259);
val = val.valueOf();
        }
        else {_yuitest_coverline("build/charts-base/charts-base.js", 5261);
if(!Y_Lang.isNumber(val) && val)
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 5263);
val = new Date(val).valueOf();
        }}

        _yuitest_coverline("build/charts-base/charts-base.js", 5266);
return val;
    }
});

_yuitest_coverline("build/charts-base/charts-base.js", 5270);
Y.TimeAxis = TimeAxis;

/**
 * CategoryAxis manages category data on an axis.
 *
 * @module charts
 * @submodule charts-base
 * @class CategoryAxis
 * @constructor
 * @param {Object} config (optional) Configuration parameters for the Chart.
 * @extends AxisType
 */
_yuitest_coverline("build/charts-base/charts-base.js", 5282);
function CategoryAxis(config)
{
	_yuitest_coverfunc("build/charts-base/charts-base.js", "CategoryAxis", 5282);
_yuitest_coverline("build/charts-base/charts-base.js", 5284);
CategoryAxis.superclass.constructor.apply(this, arguments);
}

_yuitest_coverline("build/charts-base/charts-base.js", 5287);
CategoryAxis.NAME = "categoryAxis";

_yuitest_coverline("build/charts-base/charts-base.js", 5289);
Y.extend(CategoryAxis, Y.AxisType,
{
    /**
     * Formats a label based on the axis type and optionally specified format.
     *
     * @method formatLabel
     * @param {Object} value
     * @param {Object} format Pattern used to format the value.
     * @return String
     */
    formatLabel: function(val, format)
    {
        _yuitest_coverfunc("build/charts-base/charts-base.js", "formatLabel", 5299);
_yuitest_coverline("build/charts-base/charts-base.js", 5301);
return val;
    },

    /**
     * Object storing key data.
     *
     * @property _indices
     * @private
     */
    _indices: null,

    /**
     * Constant used to generate unique id.
     *
     * @property GUID
     * @type String
     * @private
     */
    GUID: "yuicategoryaxis",

    /**
     * Type of data used in `Axis`.
     *
     * @property _dataType
     * @readOnly
     * @private
     */
    _type: "category",

    /**
     * Calculates the maximum and minimum values for the `Axis`.
     *
     * @method _updateMinAndMax
     * @private
     */
    _updateMinAndMax: function()
    {
        _yuitest_coverfunc("build/charts-base/charts-base.js", "_updateMinAndMax", 5336);
_yuitest_coverline("build/charts-base/charts-base.js", 5338);
this._dataMaximum = Math.max(this.get("data").length - 1, 0);
        _yuitest_coverline("build/charts-base/charts-base.js", 5339);
this._dataMinimum = 0;
    },

    /**
     * Gets an array of values based on a key.
     *
     * @method _getKeyArray
     * @param {String} key Value key associated with the data array.
     * @param {Array} data Array in which the data resides.
     * @return Array
     * @private
     */
    _getKeyArray: function(key, data)
    {
        _yuitest_coverfunc("build/charts-base/charts-base.js", "_getKeyArray", 5351);
_yuitest_coverline("build/charts-base/charts-base.js", 5353);
var i = 0,
            obj,
            keyArr = [],
            labels = [],
            len = data.length;
        _yuitest_coverline("build/charts-base/charts-base.js", 5358);
if(!this._indices)
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 5360);
this._indices = {};
        }
        _yuitest_coverline("build/charts-base/charts-base.js", 5362);
for(; i < len; ++i)
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 5364);
obj = data[i];
            _yuitest_coverline("build/charts-base/charts-base.js", 5365);
keyArr[i] = i;
            _yuitest_coverline("build/charts-base/charts-base.js", 5366);
labels[i] = obj[key];
        }
        _yuitest_coverline("build/charts-base/charts-base.js", 5368);
this._indices[key] = keyArr;
        _yuitest_coverline("build/charts-base/charts-base.js", 5369);
return labels;
    },

    /**
     * Sets data by key
     *
     * @method _setDataByKey
     * @param {String} key Key value to use.
     * @param {Array} data Array to use.
     * @private
     */
    _setDataByKey: function(key)
    {
        _yuitest_coverfunc("build/charts-base/charts-base.js", "_setDataByKey", 5380);
_yuitest_coverline("build/charts-base/charts-base.js", 5382);
var i,
            obj,
            arr = [],
            labels = [],
            dv = this._dataClone.concat(),
            len = dv.length;
        _yuitest_coverline("build/charts-base/charts-base.js", 5388);
if(!this._indices)
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 5390);
this._indices = {};
        }
        _yuitest_coverline("build/charts-base/charts-base.js", 5392);
for(i = 0; i < len; ++i)
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 5394);
obj = dv[i];
            _yuitest_coverline("build/charts-base/charts-base.js", 5395);
arr[i] = i;
            _yuitest_coverline("build/charts-base/charts-base.js", 5396);
labels[i] = obj[key];
        }
        _yuitest_coverline("build/charts-base/charts-base.js", 5398);
this._indices[key] = arr;
        _yuitest_coverline("build/charts-base/charts-base.js", 5399);
this.get("keys")[key] = labels.concat();
        _yuitest_coverline("build/charts-base/charts-base.js", 5400);
this._updateTotalDataFlag = true;
    },

    /**
     * Returns an array of values based on an identifier key.
     *
     * @method getDataByKey
     * @param {String} value value used to identify the array
     * @return Array
     */
    getDataByKey: function (value)
    {
        _yuitest_coverfunc("build/charts-base/charts-base.js", "getDataByKey", 5410);
_yuitest_coverline("build/charts-base/charts-base.js", 5412);
if(!this._indices)
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 5414);
this.get("keys");
        }
        _yuitest_coverline("build/charts-base/charts-base.js", 5416);
var keys = this._indices;
        _yuitest_coverline("build/charts-base/charts-base.js", 5417);
if(keys[value])
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 5419);
return keys[value];
        }
        _yuitest_coverline("build/charts-base/charts-base.js", 5421);
return null;
    },

    /**
     * Returns the total number of majorUnits that will appear on an axis.
     *
     * @method getTotalMajorUnits
     * @param {Object} majorUnit Object containing properties related to the majorUnit.
     * @param {Number} len Length of the axis.
     * @return Number
     */
    getTotalMajorUnits: function(majorUnit, len)
    {
        _yuitest_coverfunc("build/charts-base/charts-base.js", "getTotalMajorUnits", 5432);
_yuitest_coverline("build/charts-base/charts-base.js", 5434);
return this.get("data").length;
    },

    /**
     * Returns the distance between major units on an axis.
     *
     * @method getMajorUnitDistance
     * @param {Number} len Number of ticks
     * @param {Number} uiLen Size of the axis.
     * @param {Object} majorUnit Hash of properties used to determine the majorUnit
     * @return Number
     */
    getMajorUnitDistance: function(len, uiLen, majorUnit)
    {
        _yuitest_coverfunc("build/charts-base/charts-base.js", "getMajorUnitDistance", 5446);
_yuitest_coverline("build/charts-base/charts-base.js", 5448);
var dist;
        _yuitest_coverline("build/charts-base/charts-base.js", 5449);
if(majorUnit.determinant === "count")
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 5451);
dist = uiLen/len;
        }
        else {_yuitest_coverline("build/charts-base/charts-base.js", 5453);
if(majorUnit.determinant === "distance")
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 5455);
dist = majorUnit.distance;
        }}
        _yuitest_coverline("build/charts-base/charts-base.js", 5457);
return dist;
    },

    /**
     * Gets the distance that the first and last ticks are offset from there respective
     * edges.
     *
     * @method getEdgeOffset
     * @param {Number} ct Number of ticks on the axis.
     * @param {Number} l Length (in pixels) of the axis.
     * @return Number
     */
    getEdgeOffset: function(ct, l)
    {
        _yuitest_coverfunc("build/charts-base/charts-base.js", "getEdgeOffset", 5469);
_yuitest_coverline("build/charts-base/charts-base.js", 5471);
return l/ct;
    },

    /**
     * Returns a value based of a key value and an index.
     *
     * @method getKeyValueAt
     * @param {String} key value used to look up the correct array
     * @param {Number} index within the array
     * @return String
     */
    getKeyValueAt: function(key, index)
    {
        _yuitest_coverfunc("build/charts-base/charts-base.js", "getKeyValueAt", 5482);
_yuitest_coverline("build/charts-base/charts-base.js", 5484);
var value = NaN,
            keys = this.get("keys");
        _yuitest_coverline("build/charts-base/charts-base.js", 5486);
if(keys[key] && keys[key][index])
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 5488);
value = keys[key][index];
        }
        _yuitest_coverline("build/charts-base/charts-base.js", 5490);
return value;
    },

    /**
     * Calculates and returns a value based on the number of labels and the index of
     * the current label.
     *
     * @method getLabelByIndex
     * @param {Number} i Index of the label.
     * @param {Number} l Total number of labels.
     * @return String
     */
    getLabelByIndex: function(i, l)
    {
        _yuitest_coverfunc("build/charts-base/charts-base.js", "getLabelByIndex", 5502);
_yuitest_coverline("build/charts-base/charts-base.js", 5504);
var label,
            data = this.get("data"),
            position = this.get("position");
        _yuitest_coverline("build/charts-base/charts-base.js", 5507);
if(position == "bottom" || position == "top")
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 5509);
label = data[i];
        }
        else
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 5513);
label = data[l - (i + 1)];
        }
        _yuitest_coverline("build/charts-base/charts-base.js", 5515);
return label;
    },

    /**
     * Returns a string corresponding to the first label on an
     * axis.
     *
     * @method getMinimumValue
     * @return String
     */
    getMinimumValue: function()
    {
        _yuitest_coverfunc("build/charts-base/charts-base.js", "getMinimumValue", 5525);
_yuitest_coverline("build/charts-base/charts-base.js", 5527);
var data = this.get("data"),
            label = data[0];
        _yuitest_coverline("build/charts-base/charts-base.js", 5529);
return label;
    },

    /**
     * Returns a string corresponding to the last label on an
     * axis.
     *
     * @method getMaximumValue
     * @return String
     */
    getMaximumValue: function()
    {
        _yuitest_coverfunc("build/charts-base/charts-base.js", "getMaximumValue", 5539);
_yuitest_coverline("build/charts-base/charts-base.js", 5541);
var data = this.get("data"),
            len = data.length - 1,
            label = data[len];
        _yuitest_coverline("build/charts-base/charts-base.js", 5544);
return label;
    }
});

_yuitest_coverline("build/charts-base/charts-base.js", 5548);
Y.CategoryAxis = CategoryAxis;

/**
 * Utility class used for calculating curve points.
 *
 * @module charts
 * @submodule charts-base
 * @class CurveUtil
 * @constructor
 */
_yuitest_coverline("build/charts-base/charts-base.js", 5558);
function CurveUtil()
{
}

_yuitest_coverline("build/charts-base/charts-base.js", 5562);
CurveUtil.prototype = {
    /**
     * Creates an array of start, end and control points for splines.
     *
     * @method getCurveControlPoints
     * @param {Array} xcoords Collection of x-coordinates used for calculate the curves
     * @param {Array} ycoords Collection of y-coordinates used for calculate the curves
     * @return Object
     * @protected
     */
    getCurveControlPoints: function(xcoords, ycoords)
    {
		_yuitest_coverfunc("build/charts-base/charts-base.js", "getCurveControlPoints", 5572);
_yuitest_coverline("build/charts-base/charts-base.js", 5574);
var outpoints = [],
            i = 1,
            l = xcoords.length - 1,
		    xvals = [],
		    yvals = [];


		// Too few points, need at least two
		_yuitest_coverline("build/charts-base/charts-base.js", 5582);
if (l < 1)
        {
			_yuitest_coverline("build/charts-base/charts-base.js", 5584);
return null;
		}

        _yuitest_coverline("build/charts-base/charts-base.js", 5587);
outpoints[0] = {
            startx: xcoords[0],
            starty: ycoords[0],
            endx: xcoords[1],
            endy: ycoords[1]
        };

		// Special case, the Bezier should be a straight line
        _yuitest_coverline("build/charts-base/charts-base.js", 5595);
if (l === 1)
        {
			_yuitest_coverline("build/charts-base/charts-base.js", 5597);
outpoints[0].ctrlx1 = (2.0*xcoords[0] + xcoords[1])/3.0;
			_yuitest_coverline("build/charts-base/charts-base.js", 5598);
outpoints[0].ctrly2 = (2.0*ycoords[0] + ycoords[1])/3.0;
			_yuitest_coverline("build/charts-base/charts-base.js", 5599);
outpoints[0].ctrlx2 = 2.0*outpoints[0].ctrlx1 - xcoords[0];
            _yuitest_coverline("build/charts-base/charts-base.js", 5600);
outpoints[0].ctrly2 = 2.0*outpoints[0].ctrly1 - ycoords[0];
            _yuitest_coverline("build/charts-base/charts-base.js", 5601);
return outpoints;
		}

		_yuitest_coverline("build/charts-base/charts-base.js", 5604);
for (; i < l; ++i)
        {
			_yuitest_coverline("build/charts-base/charts-base.js", 5606);
outpoints.push({startx: Math.round(xcoords[i]), starty: Math.round(ycoords[i]), endx: Math.round(xcoords[i+1]), endy: Math.round(ycoords[i+1])});
			_yuitest_coverline("build/charts-base/charts-base.js", 5607);
xvals[i] = 4.0 * xcoords[i] + 2*xcoords[i+1];
			_yuitest_coverline("build/charts-base/charts-base.js", 5608);
yvals[i] = 4.0*ycoords[i] + 2*ycoords[i+1];
		}

		_yuitest_coverline("build/charts-base/charts-base.js", 5611);
xvals[0] = xcoords[0] + (2.0 * xcoords[1]);
		_yuitest_coverline("build/charts-base/charts-base.js", 5612);
xvals[l-1] = (8.0 * xcoords[l-1] + xcoords[l]) / 2.0;
		_yuitest_coverline("build/charts-base/charts-base.js", 5613);
xvals = this.getControlPoints(xvals.concat());
        _yuitest_coverline("build/charts-base/charts-base.js", 5614);
yvals[0] = ycoords[0] + (2.0 * ycoords[1]);
		_yuitest_coverline("build/charts-base/charts-base.js", 5615);
yvals[l-1] = (8.0 * ycoords[l-1] + ycoords[l]) / 2.0;
		_yuitest_coverline("build/charts-base/charts-base.js", 5616);
yvals = this.getControlPoints(yvals.concat());

        _yuitest_coverline("build/charts-base/charts-base.js", 5618);
for (i = 0; i < l; ++i)
        {
			_yuitest_coverline("build/charts-base/charts-base.js", 5620);
outpoints[i].ctrlx1 = Math.round(xvals[i]);
            _yuitest_coverline("build/charts-base/charts-base.js", 5621);
outpoints[i].ctrly1 = Math.round(yvals[i]);

			_yuitest_coverline("build/charts-base/charts-base.js", 5623);
if (i < l-1)
            {
				_yuitest_coverline("build/charts-base/charts-base.js", 5625);
outpoints[i].ctrlx2 = Math.round(2*xcoords[i+1] - xvals[i+1]);
                _yuitest_coverline("build/charts-base/charts-base.js", 5626);
outpoints[i].ctrly2 = Math.round(2*ycoords[i+1] - yvals[i+1]);
			}
			else
            {
				_yuitest_coverline("build/charts-base/charts-base.js", 5630);
outpoints[i].ctrlx2 = Math.round((xcoords[l] + xvals[l-1])/2);
                _yuitest_coverline("build/charts-base/charts-base.js", 5631);
outpoints[i].ctrly2 = Math.round((ycoords[l] + yvals[l-1])/2);
			}
		}

		_yuitest_coverline("build/charts-base/charts-base.js", 5635);
return outpoints;
	},

    /**
     * Gets the control points for the curve.
     *
     * @method getControlPoints
     * @param {Array} vals Collection of values coords used to generate control points.
     * @return Array
     * @private
     */
	getControlPoints: function(vals)
    {
		_yuitest_coverfunc("build/charts-base/charts-base.js", "getControlPoints", 5646);
_yuitest_coverline("build/charts-base/charts-base.js", 5648);
var l = vals.length,
            x = [],
            tmp = [],
            b = 2.0,
            i = 1;
		_yuitest_coverline("build/charts-base/charts-base.js", 5653);
x[0] = vals[0] / b;
		_yuitest_coverline("build/charts-base/charts-base.js", 5654);
for (; i < l; ++i)
        {
			_yuitest_coverline("build/charts-base/charts-base.js", 5656);
tmp[i] = 1/b;
			_yuitest_coverline("build/charts-base/charts-base.js", 5657);
b = (i < l-1 ? 4.0 : 3.5) - tmp[i];
			_yuitest_coverline("build/charts-base/charts-base.js", 5658);
x[i] = (vals[i] - x[i-1]) / b;
		}

		_yuitest_coverline("build/charts-base/charts-base.js", 5661);
for (i = 1; i < l; ++i)
        {
			_yuitest_coverline("build/charts-base/charts-base.js", 5663);
x[l-i-1] -= tmp[l-i] * x[l-i];
		}

		_yuitest_coverline("build/charts-base/charts-base.js", 5666);
return x;
	}
};
_yuitest_coverline("build/charts-base/charts-base.js", 5669);
Y.CurveUtil = CurveUtil;
/**
 * Utility class used for creating stacked series.
 *
 * @module charts
 * @submodule charts-base
 * @class StackingUtil
 * @constructor
 */
_yuitest_coverline("build/charts-base/charts-base.js", 5678);
function StackingUtil(){}

_yuitest_coverline("build/charts-base/charts-base.js", 5680);
StackingUtil.prototype = {
    /**
     * Indicates whether the series is stacked.
     *
     * @property _stacked
     * @private
     */
    _stacked: true,

    /**
     * @protected
     *
     * Adjusts coordinate values for stacked series.
     *
     * @method _stackCoordinates
     */
    _stackCoordinates: function()
    {
        _yuitest_coverfunc("build/charts-base/charts-base.js", "_stackCoordinates", 5696);
_yuitest_coverline("build/charts-base/charts-base.js", 5698);
if(this.get("direction") == "vertical")
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 5700);
this._stackXCoords();
        }
        else
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 5704);
this._stackYCoords();
        }
    },

    /**
     * Stacks coordinates for a stacked vertical series.
     *
     * @method _stackXCoords
     * @protected
     */
    _stackXCoords: function()
    {
        _yuitest_coverfunc("build/charts-base/charts-base.js", "_stackXCoords", 5714);
_yuitest_coverline("build/charts-base/charts-base.js", 5716);
var order = this.get("order"),
            type = this.get("type"),
            graph = this.get("graph"),
            seriesCollection = graph.seriesTypes[type],
            i = 0,
            xcoords = this.get("xcoords"),
            ycoords = this.get("ycoords"),
            len,
            coord,
            prevCoord,
            prevOrder,
            stackedXCoords = xcoords.concat(),
            prevXCoords,
            prevYCoords,
            nullIndices = [],
            nullIndex;
        _yuitest_coverline("build/charts-base/charts-base.js", 5732);
if(order > 0)
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 5734);
prevXCoords = seriesCollection[order - 1].get("stackedXCoords");
            _yuitest_coverline("build/charts-base/charts-base.js", 5735);
prevYCoords = seriesCollection[order - 1].get("stackedYCoords");
            _yuitest_coverline("build/charts-base/charts-base.js", 5736);
len = prevXCoords.length;
        }
        else
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 5740);
len = xcoords.length;
        }
        _yuitest_coverline("build/charts-base/charts-base.js", 5742);
for(; i < len; i = i + 1)
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 5744);
if(Y_Lang.isNumber(xcoords[i]))
            {
                _yuitest_coverline("build/charts-base/charts-base.js", 5746);
if(order > 0)
                {
                    _yuitest_coverline("build/charts-base/charts-base.js", 5748);
prevCoord = prevXCoords[i];
                    _yuitest_coverline("build/charts-base/charts-base.js", 5749);
if(!Y_Lang.isNumber(prevCoord))
                    {
                        _yuitest_coverline("build/charts-base/charts-base.js", 5751);
prevOrder = order;
                        _yuitest_coverline("build/charts-base/charts-base.js", 5752);
while(prevOrder >  - 1 && !Y_Lang.isNumber(prevCoord))
                        {
                            _yuitest_coverline("build/charts-base/charts-base.js", 5754);
prevOrder = prevOrder - 1;
                            _yuitest_coverline("build/charts-base/charts-base.js", 5755);
if(prevOrder > -1)
                            {
                                _yuitest_coverline("build/charts-base/charts-base.js", 5757);
prevCoord = seriesCollection[prevOrder].get("stackedXCoords")[i];
                            }
                            else
                            {
                                _yuitest_coverline("build/charts-base/charts-base.js", 5761);
prevCoord = this._leftOrigin;
                            }
                        }
                    }
                    _yuitest_coverline("build/charts-base/charts-base.js", 5765);
xcoords[i] = xcoords[i] + prevCoord;
                }
                _yuitest_coverline("build/charts-base/charts-base.js", 5767);
stackedXCoords[i] = xcoords[i];
            }
            else
            {
                _yuitest_coverline("build/charts-base/charts-base.js", 5771);
nullIndices.push(i);
            }
        }
        _yuitest_coverline("build/charts-base/charts-base.js", 5774);
this._cleanXNaN(stackedXCoords, ycoords);
        _yuitest_coverline("build/charts-base/charts-base.js", 5775);
len = nullIndices.length;
        _yuitest_coverline("build/charts-base/charts-base.js", 5776);
if(len > 0)
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 5778);
for(i = 0; i < len; i = i + 1)
            {
                _yuitest_coverline("build/charts-base/charts-base.js", 5780);
nullIndex = nullIndices[i];
                _yuitest_coverline("build/charts-base/charts-base.js", 5781);
coord = order > 0 ? prevXCoords[nullIndex] : this._leftOrigin;
                _yuitest_coverline("build/charts-base/charts-base.js", 5782);
stackedXCoords[nullIndex] =  Math.max(stackedXCoords[nullIndex], coord);
            }
        }
        _yuitest_coverline("build/charts-base/charts-base.js", 5785);
this.set("stackedXCoords", stackedXCoords);
        _yuitest_coverline("build/charts-base/charts-base.js", 5786);
this.set("stackedYCoords", ycoords);
    },

    /**
     * Stacks coordinates for a stacked horizontal series.
     *
     * @method _stackYCoords
     * @protected
     */
    _stackYCoords: function()
    {
        _yuitest_coverfunc("build/charts-base/charts-base.js", "_stackYCoords", 5795);
_yuitest_coverline("build/charts-base/charts-base.js", 5797);
var order = this.get("order"),
            type = this.get("type"),
            graph = this.get("graph"),
            h = graph.get("height"),
            seriesCollection = graph.seriesTypes[type],
            i = 0,
            xcoords = this.get("xcoords"),
            ycoords = this.get("ycoords"),
            len,
            coord,
            prevCoord,
            prevOrder,
            stackedYCoords = ycoords.concat(),
            prevXCoords,
            prevYCoords,
            nullIndices = [],
            nullIndex;
        _yuitest_coverline("build/charts-base/charts-base.js", 5814);
if(order > 0)
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 5816);
prevXCoords = seriesCollection[order - 1].get("stackedXCoords");
            _yuitest_coverline("build/charts-base/charts-base.js", 5817);
prevYCoords = seriesCollection[order - 1].get("stackedYCoords");
            _yuitest_coverline("build/charts-base/charts-base.js", 5818);
len = prevYCoords.length;
        }
        else
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 5822);
len = ycoords.length;
        }
        _yuitest_coverline("build/charts-base/charts-base.js", 5824);
for(; i < len; i = i + 1)
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 5826);
if(Y_Lang.isNumber(ycoords[i]))
            {
                _yuitest_coverline("build/charts-base/charts-base.js", 5828);
if(order > 0)
                {
                    _yuitest_coverline("build/charts-base/charts-base.js", 5830);
prevCoord = prevYCoords[i];
                    _yuitest_coverline("build/charts-base/charts-base.js", 5831);
if(!Y_Lang.isNumber(prevCoord))
                    {
                        _yuitest_coverline("build/charts-base/charts-base.js", 5833);
prevOrder = order;
                        _yuitest_coverline("build/charts-base/charts-base.js", 5834);
while(prevOrder >  - 1 && !Y_Lang.isNumber(prevCoord))
                        {
                            _yuitest_coverline("build/charts-base/charts-base.js", 5836);
prevOrder = prevOrder - 1;
                            _yuitest_coverline("build/charts-base/charts-base.js", 5837);
if(prevOrder > -1)
                            {
                                _yuitest_coverline("build/charts-base/charts-base.js", 5839);
prevCoord = seriesCollection[prevOrder].get("stackedYCoords")[i];
                            }
                            else
                            {
                                _yuitest_coverline("build/charts-base/charts-base.js", 5843);
prevCoord = this._bottomOrigin;
                            }
                        }
                    }
                    _yuitest_coverline("build/charts-base/charts-base.js", 5847);
ycoords[i] = prevCoord - (h - ycoords[i]);
                }
                _yuitest_coverline("build/charts-base/charts-base.js", 5849);
stackedYCoords[i] = ycoords[i];
            }
            else
            {
                _yuitest_coverline("build/charts-base/charts-base.js", 5853);
nullIndices.push(i);
            }
        }
        _yuitest_coverline("build/charts-base/charts-base.js", 5856);
this._cleanYNaN(xcoords, stackedYCoords);
        _yuitest_coverline("build/charts-base/charts-base.js", 5857);
len = nullIndices.length;
        _yuitest_coverline("build/charts-base/charts-base.js", 5858);
if(len > 0)
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 5860);
for(i = 0; i < len; i = i + 1)
            {
                _yuitest_coverline("build/charts-base/charts-base.js", 5862);
nullIndex = nullIndices[i];
                _yuitest_coverline("build/charts-base/charts-base.js", 5863);
coord = order > 0 ? prevYCoords[nullIndex] : h;
                _yuitest_coverline("build/charts-base/charts-base.js", 5864);
stackedYCoords[nullIndex] =  Math.min(stackedYCoords[nullIndex], coord);
            }
        }
        _yuitest_coverline("build/charts-base/charts-base.js", 5867);
this.set("stackedXCoords", xcoords);
        _yuitest_coverline("build/charts-base/charts-base.js", 5868);
this.set("stackedYCoords", stackedYCoords);
    },

    /**
     * Cleans invalid x-coordinates by calculating their value based on the corresponding y-coordinate, the
     * previous valid x-coordinate with its corresponding y-coordinate and the next valid x-coordinate with
     * its corresponding y-coordinate. If there is no previous or next valid x-coordinate, the value will not
     * be altered.
     *
     * @method _cleanXNaN
     * @param {Array} xcoords An array of x-coordinate values
     * @param {Array} ycoords An arry of y-coordinate values
     * @private
     */
    _cleanXNaN: function(xcoords, ycoords)
    {
        _yuitest_coverfunc("build/charts-base/charts-base.js", "_cleanXNaN", 5882);
_yuitest_coverline("build/charts-base/charts-base.js", 5884);
var previousValidIndex,
            nextValidIndex,
            previousValidX,
            previousValidY,
            x,
            y,
            nextValidX,
            nextValidY,
            isNumber = Y_Lang.isNumber,
            m,
            i = 0,
            len = ycoords.length;
        _yuitest_coverline("build/charts-base/charts-base.js", 5896);
for(; i < len; ++i)
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 5898);
x = xcoords[i];
            _yuitest_coverline("build/charts-base/charts-base.js", 5899);
y = ycoords[i];
            //if x is invalid, calculate where it should be
            _yuitest_coverline("build/charts-base/charts-base.js", 5901);
if(!isNumber(x) && i > 0 && i < len - 1)
            {
                _yuitest_coverline("build/charts-base/charts-base.js", 5903);
previousValidY = ycoords[i - 1];
                //check to see if the previous value is valid
                _yuitest_coverline("build/charts-base/charts-base.js", 5905);
previousValidX = this._getPreviousValidCoordValue(xcoords, i);
                _yuitest_coverline("build/charts-base/charts-base.js", 5906);
nextValidY = ycoords[i + 1];
                _yuitest_coverline("build/charts-base/charts-base.js", 5907);
nextValidX = this._getNextValidCoordValue(xcoords, i);
                //check to see if the next value is valid
                _yuitest_coverline("build/charts-base/charts-base.js", 5909);
if(isNumber(previousValidX) && isNumber(nextValidX))
                {
                    //calculate slope and solve for x
                    _yuitest_coverline("build/charts-base/charts-base.js", 5912);
m = (nextValidY - previousValidY) / (nextValidX - previousValidX);
                    _yuitest_coverline("build/charts-base/charts-base.js", 5913);
xcoords[i] = (y + (m * previousValidX) - previousValidY)/m;
                }
                _yuitest_coverline("build/charts-base/charts-base.js", 5915);
previousValidIndex = NaN;
                _yuitest_coverline("build/charts-base/charts-base.js", 5916);
nextValidIndex = NaN;
            }
        }
    },

    /**
     * Returns the previous valid (numeric) value in an array if available.
     *
     * @method _getPreviousValidCoordValue
     * @param {Array} coords Array of values
     * @param {Number} index The index in the array in which to begin searching.
     * @return Number
     * @private
     */
    _getPreviousValidCoordValue: function(coords, index)
    {
        _yuitest_coverfunc("build/charts-base/charts-base.js", "_getPreviousValidCoordValue", 5930);
_yuitest_coverline("build/charts-base/charts-base.js", 5932);
var coord,
            isNumber = Y_Lang.isNumber,
            limit = -1;
        _yuitest_coverline("build/charts-base/charts-base.js", 5935);
while(!isNumber(coord) && index > limit)
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 5937);
index = index - 1;
            _yuitest_coverline("build/charts-base/charts-base.js", 5938);
coord = coords[index];
        }
        _yuitest_coverline("build/charts-base/charts-base.js", 5940);
return coord;
    },

    /**
     * Returns the next valid (numeric) value in an array if available.
     *
     * @method _getNextValidCoordValue
     * @param {Array} coords Array of values
     * @param {Number} index The index in the array in which to begin searching.
     * @return Number
     * @private
     */
    _getNextValidCoordValue: function(coords, index)
    {
        _yuitest_coverfunc("build/charts-base/charts-base.js", "_getNextValidCoordValue", 5952);
_yuitest_coverline("build/charts-base/charts-base.js", 5954);
var coord,
            isNumber = Y_Lang.isNumber,
            limit = coords.length;
        _yuitest_coverline("build/charts-base/charts-base.js", 5957);
while(!isNumber(coord) && index < limit)
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 5959);
index = index + 1;
            _yuitest_coverline("build/charts-base/charts-base.js", 5960);
coord = coords[index];
        }
        _yuitest_coverline("build/charts-base/charts-base.js", 5962);
return coord;
    },

    /**
     * Cleans invalid y-coordinates by calculating their value based on the corresponding x-coordinate, the
     * previous valid y-coordinate with its corresponding x-coordinate and the next valid y-coordinate with
     * its corresponding x-coordinate. If there is no previous or next valid y-coordinate, the value will not
     * be altered.
     *
     * @method _cleanYNaN
     * @param {Array} xcoords An array of x-coordinate values
     * @param {Array} ycoords An arry of y-coordinate values
     * @private
     */
    _cleanYNaN: function(xcoords, ycoords)
    {
        _yuitest_coverfunc("build/charts-base/charts-base.js", "_cleanYNaN", 5976);
_yuitest_coverline("build/charts-base/charts-base.js", 5978);
var previousValidIndex,
            nextValidIndex,
            previousValidX,
            previousValidY,
            x,
            y,
            nextValidX,
            nextValidY,
            isNumber = Y_Lang.isNumber,
            m,
            i = 0,
            len = xcoords.length;
        _yuitest_coverline("build/charts-base/charts-base.js", 5990);
for(; i < len; ++i)
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 5992);
x = xcoords[i];
            _yuitest_coverline("build/charts-base/charts-base.js", 5993);
y = ycoords[i];
            //if y is invalid, calculate where it should be
            _yuitest_coverline("build/charts-base/charts-base.js", 5995);
if(!isNumber(y) && i > 0 && i < len - 1)
            {
                //check to see if the previous value is valid
                _yuitest_coverline("build/charts-base/charts-base.js", 5998);
previousValidX = xcoords[i - 1];
                _yuitest_coverline("build/charts-base/charts-base.js", 5999);
previousValidY = this._getPreviousValidCoordValue(ycoords, i);
                //check to see if the next value is valid
                _yuitest_coverline("build/charts-base/charts-base.js", 6001);
nextValidX = xcoords[i + 1];
                _yuitest_coverline("build/charts-base/charts-base.js", 6002);
nextValidY = this._getNextValidCoordValue(ycoords, i);
                _yuitest_coverline("build/charts-base/charts-base.js", 6003);
if(isNumber(previousValidY) && isNumber(nextValidY))
                {
                    //calculate slope and solve for y
                    _yuitest_coverline("build/charts-base/charts-base.js", 6006);
m = (nextValidY - previousValidY) / (nextValidX - previousValidX);
                    _yuitest_coverline("build/charts-base/charts-base.js", 6007);
ycoords[i] = previousValidY + ((m * x) - (m * previousValidX));
                }
                _yuitest_coverline("build/charts-base/charts-base.js", 6009);
previousValidIndex = NaN;
                _yuitest_coverline("build/charts-base/charts-base.js", 6010);
nextValidIndex = NaN;
            }
        }
    }
};
_yuitest_coverline("build/charts-base/charts-base.js", 6015);
Y.StackingUtil = StackingUtil;
/**
 * Utility class used for drawing lines.
 *
 * @module charts
 * @submodule charts-base
 * @class Lines
 * @constructor
 */
_yuitest_coverline("build/charts-base/charts-base.js", 6024);
function Lines(){}

_yuitest_coverline("build/charts-base/charts-base.js", 6026);
Lines.prototype = {
    /**
     * @property _lineDefaults
     * @type Object
     * @private
     */
    _lineDefaults: null,

    /**
     * Creates a graphic in which to draw a series.
     *
     * @method _getGraphic
     * @return Graphic
     * @private
     */
    _getGraphic: function()
    {
        _yuitest_coverfunc("build/charts-base/charts-base.js", "_getGraphic", 6041);
_yuitest_coverline("build/charts-base/charts-base.js", 6043);
var graphic = this.get("graphic") || this.get("graph").get("graphic");
        _yuitest_coverline("build/charts-base/charts-base.js", 6044);
if(!this._lineGraphic)
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 6046);
this._lineGraphic = graphic.addShape({type: "path"});
        }
        _yuitest_coverline("build/charts-base/charts-base.js", 6048);
this._lineGraphic.clear();
        _yuitest_coverline("build/charts-base/charts-base.js", 6049);
return this._lineGraphic;
    },

    /**
     * Toggles visibility
     *
     * @method _toggleVisible
     * @param {Boolean} visible indicates visibilitye
     * @private
     */
    _toggleVisible: function(visible)
    {
        _yuitest_coverfunc("build/charts-base/charts-base.js", "_toggleVisible", 6059);
_yuitest_coverline("build/charts-base/charts-base.js", 6061);
if(this._lineGraphic)
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 6063);
this._lineGraphic.set("visible", visible);
        }
    },

    /**
     * Draws lines for the series.
     *
     * @method drawLines
     * @protected
     */
    drawLines: function()
    {
        _yuitest_coverfunc("build/charts-base/charts-base.js", "drawLines", 6073);
_yuitest_coverline("build/charts-base/charts-base.js", 6075);
if(this.get("xcoords").length < 1)
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 6077);
return;
        }
        _yuitest_coverline("build/charts-base/charts-base.js", 6079);
var isNumber = Y_Lang.isNumber,
            xcoords,
            ycoords,
            direction = this.get("direction"),
            len,
            lastPointValid,
            pointValid,
            noPointsRendered = true,
            lastValidX,
            lastValidY,
            nextX,
            nextY,
            i,
            styles = this.get("styles").line,
            lineType = styles.lineType,
            lc = styles.color || this._getDefaultColor(this.get("graphOrder"), "line"),
            lineAlpha = styles.alpha,
            dashLength = styles.dashLength,
            gapSpace = styles.gapSpace,
            connectDiscontinuousPoints = styles.connectDiscontinuousPoints,
            discontinuousType = styles.discontinuousType,
            discontinuousDashLength = styles.discontinuousDashLength,
            discontinuousGapSpace = styles.discontinuousGapSpace,
            path = this._getGraphic();
        _yuitest_coverline("build/charts-base/charts-base.js", 6103);
if(this._stacked)
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 6105);
xcoords = this.get("stackedXCoords");
            _yuitest_coverline("build/charts-base/charts-base.js", 6106);
ycoords = this.get("stackedYCoords");
        }
        else
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 6110);
xcoords = this.get("xcoords");
            _yuitest_coverline("build/charts-base/charts-base.js", 6111);
ycoords = this.get("ycoords");
        }
        _yuitest_coverline("build/charts-base/charts-base.js", 6113);
len = direction === "vertical" ? ycoords.length : xcoords.length;
        _yuitest_coverline("build/charts-base/charts-base.js", 6114);
path.set("stroke", {
            weight: styles.weight,
            color: lc,
            opacity: lineAlpha
        });
        _yuitest_coverline("build/charts-base/charts-base.js", 6119);
for(i = 0; i < len; i = ++i)
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 6121);
nextX = xcoords[i];
            _yuitest_coverline("build/charts-base/charts-base.js", 6122);
nextY = ycoords[i];
            _yuitest_coverline("build/charts-base/charts-base.js", 6123);
pointValid = isNumber(nextX) && isNumber(nextY);
            _yuitest_coverline("build/charts-base/charts-base.js", 6124);
if(!pointValid)
            {
                _yuitest_coverline("build/charts-base/charts-base.js", 6126);
lastPointValid = pointValid;
                _yuitest_coverline("build/charts-base/charts-base.js", 6127);
continue;
            }
            _yuitest_coverline("build/charts-base/charts-base.js", 6129);
if(noPointsRendered)
            {
                _yuitest_coverline("build/charts-base/charts-base.js", 6131);
noPointsRendered = false;
                _yuitest_coverline("build/charts-base/charts-base.js", 6132);
path.moveTo(nextX, nextY);
            }
            else {_yuitest_coverline("build/charts-base/charts-base.js", 6134);
if(lastPointValid)
            {
                _yuitest_coverline("build/charts-base/charts-base.js", 6136);
if(lineType != "dashed")
                {
                    _yuitest_coverline("build/charts-base/charts-base.js", 6138);
path.lineTo(nextX, nextY);
                }
                else
                {
                    _yuitest_coverline("build/charts-base/charts-base.js", 6142);
this.drawDashedLine(path, lastValidX, lastValidY, nextX, nextY,
                                                dashLength,
                                                gapSpace);
                }
            }
            else {_yuitest_coverline("build/charts-base/charts-base.js", 6147);
if(!connectDiscontinuousPoints)
            {
                _yuitest_coverline("build/charts-base/charts-base.js", 6149);
path.moveTo(nextX, nextY);
            }
            else
            {
                _yuitest_coverline("build/charts-base/charts-base.js", 6153);
if(discontinuousType != "solid")
                {
                    _yuitest_coverline("build/charts-base/charts-base.js", 6155);
this.drawDashedLine(path, lastValidX, lastValidY, nextX, nextY,
                                                discontinuousDashLength,
                                                discontinuousGapSpace);
                }
                else
                {
                    _yuitest_coverline("build/charts-base/charts-base.js", 6161);
path.lineTo(nextX, nextY);
                }
            }}}
            _yuitest_coverline("build/charts-base/charts-base.js", 6164);
lastValidX = nextX;
            _yuitest_coverline("build/charts-base/charts-base.js", 6165);
lastValidY = nextY;
            _yuitest_coverline("build/charts-base/charts-base.js", 6166);
lastPointValid = true;
        }
        _yuitest_coverline("build/charts-base/charts-base.js", 6168);
path.end();
    },

    /**
     * Connects data points with a consistent curve for a series.
     *
     * @method drawSpline
     * @protected
     */
    drawSpline: function()
    {
        _yuitest_coverfunc("build/charts-base/charts-base.js", "drawSpline", 6177);
_yuitest_coverline("build/charts-base/charts-base.js", 6179);
if(this.get("xcoords").length < 1)
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 6181);
return;
        }
        _yuitest_coverline("build/charts-base/charts-base.js", 6183);
var xcoords = this.get("xcoords"),
            ycoords = this.get("ycoords"),
            curvecoords = this.getCurveControlPoints(xcoords, ycoords),
            len = curvecoords.length,
            cx1,
            cx2,
            cy1,
            cy2,
            x,
            y,
            i = 0,
            styles = this.get("styles").line,
            path = this._getGraphic(),
            lineAlpha = styles.alpha,
            color = styles.color || this._getDefaultColor(this.get("graphOrder"), "line");
        _yuitest_coverline("build/charts-base/charts-base.js", 6198);
path.set("stroke", {
            weight: styles.weight,
            color: color,
            opacity: lineAlpha
        });
        _yuitest_coverline("build/charts-base/charts-base.js", 6203);
path.moveTo(xcoords[0], ycoords[0]);
        _yuitest_coverline("build/charts-base/charts-base.js", 6204);
for(; i < len; i = ++i)
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 6206);
x = curvecoords[i].endx;
            _yuitest_coverline("build/charts-base/charts-base.js", 6207);
y = curvecoords[i].endy;
            _yuitest_coverline("build/charts-base/charts-base.js", 6208);
cx1 = curvecoords[i].ctrlx1;
            _yuitest_coverline("build/charts-base/charts-base.js", 6209);
cx2 = curvecoords[i].ctrlx2;
            _yuitest_coverline("build/charts-base/charts-base.js", 6210);
cy1 = curvecoords[i].ctrly1;
            _yuitest_coverline("build/charts-base/charts-base.js", 6211);
cy2 = curvecoords[i].ctrly2;
            _yuitest_coverline("build/charts-base/charts-base.js", 6212);
path.curveTo(cx1, cy1, cx2, cy2, x, y);
        }
        _yuitest_coverline("build/charts-base/charts-base.js", 6214);
path.end();
    },

    /**
     * Draws a dashed line between two points.
     *
     * @method drawDashedLine
     * @param {Number} xStart	The x position of the start of the line
     * @param {Number} yStart	The y position of the start of the line
     * @param {Number} xEnd		The x position of the end of the line
     * @param {Number} yEnd		The y position of the end of the line
     * @param {Number} dashSize	the size of dashes, in pixels
     * @param {Number} gapSize	the size of gaps between dashes, in pixels
     * @private
     */
    drawDashedLine: function(path, xStart, yStart, xEnd, yEnd, dashSize, gapSize)
    {
        _yuitest_coverfunc("build/charts-base/charts-base.js", "drawDashedLine", 6229);
_yuitest_coverline("build/charts-base/charts-base.js", 6231);
dashSize = dashSize || 10;
        _yuitest_coverline("build/charts-base/charts-base.js", 6232);
gapSize = gapSize || 10;
        _yuitest_coverline("build/charts-base/charts-base.js", 6233);
var segmentLength = dashSize + gapSize,
            xDelta = xEnd - xStart,
            yDelta = yEnd - yStart,
            delta = Math.sqrt(Math.pow(xDelta, 2) + Math.pow(yDelta, 2)),
            segmentCount = Math.floor(Math.abs(delta / segmentLength)),
            radians = Math.atan2(yDelta, xDelta),
            xCurrent = xStart,
            yCurrent = yStart,
            i;
        _yuitest_coverline("build/charts-base/charts-base.js", 6242);
xDelta = Math.cos(radians) * segmentLength;
        _yuitest_coverline("build/charts-base/charts-base.js", 6243);
yDelta = Math.sin(radians) * segmentLength;

        _yuitest_coverline("build/charts-base/charts-base.js", 6245);
for(i = 0; i < segmentCount; ++i)
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 6247);
path.moveTo(xCurrent, yCurrent);
            _yuitest_coverline("build/charts-base/charts-base.js", 6248);
path.lineTo(xCurrent + Math.cos(radians) * dashSize, yCurrent + Math.sin(radians) * dashSize);
            _yuitest_coverline("build/charts-base/charts-base.js", 6249);
xCurrent += xDelta;
            _yuitest_coverline("build/charts-base/charts-base.js", 6250);
yCurrent += yDelta;
        }

        _yuitest_coverline("build/charts-base/charts-base.js", 6253);
path.moveTo(xCurrent, yCurrent);
        _yuitest_coverline("build/charts-base/charts-base.js", 6254);
delta = Math.sqrt((xEnd - xCurrent) * (xEnd - xCurrent) + (yEnd - yCurrent) * (yEnd - yCurrent));

        _yuitest_coverline("build/charts-base/charts-base.js", 6256);
if(delta > dashSize)
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 6258);
path.lineTo(xCurrent + Math.cos(radians) * dashSize, yCurrent + Math.sin(radians) * dashSize);
        }
        else {_yuitest_coverline("build/charts-base/charts-base.js", 6260);
if(delta > 0)
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 6262);
path.lineTo(xCurrent + Math.cos(radians) * delta, yCurrent + Math.sin(radians) * delta);
        }}

        _yuitest_coverline("build/charts-base/charts-base.js", 6265);
path.moveTo(xEnd, yEnd);
    },

    /**
     * Default values for `styles` attribute.
     *
     * @method _getLineDefaults
     * @return Object
     * @protected
     */
    _getLineDefaults: function()
    {
        _yuitest_coverfunc("build/charts-base/charts-base.js", "_getLineDefaults", 6275);
_yuitest_coverline("build/charts-base/charts-base.js", 6277);
return {
            alpha: 1,
            weight: 6,
            lineType:"solid",
            dashLength:10,
            gapSpace:10,
            connectDiscontinuousPoints:true,
            discontinuousType:"solid",
            discontinuousDashLength:10,
            discontinuousGapSpace:10
        };
    }
};
_yuitest_coverline("build/charts-base/charts-base.js", 6290);
Y.augment(Lines, Y.Attribute);
_yuitest_coverline("build/charts-base/charts-base.js", 6291);
Y.Lines = Lines;
/**
 * Utility class used for drawing area fills.
 *
 * @module charts
 * @class Fills
 * @constructor
 */
_yuitest_coverline("build/charts-base/charts-base.js", 6299);
function Fills(cfg)
{
    _yuitest_coverfunc("build/charts-base/charts-base.js", "Fills", 6299);
_yuitest_coverline("build/charts-base/charts-base.js", 6301);
var attrs = {
        area: {
            getter: function()
            {
                _yuitest_coverfunc("build/charts-base/charts-base.js", "getter", 6303);
_yuitest_coverline("build/charts-base/charts-base.js", 6305);
return this._defaults || this._getAreaDefaults();
            },

            setter: function(val)
            {
                _yuitest_coverfunc("build/charts-base/charts-base.js", "setter", 6308);
_yuitest_coverline("build/charts-base/charts-base.js", 6310);
var defaults = this._defaults || this._getAreaDefaults();
                _yuitest_coverline("build/charts-base/charts-base.js", 6311);
this._defaults = Y.merge(defaults, val);
            }
        }
    };
    _yuitest_coverline("build/charts-base/charts-base.js", 6315);
this.addAttrs(attrs, cfg);
    _yuitest_coverline("build/charts-base/charts-base.js", 6316);
this.get("styles");
}

_yuitest_coverline("build/charts-base/charts-base.js", 6319);
Fills.prototype = {
    /**
     * Returns a path shape used for drawing fills.
     *
     * @method _getPath
     * @return Path
     * @private
     */
    _getPath: function()
    {
        _yuitest_coverfunc("build/charts-base/charts-base.js", "_getPath", 6327);
_yuitest_coverline("build/charts-base/charts-base.js", 6329);
var path = this._path;
        _yuitest_coverline("build/charts-base/charts-base.js", 6330);
if(!path)
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 6332);
path = this.get("graph").get("graphic").addShape({type:"path"});
            _yuitest_coverline("build/charts-base/charts-base.js", 6333);
this._path = path;
        }
        _yuitest_coverline("build/charts-base/charts-base.js", 6335);
return path;
    },

    /**
     * Toggles visibility
     *
     * @method _toggleVisible
     * @param {Boolean} visible indicates visibilitye
     * @private
     */
    _toggleVisible: function(visible)
    {
        _yuitest_coverfunc("build/charts-base/charts-base.js", "_toggleVisible", 6345);
_yuitest_coverline("build/charts-base/charts-base.js", 6347);
if(this._path)
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 6349);
this._path.set("visible", visible);
        }
    },

    /**
     * Draws fill
     *
     * @method drawFill
     * @param {Array} xcoords The x-coordinates for the series.
     * @param {Array} ycoords The y-coordinates for the series.
     * @protected
     */
    drawFill: function(xcoords, ycoords)
    {
        _yuitest_coverfunc("build/charts-base/charts-base.js", "drawFill", 6361);
_yuitest_coverline("build/charts-base/charts-base.js", 6363);
if(xcoords.length < 1)
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 6365);
return;
        }
        _yuitest_coverline("build/charts-base/charts-base.js", 6367);
var isNumber = Y_Lang.isNumber,
            len = xcoords.length,
            firstX = xcoords[0],
            firstY = ycoords[0],
            lastValidX = firstX,
            lastValidY = firstY,
            nextX,
            nextY,
            pointValid,
            noPointsRendered = true,
            i = 0,
            styles = this.get("styles").area,
            path = this._getPath(),
            color = styles.color || this._getDefaultColor(this.get("graphOrder"), "slice");
        _yuitest_coverline("build/charts-base/charts-base.js", 6381);
path.clear();
        _yuitest_coverline("build/charts-base/charts-base.js", 6382);
path.set("fill", {
            color: color,
            opacity: styles.alpha
        });
        _yuitest_coverline("build/charts-base/charts-base.js", 6386);
path.set("stroke", {weight: 0});
        _yuitest_coverline("build/charts-base/charts-base.js", 6387);
for(; i < len; i = ++i)
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 6389);
nextX = xcoords[i];
            _yuitest_coverline("build/charts-base/charts-base.js", 6390);
nextY = ycoords[i];
            _yuitest_coverline("build/charts-base/charts-base.js", 6391);
pointValid = isNumber(nextX) && isNumber(nextY);
            _yuitest_coverline("build/charts-base/charts-base.js", 6392);
if(!pointValid)
            {
                _yuitest_coverline("build/charts-base/charts-base.js", 6394);
continue;
            }
            _yuitest_coverline("build/charts-base/charts-base.js", 6396);
if(noPointsRendered)
            {
                _yuitest_coverline("build/charts-base/charts-base.js", 6398);
this._firstValidX = nextX;
                _yuitest_coverline("build/charts-base/charts-base.js", 6399);
this._firstValidY = nextY;
                _yuitest_coverline("build/charts-base/charts-base.js", 6400);
noPointsRendered = false;
                _yuitest_coverline("build/charts-base/charts-base.js", 6401);
path.moveTo(nextX, nextY);
            }
            else
            {
                _yuitest_coverline("build/charts-base/charts-base.js", 6405);
path.lineTo(nextX, nextY);
            }
            _yuitest_coverline("build/charts-base/charts-base.js", 6407);
lastValidX = nextX;
            _yuitest_coverline("build/charts-base/charts-base.js", 6408);
lastValidY = nextY;
        }
        _yuitest_coverline("build/charts-base/charts-base.js", 6410);
this._lastValidX = lastValidX;
        _yuitest_coverline("build/charts-base/charts-base.js", 6411);
this._lastValidY = lastValidY;
        _yuitest_coverline("build/charts-base/charts-base.js", 6412);
path.end();
    },

    /**
     * Draws a fill for a spline
     *
     * @method drawAreaSpline
     * @protected
     */
    drawAreaSpline: function()
    {
        _yuitest_coverfunc("build/charts-base/charts-base.js", "drawAreaSpline", 6421);
_yuitest_coverline("build/charts-base/charts-base.js", 6423);
if(this.get("xcoords").length < 1)
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 6425);
return;
        }
        _yuitest_coverline("build/charts-base/charts-base.js", 6427);
var xcoords = this.get("xcoords"),
            ycoords = this.get("ycoords"),
            curvecoords = this.getCurveControlPoints(xcoords, ycoords),
            len = curvecoords.length,
            cx1,
            cx2,
            cy1,
            cy2,
            x,
            y,
            i = 0,
            firstX = xcoords[0],
            firstY = ycoords[0],
            styles = this.get("styles").area,
            path = this._getPath(),
            color = styles.color || this._getDefaultColor(this.get("graphOrder"), "slice");
        _yuitest_coverline("build/charts-base/charts-base.js", 6443);
path.set("fill", {
            color: color,
            opacity: styles.alpha
        });
        _yuitest_coverline("build/charts-base/charts-base.js", 6447);
path.set("stroke", {weight: 0});
        _yuitest_coverline("build/charts-base/charts-base.js", 6448);
path.moveTo(firstX, firstY);
        _yuitest_coverline("build/charts-base/charts-base.js", 6449);
for(; i < len; i = ++i)
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 6451);
x = curvecoords[i].endx;
            _yuitest_coverline("build/charts-base/charts-base.js", 6452);
y = curvecoords[i].endy;
            _yuitest_coverline("build/charts-base/charts-base.js", 6453);
cx1 = curvecoords[i].ctrlx1;
            _yuitest_coverline("build/charts-base/charts-base.js", 6454);
cx2 = curvecoords[i].ctrlx2;
            _yuitest_coverline("build/charts-base/charts-base.js", 6455);
cy1 = curvecoords[i].ctrly1;
            _yuitest_coverline("build/charts-base/charts-base.js", 6456);
cy2 = curvecoords[i].ctrly2;
            _yuitest_coverline("build/charts-base/charts-base.js", 6457);
path.curveTo(cx1, cy1, cx2, cy2, x, y);
        }
        _yuitest_coverline("build/charts-base/charts-base.js", 6459);
if(this.get("direction") === "vertical")
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 6461);
path.lineTo(this._leftOrigin, y);
            _yuitest_coverline("build/charts-base/charts-base.js", 6462);
path.lineTo(this._leftOrigin, firstY);
        }
        else
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 6466);
path.lineTo(x, this._bottomOrigin);
            _yuitest_coverline("build/charts-base/charts-base.js", 6467);
path.lineTo(firstX, this._bottomOrigin);
        }
        _yuitest_coverline("build/charts-base/charts-base.js", 6469);
path.lineTo(firstX, firstY);
        _yuitest_coverline("build/charts-base/charts-base.js", 6470);
path.end();
    },

    /**
     * Draws a a stacked area spline
     *
     * @method drawStackedAreaSpline
     * @protected
     */
    drawStackedAreaSpline: function()
    {
        _yuitest_coverfunc("build/charts-base/charts-base.js", "drawStackedAreaSpline", 6479);
_yuitest_coverline("build/charts-base/charts-base.js", 6481);
if(this.get("xcoords").length < 1)
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 6483);
return;
        }
        _yuitest_coverline("build/charts-base/charts-base.js", 6485);
var xcoords = this.get("xcoords"),
            ycoords = this.get("ycoords"),
            curvecoords,
            order = this.get("order"),
            type = this.get("type"),
            graph = this.get("graph"),
            seriesCollection = graph.seriesTypes[type],
            prevXCoords,
            prevYCoords,
            len,
            cx1,
            cx2,
            cy1,
            cy2,
            x,
            y,
            i = 0,
            firstX,
            firstY,
            styles = this.get("styles").area,
            path = this._getPath(),
            color = styles.color || this._getDefaultColor(this.get("graphOrder"), "slice");
        _yuitest_coverline("build/charts-base/charts-base.js", 6507);
firstX = xcoords[0];
        _yuitest_coverline("build/charts-base/charts-base.js", 6508);
firstY = ycoords[0];
        _yuitest_coverline("build/charts-base/charts-base.js", 6509);
curvecoords = this.getCurveControlPoints(xcoords, ycoords);
        _yuitest_coverline("build/charts-base/charts-base.js", 6510);
len = curvecoords.length;
        _yuitest_coverline("build/charts-base/charts-base.js", 6511);
path.set("fill", {
            color: color,
            opacity: styles.alpha
        });
        _yuitest_coverline("build/charts-base/charts-base.js", 6515);
path.set("stroke", {weight: 0});
        _yuitest_coverline("build/charts-base/charts-base.js", 6516);
path.moveTo(firstX, firstY);
        _yuitest_coverline("build/charts-base/charts-base.js", 6517);
for(; i < len; i = ++i)
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 6519);
x = curvecoords[i].endx;
            _yuitest_coverline("build/charts-base/charts-base.js", 6520);
y = curvecoords[i].endy;
            _yuitest_coverline("build/charts-base/charts-base.js", 6521);
cx1 = curvecoords[i].ctrlx1;
            _yuitest_coverline("build/charts-base/charts-base.js", 6522);
cx2 = curvecoords[i].ctrlx2;
            _yuitest_coverline("build/charts-base/charts-base.js", 6523);
cy1 = curvecoords[i].ctrly1;
            _yuitest_coverline("build/charts-base/charts-base.js", 6524);
cy2 = curvecoords[i].ctrly2;
            _yuitest_coverline("build/charts-base/charts-base.js", 6525);
path.curveTo(cx1, cy1, cx2, cy2, x, y);
        }
        _yuitest_coverline("build/charts-base/charts-base.js", 6527);
if(order > 0)
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 6529);
prevXCoords = seriesCollection[order - 1].get("xcoords").concat().reverse();
            _yuitest_coverline("build/charts-base/charts-base.js", 6530);
prevYCoords = seriesCollection[order - 1].get("ycoords").concat().reverse();
            _yuitest_coverline("build/charts-base/charts-base.js", 6531);
curvecoords = this.getCurveControlPoints(prevXCoords, prevYCoords);
            _yuitest_coverline("build/charts-base/charts-base.js", 6532);
i = 0;
            _yuitest_coverline("build/charts-base/charts-base.js", 6533);
len = curvecoords.length;
            _yuitest_coverline("build/charts-base/charts-base.js", 6534);
path.lineTo(prevXCoords[0], prevYCoords[0]);
            _yuitest_coverline("build/charts-base/charts-base.js", 6535);
for(; i < len; i = ++i)
            {
                _yuitest_coverline("build/charts-base/charts-base.js", 6537);
x = curvecoords[i].endx;
                _yuitest_coverline("build/charts-base/charts-base.js", 6538);
y = curvecoords[i].endy;
                _yuitest_coverline("build/charts-base/charts-base.js", 6539);
cx1 = curvecoords[i].ctrlx1;
                _yuitest_coverline("build/charts-base/charts-base.js", 6540);
cx2 = curvecoords[i].ctrlx2;
                _yuitest_coverline("build/charts-base/charts-base.js", 6541);
cy1 = curvecoords[i].ctrly1;
                _yuitest_coverline("build/charts-base/charts-base.js", 6542);
cy2 = curvecoords[i].ctrly2;
                _yuitest_coverline("build/charts-base/charts-base.js", 6543);
path.curveTo(cx1, cy1, cx2, cy2, x, y);
            }
        }
        else
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 6548);
if(this.get("direction") === "vertical")
            {
                _yuitest_coverline("build/charts-base/charts-base.js", 6550);
path.lineTo(this._leftOrigin, ycoords[ycoords.length-1]);
                _yuitest_coverline("build/charts-base/charts-base.js", 6551);
path.lineTo(this._leftOrigin, firstY);
            }
            else
            {
                _yuitest_coverline("build/charts-base/charts-base.js", 6555);
path.lineTo(xcoords[xcoords.length-1], this._bottomOrigin);
                _yuitest_coverline("build/charts-base/charts-base.js", 6556);
path.lineTo(firstX, this._bottomOrigin);
            }

        }
        _yuitest_coverline("build/charts-base/charts-base.js", 6560);
path.lineTo(firstX, firstY);
        _yuitest_coverline("build/charts-base/charts-base.js", 6561);
path.end();
    },

    /**
     * Storage for default area styles.
     *
     * @property _defaults
     * @type Object
     * @private
     */
    _defaults: null,

    /**
     * Concatenates coordinate array with correct coordinates for closing an area fill.
     *
     * @method _getClosingPoints
     * @return Array
     * @protected
     */
    _getClosingPoints: function()
    {
        _yuitest_coverfunc("build/charts-base/charts-base.js", "_getClosingPoints", 6580);
_yuitest_coverline("build/charts-base/charts-base.js", 6582);
var xcoords = this.get("xcoords").concat(),
            ycoords = this.get("ycoords").concat(),
            firstValidIndex,
            lastValidIndex;
        _yuitest_coverline("build/charts-base/charts-base.js", 6586);
if(this.get("direction") === "vertical")
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 6588);
lastValidIndex = this._getLastValidIndex(xcoords);
            _yuitest_coverline("build/charts-base/charts-base.js", 6589);
firstValidIndex = this._getFirstValidIndex(xcoords);
            _yuitest_coverline("build/charts-base/charts-base.js", 6590);
ycoords.push(ycoords[lastValidIndex]);
            _yuitest_coverline("build/charts-base/charts-base.js", 6591);
ycoords.push(ycoords[firstValidIndex]);
            _yuitest_coverline("build/charts-base/charts-base.js", 6592);
xcoords.push(this._leftOrigin);
            _yuitest_coverline("build/charts-base/charts-base.js", 6593);
xcoords.push(this._leftOrigin);
        }
        else
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 6597);
lastValidIndex = this._getLastValidIndex(ycoords);
            _yuitest_coverline("build/charts-base/charts-base.js", 6598);
firstValidIndex = this._getFirstValidIndex(ycoords);
            _yuitest_coverline("build/charts-base/charts-base.js", 6599);
xcoords.push(xcoords[lastValidIndex]);
            _yuitest_coverline("build/charts-base/charts-base.js", 6600);
xcoords.push(xcoords[firstValidIndex]);
            _yuitest_coverline("build/charts-base/charts-base.js", 6601);
ycoords.push(this._bottomOrigin);
            _yuitest_coverline("build/charts-base/charts-base.js", 6602);
ycoords.push(this._bottomOrigin);
        }
        _yuitest_coverline("build/charts-base/charts-base.js", 6604);
xcoords.push(xcoords[0]);
        _yuitest_coverline("build/charts-base/charts-base.js", 6605);
ycoords.push(ycoords[0]);
        _yuitest_coverline("build/charts-base/charts-base.js", 6606);
return [xcoords, ycoords];
    },

    /**
     * Returns the order of the series closest to the current series that has a valid value for the current index.
     *
     * @method _getHighestValidOrder
     * @param {Array} seriesCollection Array of series of a given type.
     * @param {Number} index Index of the series item.
     * @param {Number} order Index of the the series in the seriesCollection
     * @param {String} direction Indicates the direction of the series
     * @return Number
     * @private
     */
    _getHighestValidOrder: function(seriesCollection, index, order, direction)
    {
        _yuitest_coverfunc("build/charts-base/charts-base.js", "_getHighestValidOrder", 6620);
_yuitest_coverline("build/charts-base/charts-base.js", 6622);
var coords = direction == "vertical" ? "stackedXCoords" : "stackedYCoords",
            coord;
        _yuitest_coverline("build/charts-base/charts-base.js", 6624);
while(isNaN(coord) && order > -1)
        {
          _yuitest_coverline("build/charts-base/charts-base.js", 6626);
order = order - 1;
          _yuitest_coverline("build/charts-base/charts-base.js", 6627);
if(order > -1)
          {
            _yuitest_coverline("build/charts-base/charts-base.js", 6629);
coord = seriesCollection[order].get(coords)[index];
          }
        }
        _yuitest_coverline("build/charts-base/charts-base.js", 6632);
return order;
    },

    /**
     * Returns an array containing the x and y coordinates for a given series and index.
     *
     * @method _getCoordsByOrderAndIndex
     * @param {Array} seriesCollection Array of series of a given type.
     * @param {Number} index Index of the series item.
     * @param {Number} order Index of the the series in the seriesCollection
     * @param {String} direction Indicates the direction of the series
     * @return Array
     * @private
     */
    _getCoordsByOrderAndIndex: function(seriesCollection, index, order, direction)
    {
        _yuitest_coverfunc("build/charts-base/charts-base.js", "_getCoordsByOrderAndIndex", 6646);
_yuitest_coverline("build/charts-base/charts-base.js", 6648);
var xcoord,
            ycoord;
        _yuitest_coverline("build/charts-base/charts-base.js", 6650);
if(direction == "vertical")
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 6652);
xcoord = order < 0 ? this._leftOrigin : seriesCollection[order].get("stackedXCoords")[index];
            _yuitest_coverline("build/charts-base/charts-base.js", 6653);
ycoord = this.get("stackedYCoords")[index];
        }
        else
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 6657);
xcoord = this.get("stackedXCoords")[index];
            _yuitest_coverline("build/charts-base/charts-base.js", 6658);
ycoord = order < 0 ? this._bottomOrigin : seriesCollection[order].get("stackedYCoords")[index];
        }
        _yuitest_coverline("build/charts-base/charts-base.js", 6660);
return [xcoord, ycoord];
    },

    /**
     * Concatenates coordinate array with the correct coordinates for closing an area stack.
     *
     * @method _getStackedClosingPoints
     * @return Array
     * @protected
     */
    _getStackedClosingPoints: function()
    {
        _yuitest_coverfunc("build/charts-base/charts-base.js", "_getStackedClosingPoints", 6670);
_yuitest_coverline("build/charts-base/charts-base.js", 6672);
var order = this.get("order"),
            type = this.get("type"),
            graph = this.get("graph"),
            direction = this.get("direction"),
            seriesCollection = graph.seriesTypes[type],
            firstValidIndex,
            lastValidIndex,
            xcoords = this.get("stackedXCoords"),
            ycoords = this.get("stackedYCoords"),
            limit,
            previousSeries,
            previousSeriesFirstValidIndex,
            previousSeriesLastValidIndex,
            previousXCoords,
            previousYCoords,
            coords,
            closingXCoords,
            closingYCoords,
            currentIndex,
            highestValidOrder,
            oldOrder;
        _yuitest_coverline("build/charts-base/charts-base.js", 6693);
if(order < 1)
        {
          _yuitest_coverline("build/charts-base/charts-base.js", 6695);
return this._getClosingPoints();
        }

        _yuitest_coverline("build/charts-base/charts-base.js", 6698);
previousSeries = seriesCollection[order - 1];
        _yuitest_coverline("build/charts-base/charts-base.js", 6699);
previousXCoords = previousSeries.get("stackedXCoords").concat();
        _yuitest_coverline("build/charts-base/charts-base.js", 6700);
previousYCoords = previousSeries.get("stackedYCoords").concat();
        _yuitest_coverline("build/charts-base/charts-base.js", 6701);
if(direction == "vertical")
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 6703);
firstValidIndex = this._getFirstValidIndex(xcoords);
            _yuitest_coverline("build/charts-base/charts-base.js", 6704);
lastValidIndex = this._getLastValidIndex(xcoords);
            _yuitest_coverline("build/charts-base/charts-base.js", 6705);
previousSeriesFirstValidIndex = previousSeries._getFirstValidIndex(previousXCoords);
            _yuitest_coverline("build/charts-base/charts-base.js", 6706);
previousSeriesLastValidIndex = previousSeries._getLastValidIndex(previousXCoords);
        }
        else
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 6710);
firstValidIndex = this._getFirstValidIndex(ycoords);
            _yuitest_coverline("build/charts-base/charts-base.js", 6711);
lastValidIndex = this._getLastValidIndex(ycoords);
            _yuitest_coverline("build/charts-base/charts-base.js", 6712);
previousSeriesFirstValidIndex = previousSeries._getFirstValidIndex(previousYCoords);
            _yuitest_coverline("build/charts-base/charts-base.js", 6713);
previousSeriesLastValidIndex = previousSeries._getLastValidIndex(previousYCoords);
        }
        _yuitest_coverline("build/charts-base/charts-base.js", 6715);
if(previousSeriesLastValidIndex >= firstValidIndex && previousSeriesFirstValidIndex <= lastValidIndex)
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 6717);
previousSeriesFirstValidIndex = Math.max(firstValidIndex, previousSeriesFirstValidIndex);
            _yuitest_coverline("build/charts-base/charts-base.js", 6718);
previousSeriesLastValidIndex = Math.min(lastValidIndex, previousSeriesLastValidIndex);
            _yuitest_coverline("build/charts-base/charts-base.js", 6719);
previousXCoords = previousXCoords.slice(previousSeriesFirstValidIndex, previousSeriesLastValidIndex + 1);
            _yuitest_coverline("build/charts-base/charts-base.js", 6720);
previousYCoords = previousYCoords.slice(previousSeriesFirstValidIndex, previousSeriesLastValidIndex + 1);
            _yuitest_coverline("build/charts-base/charts-base.js", 6721);
limit = previousSeriesFirstValidIndex;
        }
        else
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 6725);
limit = lastValidIndex;
        }

        _yuitest_coverline("build/charts-base/charts-base.js", 6728);
closingXCoords = [xcoords[firstValidIndex]];
        _yuitest_coverline("build/charts-base/charts-base.js", 6729);
closingYCoords = [ycoords[firstValidIndex]];
        _yuitest_coverline("build/charts-base/charts-base.js", 6730);
currentIndex = firstValidIndex;
        _yuitest_coverline("build/charts-base/charts-base.js", 6731);
while((isNaN(highestValidOrder) || highestValidOrder < order - 1) && currentIndex <= limit)
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 6733);
oldOrder = highestValidOrder;
            _yuitest_coverline("build/charts-base/charts-base.js", 6734);
highestValidOrder = this._getHighestValidOrder(seriesCollection, currentIndex, order, direction);
            _yuitest_coverline("build/charts-base/charts-base.js", 6735);
if(!isNaN(oldOrder) && highestValidOrder > oldOrder)
            {
                _yuitest_coverline("build/charts-base/charts-base.js", 6737);
coords = this._getCoordsByOrderAndIndex(seriesCollection, currentIndex, oldOrder, direction);
                _yuitest_coverline("build/charts-base/charts-base.js", 6738);
closingXCoords.push(coords[0]);
                _yuitest_coverline("build/charts-base/charts-base.js", 6739);
closingYCoords.push(coords[1]);
            }
            _yuitest_coverline("build/charts-base/charts-base.js", 6741);
coords = this._getCoordsByOrderAndIndex(seriesCollection, currentIndex, highestValidOrder, direction);
            _yuitest_coverline("build/charts-base/charts-base.js", 6742);
closingXCoords.push(coords[0]);
            _yuitest_coverline("build/charts-base/charts-base.js", 6743);
closingYCoords.push(coords[1]);
            _yuitest_coverline("build/charts-base/charts-base.js", 6744);
currentIndex = currentIndex + 1;
        }
        _yuitest_coverline("build/charts-base/charts-base.js", 6746);
if(previousXCoords && previousXCoords.length > 0 && previousSeriesLastValidIndex > firstValidIndex && previousSeriesFirstValidIndex < lastValidIndex)
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 6748);
closingXCoords = closingXCoords.concat(previousXCoords);
            _yuitest_coverline("build/charts-base/charts-base.js", 6749);
closingYCoords = closingYCoords.concat(previousYCoords);
            _yuitest_coverline("build/charts-base/charts-base.js", 6750);
highestValidOrder = order -1;
        }
        _yuitest_coverline("build/charts-base/charts-base.js", 6752);
currentIndex = Math.max(firstValidIndex, previousSeriesLastValidIndex);
        _yuitest_coverline("build/charts-base/charts-base.js", 6753);
order = order - 1;
        _yuitest_coverline("build/charts-base/charts-base.js", 6754);
highestValidOrder = NaN;
        _yuitest_coverline("build/charts-base/charts-base.js", 6755);
while(currentIndex <= lastValidIndex)
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 6757);
oldOrder = highestValidOrder;
            _yuitest_coverline("build/charts-base/charts-base.js", 6758);
highestValidOrder = this._getHighestValidOrder(seriesCollection, currentIndex, order, direction);
            _yuitest_coverline("build/charts-base/charts-base.js", 6759);
if(!isNaN(oldOrder))
            {
                _yuitest_coverline("build/charts-base/charts-base.js", 6761);
if(highestValidOrder > oldOrder)
                {
                    _yuitest_coverline("build/charts-base/charts-base.js", 6763);
coords = this._getCoordsByOrderAndIndex(seriesCollection, currentIndex, oldOrder, direction);
                    _yuitest_coverline("build/charts-base/charts-base.js", 6764);
closingXCoords.push(coords[0]);
                    _yuitest_coverline("build/charts-base/charts-base.js", 6765);
closingYCoords.push(coords[1]);
                }
                else {_yuitest_coverline("build/charts-base/charts-base.js", 6767);
if(highestValidOrder < oldOrder)
                {
                    _yuitest_coverline("build/charts-base/charts-base.js", 6769);
coords = this._getCoordsByOrderAndIndex(seriesCollection, currentIndex - 1, highestValidOrder, direction);
                    _yuitest_coverline("build/charts-base/charts-base.js", 6770);
closingXCoords.push(coords[0]);
                    _yuitest_coverline("build/charts-base/charts-base.js", 6771);
closingYCoords.push(coords[1]);
                }}
            }
            _yuitest_coverline("build/charts-base/charts-base.js", 6774);
coords = this._getCoordsByOrderAndIndex(seriesCollection, currentIndex, highestValidOrder, direction);
            _yuitest_coverline("build/charts-base/charts-base.js", 6775);
closingXCoords.push(coords[0]);
            _yuitest_coverline("build/charts-base/charts-base.js", 6776);
closingYCoords.push(coords[1]);
            _yuitest_coverline("build/charts-base/charts-base.js", 6777);
currentIndex = currentIndex + 1;
        }

        _yuitest_coverline("build/charts-base/charts-base.js", 6780);
closingXCoords.reverse();
        _yuitest_coverline("build/charts-base/charts-base.js", 6781);
closingYCoords.reverse();
        _yuitest_coverline("build/charts-base/charts-base.js", 6782);
return [xcoords.concat(closingXCoords), ycoords.concat(closingYCoords)];
    },

    /**
     * Returns default values for area styles.
     *
     * @method _getAreaDefaults
     * @return Object
     * @private
     */
    _getAreaDefaults: function()
    {
        _yuitest_coverfunc("build/charts-base/charts-base.js", "_getAreaDefaults", 6792);
_yuitest_coverline("build/charts-base/charts-base.js", 6794);
return {
        };
    }
};
_yuitest_coverline("build/charts-base/charts-base.js", 6798);
Y.augment(Fills, Y.Attribute);
_yuitest_coverline("build/charts-base/charts-base.js", 6799);
Y.Fills = Fills;
/**
 * Utility class used for drawing markers.
 *
 * @module charts
 * @submodule charts-base
 * @class Plots
 * @constructor
 */
_yuitest_coverline("build/charts-base/charts-base.js", 6808);
function Plots(cfg)
{
    _yuitest_coverfunc("build/charts-base/charts-base.js", "Plots", 6808);
_yuitest_coverline("build/charts-base/charts-base.js", 6810);
var attrs = {
        markers: {
            getter: function()
            {
                _yuitest_coverfunc("build/charts-base/charts-base.js", "getter", 6812);
_yuitest_coverline("build/charts-base/charts-base.js", 6814);
return this._markers;
            }
        }
    };
    _yuitest_coverline("build/charts-base/charts-base.js", 6818);
this.addAttrs(attrs, cfg);
}

_yuitest_coverline("build/charts-base/charts-base.js", 6821);
Plots.prototype = {
    /**
     * Storage for default marker styles.
     *
     * @property _plotDefaults
     * @type Object
     * @private
     */
    _plotDefaults: null,

    /**
     * Draws the markers
     *
     * @method drawPlots
     * @protected
     */
    drawPlots: function()
    {
        _yuitest_coverfunc("build/charts-base/charts-base.js", "drawPlots", 6837);
_yuitest_coverline("build/charts-base/charts-base.js", 6839);
if(!this.get("xcoords") || this.get("xcoords").length < 1)
		{
			_yuitest_coverline("build/charts-base/charts-base.js", 6841);
return;
		}
        _yuitest_coverline("build/charts-base/charts-base.js", 6843);
var isNumber = Y_Lang.isNumber,
            style = Y.clone(this.get("styles").marker),
            w = style.width,
            h = style.height,
            xcoords = this.get("xcoords"),
            ycoords = this.get("ycoords"),
            i = 0,
            len = xcoords.length,
            top = ycoords[0],
            left,
            marker,
            offsetWidth = w/2,
            offsetHeight = h/2,
            xvalues,
            yvalues,
            fillColors = null,
            borderColors = null,
            graphOrder = this.get("graphOrder"),
            groupMarkers = this.get("groupMarkers");
        _yuitest_coverline("build/charts-base/charts-base.js", 6862);
if(groupMarkers)
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 6864);
xvalues = [];
            _yuitest_coverline("build/charts-base/charts-base.js", 6865);
yvalues = [];
            _yuitest_coverline("build/charts-base/charts-base.js", 6866);
for(; i < len; ++i)
            {
                _yuitest_coverline("build/charts-base/charts-base.js", 6868);
xvalues.push(parseFloat(xcoords[i] - offsetWidth));
                _yuitest_coverline("build/charts-base/charts-base.js", 6869);
yvalues.push(parseFloat(ycoords[i] - offsetHeight));
            }
            _yuitest_coverline("build/charts-base/charts-base.js", 6871);
this._createGroupMarker({
                xvalues: xvalues,
                yvalues: yvalues,
                fill: style.fill,
                border: style.border,
                dimensions: {
                    width: w,
                    height: h
                },
                graphOrder: graphOrder,
                shape: style.shape
            });
            _yuitest_coverline("build/charts-base/charts-base.js", 6883);
return;
        }
        _yuitest_coverline("build/charts-base/charts-base.js", 6885);
if(Y_Lang.isArray(style.fill.color))
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 6887);
fillColors = style.fill.color.concat();
        }
        _yuitest_coverline("build/charts-base/charts-base.js", 6889);
if(Y_Lang.isArray(style.border.color))
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 6891);
borderColors = style.border.color.concat();
        }
        _yuitest_coverline("build/charts-base/charts-base.js", 6893);
this._createMarkerCache();
        _yuitest_coverline("build/charts-base/charts-base.js", 6894);
for(; i < len; ++i)
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 6896);
top = parseFloat(ycoords[i] - offsetHeight);
            _yuitest_coverline("build/charts-base/charts-base.js", 6897);
left = parseFloat(xcoords[i] - offsetWidth);
            _yuitest_coverline("build/charts-base/charts-base.js", 6898);
if(!isNumber(left) || !isNumber(top))
            {
                _yuitest_coverline("build/charts-base/charts-base.js", 6900);
this._markers.push(null);
                _yuitest_coverline("build/charts-base/charts-base.js", 6901);
continue;
            }
            _yuitest_coverline("build/charts-base/charts-base.js", 6903);
if(fillColors)
            {
                _yuitest_coverline("build/charts-base/charts-base.js", 6905);
style.fill.color = fillColors[i % fillColors.length];
            }
            _yuitest_coverline("build/charts-base/charts-base.js", 6907);
if(borderColors)
            {
                _yuitest_coverline("build/charts-base/charts-base.js", 6909);
style.border.color = borderColors[i % borderColors.length];
            }

            _yuitest_coverline("build/charts-base/charts-base.js", 6912);
style.x = left;
            _yuitest_coverline("build/charts-base/charts-base.js", 6913);
style.y = top;
            _yuitest_coverline("build/charts-base/charts-base.js", 6914);
marker = this.getMarker(style, graphOrder, i);
        }
        _yuitest_coverline("build/charts-base/charts-base.js", 6916);
this._clearMarkerCache();
    },

    /**
     * Pre-defined group shapes.
     *
     * @property _groupShapes
     * @private
     */
    _groupShapes: {
        circle: Y.CircleGroup,
        rect: Y.RectGroup,
        ellipse: Y.EllipseGroup,
        diamond: Y.DiamondGroup
    },

    /**
     * Returns the correct group shape class.
     *
     * @method _getGroupShape
     * @param {Shape | String} shape Indicates which shape class.
     * @return Function
     * @protected
     */
    _getGroupShape: function(shape)
    {
        _yuitest_coverfunc("build/charts-base/charts-base.js", "_getGroupShape", 6940);
_yuitest_coverline("build/charts-base/charts-base.js", 6942);
if(Y_Lang.isString(shape))
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 6944);
shape = this._groupShapes[shape];
        }
        _yuitest_coverline("build/charts-base/charts-base.js", 6946);
return shape;
    },

    /**
     * Gets the default values for series that use the utility. This method is used by
     * the class' `styles` attribute's getter to get build default values.
     *
     * @method _getPlotDefaults
     * @return Object
     * @protected
     */
    _getPlotDefaults: function()
    {
        _yuitest_coverfunc("build/charts-base/charts-base.js", "_getPlotDefaults", 6957);
_yuitest_coverline("build/charts-base/charts-base.js", 6959);
var defs = {
            fill:{
                type: "solid",
                alpha: 1,
                colors:null,
                alphas: null,
                ratios: null
            },
            border:{
                weight: 1,
                alpha: 1
            },
            width: 10,
            height: 10,
            shape: "circle"
        };
        _yuitest_coverline("build/charts-base/charts-base.js", 6975);
defs.fill.color = this._getDefaultColor(this.get("graphOrder"), "fill");
        _yuitest_coverline("build/charts-base/charts-base.js", 6976);
defs.border.color = this._getDefaultColor(this.get("graphOrder"), "border");
        _yuitest_coverline("build/charts-base/charts-base.js", 6977);
return defs;
    },

    /**
     * Collection of markers to be used in the series.
     *
     * @property _markers
     * @type Array
     * @private
     */
    _markers: null,

    /**
     * Collection of markers to be re-used on a series redraw.
     *
     * @property _markerCache
     * @type Array
     * @private
     */
    _markerCache: null,

    /**
     * Gets and styles a marker. If there is a marker in cache, it will use it. Otherwise
     * it will create one.
     *
     * @method getMarker
     * @param {Object} styles Hash of style properties.
     * @param {Number} order Order of the series.
     * @param {Number} index Index within the series associated with the marker.
     * @return Shape
     * @protected
     */
    getMarker: function(styles, order, index)
    {
        _yuitest_coverfunc("build/charts-base/charts-base.js", "getMarker", 7009);
_yuitest_coverline("build/charts-base/charts-base.js", 7011);
var marker,
            border = styles.border;
        _yuitest_coverline("build/charts-base/charts-base.js", 7013);
styles.id = this.get("chart").get("id") + "_" + order + "_" + index;
        //fix name differences between graphic layer
        _yuitest_coverline("build/charts-base/charts-base.js", 7015);
border.opacity = border.alpha;
        _yuitest_coverline("build/charts-base/charts-base.js", 7016);
styles.stroke = border;
        _yuitest_coverline("build/charts-base/charts-base.js", 7017);
styles.fill.opacity = styles.fill.alpha;
        _yuitest_coverline("build/charts-base/charts-base.js", 7018);
if(this._markerCache.length > 0)
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 7020);
while(!marker)
            {
                _yuitest_coverline("build/charts-base/charts-base.js", 7022);
if(this._markerCache.length < 1)
                {
                    _yuitest_coverline("build/charts-base/charts-base.js", 7024);
marker = this._createMarker(styles, order, index);
                    _yuitest_coverline("build/charts-base/charts-base.js", 7025);
break;
                }
                _yuitest_coverline("build/charts-base/charts-base.js", 7027);
marker = this._markerCache.shift();

            }
            _yuitest_coverline("build/charts-base/charts-base.js", 7030);
marker.set(styles);
        }
        else
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 7034);
marker = this._createMarker(styles, order, index);
        }
        _yuitest_coverline("build/charts-base/charts-base.js", 7036);
this._markers.push(marker);
        _yuitest_coverline("build/charts-base/charts-base.js", 7037);
return marker;
    },

    /**
     * Creates a shape to be used as a marker.
     *
     * @method _createMarker
     * @param {Object} styles Hash of style properties.
     * @param {Number} order Order of the series.
     * @param {Number} index Index within the series associated with the marker.
     * @return Shape
     * @private
     */
    _createMarker: function(styles, order, index)
    {
        _yuitest_coverfunc("build/charts-base/charts-base.js", "_createMarker", 7050);
_yuitest_coverline("build/charts-base/charts-base.js", 7052);
var graphic = this.get("graphic"),
            marker,
            cfg = Y.clone(styles);
        _yuitest_coverline("build/charts-base/charts-base.js", 7055);
graphic.set("autoDraw", false);
        _yuitest_coverline("build/charts-base/charts-base.js", 7056);
cfg.type = cfg.shape;
        _yuitest_coverline("build/charts-base/charts-base.js", 7057);
marker = graphic.addShape(cfg);
        _yuitest_coverline("build/charts-base/charts-base.js", 7058);
marker.addClass(SERIES_MARKER);
        _yuitest_coverline("build/charts-base/charts-base.js", 7059);
return marker;
    },

    /**
     * Creates a cache of markers for reuse.
     *
     * @method _createMarkerCache
     * @private
     */
    _createMarkerCache: function()
    {
        _yuitest_coverfunc("build/charts-base/charts-base.js", "_createMarkerCache", 7068);
_yuitest_coverline("build/charts-base/charts-base.js", 7070);
if(this._groupMarker)
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 7072);
this._groupMarker.destroy();
            _yuitest_coverline("build/charts-base/charts-base.js", 7073);
this._groupMarker = null;
        }
        _yuitest_coverline("build/charts-base/charts-base.js", 7075);
if(this._markers && this._markers.length > 0)
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 7077);
this._markerCache = this._markers.concat();
        }
        else
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 7081);
this._markerCache = [];
        }
        _yuitest_coverline("build/charts-base/charts-base.js", 7083);
this._markers = [];
    },

    /**
     * Draws a series of markers in a single shape instance.
     *
     * @method _createGroupMarkers
     * @param {Object} styles Set of configuration properties used to create the markers.
     * @protected
     */
    _createGroupMarker: function(styles)
    {
        _yuitest_coverfunc("build/charts-base/charts-base.js", "_createGroupMarker", 7093);
_yuitest_coverline("build/charts-base/charts-base.js", 7095);
var marker,
            markers = this.get("markers"),
            border = styles.border,
            graphic,
            cfg,
            shape;
        _yuitest_coverline("build/charts-base/charts-base.js", 7101);
if(markers && markers.length > 0)
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 7103);
while(markers.length > 0)
            {
                _yuitest_coverline("build/charts-base/charts-base.js", 7105);
marker = markers.shift();
                _yuitest_coverline("build/charts-base/charts-base.js", 7106);
marker.destroy();
            }
            _yuitest_coverline("build/charts-base/charts-base.js", 7108);
this.set("markers", []);
        }
        //fix name differences between graphic layer
        _yuitest_coverline("build/charts-base/charts-base.js", 7111);
border.opacity = border.alpha;
        _yuitest_coverline("build/charts-base/charts-base.js", 7112);
cfg = {
            id: this.get("chart").get("id") + "_" + styles.graphOrder,
            stroke: border,
            fill: styles.fill,
            dimensions: styles.dimensions,
            xvalues: styles.xvalues,
            yvalues: styles.yvalues
        };
        _yuitest_coverline("build/charts-base/charts-base.js", 7120);
cfg.fill.opacity = styles.fill.alpha;
        _yuitest_coverline("build/charts-base/charts-base.js", 7121);
shape = this._getGroupShape(styles.shape);
        _yuitest_coverline("build/charts-base/charts-base.js", 7122);
if(shape)
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 7124);
cfg.type = shape;
        }
        _yuitest_coverline("build/charts-base/charts-base.js", 7126);
if(styles.hasOwnProperty("radius") && !isNaN(styles.radius))
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 7128);
cfg.dimensions.radius = styles.radius;
        }
        _yuitest_coverline("build/charts-base/charts-base.js", 7130);
if(this._groupMarker)
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 7132);
this._groupMarker.destroy();
        }
        _yuitest_coverline("build/charts-base/charts-base.js", 7134);
graphic = this.get("graphic");
        _yuitest_coverline("build/charts-base/charts-base.js", 7135);
this._groupMarker = graphic.addShape(cfg);
        _yuitest_coverline("build/charts-base/charts-base.js", 7136);
graphic._redraw();
    },

    /**
     * Toggles visibility
     *
     * @method _toggleVisible
     * @param {Boolean} visible indicates visibilitye
     * @private
     */
    _toggleVisible: function(visible)
    {
        _yuitest_coverfunc("build/charts-base/charts-base.js", "_toggleVisible", 7146);
_yuitest_coverline("build/charts-base/charts-base.js", 7148);
var marker,
            markers = this.get("markers"),
            i = 0,
            len;
        _yuitest_coverline("build/charts-base/charts-base.js", 7152);
if(markers)
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 7154);
len = markers.length;
            _yuitest_coverline("build/charts-base/charts-base.js", 7155);
for(; i < len; ++i)
            {
                _yuitest_coverline("build/charts-base/charts-base.js", 7157);
marker = markers[i];
                _yuitest_coverline("build/charts-base/charts-base.js", 7158);
if(marker)
                {
                    _yuitest_coverline("build/charts-base/charts-base.js", 7160);
marker.set("visible", visible);
                }
            }
        }
    },

    /**
     * Removes unused markers from the marker cache
     *
     * @method _clearMarkerCache
     * @private
     */
    _clearMarkerCache: function()
    {
        _yuitest_coverfunc("build/charts-base/charts-base.js", "_clearMarkerCache", 7172);
_yuitest_coverline("build/charts-base/charts-base.js", 7174);
var marker;
        _yuitest_coverline("build/charts-base/charts-base.js", 7175);
while(this._markerCache.length > 0)
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 7177);
marker = this._markerCache.shift();
            _yuitest_coverline("build/charts-base/charts-base.js", 7178);
if(marker)
            {
                _yuitest_coverline("build/charts-base/charts-base.js", 7180);
marker.destroy();
            }
        }
    },

    /**
     * Resizes and positions markers based on a mouse interaction.
     *
     * @method updateMarkerState
     * @param {String} type state of the marker
     * @param {Number} i index of the marker
     * @protected
     */
    updateMarkerState: function(type, i)
    {
        _yuitest_coverfunc("build/charts-base/charts-base.js", "updateMarkerState", 7193);
_yuitest_coverline("build/charts-base/charts-base.js", 7195);
if(this._markers && this._markers[i])
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 7197);
var w,
                h,
                styles = Y.clone(this.get("styles").marker),
                state = this._getState(type),
                xcoords = this.get("xcoords"),
                ycoords = this.get("ycoords"),
                marker = this._markers[i],
                markerStyles = state == "off" || !styles[state] ? styles : styles[state];
                _yuitest_coverline("build/charts-base/charts-base.js", 7205);
markerStyles.fill.color = this._getItemColor(markerStyles.fill.color, i);
                _yuitest_coverline("build/charts-base/charts-base.js", 7206);
markerStyles.border.color = this._getItemColor(markerStyles.border.color, i);
                _yuitest_coverline("build/charts-base/charts-base.js", 7207);
markerStyles.stroke = markerStyles.border;
                _yuitest_coverline("build/charts-base/charts-base.js", 7208);
marker.set(markerStyles);
                _yuitest_coverline("build/charts-base/charts-base.js", 7209);
w = markerStyles.width;
                _yuitest_coverline("build/charts-base/charts-base.js", 7210);
h = markerStyles.height;
                _yuitest_coverline("build/charts-base/charts-base.js", 7211);
marker.set("x", (xcoords[i] - w/2));
                _yuitest_coverline("build/charts-base/charts-base.js", 7212);
marker.set("y",  (ycoords[i] - h/2));
                _yuitest_coverline("build/charts-base/charts-base.js", 7213);
marker.set("visible", this.get("visible"));
        }
    },

    /**
     * Parses a color from an array.
     *
     * @method _getItemColor
     * @param {Array} val collection of colors
     * @param {Number} i index of the item
     * @return String
     * @protected
     */
    _getItemColor: function(val, i)
    {
        _yuitest_coverfunc("build/charts-base/charts-base.js", "_getItemColor", 7226);
_yuitest_coverline("build/charts-base/charts-base.js", 7228);
if(Y_Lang.isArray(val))
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 7230);
return val[i % val.length];
        }
        _yuitest_coverline("build/charts-base/charts-base.js", 7232);
return val;
    },

    /**
     * Method used by `styles` setter. Overrides base implementation.
     *
     * @method _setStyles
     * @param {Object} newStyles Hash of properties to update.
     * @return Object
     * @protected
     */
    _setStyles: function(val)
    {
        _yuitest_coverfunc("build/charts-base/charts-base.js", "_setStyles", 7243);
_yuitest_coverline("build/charts-base/charts-base.js", 7245);
val = this._parseMarkerStyles(val);
        _yuitest_coverline("build/charts-base/charts-base.js", 7246);
return Y.Renderer.prototype._setStyles.apply(this, [val]);
    },

    /**
     * Combines new styles with existing styles.
     *
     * @method _parseMarkerStyles
     * @param {Object} Object containing style properties for the marker.
     * @return Object
     * @private
     */
    _parseMarkerStyles: function(val)
    {
        _yuitest_coverfunc("build/charts-base/charts-base.js", "_parseMarkerStyles", 7257);
_yuitest_coverline("build/charts-base/charts-base.js", 7259);
if(val.marker)
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 7261);
var defs = this._getPlotDefaults();
            _yuitest_coverline("build/charts-base/charts-base.js", 7262);
val.marker = this._mergeStyles(val.marker, defs);
            _yuitest_coverline("build/charts-base/charts-base.js", 7263);
if(val.marker.over)
            {
                _yuitest_coverline("build/charts-base/charts-base.js", 7265);
val.marker.over = this._mergeStyles(val.marker.over, val.marker);
            }
            _yuitest_coverline("build/charts-base/charts-base.js", 7267);
if(val.marker.down)
            {
                _yuitest_coverline("build/charts-base/charts-base.js", 7269);
val.marker.down = this._mergeStyles(val.marker.down, val.marker);
            }
        }
        _yuitest_coverline("build/charts-base/charts-base.js", 7272);
return val;
    },

    /**
     * Returns marker state based on event type
     *
     * @method _getState
     * @param {String} type event type
     * @return String
     * @protected
     */
    _getState: function(type)
    {
        _yuitest_coverfunc("build/charts-base/charts-base.js", "_getState", 7283);
_yuitest_coverline("build/charts-base/charts-base.js", 7285);
var state;
        _yuitest_coverline("build/charts-base/charts-base.js", 7286);
switch(type)
        {
            case "mouseout" :
                _yuitest_coverline("build/charts-base/charts-base.js", 7289);
state = "off";
            _yuitest_coverline("build/charts-base/charts-base.js", 7290);
break;
            case "mouseover" :
                _yuitest_coverline("build/charts-base/charts-base.js", 7292);
state = "over";
            _yuitest_coverline("build/charts-base/charts-base.js", 7293);
break;
            case "mouseup" :
                _yuitest_coverline("build/charts-base/charts-base.js", 7295);
state = "over";
            _yuitest_coverline("build/charts-base/charts-base.js", 7296);
break;
            case "mousedown" :
                _yuitest_coverline("build/charts-base/charts-base.js", 7298);
state = "down";
            _yuitest_coverline("build/charts-base/charts-base.js", 7299);
break;
        }
        _yuitest_coverline("build/charts-base/charts-base.js", 7301);
return state;
    },

    /**
     * @property _statSyles
     * @type Object
     * @private
     */
    _stateSyles: null
};

_yuitest_coverline("build/charts-base/charts-base.js", 7312);
Y.augment(Plots, Y.Attribute);
_yuitest_coverline("build/charts-base/charts-base.js", 7313);
Y.Plots = Plots;
/**
 * Histogram is the base class for Column and Bar series.
 *
 * @module charts
 * @submodule charts-base
 * @class Histogram
 * @constructor
 */
_yuitest_coverline("build/charts-base/charts-base.js", 7322);
function Histogram(){}

_yuitest_coverline("build/charts-base/charts-base.js", 7324);
Histogram.prototype = {
    /**
     * Draws the series.
     *
     * @method drawSeries
     * @protected
     */
    drawSeries: function()
    {
        _yuitest_coverfunc("build/charts-base/charts-base.js", "drawSeries", 7331);
_yuitest_coverline("build/charts-base/charts-base.js", 7333);
if(this.get("xcoords").length < 1)
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 7335);
return;
        }
        _yuitest_coverline("build/charts-base/charts-base.js", 7337);
var style = Y.clone(this.get("styles").marker),
            setSize,
            calculatedSize,
            xcoords = this.get("xcoords"),
            ycoords = this.get("ycoords"),
            i = 0,
            len = xcoords.length,
            top = ycoords[0],
            type = this.get("type"),
            graph = this.get("graph"),
            seriesCollection = graph.seriesTypes[type],
            seriesLen = seriesCollection.length,
            seriesSize = 0,
            totalSize = 0,
            offset = 0,
            ratio,
            renderer,
            order = this.get("order"),
            graphOrder = this.get("graphOrder"),
            left,
            marker,
            setSizeKey,
            calculatedSizeKey,
            config,
            fillColors = null,
            borderColors = null,
            xMarkerPlane = [],
            yMarkerPlane = [],
            xMarkerPlaneLeft,
            xMarkerPlaneRight,
            yMarkerPlaneTop,
            yMarkerPlaneBottom,
            dimensions = {
                width: [],
                height: []
            },
            xvalues = [],
            yvalues = [],
            groupMarkers = this.get("groupMarkers");
        _yuitest_coverline("build/charts-base/charts-base.js", 7376);
if(Y_Lang.isArray(style.fill.color))
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 7378);
fillColors = style.fill.color.concat();
        }
        _yuitest_coverline("build/charts-base/charts-base.js", 7380);
if(Y_Lang.isArray(style.border.color))
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 7382);
borderColors = style.border.color.concat();
        }
        _yuitest_coverline("build/charts-base/charts-base.js", 7384);
if(this.get("direction") == "vertical")
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 7386);
setSizeKey = "height";
            _yuitest_coverline("build/charts-base/charts-base.js", 7387);
calculatedSizeKey = "width";
        }
        else
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 7391);
setSizeKey = "width";
            _yuitest_coverline("build/charts-base/charts-base.js", 7392);
calculatedSizeKey = "height";
        }
        _yuitest_coverline("build/charts-base/charts-base.js", 7394);
setSize = style[setSizeKey];
        _yuitest_coverline("build/charts-base/charts-base.js", 7395);
calculatedSize = style[calculatedSizeKey];
        _yuitest_coverline("build/charts-base/charts-base.js", 7396);
this._createMarkerCache();
        _yuitest_coverline("build/charts-base/charts-base.js", 7397);
for(; i < seriesLen; ++i)
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 7399);
renderer = seriesCollection[i];
            _yuitest_coverline("build/charts-base/charts-base.js", 7400);
seriesSize += renderer.get("styles").marker[setSizeKey];
            _yuitest_coverline("build/charts-base/charts-base.js", 7401);
if(order > i)
            {
                _yuitest_coverline("build/charts-base/charts-base.js", 7403);
offset = seriesSize;
            }
        }
        _yuitest_coverline("build/charts-base/charts-base.js", 7406);
totalSize = len * seriesSize;
        _yuitest_coverline("build/charts-base/charts-base.js", 7407);
this._maxSize = graph.get(setSizeKey);
        _yuitest_coverline("build/charts-base/charts-base.js", 7408);
if(totalSize > this._maxSize)
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 7410);
ratio = graph.get(setSizeKey)/totalSize;
            _yuitest_coverline("build/charts-base/charts-base.js", 7411);
seriesSize *= ratio;
            _yuitest_coverline("build/charts-base/charts-base.js", 7412);
offset *= ratio;
            _yuitest_coverline("build/charts-base/charts-base.js", 7413);
setSize *= ratio;
            _yuitest_coverline("build/charts-base/charts-base.js", 7414);
setSize = Math.max(setSize, 1);
            _yuitest_coverline("build/charts-base/charts-base.js", 7415);
this._maxSize = setSize;
        }
        _yuitest_coverline("build/charts-base/charts-base.js", 7417);
offset -= seriesSize/2;
        _yuitest_coverline("build/charts-base/charts-base.js", 7418);
for(i = 0; i < len; ++i)
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 7420);
xMarkerPlaneLeft = xcoords[i] - seriesSize/2;
            _yuitest_coverline("build/charts-base/charts-base.js", 7421);
xMarkerPlaneRight = xMarkerPlaneLeft + seriesSize;
            _yuitest_coverline("build/charts-base/charts-base.js", 7422);
yMarkerPlaneTop = ycoords[i] - seriesSize/2;
            _yuitest_coverline("build/charts-base/charts-base.js", 7423);
yMarkerPlaneBottom = yMarkerPlaneTop + seriesSize;
            _yuitest_coverline("build/charts-base/charts-base.js", 7424);
xMarkerPlane.push({start: xMarkerPlaneLeft, end: xMarkerPlaneRight});
            _yuitest_coverline("build/charts-base/charts-base.js", 7425);
yMarkerPlane.push({start: yMarkerPlaneTop, end: yMarkerPlaneBottom});
            _yuitest_coverline("build/charts-base/charts-base.js", 7426);
if(isNaN(xcoords[i]) || isNaN(ycoords[i]))
            {
                _yuitest_coverline("build/charts-base/charts-base.js", 7428);
this._markers.push(null);
                _yuitest_coverline("build/charts-base/charts-base.js", 7429);
continue;
            }
            _yuitest_coverline("build/charts-base/charts-base.js", 7431);
config = this._getMarkerDimensions(xcoords[i], ycoords[i], calculatedSize, offset);
            _yuitest_coverline("build/charts-base/charts-base.js", 7432);
if(!isNaN(config.calculatedSize) && config.calculatedSize > 0)
            {
                _yuitest_coverline("build/charts-base/charts-base.js", 7434);
top = config.top;
                _yuitest_coverline("build/charts-base/charts-base.js", 7435);
left = config.left;

                _yuitest_coverline("build/charts-base/charts-base.js", 7437);
if(groupMarkers)
                {
                    _yuitest_coverline("build/charts-base/charts-base.js", 7439);
dimensions[setSizeKey][i] = setSize;
                    _yuitest_coverline("build/charts-base/charts-base.js", 7440);
dimensions[calculatedSizeKey][i] = config.calculatedSize;
                    _yuitest_coverline("build/charts-base/charts-base.js", 7441);
xvalues.push(left);
                    _yuitest_coverline("build/charts-base/charts-base.js", 7442);
yvalues.push(top);
                }
                else
                {
                    _yuitest_coverline("build/charts-base/charts-base.js", 7446);
style[setSizeKey] = setSize;
                    _yuitest_coverline("build/charts-base/charts-base.js", 7447);
style[calculatedSizeKey] = config.calculatedSize;
                    _yuitest_coverline("build/charts-base/charts-base.js", 7448);
style.x = left;
                    _yuitest_coverline("build/charts-base/charts-base.js", 7449);
style.y = top;
                    _yuitest_coverline("build/charts-base/charts-base.js", 7450);
if(fillColors)
                    {
                        _yuitest_coverline("build/charts-base/charts-base.js", 7452);
style.fill.color = fillColors[i % fillColors.length];
                    }
                    _yuitest_coverline("build/charts-base/charts-base.js", 7454);
if(borderColors)
                    {
                        _yuitest_coverline("build/charts-base/charts-base.js", 7456);
style.border.color = borderColors[i % borderColors.length];
                    }
                    _yuitest_coverline("build/charts-base/charts-base.js", 7458);
marker = this.getMarker(style, graphOrder, i);
                }

            }
            else {_yuitest_coverline("build/charts-base/charts-base.js", 7462);
if(!groupMarkers)
            {
                _yuitest_coverline("build/charts-base/charts-base.js", 7464);
this._markers.push(null);
            }}
        }
        _yuitest_coverline("build/charts-base/charts-base.js", 7467);
this.set("xMarkerPlane", xMarkerPlane);
        _yuitest_coverline("build/charts-base/charts-base.js", 7468);
this.set("yMarkerPlane", yMarkerPlane);
        _yuitest_coverline("build/charts-base/charts-base.js", 7469);
if(groupMarkers)
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 7471);
this._createGroupMarker({
                fill: style.fill,
                border: style.border,
                dimensions: dimensions,
                xvalues: xvalues,
                yvalues: yvalues,
                shape: style.shape
            });
        }
        else
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 7482);
this._clearMarkerCache();
        }
    },

    /**
     * Collection of default colors used for marker fills in a series when not specified by user.
     *
     * @property _defaultFillColors
     * @type Array
     * @protected
     */
    _defaultFillColors: ["#66007f", "#a86f41", "#295454", "#996ab2", "#e8cdb7", "#90bdbd","#000000","#c3b8ca", "#968373", "#678585"],

    /**
     * Gets the default style values for the markers.
     *
     * @method _getPlotDefaults
     * @return Object
     * @private
     */
    _getPlotDefaults: function()
    {
        _yuitest_coverfunc("build/charts-base/charts-base.js", "_getPlotDefaults", 7502);
_yuitest_coverline("build/charts-base/charts-base.js", 7504);
var defs = {
            fill:{
                type: "solid",
                alpha: 1,
                colors:null,
                alphas: null,
                ratios: null
            },
            border:{
                weight: 0,
                alpha: 1
            },
            width: 12,
            height: 12,
            shape: "rect",

            padding:{
                top: 0,
                left: 0,
                right: 0,
                bottom: 0
            }
        };
        _yuitest_coverline("build/charts-base/charts-base.js", 7527);
defs.fill.color = this._getDefaultColor(this.get("graphOrder"), "fill");
        _yuitest_coverline("build/charts-base/charts-base.js", 7528);
defs.border.color = this._getDefaultColor(this.get("graphOrder"), "border");
        _yuitest_coverline("build/charts-base/charts-base.js", 7529);
return defs;
    }
};

_yuitest_coverline("build/charts-base/charts-base.js", 7533);
Y.Histogram = Histogram;
/**
 * The CartesianSeries class creates a chart with horizontal and vertical axes.
 *
 * @module charts
 * @submodule charts-base
 * @class CartesianSeries
 * @extends Base
 * @uses Renderer
 * @constructor
 */
_yuitest_coverline("build/charts-base/charts-base.js", 7544);
Y.CartesianSeries = Y.Base.create("cartesianSeries", Y.Base, [Y.Renderer], {
    /**
     * Storage for `xDisplayName` attribute.
     *
     * @property _xDisplayName
     * @type String
     * @private
     */
    _xDisplayName: null,

    /**
     * Storage for `yDisplayName` attribute.
     *
     * @property _yDisplayName
     * @type String
     * @private
     */
    _yDisplayName: null,

    /**
     * Th x-coordinate for the left edge of the series.
     *
     * @property _leftOrigin
     * @type String
     * @private
     */
    _leftOrigin: null,

    /**
     * The y-coordinate for the bottom edge of the series.
     *
     * @property _bottomOrigin
     * @type String
     * @private
     */
    _bottomOrigin: null,

    /**
     * @method render
     * @private
     */
    render: function()
    {
        _yuitest_coverfunc("build/charts-base/charts-base.js", "render", 7585);
_yuitest_coverline("build/charts-base/charts-base.js", 7587);
this._setCanvas();
        _yuitest_coverline("build/charts-base/charts-base.js", 7588);
this.addListeners();
        _yuitest_coverline("build/charts-base/charts-base.js", 7589);
this.set("rendered", true);
        _yuitest_coverline("build/charts-base/charts-base.js", 7590);
this.validate();
    },

    /**
     * Adds event listeners.
     *
     * @method addListeners
     * @private
     */
    addListeners: function()
    {
        _yuitest_coverfunc("build/charts-base/charts-base.js", "addListeners", 7599);
_yuitest_coverline("build/charts-base/charts-base.js", 7601);
var xAxis = this.get("xAxis"),
            yAxis = this.get("yAxis");
        _yuitest_coverline("build/charts-base/charts-base.js", 7603);
if(xAxis)
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 7605);
this._xDataReadyHandle = xAxis.after("dataReady", Y.bind(this._xDataChangeHandler, this));
            _yuitest_coverline("build/charts-base/charts-base.js", 7606);
this._xDataUpdateHandle = xAxis.after("dataUpdate", Y.bind(this._xDataChangeHandler, this));
        }
        _yuitest_coverline("build/charts-base/charts-base.js", 7608);
if(yAxis)
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 7610);
this._yDataReadyHandle = yAxis.after("dataReady", Y.bind(this._yDataChangeHandler, this));
            _yuitest_coverline("build/charts-base/charts-base.js", 7611);
this._yDataUpdateHandle = yAxis.after("dataUpdate", Y.bind(this._yDataChangeHandler, this));
        }
        _yuitest_coverline("build/charts-base/charts-base.js", 7613);
this._xAxisChangeHandle = this.after("xAxisChange", this._xAxisChangeHandler);
        _yuitest_coverline("build/charts-base/charts-base.js", 7614);
this._yAxisChangeHandle = this.after("yAxisChange", this._yAxisChangeHandler);
        _yuitest_coverline("build/charts-base/charts-base.js", 7615);
this._stylesChangeHandle = this.after("stylesChange", function(e) {
            _yuitest_coverfunc("build/charts-base/charts-base.js", "(anonymous 3)", 7615);
_yuitest_coverline("build/charts-base/charts-base.js", 7616);
var axesReady = this._updateAxisData();
            _yuitest_coverline("build/charts-base/charts-base.js", 7617);
if(axesReady)
            {
                _yuitest_coverline("build/charts-base/charts-base.js", 7619);
this.draw();
            }
        });
        _yuitest_coverline("build/charts-base/charts-base.js", 7622);
this._widthChangeHandle = this.after("widthChange", function(e) {
            _yuitest_coverfunc("build/charts-base/charts-base.js", "(anonymous 4)", 7622);
_yuitest_coverline("build/charts-base/charts-base.js", 7623);
var axesReady = this._updateAxisData();
            _yuitest_coverline("build/charts-base/charts-base.js", 7624);
if(axesReady)
            {
                _yuitest_coverline("build/charts-base/charts-base.js", 7626);
this.draw();
            }
        });
        _yuitest_coverline("build/charts-base/charts-base.js", 7629);
this._heightChangeHandle = this.after("heightChange", function(e) {
            _yuitest_coverfunc("build/charts-base/charts-base.js", "(anonymous 5)", 7629);
_yuitest_coverline("build/charts-base/charts-base.js", 7630);
var axesReady = this._updateAxisData();
            _yuitest_coverline("build/charts-base/charts-base.js", 7631);
if(axesReady)
            {
                _yuitest_coverline("build/charts-base/charts-base.js", 7633);
this.draw();
            }
        });
        _yuitest_coverline("build/charts-base/charts-base.js", 7636);
this._visibleChangeHandle = this.after("visibleChange", this._handleVisibleChange);
    },

    /**
     * Event handler for the xAxisChange event.
     *
     * @method _xAxisChangeHandler
     * @param {Object} e Event object.
     * @private
     */
    _xAxisChangeHandler: function(e)
    {
        _yuitest_coverfunc("build/charts-base/charts-base.js", "_xAxisChangeHandler", 7646);
_yuitest_coverline("build/charts-base/charts-base.js", 7648);
var xAxis = this.get("xAxis");
        _yuitest_coverline("build/charts-base/charts-base.js", 7649);
xAxis.after("dataReady", Y.bind(this._xDataChangeHandler, this));
        _yuitest_coverline("build/charts-base/charts-base.js", 7650);
xAxis.after("dataUpdate", Y.bind(this._xDataChangeHandler, this));
    },

    /**
     * Event handler the yAxisChange event.
     *
     * @method _yAxisChangeHandler
     * @param {Object} e Event object.
     * @private
     */
    _yAxisChangeHandler: function(e)
    {
        _yuitest_coverfunc("build/charts-base/charts-base.js", "_yAxisChangeHandler", 7660);
_yuitest_coverline("build/charts-base/charts-base.js", 7662);
var yAxis = this.get("yAxis");
        _yuitest_coverline("build/charts-base/charts-base.js", 7663);
yAxis.after("dataReady", Y.bind(this._yDataChangeHandler, this));
        _yuitest_coverline("build/charts-base/charts-base.js", 7664);
yAxis.after("dataUpdate", Y.bind(this._yDataChangeHandler, this));
    },

    /**
     * Constant used to generate unique id.
     *
     * @property GUID
     * @type String
     * @private
     */
    GUID: "yuicartesianseries",

    /**
     * Event handler for xDataChange event.
     *
     * @method _xDataChangeHandler
     * @param {Object} event Event object.
     * @private
     */
    _xDataChangeHandler: function(event)
    {
        _yuitest_coverfunc("build/charts-base/charts-base.js", "_xDataChangeHandler", 7683);
_yuitest_coverline("build/charts-base/charts-base.js", 7685);
var axesReady = this._updateAxisData();
        _yuitest_coverline("build/charts-base/charts-base.js", 7686);
if(axesReady)
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 7688);
this.draw();
        }
    },

    /**
     * Event handler for yDataChange event.
     *
     * @method _yDataChangeHandler
     * @param {Object} event Event object.
     * @private
     */
    _yDataChangeHandler: function(event)
    {
        _yuitest_coverfunc("build/charts-base/charts-base.js", "_yDataChangeHandler", 7699);
_yuitest_coverline("build/charts-base/charts-base.js", 7701);
var axesReady = this._updateAxisData();
        _yuitest_coverline("build/charts-base/charts-base.js", 7702);
if(axesReady)
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 7704);
this.draw();
        }
    },

    /**
     * Checks to ensure that both xAxis and yAxis data are available. If so, set the `xData` and `yData` attributes
     * and return `true`. Otherwise, return `false`.
     *
     * @method _updateAxisData
     * @return Boolean
     * @private
     */
    _updateAxisData: function()
    {
        _yuitest_coverfunc("build/charts-base/charts-base.js", "_updateAxisData", 7716);
_yuitest_coverline("build/charts-base/charts-base.js", 7718);
var xAxis = this.get("xAxis"),
            yAxis = this.get("yAxis"),
            xKey = this.get("xKey"),
            yKey = this.get("yKey"),
            yData,
            xData;
        _yuitest_coverline("build/charts-base/charts-base.js", 7724);
if(!xAxis || !yAxis || !xKey || !yKey)
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 7726);
return false;
        }
        _yuitest_coverline("build/charts-base/charts-base.js", 7728);
xData = xAxis.getDataByKey(xKey);
        _yuitest_coverline("build/charts-base/charts-base.js", 7729);
yData = yAxis.getDataByKey(yKey);
        _yuitest_coverline("build/charts-base/charts-base.js", 7730);
if(!xData || !yData)
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 7732);
return false;
        }
        _yuitest_coverline("build/charts-base/charts-base.js", 7734);
this.set("xData", xData.concat());
        _yuitest_coverline("build/charts-base/charts-base.js", 7735);
this.set("yData", yData.concat());
        _yuitest_coverline("build/charts-base/charts-base.js", 7736);
return true;
    },

    /**
     * Draws the series is the xAxis and yAxis data are both available.
     *
     * @method validate
     * @private
     */
    validate: function()
    {
        _yuitest_coverfunc("build/charts-base/charts-base.js", "validate", 7745);
_yuitest_coverline("build/charts-base/charts-base.js", 7747);
if((this.get("xData") && this.get("yData")) || this._updateAxisData())
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 7749);
this.draw();
        }
        else
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 7753);
this.fire("drawingComplete");
        }
    },

    /**
     * Creates a `Graphic` instance.
     *
     * @method _setCanvas
     * @protected
     */
    _setCanvas: function()
    {
        _yuitest_coverfunc("build/charts-base/charts-base.js", "_setCanvas", 7763);
_yuitest_coverline("build/charts-base/charts-base.js", 7765);
var graph = this.get("graph"),
            graphic = graph.get("graphic");
        _yuitest_coverline("build/charts-base/charts-base.js", 7767);
this.set("graphic", graphic);
    },

    /**
     * Calculates the coordinates for the series.
     *
     * @method setAreaData
     * @protected
     */
    setAreaData: function()
    {
        _yuitest_coverfunc("build/charts-base/charts-base.js", "setAreaData", 7776);
_yuitest_coverline("build/charts-base/charts-base.js", 7778);
var isNumber = Y_Lang.isNumber,
            nextX, nextY,
            graph = this.get("graph"),
            w = graph.get("width"),
            h = graph.get("height"),
            xAxis = this.get("xAxis"),
            yAxis = this.get("yAxis"),
            xData = this.get("xData").concat(),
            yData = this.get("yData").concat(),
            xValue,
            yValue,
            xOffset = xAxis.getEdgeOffset(xData.length, w),
            yOffset = yAxis.getEdgeOffset(yData.length, h),
            padding = this.get("styles").padding,
			leftPadding = padding.left,
			topPadding = padding.top,
			dataWidth = w - (leftPadding + padding.right + xOffset),
			dataHeight = h - (topPadding + padding.bottom + yOffset),
			xcoords = [],
			ycoords = [],
			xMax = xAxis.get("maximum"),
			xMin = xAxis.get("minimum"),
			yMax = yAxis.get("maximum"),
			yMin = yAxis.get("minimum"),
            xScaleFactor = dataWidth / (xMax - xMin),
			yScaleFactor = dataHeight / (yMax - yMin),
            dataLength,
            direction = this.get("direction"),
            i = 0,
            xMarkerPlane = [],
            yMarkerPlane = [],
            xMarkerPlaneOffset = this.get("xMarkerPlaneOffset"),
            yMarkerPlaneOffset = this.get("yMarkerPlaneOffset"),
            graphic = this.get("graphic");
        _yuitest_coverline("build/charts-base/charts-base.js", 7812);
graphic.set("width", w);
        _yuitest_coverline("build/charts-base/charts-base.js", 7813);
graphic.set("height", h);
        _yuitest_coverline("build/charts-base/charts-base.js", 7814);
dataLength = xData.length;
        _yuitest_coverline("build/charts-base/charts-base.js", 7815);
xOffset *= 0.5;
        _yuitest_coverline("build/charts-base/charts-base.js", 7816);
yOffset *= 0.5;
        //Assuming a vertical graph has a range/category for its vertical axis.
        _yuitest_coverline("build/charts-base/charts-base.js", 7818);
if(direction === "vertical")
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 7820);
yData = yData.reverse();
        }
        _yuitest_coverline("build/charts-base/charts-base.js", 7822);
this._leftOrigin = Math.round(((0 - xMin) * xScaleFactor) + leftPadding + xOffset);
        _yuitest_coverline("build/charts-base/charts-base.js", 7823);
this._bottomOrigin = Math.round((dataHeight + topPadding + yOffset));
        _yuitest_coverline("build/charts-base/charts-base.js", 7824);
if(yMin < 0)
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 7826);
this._bottomOrigin = this._bottomOrigin - ((0 - yMin) * yScaleFactor);
        }
        _yuitest_coverline("build/charts-base/charts-base.js", 7828);
for (; i < dataLength; ++i)
		{
            _yuitest_coverline("build/charts-base/charts-base.js", 7830);
xValue = parseFloat(xData[i]);
            _yuitest_coverline("build/charts-base/charts-base.js", 7831);
yValue = parseFloat(yData[i]);
            _yuitest_coverline("build/charts-base/charts-base.js", 7832);
if(isNumber(xValue))
            {
                _yuitest_coverline("build/charts-base/charts-base.js", 7834);
nextX = (((xValue - xMin) * xScaleFactor) + leftPadding + xOffset);
            }
            else
            {
                _yuitest_coverline("build/charts-base/charts-base.js", 7838);
nextX = NaN;
            }
            _yuitest_coverline("build/charts-base/charts-base.js", 7840);
if(isNumber(yValue))
            {
			    _yuitest_coverline("build/charts-base/charts-base.js", 7842);
nextY = ((dataHeight + topPadding + yOffset) - (yValue - yMin) * yScaleFactor);
            }
            else
            {
                _yuitest_coverline("build/charts-base/charts-base.js", 7846);
nextY = NaN;
            }
            _yuitest_coverline("build/charts-base/charts-base.js", 7848);
xcoords.push(nextX);
            _yuitest_coverline("build/charts-base/charts-base.js", 7849);
ycoords.push(nextY);
            _yuitest_coverline("build/charts-base/charts-base.js", 7850);
xMarkerPlane.push({start:nextX - xMarkerPlaneOffset, end: nextX + xMarkerPlaneOffset});
            _yuitest_coverline("build/charts-base/charts-base.js", 7851);
yMarkerPlane.push({start:nextY - yMarkerPlaneOffset, end: nextY + yMarkerPlaneOffset});
        }
        _yuitest_coverline("build/charts-base/charts-base.js", 7853);
this.set("xcoords", xcoords);
		_yuitest_coverline("build/charts-base/charts-base.js", 7854);
this.set("ycoords", ycoords);
        _yuitest_coverline("build/charts-base/charts-base.js", 7855);
this.set("xMarkerPlane", xMarkerPlane);
        _yuitest_coverline("build/charts-base/charts-base.js", 7856);
this.set("yMarkerPlane", yMarkerPlane);
        _yuitest_coverline("build/charts-base/charts-base.js", 7857);
this._dataLength = dataLength;
    },

    /**
     * Finds the first valid index of an array coordinates.
     *
     * @method _getFirstValidIndex
     * @param {Array} coords An array of x or y coordinates.
     * @return Number
     * @private
     */
    _getFirstValidIndex: function(coords)
    {
        _yuitest_coverfunc("build/charts-base/charts-base.js", "_getFirstValidIndex", 7868);
_yuitest_coverline("build/charts-base/charts-base.js", 7870);
var coord,
            i = -1,
            limit = coords.length;
        _yuitest_coverline("build/charts-base/charts-base.js", 7873);
while(!Y_Lang.isNumber(coord) && i < limit)
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 7875);
i += 1;
            _yuitest_coverline("build/charts-base/charts-base.js", 7876);
coord = coords[i];
        }
        _yuitest_coverline("build/charts-base/charts-base.js", 7878);
return i;
    },

    /**
     * Finds the last valid index of an array coordinates.
     *
     * @method _getLastValidIndex
     * @param {Array} coords An array of x or y coordinates.
     * @return Number
     * @private
     */
    _getLastValidIndex: function(coords)
    {
        _yuitest_coverfunc("build/charts-base/charts-base.js", "_getLastValidIndex", 7889);
_yuitest_coverline("build/charts-base/charts-base.js", 7891);
var coord,
            i = coords.length,
            limit = -1;
        _yuitest_coverline("build/charts-base/charts-base.js", 7894);
while(!Y_Lang.isNumber(coord) && i > limit)
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 7896);
i -= 1;
            _yuitest_coverline("build/charts-base/charts-base.js", 7897);
coord = coords[i];
        }
        _yuitest_coverline("build/charts-base/charts-base.js", 7899);
return i;
    },

    /**
     * Draws the series.
     *
     * @method draw
     * @protected
     */
    draw: function()
    {
        _yuitest_coverfunc("build/charts-base/charts-base.js", "draw", 7908);
_yuitest_coverline("build/charts-base/charts-base.js", 7910);
var graph = this.get("graph"),
            w = graph.get("width"),
            h = graph.get("height");
        _yuitest_coverline("build/charts-base/charts-base.js", 7913);
if(this.get("rendered"))
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 7915);
if((isFinite(w) && isFinite(h) && w > 0 && h > 0) && ((this.get("xData") && this.get("yData")) || this._updateAxisData()))
            {
                _yuitest_coverline("build/charts-base/charts-base.js", 7917);
if(this._drawing)
                {
                    _yuitest_coverline("build/charts-base/charts-base.js", 7919);
this._callLater = true;
                    _yuitest_coverline("build/charts-base/charts-base.js", 7920);
return;
                }
                _yuitest_coverline("build/charts-base/charts-base.js", 7922);
this._drawing = true;
                _yuitest_coverline("build/charts-base/charts-base.js", 7923);
this._callLater = false;
                _yuitest_coverline("build/charts-base/charts-base.js", 7924);
this.setAreaData();
                _yuitest_coverline("build/charts-base/charts-base.js", 7925);
if(this.get("xcoords") && this.get("ycoords"))
                {
                    _yuitest_coverline("build/charts-base/charts-base.js", 7927);
this.drawSeries();
                }
                _yuitest_coverline("build/charts-base/charts-base.js", 7929);
this._drawing = false;
                _yuitest_coverline("build/charts-base/charts-base.js", 7930);
if(this._callLater)
                {
                    _yuitest_coverline("build/charts-base/charts-base.js", 7932);
this.draw();
                }
                else
                {
                    _yuitest_coverline("build/charts-base/charts-base.js", 7936);
this._toggleVisible(this.get("visible"));
                    _yuitest_coverline("build/charts-base/charts-base.js", 7937);
this.fire("drawingComplete");
                }
            }
        }
    },

    /**
     * Default value for plane offsets when the parent chart's `interactiveType` is `planar`.
     *
     * @property _defaultPlaneOffset
     * @type Number
     * @private
     */
    _defaultPlaneOffset: 4,

    /**
     * Gets the default value for the `styles` attribute. Overrides
     * base implementation.
     *
     * @method _getDefaultStyles
     * @return Object
     * @protected
     */
    _getDefaultStyles: function()
    {
        _yuitest_coverfunc("build/charts-base/charts-base.js", "_getDefaultStyles", 7960);
_yuitest_coverline("build/charts-base/charts-base.js", 7962);
return {padding:{
                top: 0,
                left: 0,
                right: 0,
                bottom: 0
            }};
    },

    /**
     * Collection of default colors used for lines in a series when not specified by user.
     *
     * @property _defaultLineColors
     * @type Array
     * @protected
     */
    _defaultLineColors:["#426ab3", "#d09b2c", "#000000", "#b82837", "#b384b5", "#ff7200", "#779de3", "#cbc8ba", "#7ed7a6", "#007a6c"],

    /**
     * Collection of default colors used for marker fills in a series when not specified by user.
     *
     * @property _defaultFillColors
     * @type Array
     * @protected
     */
    _defaultFillColors:["#6084d0", "#eeb647", "#6c6b5f", "#d6484f", "#ce9ed1", "#ff9f3b", "#93b7ff", "#e0ddd0", "#94ecba", "#309687"],

    /**
     * Collection of default colors used for marker borders in a series when not specified by user.
     *
     * @property _defaultBorderColors
     * @type Array
     * @protected
     */
    _defaultBorderColors:["#205096", "#b38206", "#000000", "#94001e", "#9d6fa0", "#e55b00", "#5e85c9", "#adab9e", "#6ac291", "#006457"],

    /**
     * Collection of default colors used for area fills, histogram fills and pie fills in a series when not specified by user.
     *
     * @property _defaultSliceColors
     * @type Array
     * @protected
     */
    _defaultSliceColors: ["#66007f", "#a86f41", "#295454", "#996ab2", "#e8cdb7", "#90bdbd","#000000","#c3b8ca", "#968373", "#678585"],

    /**
     * Parses a color based on a series order and type.
     *
     * @method _getDefaultColor
     * @param {Number} index Index indicating the series order.
     * @param {String} type Indicates which type of object needs the color.
     * @return String
     * @protected
     */
    _getDefaultColor: function(index, type)
    {
        _yuitest_coverfunc("build/charts-base/charts-base.js", "_getDefaultColor", 8015);
_yuitest_coverline("build/charts-base/charts-base.js", 8017);
var colors = {
                line: this._defaultLineColors,
                fill: this._defaultFillColors,
                border: this._defaultBorderColors,
                slice: this._defaultSliceColors
            },
            col = colors[type],
            l = col.length;
        _yuitest_coverline("build/charts-base/charts-base.js", 8025);
index = index || 0;
        _yuitest_coverline("build/charts-base/charts-base.js", 8026);
if(index >= l)
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 8028);
index = index % l;
        }
        _yuitest_coverline("build/charts-base/charts-base.js", 8030);
type = type || "fill";
        _yuitest_coverline("build/charts-base/charts-base.js", 8031);
return colors[type][index];
    },

    /**
     * Shows/hides contents of the series.
     *
     * @method _handleVisibleChange
     * @param {Object} e Event object.
     * @protected
     */
    _handleVisibleChange: function(e)
    {
        _yuitest_coverfunc("build/charts-base/charts-base.js", "_handleVisibleChange", 8041);
_yuitest_coverline("build/charts-base/charts-base.js", 8043);
this._toggleVisible(this.get("visible"));
    },

    /**
     * Returns the sum of all values for the series.
     *
     * @method getTotalValues
     * @return Number
     */
    getTotalValues: function()
    {
        _yuitest_coverfunc("build/charts-base/charts-base.js", "getTotalValues", 8052);
_yuitest_coverline("build/charts-base/charts-base.js", 8054);
var total = this.get("valueAxis").getTotalByKey(this.get("valueKey"));
        _yuitest_coverline("build/charts-base/charts-base.js", 8055);
return total;
    },

    /**
     * Destructor implementation for the CartesianSeries class. Calls destroy on all Graphic instances.
     *
     * @method destructor
     * @protected
     */
    destructor: function()
    {
        _yuitest_coverfunc("build/charts-base/charts-base.js", "destructor", 8064);
_yuitest_coverline("build/charts-base/charts-base.js", 8066);
var marker,
            markers = this.get("markers");
        _yuitest_coverline("build/charts-base/charts-base.js", 8068);
if(this.get("rendered"))
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 8070);
if(this._xDataReadyHandle)
            {
                _yuitest_coverline("build/charts-base/charts-base.js", 8072);
this._xDataReadyHandle.detach();
            }
            _yuitest_coverline("build/charts-base/charts-base.js", 8074);
if(this._xDataUpdateHandle)
            {
                _yuitest_coverline("build/charts-base/charts-base.js", 8076);
this._xDataUpdateHandle.detach();
            }
            _yuitest_coverline("build/charts-base/charts-base.js", 8078);
if(this._yDataReadyHandle)
            {
                _yuitest_coverline("build/charts-base/charts-base.js", 8080);
this._yDataReadyHandle.detach();
            }
            _yuitest_coverline("build/charts-base/charts-base.js", 8082);
if(this._yDataUpdateHandle)
            {
                _yuitest_coverline("build/charts-base/charts-base.js", 8084);
this._yDataUpdateHandle.detach();
            }
            _yuitest_coverline("build/charts-base/charts-base.js", 8086);
this._xAxisChangeHandle.detach();
            _yuitest_coverline("build/charts-base/charts-base.js", 8087);
this._yAxisChangeHandle.detach();
            _yuitest_coverline("build/charts-base/charts-base.js", 8088);
this._stylesChangeHandle.detach();
            _yuitest_coverline("build/charts-base/charts-base.js", 8089);
this._widthChangeHandle.detach();
            _yuitest_coverline("build/charts-base/charts-base.js", 8090);
this._heightChangeHandle.detach();
            _yuitest_coverline("build/charts-base/charts-base.js", 8091);
this._visibleChangeHandle.detach();
        }
        _yuitest_coverline("build/charts-base/charts-base.js", 8093);
while(markers && markers.length > 0)
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 8095);
marker = markers.shift();
            _yuitest_coverline("build/charts-base/charts-base.js", 8096);
if(marker && marker instanceof Y.Shape)
            {
                _yuitest_coverline("build/charts-base/charts-base.js", 8098);
marker.destroy();
            }
        }
        _yuitest_coverline("build/charts-base/charts-base.js", 8101);
if(this._path)
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 8103);
this._path.destroy();
            _yuitest_coverline("build/charts-base/charts-base.js", 8104);
this._path = null;
        }
        _yuitest_coverline("build/charts-base/charts-base.js", 8106);
if(this._lineGraphic)
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 8108);
this._lineGraphic.destroy();
            _yuitest_coverline("build/charts-base/charts-base.js", 8109);
this._lineGraphic = null;
        }
        _yuitest_coverline("build/charts-base/charts-base.js", 8111);
if(this._groupMarker)
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 8113);
this._groupMarker.destroy();
            _yuitest_coverline("build/charts-base/charts-base.js", 8114);
this._groupMarker = null;
        }
    }
        /**
         * Event handle for the x-axis' dataReady event.
         *
         * @property _xDataReadyHandle
         * @type {EventHandle}
         * @private
         */

        /**
         * Event handle for the x-axis dataUpdate event.
         *
         * @property _xDataUpdateHandle
         * @type {EventHandle}
         * @private
         */

        /**
         * Event handle for the y-axis dataReady event.
         *
         * @property _yDataReadyHandle
         * @type {EventHandle}
         * @private
         */

        /**
         * Event handle for the y-axis dataUpdate event.
         * @property _yDataUpdateHandle
         * @type {EventHandle}
         * @private
         */

        /**
         * Event handle for the xAxisChange event.
         * @property _xAxisChangeHandle
         * @type {EventHandle}
         * @private
         */

        /**
         * Event handle for the yAxisChange event.
         * @property _yAxisChangeHandle
         * @type {EventHandle}
         * @private
         */

        /**
         * Event handle for the stylesChange event.
         * @property _stylesChangeHandle
         * @type {EventHandle}
         * @private
         */

        /**
         * Event handle for the widthChange event.
         * @property _widthChangeHandle
         * @type {EventHandle}
         * @private
         */

        /**
         * Event handle for the heightChange event.
         * @property _heightChangeHandle
         * @type {EventHandle}
         * @private
         */

        /**
         * Event handle for the visibleChange event.
         * @property _visibleChangeHandle
         * @type {EventHandle}
         * @private
         */
}, {
    ATTRS: {
        /**
         * Name used for for displaying data related to the x-coordinate.
         *
         * @attribute xDisplayName
         * @type String
         */
        xDisplayName: {
            getter: function()
            {
                _yuitest_coverfunc("build/charts-base/charts-base.js", "getter", 8198);
_yuitest_coverline("build/charts-base/charts-base.js", 8200);
return this._xDisplayName || this.get("xKey");
            },

            setter: function(val)
            {
                _yuitest_coverfunc("build/charts-base/charts-base.js", "setter", 8203);
_yuitest_coverline("build/charts-base/charts-base.js", 8205);
this._xDisplayName = val.toString();
                _yuitest_coverline("build/charts-base/charts-base.js", 8206);
return val;
            }
        },

        /**
         * Name used for for displaying data related to the y-coordinate.
         *
         * @attribute yDisplayName
         * @type String
         */
        yDisplayName: {
            getter: function()
            {
                _yuitest_coverfunc("build/charts-base/charts-base.js", "getter", 8217);
_yuitest_coverline("build/charts-base/charts-base.js", 8219);
return this._yDisplayName || this.get("yKey");
            },

            setter: function(val)
            {
                _yuitest_coverfunc("build/charts-base/charts-base.js", "setter", 8222);
_yuitest_coverline("build/charts-base/charts-base.js", 8224);
this._yDisplayName = val.toString();
                _yuitest_coverline("build/charts-base/charts-base.js", 8225);
return val;
            }
        },

        /**
         * Name used for for displaying category data
         *
         * @attribute categoryDisplayName
         * @type String
         * @readOnly
         */
        categoryDisplayName: {
            lazyAdd: false,

            getter: function()
            {
                _yuitest_coverfunc("build/charts-base/charts-base.js", "getter", 8239);
_yuitest_coverline("build/charts-base/charts-base.js", 8241);
return this.get("direction") == "vertical" ? this.get("yDisplayName") : this.get("xDisplayName");
           },

            setter: function(val)
            {
                _yuitest_coverfunc("build/charts-base/charts-base.js", "setter", 8244);
_yuitest_coverline("build/charts-base/charts-base.js", 8246);
if(this.get("direction") == "vertical")
                {
                    _yuitest_coverline("build/charts-base/charts-base.js", 8248);
this._yDisplayName = val;
                }
                else
                {
                    _yuitest_coverline("build/charts-base/charts-base.js", 8252);
this._xDisplayName = val;
                }
                _yuitest_coverline("build/charts-base/charts-base.js", 8254);
return val;
            }
        },

        /**
         * Name used for for displaying value data
         *
         * @attribute valueDisplayName
         * @type String
         * @readOnly
         */
        valueDisplayName: {
            lazyAdd: false,

            getter: function()
            {
                _yuitest_coverfunc("build/charts-base/charts-base.js", "getter", 8268);
_yuitest_coverline("build/charts-base/charts-base.js", 8270);
return this.get("direction") == "vertical" ? this.get("xDisplayName") : this.get("yDisplayName");
            },

            setter: function(val)
            {
                _yuitest_coverfunc("build/charts-base/charts-base.js", "setter", 8273);
_yuitest_coverline("build/charts-base/charts-base.js", 8275);
if(this.get("direction") == "vertical")
                {
                    _yuitest_coverline("build/charts-base/charts-base.js", 8277);
this._xDisplayName = val;
                }
                else
                {
                    _yuitest_coverline("build/charts-base/charts-base.js", 8281);
this._yDisplayName = val;
                }
                _yuitest_coverline("build/charts-base/charts-base.js", 8283);
return val;
            }
        },

        /**
         * Read-only attribute indicating the type of series.
         *
         * @attribute type
         * @type String
         * @default cartesian
         */
        type: {
            value: "cartesian"
        },

        /**
         * Order of this instance of this `type`.
         *
         * @attribute order
         * @type Number
         */
        order: {},

        /**
         * Order of the instance
         *
         * @attribute graphOrder
         * @type Number
         */
        graphOrder: {},

        /**
         * x coordinates for the series.
         *
         * @attribute xcoords
         * @type Array
         */
        xcoords: {},

        /**
         * y coordinates for the series
         *
         * @attribute ycoords
         * @type Array
         */
        ycoords: {},

        /**
         * Reference to the `Chart` application.
         *
         * @attribute chart
         * @type ChartBase
         * @readOnly
         */
        chart: {
            readOnly: true,

            getter: function()
            {
                _yuitest_coverfunc("build/charts-base/charts-base.js", "getter", 8340);
_yuitest_coverline("build/charts-base/charts-base.js", 8342);
return this.get("graph").get("chart");
            }
        },

        /**
         * Reference to the `Graph` in which the series is drawn into.
         *
         * @attribute graph
         * @type Graph
         */
        graph: {},

        /**
         * Reference to the `Axis` instance used for assigning
         * x-values to the graph.
         *
         * @attribute xAxis
         * @type Axis
         */
        xAxis: {},

        /**
         * Reference to the `Axis` instance used for assigning
         * y-values to the graph.
         *
         * @attribute yAxis
         * @type Axis
         */
        yAxis: {},

        /**
         * Indicates which array to from the hash of value arrays in
         * the x-axis `Axis` instance.
         *
         * @attribute xKey
         * @type String
         */
        xKey: {
            setter: function(val)
            {
                _yuitest_coverfunc("build/charts-base/charts-base.js", "setter", 8380);
_yuitest_coverline("build/charts-base/charts-base.js", 8382);
return val.toString();
            }
        },

        /**
         * Indicates which array to from the hash of value arrays in
         * the y-axis `Axis` instance.
         *
         * @attribute yKey
         * @type String
         */
        yKey: {
            setter: function(val)
            {
                _yuitest_coverfunc("build/charts-base/charts-base.js", "setter", 8394);
_yuitest_coverline("build/charts-base/charts-base.js", 8396);
return val.toString();
            }
        },

        /**
         * Array of x values for the series.
         *
         * @attribute xData
         * @type Array
         */
        xData: {},

        /**
         * Array of y values for the series.
         *
         * @attribute yData
         * @type Array
         */
        yData: {},

        /**
         * Indicates whether the Series has been through its initial set up.
         *
         * @attribute rendered
         * @type Boolean
         */
        rendered: {
            value: false
        },

        /*
         * Returns the width of the parent graph
         *
         * @attribute width
         * @type Number
         */
        width: {
            readOnly: true,

            getter: function()
            {
                _yuitest_coverfunc("build/charts-base/charts-base.js", "getter", 8435);
_yuitest_coverline("build/charts-base/charts-base.js", 8437);
this.get("graph").get("width");
            }
        },

        /**
         * Returns the height of the parent graph
         *
         * @attribute height
         * @type Number
         */
        height: {
            readOnly: true,

            getter: function()
            {
                _yuitest_coverfunc("build/charts-base/charts-base.js", "getter", 8450);
_yuitest_coverline("build/charts-base/charts-base.js", 8452);
this.get("graph").get("height");
            }
        },

        /**
         * Indicates whether to show the series
         *
         * @attribute visible
         * @type Boolean
         * @default true
         */
        visible: {
            value: true
        },

        /**
         * Collection of area maps along the xAxis. Used to determine mouseover for multiple
         * series.
         *
         * @attribute xMarkerPlane
         * @type Array
         */
        xMarkerPlane: {},

        /**
         * Collection of area maps along the yAxis. Used to determine mouseover for multiple
         * series.
         *
         * @attribute yMarkerPlane
         * @type Array
         */
        yMarkerPlane: {},

        /**
         * Distance from a data coordinate to the left/right for setting a hotspot.
         *
         * @attribute xMarkerPlaneOffset
         * @type Number
         */
        xMarkerPlaneOffset: {
            getter: function() {
                _yuitest_coverfunc("build/charts-base/charts-base.js", "getter", 8492);
_yuitest_coverline("build/charts-base/charts-base.js", 8493);
var marker = this.get("styles").marker;
                _yuitest_coverline("build/charts-base/charts-base.js", 8494);
if(marker && marker.width && isFinite(marker.width))
                {
                    _yuitest_coverline("build/charts-base/charts-base.js", 8496);
return marker.width * 0.5;
                }
                _yuitest_coverline("build/charts-base/charts-base.js", 8498);
return this._defaultPlaneOffset;
            }
        },

        /**
         * Distance from a data coordinate to the top/bottom for setting a hotspot.
         *
         * @attribute yMarkerPlaneOffset
         * @type Number
         */
        yMarkerPlaneOffset: {
            getter: function() {
                _yuitest_coverfunc("build/charts-base/charts-base.js", "getter", 8509);
_yuitest_coverline("build/charts-base/charts-base.js", 8510);
var marker = this.get("styles").marker;
                _yuitest_coverline("build/charts-base/charts-base.js", 8511);
if(marker && marker.height && isFinite(marker.height))
                {
                    _yuitest_coverline("build/charts-base/charts-base.js", 8513);
return marker.height * 0.5;
                }
                _yuitest_coverline("build/charts-base/charts-base.js", 8515);
return this._defaultPlaneOffset;
            }
        },

        /**
         * Direction of the series
         *
         * @attribute direction
         * @type String
         */
        direction: {
            value: "horizontal"
        },

        /**
         * Indicates whether or not markers for a series will be grouped and rendered in a single complex shape instance.
         *
         * @attribute groupMarkers
         * @type Boolean
         */
        groupMarkers: {
            getter: function()
            {
                _yuitest_coverfunc("build/charts-base/charts-base.js", "getter", 8536);
_yuitest_coverline("build/charts-base/charts-base.js", 8538);
if(this._groupMarkers === undefined)
                {
                    _yuitest_coverline("build/charts-base/charts-base.js", 8540);
return this.get("graph").get("groupMarkers");
                }
                else
                {
                    _yuitest_coverline("build/charts-base/charts-base.js", 8544);
return this._groupMarkers;
                }
            },

            setter: function(val)
            {
                _yuitest_coverfunc("build/charts-base/charts-base.js", "setter", 8548);
_yuitest_coverline("build/charts-base/charts-base.js", 8550);
this._groupMarkers = val;
                _yuitest_coverline("build/charts-base/charts-base.js", 8551);
return val;
            }
        }
    }
});
/**
 * The MarkerSeries class renders quantitative data by plotting relevant data points
 * on a graph.
 *
 * @module charts
 * @submodule charts-base
 * @class MarkerSeries
 * @extends CartesianSeries
 * @uses Plots
 * @constructor
 */
_yuitest_coverline("build/charts-base/charts-base.js", 8567);
Y.MarkerSeries = Y.Base.create("markerSeries", Y.CartesianSeries, [Y.Plots], {
    /**
     * @protected
     *
     * Draws the series.
     *
     * @method drawSeries
     */
    drawSeries: function()
    {
        _yuitest_coverfunc("build/charts-base/charts-base.js", "drawSeries", 8575);
_yuitest_coverline("build/charts-base/charts-base.js", 8577);
this.drawPlots();
    },

    /**
     * @protected
     *
     * Method used by `styles` setter. Overrides base implementation.
     *
     * @method _setStyles
     * @param {Object} newStyles Hash of properties to update.
     * @return Object
     */
    _setStyles: function(val)
    {
        _yuitest_coverfunc("build/charts-base/charts-base.js", "_setStyles", 8589);
_yuitest_coverline("build/charts-base/charts-base.js", 8591);
if(!val.marker)
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 8593);
val = {marker:val};
        }
        _yuitest_coverline("build/charts-base/charts-base.js", 8595);
val = this._parseMarkerStyles(val);
        _yuitest_coverline("build/charts-base/charts-base.js", 8596);
return Y.MarkerSeries.superclass._mergeStyles.apply(this, [val, this._getDefaultStyles()]);
    },

    /**
     * @protected
     *
     * Gets the default value for the `styles` attribute. Overrides
     * base implementation.
     *
     * @method _getDefaultStyles
     * @return Object
     */
    _getDefaultStyles: function()
    {
        _yuitest_coverfunc("build/charts-base/charts-base.js", "_getDefaultStyles", 8608);
_yuitest_coverline("build/charts-base/charts-base.js", 8610);
var styles = this._mergeStyles({marker:this._getPlotDefaults()}, Y.MarkerSeries.superclass._getDefaultStyles());
        _yuitest_coverline("build/charts-base/charts-base.js", 8611);
return styles;
    }
},{
    ATTRS : {
        /**
         * Read-only attribute indicating the type of series.
         *
         * @attribute type
         * @type String
         * @default marker
         */
        type: {
            value:"marker"
        }

        /**
         * Style properties used for drawing markers. This attribute is inherited from `Renderer`. Below are the default
         * values:
         *  <dl>
         *      <dt>fill</dt><dd>A hash containing the following values:
         *          <dl>
         *              <dt>color</dt><dd>Color of the fill. The default value is determined by the order of the series on
         *              the graph. The color will be retrieved from the below array:<br/>
         *              `["#6084d0", "#eeb647", "#6c6b5f", "#d6484f", "#ce9ed1", "#ff9f3b", "#93b7ff", "#e0ddd0", "#94ecba", "#309687"]`
         *              </dd>
         *              <dt>alpha</dt><dd>Number from 0 to 1 indicating the opacity of the marker fill. The default value is 1.</dd>
         *          </dl>
         *      </dd>
         *      <dt>border</dt><dd>A hash containing the following values:
         *          <dl>
         *              <dt>color</dt><dd>Color of the border. The default value is determined by the order of the series on
         *              the graph. The color will be retrieved from the below array:<br/>
         *              `["#205096", "#b38206", "#000000", "#94001e", "#9d6fa0", "#e55b00", "#5e85c9", "#adab9e", "#6ac291", "#006457"]`
         *              <dt>alpha</dt><dd>Number from 0 to 1 indicating the opacity of the marker border. The default value is 1.</dd>
         *              <dt>weight</dt><dd>Number indicating the width of the border. The default value is 1.</dd>
         *          </dl>
         *      </dd>
         *      <dt>width</dt><dd>indicates the width of the marker. The default value is 10.</dd>
         *      <dt>height</dt><dd>indicates the height of the marker The default value is 10.</dd>
         *      <dt>over</dt><dd>hash containing styles for markers when highlighted by a `mouseover` event. The default
         *      values for each style is null. When an over style is not set, the non-over value will be used. For example,
         *      the default value for `marker.over.fill.color` is equivalent to `marker.fill.color`.</dd>
         *  </dl>
         *
         * @attribute styles
         * @type Object
         */
    }
});

/**
 * The LineSeries class renders quantitative data on a graph by connecting relevant data points.
 *
 * @module charts
 * @submodule charts-base
 * @class LineSeries
 * @extends CartesianSeries
 * @uses Lines
 * @constructor
 */
_yuitest_coverline("build/charts-base/charts-base.js", 8671);
Y.LineSeries = Y.Base.create("lineSeries", Y.CartesianSeries, [Y.Lines], {
    /**
     * @protected
     *
     * @method drawSeries
     */
    drawSeries: function()
    {
        _yuitest_coverfunc("build/charts-base/charts-base.js", "drawSeries", 8677);
_yuitest_coverline("build/charts-base/charts-base.js", 8679);
this.drawLines();
    },

    /**
     * @protected
     *
     * Method used by `styles` setter. Overrides base implementation.
     *
     * @method _setStyles
     * @param {Object} newStyles Hash of properties to update.
     * @return Object
     */
    _setStyles: function(val)
    {
        _yuitest_coverfunc("build/charts-base/charts-base.js", "_setStyles", 8691);
_yuitest_coverline("build/charts-base/charts-base.js", 8693);
if(!val.line)
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 8695);
val = {line:val};
        }
        _yuitest_coverline("build/charts-base/charts-base.js", 8697);
return Y.LineSeries.superclass._setStyles.apply(this, [val]);
    },

    /**
     * @protected
     *
     * Gets the default value for the `styles` attribute. Overrides
     * base implementation.
     *
     * @method _getDefaultStyles
     * @return Object
     */
    _getDefaultStyles: function()
    {
        _yuitest_coverfunc("build/charts-base/charts-base.js", "_getDefaultStyles", 8709);
_yuitest_coverline("build/charts-base/charts-base.js", 8711);
var styles = this._mergeStyles({line:this._getLineDefaults()}, Y.LineSeries.superclass._getDefaultStyles());
        _yuitest_coverline("build/charts-base/charts-base.js", 8712);
return styles;
    }
},
{
    ATTRS: {
        /**
         * Read-only attribute indicating the type of series.
         *
         * @attribute type
         * @type String
         * @default line
         */
        type: {
            value:"line"
        }

        /**
         * Style properties used for drawing lines. This attribute is inherited from `Renderer`. Below are the
         * default values:
         *  <dl>
         *      <dt>color</dt><dd>The color of the line. The default value is determined by the order of the series
         *      on the graph. The color will be retrieved from the following array:
         *      `["#426ab3", "#d09b2c", "#000000", "#b82837", "#b384b5", "#ff7200", "#779de3", "#cbc8ba", "#7ed7a6", "#007a6c"]`
         *      <dt>weight</dt><dd>Number that indicates the width of the line. The default value is 6.</dd>
         *      <dt>alpha</dt><dd>Number between 0 and 1 that indicates the opacity of the line. The default value is 1.</dd>
         *      <dt>lineType</dt><dd>Indicates whether the line is solid or dashed. The default value is solid.</dd>
         *      <dt>dashLength</dt><dd>When the `lineType` is dashed, indicates the length of the dash. The default
         *      value is 10.</dd>
         *      <dt>gapSpace</dt><dd>When the `lineType` is dashed, indicates the distance between dashes. The default
         *      value is 10.</dd>
         *      <dt>connectDiscontinuousPoints</dt><dd>Indicates whether or not to connect lines when there is a missing
         *      or null value between points. The default value is true.</dd>
         *      <dt>discontinuousType</dt><dd>Indicates whether the line between discontinuous points is solid or dashed.
         *      The default value is solid.</dd>
         *      <dt>discontinuousDashLength</dt><dd>When the `discontinuousType` is dashed, indicates the length of the
         *      dash. The default value is 10.</dd>
         *      <dt>discontinuousGapSpace</dt><dd>When the `discontinuousType` is dashed, indicates the distance between
         *      dashes. The default value is 10.</dd>
         *  </dl>
         *
         * @attribute styles
         * @type Object
         */
    }
});






/**
 * SplineSeries renders a graph with data points connected by a curve.
 *
 * @module charts
 * @submodule charts-base
 * @class SplineSeries
 * @constructor
 * @extends CartesianSeries
 * @uses CurveUtil
 * @uses Lines
 */
_yuitest_coverline("build/charts-base/charts-base.js", 8774);
Y.SplineSeries = Y.Base.create("splineSeries",  Y.LineSeries, [Y.CurveUtil, Y.Lines], {
    /**
     * @protected
     *
     * Draws the series.
     *
     * @method drawSeries
     */
    drawSeries: function()
    {
        _yuitest_coverfunc("build/charts-base/charts-base.js", "drawSeries", 8782);
_yuitest_coverline("build/charts-base/charts-base.js", 8784);
this.drawSpline();
    }
}, {
	ATTRS : {
        /**
         * Read-only attribute indicating the type of series.
         *
         * @attribute type
         * @type String
         * @default spline
         */
        type : {
            value:"spline"
        }

        /**
         * Style properties used for drawing lines. This attribute is inherited from `Renderer`.
         * Below are the default values:
         *  <dl>
         *      <dt>color</dt><dd>The color of the line. The default value is determined by the order of the series on
         *      the graph. The color will be retrieved from the following array:
         *      `["#426ab3", "#d09b2c", "#000000", "#b82837", "#b384b5", "#ff7200", "#779de3", "#cbc8ba", "#7ed7a6", "#007a6c"]`
         *      <dt>weight</dt><dd>Number that indicates the width of the line. The default value is 6.</dd>
         *      <dt>alpha</dt><dd>Number between 0 and 1 that indicates the opacity of the line. The default value is 1.</dd>
         *      <dt>lineType</dt><dd>Indicates whether the line is solid or dashed. The default value is solid.</dd>
         *      <dt>dashLength</dt><dd>When the `lineType` is dashed, indicates the length of the dash. The default value
         *      is 10.</dd>
         *      <dt>gapSpace</dt><dd>When the `lineType` is dashed, indicates the distance between dashes. The default value is
         *      10.</dd>
         *      <dt>connectDiscontinuousPoints</dt><dd>Indicates whether or not to connect lines when there is a missing or null
         *      value between points. The default value is true.</dd>
         *      <dt>discontinuousType</dt><dd>Indicates whether the line between discontinuous points is solid or dashed. The
         *      default value is solid.</dd>
         *      <dt>discontinuousDashLength</dt><dd>When the `discontinuousType` is dashed, indicates the length of the dash.
         *      The default value is 10.</dd>
         *      <dt>discontinuousGapSpace</dt><dd>When the `discontinuousType` is dashed, indicates the distance between dashes.
         *      The default value is 10.</dd>
         *  </dl>
         *
         * @attribute styles
         * @type Object
         */
    }
});






/**
 * StackedSplineSeries creates spline graphs in which the different series are stacked along a value axis
 * to indicate their contribution to a cumulative total.
 *
 * @module charts
 * @submodule charts-base
 * @class StackedSplineSeries
 * @constructor
 * @extends SplineSeries
 * @extends StackingUtil
 */
_yuitest_coverline("build/charts-base/charts-base.js", 8845);
Y.StackedSplineSeries = Y.Base.create("stackedSplineSeries", Y.SplineSeries, [Y.StackingUtil], {
    /**
     * @protected
     *
     * Calculates the coordinates for the series. Overrides base implementation.
     *
     * @method setAreaData
     */
    setAreaData: function()
    {
        _yuitest_coverfunc("build/charts-base/charts-base.js", "setAreaData", 8853);
_yuitest_coverline("build/charts-base/charts-base.js", 8855);
Y.StackedSplineSeries.superclass.setAreaData.apply(this);
        _yuitest_coverline("build/charts-base/charts-base.js", 8856);
this._stackCoordinates.apply(this);
    }
}, {
    ATTRS: {
        /**
         * Read-only attribute indicating the type of series.
         *
         * @attribute type
         * @type String
         * @default stackedSpline
         */
        type: {
            value:"stackedSpline"
        }
    }
});

/**
 * StackedMarkerSeries plots markers with different series stacked along the value axis to indicate each
 * series' contribution to a cumulative total.
 *
 * @module charts
 * @submodule charts-base
 * @class StackedMarkerSeries
 * @constructor
 * @extends MarkerSeries
 * @extends StackingUtil
 */
_yuitest_coverline("build/charts-base/charts-base.js", 8884);
Y.StackedMarkerSeries = Y.Base.create("stackedMarkerSeries", Y.MarkerSeries, [Y.StackingUtil], {
    /**
     * @protected
     *
     * Calculates the coordinates for the series. Overrides base implementation.
     *
     * @method setAreaData
     */
    setAreaData: function()
    {
        _yuitest_coverfunc("build/charts-base/charts-base.js", "setAreaData", 8892);
_yuitest_coverline("build/charts-base/charts-base.js", 8894);
Y.StackedMarkerSeries.superclass.setAreaData.apply(this);
        _yuitest_coverline("build/charts-base/charts-base.js", 8895);
this._stackCoordinates.apply(this);
    }
}, {
    ATTRS: {
        /**
         * Read-only attribute indicating the type of series.
         *
         * @attribute type
         * @type String
         * @default stackedMarker
         */
        type: {
            value:"stackedMarker"
        }
    }
});

/**
 * The ColumnSeries class renders columns positioned horizontally along a category or time axis. The columns'
 * lengths are proportional to the values they represent along a vertical axis.
 * and the relevant data points.
 *
 * @module charts
 * @submodule charts-base
 * @class ColumnSeries
 * @extends MarkerSeries
 * @uses Histogram
 * @constructor
 */
_yuitest_coverline("build/charts-base/charts-base.js", 8924);
Y.ColumnSeries = Y.Base.create("columnSeries", Y.MarkerSeries, [Y.Histogram], {
    /**
     * Helper method for calculating the size of markers.
     *
     * @method _getMarkerDimensions
     * @param {Number} xcoord The x-coordinate representing the data point for the marker.
     * @param {Number} ycoord The y-coordinate representing the data point for the marker.
     * @param {Number} calculatedSize The calculated size for the marker. For a `BarSeries` is it the width. For a `ColumnSeries` it is the height.
     * @param {Number} offset Distance of position offset dictated by other marker series in the same graph.
     * @return Object
     * @private
     */
    _getMarkerDimensions: function(xcoord, ycoord, calculatedSize, offset)
    {
        _yuitest_coverfunc("build/charts-base/charts-base.js", "_getMarkerDimensions", 8936);
_yuitest_coverline("build/charts-base/charts-base.js", 8938);
var config = {
            left: xcoord + offset
        };
        _yuitest_coverline("build/charts-base/charts-base.js", 8941);
if(this._bottomOrigin >= ycoord)
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 8943);
config.top = ycoord;
            _yuitest_coverline("build/charts-base/charts-base.js", 8944);
config.calculatedSize = this._bottomOrigin - config.top;
        }
        else
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 8948);
config.top = this._bottomOrigin;
            _yuitest_coverline("build/charts-base/charts-base.js", 8949);
config.calculatedSize = ycoord - this._bottomOrigin;
        }
        _yuitest_coverline("build/charts-base/charts-base.js", 8951);
return config;
    },

    /**
     * Resizes and positions markers based on a mouse interaction.
     *
     * @method updateMarkerState
     * @param {String} type state of the marker
     * @param {Number} i index of the marker
     * @protected
     */
    updateMarkerState: function(type, i)
    {
        _yuitest_coverfunc("build/charts-base/charts-base.js", "updateMarkerState", 8962);
_yuitest_coverline("build/charts-base/charts-base.js", 8964);
if(this._markers && this._markers[i])
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 8966);
var styles = Y.clone(this.get("styles").marker),
                markerStyles,
                state = this._getState(type),
                xcoords = this.get("xcoords"),
                ycoords = this.get("ycoords"),
                marker = this._markers[i],
                markers,
                graph = this.get("graph"),
                seriesStyles,
                seriesCollection = graph.seriesTypes[this.get("type")],
                seriesLen = seriesCollection.length,
                seriesSize = 0,
                offset = 0,
                renderer,
                n = 0,
                xs = [],
                order = this.get("order"),
                config;
            _yuitest_coverline("build/charts-base/charts-base.js", 8984);
markerStyles = state == "off" || !styles[state] ? Y.clone(styles) : Y.clone(styles[state]);
            _yuitest_coverline("build/charts-base/charts-base.js", 8985);
markerStyles.fill.color = this._getItemColor(markerStyles.fill.color, i);
            _yuitest_coverline("build/charts-base/charts-base.js", 8986);
markerStyles.border.color = this._getItemColor(markerStyles.border.color, i);
            _yuitest_coverline("build/charts-base/charts-base.js", 8987);
config = this._getMarkerDimensions(xcoords[i], ycoords[i], styles.width, offset);
            _yuitest_coverline("build/charts-base/charts-base.js", 8988);
markerStyles.height = config.calculatedSize;
            _yuitest_coverline("build/charts-base/charts-base.js", 8989);
markerStyles.width = Math.min(this._maxSize, markerStyles.width);
            _yuitest_coverline("build/charts-base/charts-base.js", 8990);
marker.set(markerStyles);
            _yuitest_coverline("build/charts-base/charts-base.js", 8991);
for(; n < seriesLen; ++n)
            {
                _yuitest_coverline("build/charts-base/charts-base.js", 8993);
xs[n] = xcoords[i] + seriesSize;
                _yuitest_coverline("build/charts-base/charts-base.js", 8994);
seriesStyles = seriesCollection[n].get("styles").marker;
                _yuitest_coverline("build/charts-base/charts-base.js", 8995);
seriesSize += Math.min(this._maxSize, seriesStyles.width);
                _yuitest_coverline("build/charts-base/charts-base.js", 8996);
if(order > n)
                {
                    _yuitest_coverline("build/charts-base/charts-base.js", 8998);
offset = seriesSize;
                }
                _yuitest_coverline("build/charts-base/charts-base.js", 9000);
offset -= seriesSize/2;
            }
            _yuitest_coverline("build/charts-base/charts-base.js", 9002);
for(n = 0; n < seriesLen; ++n)
            {
                _yuitest_coverline("build/charts-base/charts-base.js", 9004);
markers = seriesCollection[n].get("markers");
                _yuitest_coverline("build/charts-base/charts-base.js", 9005);
if(markers)
                {
                    _yuitest_coverline("build/charts-base/charts-base.js", 9007);
renderer = markers[i];
                    _yuitest_coverline("build/charts-base/charts-base.js", 9008);
if(renderer && renderer !== undefined)
                    {
                        _yuitest_coverline("build/charts-base/charts-base.js", 9010);
renderer.set("x", (xs[n] - seriesSize/2));
                    }
                }
            }
        }
    }
}, {
    ATTRS: {
        /**
         * Read-only attribute indicating the type of series.
         *
         * @attribute type
         * @type String
         * @readOnly
         * @default column
         */
        type: {
            value: "column"
        }

        /**
         * Style properties used for drawing markers. This attribute is inherited from `MarkerSeries`. Below are the default values:
         *  <dl>
         *      <dt>fill</dt><dd>A hash containing the following values:
         *          <dl>
         *              <dt>color</dt><dd>Color of the fill. The default value is determined by the order of the series on the graph. The color
         *              will be retrieved from the below array:<br/>
         *              `["#66007f", "#a86f41", "#295454", "#996ab2", "#e8cdb7", "#90bdbd","#000000","#c3b8ca", "#968373", "#678585"]`
         *              </dd>
         *              <dt>alpha</dt><dd>Number from 0 to 1 indicating the opacity of the marker fill. The default value is 1.</dd>
         *          </dl>
         *      </dd>
         *      <dt>border</dt><dd>A hash containing the following values:
         *          <dl>
         *              <dt>color</dt><dd>Color of the border. The default value is determined by the order of the series on the graph. The color
         *              will be retrieved from the below array:<br/>
         *              `["#205096", "#b38206", "#000000", "#94001e", "#9d6fa0", "#e55b00", "#5e85c9", "#adab9e", "#6ac291", "#006457"]`
         *              <dt>alpha</dt><dd>Number from 0 to 1 indicating the opacity of the marker border. The default value is 1.</dd>
         *              <dt>weight</dt><dd>Number indicating the width of the border. The default value is 1.</dd>
         *          </dl>
         *      </dd>
         *      <dt>width</dt><dd>indicates the width of the marker. The default value is 12.</dd>
         *      <dt>over</dt><dd>hash containing styles for markers when highlighted by a `mouseover` event. The default
         *      values for each style is null. When an over style is not set, the non-over value will be used. For example,
         *      the default value for `marker.over.fill.color` is equivalent to `marker.fill.color`.</dd>
         *  </dl>
         *
         * @attribute styles
         * @type Object
         */
    }
});
/**
 * The BarSeries class renders bars positioned vertically along a category or time axis. The bars'
 * lengths are proportional to the values they represent along a horizontal axis.
 * and the relevant data points.
 *
 * @module charts
 * @submodule charts-base
 * @class BarSeries
 * @extends MarkerSeries
 * @uses Histogram
 * @constructor
 */
_yuitest_coverline("build/charts-base/charts-base.js", 9074);
Y.BarSeries = Y.Base.create("barSeries", Y.MarkerSeries, [Y.Histogram], {
    /**
     * Helper method for calculating the size of markers.
     *
     * @method _getMarkerDimensions
     * @param {Number} xcoord The x-coordinate representing the data point for the marker.
     * @param {Number} ycoord The y-coordinate representing the data point for the marker.
     * @param {Number} calculatedSize The calculated size for the marker. For a `BarSeries` is it the width. For a `ColumnSeries` it is the height.
     * @param {Number} offset Distance of position offset dictated by other marker series in the same graph.
     * @return Object
     * @private
     */
    _getMarkerDimensions: function(xcoord, ycoord, calculatedSize, offset)
    {
        _yuitest_coverfunc("build/charts-base/charts-base.js", "_getMarkerDimensions", 9086);
_yuitest_coverline("build/charts-base/charts-base.js", 9088);
var config = {
            top: ycoord + offset
        };
        _yuitest_coverline("build/charts-base/charts-base.js", 9091);
if(xcoord >= this._leftOrigin)
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 9093);
config.left = this._leftOrigin;
            _yuitest_coverline("build/charts-base/charts-base.js", 9094);
config.calculatedSize = xcoord - config.left;
        }
        else
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 9098);
config.left = xcoord;
            _yuitest_coverline("build/charts-base/charts-base.js", 9099);
config.calculatedSize = this._leftOrigin - xcoord;
        }
        _yuitest_coverline("build/charts-base/charts-base.js", 9101);
return config;
    },

    /**
     * Resizes and positions markers based on a mouse interaction.
     *
     * @method updateMarkerState
     * @param {String} type state of the marker
     * @param {Number} i index of the marker
     * @protected
     */
    updateMarkerState: function(type, i)
    {
        _yuitest_coverfunc("build/charts-base/charts-base.js", "updateMarkerState", 9112);
_yuitest_coverline("build/charts-base/charts-base.js", 9114);
if(this._markers && this._markers[i])
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 9116);
var styles = Y.clone(this.get("styles").marker),
                markerStyles,
                state = this._getState(type),
                xcoords = this.get("xcoords"),
                ycoords = this.get("ycoords"),
                marker = this._markers[i],
                markers,
                graph = this.get("graph"),
                seriesCollection = graph.seriesTypes[this.get("type")],
                seriesLen = seriesCollection.length,
                seriesStyles,
                seriesSize = 0,
                offset = 0,
                renderer,
                n = 0,
                ys = [],
                order = this.get("order"),
                config;
            _yuitest_coverline("build/charts-base/charts-base.js", 9134);
markerStyles = state == "off" || !styles[state] ? styles : styles[state];
            _yuitest_coverline("build/charts-base/charts-base.js", 9135);
markerStyles.fill.color = this._getItemColor(markerStyles.fill.color, i);
            _yuitest_coverline("build/charts-base/charts-base.js", 9136);
markerStyles.border.color = this._getItemColor(markerStyles.border.color, i);
            _yuitest_coverline("build/charts-base/charts-base.js", 9137);
config = this._getMarkerDimensions(xcoords[i], ycoords[i], styles.height, offset);
            _yuitest_coverline("build/charts-base/charts-base.js", 9138);
markerStyles.width = config.calculatedSize;
            _yuitest_coverline("build/charts-base/charts-base.js", 9139);
markerStyles.height = Math.min(this._maxSize, markerStyles.height);
            _yuitest_coverline("build/charts-base/charts-base.js", 9140);
marker.set(markerStyles);
            _yuitest_coverline("build/charts-base/charts-base.js", 9141);
for(; n < seriesLen; ++n)
            {
                _yuitest_coverline("build/charts-base/charts-base.js", 9143);
ys[n] = ycoords[i] + seriesSize;
                _yuitest_coverline("build/charts-base/charts-base.js", 9144);
seriesStyles = seriesCollection[n].get("styles").marker;
                _yuitest_coverline("build/charts-base/charts-base.js", 9145);
seriesSize += Math.min(this._maxSize, seriesStyles.height);
                _yuitest_coverline("build/charts-base/charts-base.js", 9146);
if(order > n)
                {
                    _yuitest_coverline("build/charts-base/charts-base.js", 9148);
offset = seriesSize;
                }
                _yuitest_coverline("build/charts-base/charts-base.js", 9150);
offset -= seriesSize/2;
            }
            _yuitest_coverline("build/charts-base/charts-base.js", 9152);
for(n = 0; n < seriesLen; ++n)
            {
                _yuitest_coverline("build/charts-base/charts-base.js", 9154);
markers = seriesCollection[n].get("markers");
                _yuitest_coverline("build/charts-base/charts-base.js", 9155);
if(markers)
                {
                    _yuitest_coverline("build/charts-base/charts-base.js", 9157);
renderer = markers[i];
                    _yuitest_coverline("build/charts-base/charts-base.js", 9158);
if(renderer && renderer !== undefined)
                    {
                        _yuitest_coverline("build/charts-base/charts-base.js", 9160);
renderer.set("y", (ys[n] - seriesSize/2));
                    }
                }
            }
        }
    }
}, {
    ATTRS: {
        /**
         * Read-only attribute indicating the type of series.
         *
         * @attribute type
         * @type String
         * @default bar
         */
        type: {
            value: "bar"
        },

        /**
         * Indicates the direction of the category axis that the bars are plotted against.
         *
         * @attribute direction
         * @type String
         */
        direction: {
            value: "vertical"
        }

        /**
         * Style properties used for drawing markers. This attribute is inherited from `MarkerSeries`. Below are the default values:
         *  <dl>
         *      <dt>fill</dt><dd>A hash containing the following values:
         *          <dl>
         *              <dt>color</dt><dd>Color of the fill. The default value is determined by the order of the series on the graph. The color
         *              will be retrieved from the below array:<br/>
         *              `["#66007f", "#a86f41", "#295454", "#996ab2", "#e8cdb7", "#90bdbd","#000000","#c3b8ca", "#968373", "#678585"]`
         *              </dd>
         *              <dt>alpha</dt><dd>Number from 0 to 1 indicating the opacity of the marker fill. The default value is 1.</dd>
         *          </dl>
         *      </dd>
         *      <dt>border</dt><dd>A hash containing the following values:
         *          <dl>
         *              <dt>color</dt><dd>Color of the border. The default value is determined by the order of the series on the graph. The color
         *              will be retrieved from the below array:<br/>
         *              `["#205096", "#b38206", "#000000", "#94001e", "#9d6fa0", "#e55b00", "#5e85c9", "#adab9e", "#6ac291", "#006457"]`
         *              <dt>alpha</dt><dd>Number from 0 to 1 indicating the opacity of the marker border. The default value is 1.</dd>
         *              <dt>weight</dt><dd>Number indicating the width of the border. The default value is 1.</dd>
         *          </dl>
         *      </dd>
         *      <dt>height</dt><dd>indicates the width of the marker. The default value is 12.</dd>
         *      <dt>over</dt><dd>hash containing styles for markers when highlighted by a `mouseover` event. The default
         *      values for each style is null. When an over style is not set, the non-over value will be used. For example,
         *      the default value for `marker.over.fill.color` is equivalent to `marker.fill.color`.</dd>
         *  </dl>
         *
         * @attribute styles
         * @type Object
         */
    }
});
/**
 * The AreaSeries class renders quantitative data on a graph by creating a fill between 0
 * and the relevant data points.
 *
 * @module charts
 * @submodule charts-base
 * @class AreaSeries
 * @extends CartesianSeries
 * @uses Fills
 * @constructor
 */
_yuitest_coverline("build/charts-base/charts-base.js", 9232);
Y.AreaSeries = Y.Base.create("areaSeries", Y.CartesianSeries, [Y.Fills], {
    /**
     * @protected
     *
     * Renders the series.
     *
     * @method drawSeries
     */
    drawSeries: function()
    {
        _yuitest_coverfunc("build/charts-base/charts-base.js", "drawSeries", 9240);
_yuitest_coverline("build/charts-base/charts-base.js", 9242);
this.drawFill.apply(this, this._getClosingPoints());
    },

    /**
     * @protected
     *
     * Method used by `styles` setter. Overrides base implementation.
     *
     * @method _setStyles
     * @param {Object} newStyles Hash of properties to update.
     * @return Object
     */
    _setStyles: function(val)
    {
        _yuitest_coverfunc("build/charts-base/charts-base.js", "_setStyles", 9254);
_yuitest_coverline("build/charts-base/charts-base.js", 9256);
if(!val.area)
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 9258);
val = {area:val};
        }
        _yuitest_coverline("build/charts-base/charts-base.js", 9260);
return Y.AreaSeries.superclass._setStyles.apply(this, [val]);
    },

    /**
     * @protected
     *
     * Gets the default value for the `styles` attribute. Overrides
     * base implementation.
     *
     * @method _getDefaultStyles
     * @return Object
     */
    _getDefaultStyles: function()
    {
        _yuitest_coverfunc("build/charts-base/charts-base.js", "_getDefaultStyles", 9272);
_yuitest_coverline("build/charts-base/charts-base.js", 9274);
var styles = this._mergeStyles({area:this._getAreaDefaults()}, Y.AreaSeries.superclass._getDefaultStyles());
        _yuitest_coverline("build/charts-base/charts-base.js", 9275);
return styles;
    }
},
{
    ATTRS: {
        /**
         * Read-only attribute indicating the type of series.
         *
         * @attribute type
         * @type String
         * @default area
         */
        type: {
            value:"area"
        }

        /**
         * Style properties used for drawing area fills. This attribute is inherited from `Renderer`. Below are the default values:
         *
         *  <dl>
         *      <dt>color</dt><dd>The color of the fill. The default value is determined by the order of the series on the graph. The color will be
         *      retrieved from the following array:
         *      `["#66007f", "#a86f41", "#295454", "#996ab2", "#e8cdb7", "#90bdbd","#000000","#c3b8ca", "#968373", "#678585"]`
         *      </dd>
         *      <dt>alpha</dt><dd>Number between 0 and 1 that indicates the opacity of the fill. The default value is 1</dd>
         *  </dl>
         *
         * @attribute styles
         * @type Object
         */
    }
});






/**
 * AreaSplineSeries renders an area graph with data points connected by a curve.
 *
 * @module charts
 * @submodule charts-base
 * @class AreaSplineSeries
 * @constructor
 * @extends CartesianSeries
 * @uses Fills
 * @uses CurveUtil
 */
_yuitest_coverline("build/charts-base/charts-base.js", 9324);
Y.AreaSplineSeries = Y.Base.create("areaSplineSeries", Y.AreaSeries, [Y.CurveUtil], {
    /**
     * @protected
     *
     * Draws the series.
     *
     * @method drawSeries
     */
    drawSeries: function()
    {
        _yuitest_coverfunc("build/charts-base/charts-base.js", "drawSeries", 9332);
_yuitest_coverline("build/charts-base/charts-base.js", 9334);
this.drawAreaSpline();
    }
}, {
	ATTRS : {
        /**
         * Read-only attribute indicating the type of series.
         *
         * @attribute type
         * @type String
         * @default areaSpline
         */
        type: {
            value:"areaSpline"
        }

        /**
         * Style properties used for drawing area fills. This attribute is inherited from `Renderer`. Below are the default values:
         *
         *  <dl>
         *      <dt>color</dt><dd>The color of the fill. The default value is determined by the order of the series on the graph. The color will be
         *      retrieved from the following array:
         *      `["#66007f", "#a86f41", "#295454", "#996ab2", "#e8cdb7", "#90bdbd","#000000","#c3b8ca", "#968373", "#678585"]`
         *      </dd>
         *      <dt>alpha</dt><dd>Number between 0 and 1 that indicates the opacity of the fill. The default value is 1</dd>
         *  </dl>
         *
         * @attribute styles
         * @type Object
         */
    }
});

/**
 * StackedAreaSplineSeries creates a stacked area chart with points data points connected by a curve.
 *
 * @module charts
 * @submodule charts-base
 * @class StackedAreaSplineSeries
 * @constructor
 * @extends AreaSeries
 * @uses CurveUtil
 * @uses StackingUtil
 */
_yuitest_coverline("build/charts-base/charts-base.js", 9377);
Y.StackedAreaSplineSeries = Y.Base.create("stackedAreaSplineSeries", Y.AreaSeries, [Y.CurveUtil, Y.StackingUtil], {
    /**
     * @protected
     *
     * Draws the series.
     *
     * @method drawSeries
     */
    drawSeries: function()
    {
        _yuitest_coverfunc("build/charts-base/charts-base.js", "drawSeries", 9385);
_yuitest_coverline("build/charts-base/charts-base.js", 9387);
this._stackCoordinates();
        _yuitest_coverline("build/charts-base/charts-base.js", 9388);
this.drawStackedAreaSpline();
    }
}, {
    ATTRS : {
        /**
         * Read-only attribute indicating the type of series.
         *
         * @attribute type
         * @type String
         * @default stackedAreaSpline
         */
        type: {
            value:"stackedAreaSpline"
        }
    }
});

/**
 * The ComboSeries class renders a combination of lines, plots and area fills in a single series.
 * Each series type has a corresponding boolean attribute indicating if it is rendered. By default,
 * lines and plots are rendered and area is not.
 *
 * @module charts
 * @submodule charts-base
 * @class ComboSeries
 * @extends CartesianSeries
 * @uses Fills
 * @uses Lines
 * @uses Plots
 * @constructor
 */
_yuitest_coverline("build/charts-base/charts-base.js", 9419);
Y.ComboSeries = Y.Base.create("comboSeries", Y.CartesianSeries, [Y.Fills, Y.Lines, Y.Plots], {
	/**
     * @protected
     *
     * Draws the series.
     *
     * @method drawSeries
     */
    drawSeries: function()
    {
        _yuitest_coverfunc("build/charts-base/charts-base.js", "drawSeries", 9427);
_yuitest_coverline("build/charts-base/charts-base.js", 9429);
if(this.get("showAreaFill"))
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 9431);
this.drawFill.apply(this, this._getClosingPoints());
        }
        _yuitest_coverline("build/charts-base/charts-base.js", 9433);
if(this.get("showLines"))
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 9435);
this.drawLines();
        }
        _yuitest_coverline("build/charts-base/charts-base.js", 9437);
if(this.get("showMarkers"))
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 9439);
this.drawPlots();
        }
    },

    /**
     * Toggles visibility
     *
     * @method _toggleVisible
     * @param {Boolean} visible indicates visibilitye
     * @private
     */
    _toggleVisible: function(visible)
    {
        _yuitest_coverfunc("build/charts-base/charts-base.js", "_toggleVisible", 9450);
_yuitest_coverline("build/charts-base/charts-base.js", 9452);
var markers,
            marker,
            len,
            i;
        _yuitest_coverline("build/charts-base/charts-base.js", 9456);
if(this.get("showAreaFill") && this._path)
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 9458);
this._path.set("visible", visible);
        }
        _yuitest_coverline("build/charts-base/charts-base.js", 9460);
if(this.get("showLines") && this._lineGraphic)
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 9462);
this._lineGraphic.set("visible", visible);
        }
        _yuitest_coverline("build/charts-base/charts-base.js", 9464);
if(this.get("showMarkers"))
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 9466);
markers = this.get("markers");
            _yuitest_coverline("build/charts-base/charts-base.js", 9467);
if(markers)
            {
                _yuitest_coverline("build/charts-base/charts-base.js", 9469);
i = 0;
                _yuitest_coverline("build/charts-base/charts-base.js", 9470);
len = markers.length;
                _yuitest_coverline("build/charts-base/charts-base.js", 9471);
for(; i < len; ++i)
                {
                    _yuitest_coverline("build/charts-base/charts-base.js", 9473);
marker = markers[i];
                    _yuitest_coverline("build/charts-base/charts-base.js", 9474);
if(marker)
                    {
                        _yuitest_coverline("build/charts-base/charts-base.js", 9476);
marker.set("visible", visible);
                    }
                }
            }
        }
    },

    /**
     * @protected
     *
     * Returns the default hash for the `styles` attribute.
     *
     * @method _getDefaultStyles
     * @return Object
     */
    _getDefaultStyles: function()
    {
        _yuitest_coverfunc("build/charts-base/charts-base.js", "_getDefaultStyles", 9491);
_yuitest_coverline("build/charts-base/charts-base.js", 9493);
var styles = Y.ComboSeries.superclass._getDefaultStyles();
        _yuitest_coverline("build/charts-base/charts-base.js", 9494);
styles.line = this._getLineDefaults();
        _yuitest_coverline("build/charts-base/charts-base.js", 9495);
styles.marker = this._getPlotDefaults();
        _yuitest_coverline("build/charts-base/charts-base.js", 9496);
styles.area = this._getAreaDefaults();
        _yuitest_coverline("build/charts-base/charts-base.js", 9497);
return styles;
    }
},
{
    ATTRS: {
        /**
         * Read-only attribute indicating the type of series.
         *
         * @attribute type
         * @type String
         * @default combo
         */
        type: {
            value:"combo"
        },

        /**
         * Indicates whether a fill is displayed.
         *
         * @attribute showAreaFill
         * @type Boolean
         * @default false
         */
        showAreaFill: {
            value: false
        },

        /**
         * Indicates whether lines are displayed.
         *
         * @attribute showLines
         * @type Boolean
         * @default true
         */
        showLines: {
            value: true
        },

        /**
         * Indicates whether markers are displayed.
         *
         * @attribute showMarkers
         * @type Boolean
         * @default true
         */
        showMarkers: {
            value: true
        },

        /**
         * Reference to the styles of the markers. These styles can also
         * be accessed through the `styles` attribute. Below are default
         * values:
         *  <dl>
         *      <dt>fill</dt><dd>A hash containing the following values:
         *          <dl>
         *              <dt>color</dt><dd>Color of the fill. The default value is determined by the order of the series on the
         *              graph. The color will be retrieved from the below array:<br/>
         *              `["#6084d0", "#eeb647", "#6c6b5f", "#d6484f", "#ce9ed1", "#ff9f3b", "#93b7ff", "#e0ddd0", "#94ecba", "#309687"]`
         *              </dd>
         *              <dt>alpha</dt><dd>Number from 0 to 1 indicating the opacity of the marker fill. The default value is 1.</dd>
         *          </dl>
         *      </dd>
         *      <dt>border</dt><dd>A hash containing the following values:
         *          <dl>
         *              <dt>color</dt><dd>Color of the border. The default value is determined by the order of the series on the graph.
         *              The color will be retrieved from the below array:<br/>
         *              `["#205096", "#b38206", "#000000", "#94001e", "#9d6fa0", "#e55b00", "#5e85c9", "#adab9e", "#6ac291", "#006457"]`
         *              <dt>alpha</dt><dd>Number from 0 to 1 indicating the opacity of the marker border. The default value is 1.</dd>
         *              <dt>weight</dt><dd>Number indicating the width of the border. The default value is 1.</dd>
         *          </dl>
         *      </dd>
         *      <dt>width</dt><dd>indicates the width of the marker. The default value is 10.</dd>
         *      <dt>height</dt><dd>indicates the height of the marker The default value is 10.</dd>
         *      <dt>over</dt><dd>hash containing styles for markers when highlighted by a `mouseover` event. The default
         *      values for each style is null. When an over style is not set, the non-over value will be used. For example,
         *      the default value for `marker.over.fill.color` is equivalent to `marker.fill.color`.</dd>
         *  </dl>
         *
         * @attribute marker
         * @type Object
         */
        marker: {
            lazyAdd: false,
            getter: function()
            {
                _yuitest_coverfunc("build/charts-base/charts-base.js", "getter", 9581);
_yuitest_coverline("build/charts-base/charts-base.js", 9583);
return this.get("styles").marker;
            },
            setter: function(val)
            {
                _yuitest_coverfunc("build/charts-base/charts-base.js", "setter", 9585);
_yuitest_coverline("build/charts-base/charts-base.js", 9587);
this.set("styles", {marker:val});
            }
        },

        /**
         * Reference to the styles of the lines. These styles can also be accessed through the `styles` attribute.
         * Below are the default values:
         *  <dl>
         *      <dt>color</dt><dd>The color of the line. The default value is determined by the order of the series on the graph. The color
         *      will be retrieved from the following array:
         *      `["#426ab3", "#d09b2c", "#000000", "#b82837", "#b384b5", "#ff7200", "#779de3", "#cbc8ba", "#7ed7a6", "#007a6c"]`
         *      <dt>weight</dt><dd>Number that indicates the width of the line. The default value is 6.</dd>
         *      <dt>alpha</dt><dd>Number between 0 and 1 that indicates the opacity of the line. The default value is 1.</dd>
         *      <dt>lineType</dt><dd>Indicates whether the line is solid or dashed. The default value is solid.</dd>
         *      <dt>dashLength</dt><dd>When the `lineType` is dashed, indicates the length of the dash. The default value is 10.</dd>
         *      <dt>gapSpace</dt><dd>When the `lineType` is dashed, indicates the distance between dashes. The default value is 10.</dd>
         *      <dt>connectDiscontinuousPoints</dt><dd>Indicates whether or not to connect lines when there is a missing or null value
         *      between points. The default value is true.</dd>
         *      <dt>discontinuousType</dt><dd>Indicates whether the line between discontinuous points is solid or dashed. The default
         *      value is solid.</dd>
         *      <dt>discontinuousDashLength</dt><dd>When the `discontinuousType` is dashed, indicates the length of the dash. The default
         *      value is 10.</dd>
         *      <dt>discontinuousGapSpace</dt><dd>When the `discontinuousType` is dashed, indicates the distance between dashes. The default
         *      value is 10.</dd>
         *  </dl>
         *
         * @attribute line
         * @type Object
         */
        line: {
            lazyAdd: false,
            getter: function()
            {
                _yuitest_coverfunc("build/charts-base/charts-base.js", "getter", 9618);
_yuitest_coverline("build/charts-base/charts-base.js", 9620);
return this.get("styles").line;
            },
            setter: function(val)
            {
                _yuitest_coverfunc("build/charts-base/charts-base.js", "setter", 9622);
_yuitest_coverline("build/charts-base/charts-base.js", 9624);
this.set("styles", {line:val});
            }
        },

        /**
         * Reference to the styles of the area fills. These styles can also be accessed through the `styles` attribute.
         * Below are the default values:
         *
         *  <dl>
         *      <dt>color</dt><dd>The color of the fill. The default value is determined by the order of the series on the
         *      graph. The color will be retrieved from the following array:
         *      `["#66007f", "#a86f41", "#295454", "#996ab2", "#e8cdb7", "#90bdbd","#000000","#c3b8ca", "#968373", "#678585"]`
         *      </dd>
         *      <dt>alpha</dt><dd>Number between 0 and 1 that indicates the opacity of the fill. The default value is 1</dd>
         *  </dl>
         *
         * @attribute area
         * @type Object
         */
        area: {
            lazyAdd: false,
            getter: function()
            {
                _yuitest_coverfunc("build/charts-base/charts-base.js", "getter", 9645);
_yuitest_coverline("build/charts-base/charts-base.js", 9647);
return this.get("styles").area;
            },
            setter: function(val)
            {
                _yuitest_coverfunc("build/charts-base/charts-base.js", "setter", 9649);
_yuitest_coverline("build/charts-base/charts-base.js", 9651);
this.set("styles", {area:val});
            }
        }

        /**
         * Style properties for the series. Contains a key indexed hash of the following:
         *  <dl>
         *      <dt>marker</dt><dd>Style properties for the markers in the series. Specific style attributes are listed
         *      <a href="#attr_marker">here</a>.</dd>
         *      <dt>line</dt><dd>Style properties for the lines in the series. Specific
         *      style attributes are listed <a href="#attr_line">here</a>.</dd>
         *      <dt>area</dt><dd>Style properties for the area fills in the series. Specific style attributes are listed
         *      <a href="#attr_area">here</a>.</dd>
         *  </dl>
         *
         * @attribute styles
         * @type Object
         */
    }
});






/**
 * The StackedComboSeries class renders a combination of lines, plots and area fills in a single series. Series
 * are stacked along the value axis to indicate each series contribution to a cumulative total. Each
 * series type has a corresponding boolean attribute indicating if it is rendered. By default, all three types are
 * rendered.
 *
 * @module charts
 * @submodule charts-base
 * @class StackedComboSeries
 * @extends ComboSeries
 * @uses StackingUtil
 * @constructor
 */
_yuitest_coverline("build/charts-base/charts-base.js", 9690);
Y.StackedComboSeries = Y.Base.create("stackedComboSeries", Y.ComboSeries, [Y.StackingUtil], {
    /**
     * @protected
     *
     * Calculates the coordinates for the series. Overrides base implementation.
     *
     * @method setAreaData
     */
    setAreaData: function()
    {
        _yuitest_coverfunc("build/charts-base/charts-base.js", "setAreaData", 9698);
_yuitest_coverline("build/charts-base/charts-base.js", 9700);
Y.StackedComboSeries.superclass.setAreaData.apply(this);
        _yuitest_coverline("build/charts-base/charts-base.js", 9701);
this._stackCoordinates.apply(this);
    },

    /**
     * @protected
     *
     * Draws the series.
     *
     * @method drawSeries
     */
    drawSeries: function()
    {
        _yuitest_coverfunc("build/charts-base/charts-base.js", "drawSeries", 9711);
_yuitest_coverline("build/charts-base/charts-base.js", 9713);
if(this.get("showAreaFill"))
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 9715);
this.drawFill.apply(this, this._getStackedClosingPoints());
        }
        _yuitest_coverline("build/charts-base/charts-base.js", 9717);
if(this.get("showLines"))
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 9719);
this.drawLines();
        }
        _yuitest_coverline("build/charts-base/charts-base.js", 9721);
if(this.get("showMarkers"))
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 9723);
this.drawPlots();
        }
    }

}, {
    ATTRS : {
        /**
         * Read-only attribute indicating the type of series.
         *
         * @attribute type
         * @type String
         * @default stackedCombo
         */
        type: {
            value: "stackedCombo"
        },

        /**
         * Indicates whether a fill is displayed.
         *
         * @attribute showAreaFill
         * @type Boolean
         * @default true
         */
        showAreaFill: {
            value: true
        }
    }
});
/**
 * The ComboSplineSeries class renders a combination of splines, plots and areaspline fills in a single series. Each
 * series type has a corresponding boolean attribute indicating if it is rendered. By default, splines and plots
 * are rendered and areaspline is not.
 *
 * @module charts
 * @submodule charts-base
 * @class ComboSplineSeries
 * @extends ComboSeries
 * @extends CurveUtil
 * @constructor
 */
_yuitest_coverline("build/charts-base/charts-base.js", 9764);
Y.ComboSplineSeries = Y.Base.create("comboSplineSeries", Y.ComboSeries, [Y.CurveUtil], {
    /**
     * @protected
     *
     * Draws the series.
     *
     * @method drawSeries
     */
    drawSeries: function()
    {
        _yuitest_coverfunc("build/charts-base/charts-base.js", "drawSeries", 9772);
_yuitest_coverline("build/charts-base/charts-base.js", 9774);
if(this.get("showAreaFill"))
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 9776);
this.drawAreaSpline();
        }
        _yuitest_coverline("build/charts-base/charts-base.js", 9778);
if(this.get("showLines"))
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 9780);
this.drawSpline();
        }
        _yuitest_coverline("build/charts-base/charts-base.js", 9782);
if(this.get("showMarkers"))
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 9784);
this.drawPlots();
        }
    }
}, {
    ATTRS: {
        /**
         * Read-only attribute indicating the type of series.
         *
         * @attribute type
         * @type String
         * @default comboSpline
         */
        type: {
            value : "comboSpline"
        }
    }
});
/**
 * The StackedComboSplineSeries class renders a combination of splines, plots and areaspline fills in a single series. Series
 * are stacked along the value axis to indicate each series contribution to a cumulative total. Each
 * series type has a corresponding boolean attribute indicating if it is rendered. By default, all three types are
 * rendered.
 *
 * @module charts
 * @submodule charts-base
 * @class StackedComboSplineSeries
 * @extends StackedComboSeries
 * @uses CurveUtil
 * @constructor
 */
_yuitest_coverline("build/charts-base/charts-base.js", 9814);
Y.StackedComboSplineSeries = Y.Base.create("stackedComboSplineSeries", Y.StackedComboSeries, [Y.CurveUtil], {
    /**
	 * @protected
     *
     * Draws the series.
     *
     * @method drawSeries
	 */
	drawSeries: function()
    {
        _yuitest_coverfunc("build/charts-base/charts-base.js", "drawSeries", 9822);
_yuitest_coverline("build/charts-base/charts-base.js", 9824);
if(this.get("showAreaFill"))
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 9826);
this.drawStackedAreaSpline();
        }
        _yuitest_coverline("build/charts-base/charts-base.js", 9828);
if(this.get("showLines"))
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 9830);
this.drawSpline();
        }
        _yuitest_coverline("build/charts-base/charts-base.js", 9832);
if(this.get("showMarkers"))
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 9834);
this.drawPlots();
        }
    }
}, {
    ATTRS: {
        /**
         * Read-only attribute indicating the type of series.
         *
         * @attribute type
         * @type String
         * @default stackedComboSpline
         */
        type : {
            value : "stackedComboSpline"
        },

        /**
         * Indicates whether a fill is displayed.
         *
         * @attribute showAreaFill
         * @type Boolean
         * @default true
         */
        showAreaFill: {
            value: true
        }
    }
});
/**
 * StackedLineSeries creates line graphs in which the different series are stacked along a value axis
 * to indicate their contribution to a cumulative total.
 *
 * @module charts
 * @submodule charts-base
 * @class StackedLineSeries
 * @constructor
 * @extends  LineSeries
 * @uses StackingUtil
 */
_yuitest_coverline("build/charts-base/charts-base.js", 9873);
Y.StackedLineSeries = Y.Base.create("stackedLineSeries", Y.LineSeries, [Y.StackingUtil], {
    /**
     * @protected
     *
     * Calculates the coordinates for the series. Overrides base implementation.
     *
     * @method setAreaData
     */
    setAreaData: function()
    {
        _yuitest_coverfunc("build/charts-base/charts-base.js", "setAreaData", 9881);
_yuitest_coverline("build/charts-base/charts-base.js", 9883);
Y.StackedLineSeries.superclass.setAreaData.apply(this);
        _yuitest_coverline("build/charts-base/charts-base.js", 9884);
this._stackCoordinates.apply(this);
    }
}, {
    ATTRS: {
        /**
         * Read-only attribute indicating the type of series.
         *
         * @attribute type
         * @type String
         * @default stackedLine
         */
        type: {
            value:"stackedLine"
        }
    }
});
/**
 * StackedAreaSeries area fills to display data showing its contribution to a whole.
 *
 * @module charts
 * @submodule charts-base
 * @class StackedAreaSeries
 * @constructor
 * @param {Object} config (optional) Configuration parameters for the Chart.
 * @extends AreaSeries
 * @uses StackingUtil
 */
_yuitest_coverline("build/charts-base/charts-base.js", 9911);
Y.StackedAreaSeries = Y.Base.create("stackedAreaSeries", Y.AreaSeries, [Y.StackingUtil], {
    /**
     * @protected
     *
     * Calculates the coordinates for the series. Overrides base implementation.
     *
     * @method setAreaData
     */
    setAreaData: function()
    {
        _yuitest_coverfunc("build/charts-base/charts-base.js", "setAreaData", 9919);
_yuitest_coverline("build/charts-base/charts-base.js", 9921);
Y.StackedAreaSeries.superclass.setAreaData.apply(this);
        _yuitest_coverline("build/charts-base/charts-base.js", 9922);
this._stackCoordinates.apply(this);
    },

    /**
     * @protected
     *
     * Draws the series
     *
     * @method drawSeries
     */
	drawSeries: function()
    {
        _yuitest_coverfunc("build/charts-base/charts-base.js", "drawSeries", 9932);
_yuitest_coverline("build/charts-base/charts-base.js", 9934);
this.drawFill.apply(this, this._getStackedClosingPoints());
    }
}, {
    ATTRS: {
        /**
         * Read-only attribute indicating the type of series.
         *
         * @attribute type
         * @type String
         * @default stackedArea
         */
        type: {
            value:"stackedArea"
        }
    }
});
/**
 * The StackedColumnSeries renders column chart in which series are stacked vertically to show
 * their contribution to the cumulative total.
 *
 * @module charts
 * @submodule charts-base
 * @class StackedColumnSeries
 * @extends ColumnSeries
 * @uses StackingUtil
 * @constructor
 */
_yuitest_coverline("build/charts-base/charts-base.js", 9961);
Y.StackedColumnSeries = Y.Base.create("stackedColumnSeries", Y.ColumnSeries, [Y.StackingUtil], {
    /**
     * Draws the series.
     *
     * @method drawSeries
	 * @protected
	 */
	drawSeries: function()
	{
        _yuitest_coverfunc("build/charts-base/charts-base.js", "drawSeries", 9968);
_yuitest_coverline("build/charts-base/charts-base.js", 9970);
if(this.get("xcoords").length < 1)
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 9972);
return;
        }
        _yuitest_coverline("build/charts-base/charts-base.js", 9974);
var isNumber = Y_Lang.isNumber,
            style = Y.clone(this.get("styles").marker),
            w = style.width,
            h = style.height,
            xcoords = this.get("xcoords"),
            ycoords = this.get("ycoords"),
            i = 0,
            len = xcoords.length,
            top = ycoords[0],
            type = this.get("type"),
            graph = this.get("graph"),
            seriesCollection = graph.seriesTypes[type],
            ratio,
            order = this.get("order"),
            graphOrder = this.get("graphOrder"),
            left,
            marker,
            fillColors,
            borderColors,
            lastCollection,
            negativeBaseValues,
            positiveBaseValues,
            useOrigin = order === 0,
            totalWidth = len * w,
            dimensions = {
                width: [],
                height: []
            },
            xvalues = [],
            yvalues = [],
            groupMarkers = this.get("groupMarkers");
        _yuitest_coverline("build/charts-base/charts-base.js", 10005);
if(Y_Lang.isArray(style.fill.color))
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 10007);
fillColors = style.fill.color.concat();
        }
        _yuitest_coverline("build/charts-base/charts-base.js", 10009);
if(Y_Lang.isArray(style.border.color))
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 10011);
borderColors = style.border.color.concat();
        }
        _yuitest_coverline("build/charts-base/charts-base.js", 10013);
this._createMarkerCache();
        _yuitest_coverline("build/charts-base/charts-base.js", 10014);
if(totalWidth > this.get("width"))
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 10016);
ratio = this.width/totalWidth;
            _yuitest_coverline("build/charts-base/charts-base.js", 10017);
w *= ratio;
            _yuitest_coverline("build/charts-base/charts-base.js", 10018);
w = Math.max(w, 1);
        }
        _yuitest_coverline("build/charts-base/charts-base.js", 10020);
if(!useOrigin)
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 10022);
lastCollection = seriesCollection[order - 1];
            _yuitest_coverline("build/charts-base/charts-base.js", 10023);
negativeBaseValues = lastCollection.get("negativeBaseValues");
            _yuitest_coverline("build/charts-base/charts-base.js", 10024);
positiveBaseValues = lastCollection.get("positiveBaseValues");
            _yuitest_coverline("build/charts-base/charts-base.js", 10025);
if(!negativeBaseValues || !positiveBaseValues)
            {
                _yuitest_coverline("build/charts-base/charts-base.js", 10027);
useOrigin = true;
                _yuitest_coverline("build/charts-base/charts-base.js", 10028);
positiveBaseValues = [];
                _yuitest_coverline("build/charts-base/charts-base.js", 10029);
negativeBaseValues = [];
            }
        }
        else
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 10034);
negativeBaseValues = [];
            _yuitest_coverline("build/charts-base/charts-base.js", 10035);
positiveBaseValues = [];
        }
        _yuitest_coverline("build/charts-base/charts-base.js", 10037);
this.set("negativeBaseValues", negativeBaseValues);
        _yuitest_coverline("build/charts-base/charts-base.js", 10038);
this.set("positiveBaseValues", positiveBaseValues);
        _yuitest_coverline("build/charts-base/charts-base.js", 10039);
for(i = 0; i < len; ++i)
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 10041);
left = xcoords[i];
            _yuitest_coverline("build/charts-base/charts-base.js", 10042);
top = ycoords[i];

            _yuitest_coverline("build/charts-base/charts-base.js", 10044);
if(!isNumber(top) || !isNumber(left))
            {
                _yuitest_coverline("build/charts-base/charts-base.js", 10046);
if(useOrigin)
                {
                    _yuitest_coverline("build/charts-base/charts-base.js", 10048);
negativeBaseValues[i] = this._bottomOrigin;
                    _yuitest_coverline("build/charts-base/charts-base.js", 10049);
positiveBaseValues[i] = this._bottomOrigin;
                }
                _yuitest_coverline("build/charts-base/charts-base.js", 10051);
this._markers.push(null);
                _yuitest_coverline("build/charts-base/charts-base.js", 10052);
continue;
            }
            _yuitest_coverline("build/charts-base/charts-base.js", 10054);
if(useOrigin)
            {
                _yuitest_coverline("build/charts-base/charts-base.js", 10056);
h = Math.abs(this._bottomOrigin - top);
                _yuitest_coverline("build/charts-base/charts-base.js", 10057);
if(top < this._bottomOrigin)
                {
                    _yuitest_coverline("build/charts-base/charts-base.js", 10059);
positiveBaseValues[i] = top;
                    _yuitest_coverline("build/charts-base/charts-base.js", 10060);
negativeBaseValues[i] = this._bottomOrigin;
                }
                else {_yuitest_coverline("build/charts-base/charts-base.js", 10062);
if(top > this._bottomOrigin)
                {
                    _yuitest_coverline("build/charts-base/charts-base.js", 10064);
positiveBaseValues[i] = this._bottomOrigin;
                    _yuitest_coverline("build/charts-base/charts-base.js", 10065);
negativeBaseValues[i] = top;
                    _yuitest_coverline("build/charts-base/charts-base.js", 10066);
top -= h;
                }
                else
                {
                    _yuitest_coverline("build/charts-base/charts-base.js", 10070);
positiveBaseValues[i] = top;
                    _yuitest_coverline("build/charts-base/charts-base.js", 10071);
negativeBaseValues[i] = top;
                }}
            }
            else
            {
                _yuitest_coverline("build/charts-base/charts-base.js", 10076);
if(top > this._bottomOrigin)
                {
                    _yuitest_coverline("build/charts-base/charts-base.js", 10078);
top += (negativeBaseValues[i] - this._bottomOrigin);
                    _yuitest_coverline("build/charts-base/charts-base.js", 10079);
h = top - negativeBaseValues[i];
                    _yuitest_coverline("build/charts-base/charts-base.js", 10080);
negativeBaseValues[i] = top;
                    _yuitest_coverline("build/charts-base/charts-base.js", 10081);
top -= h;
                }
                else {_yuitest_coverline("build/charts-base/charts-base.js", 10083);
if(top <= this._bottomOrigin)
                {
                    _yuitest_coverline("build/charts-base/charts-base.js", 10085);
top = positiveBaseValues[i] - (this._bottomOrigin - top);
                    _yuitest_coverline("build/charts-base/charts-base.js", 10086);
h = positiveBaseValues[i] - top;
                    _yuitest_coverline("build/charts-base/charts-base.js", 10087);
positiveBaseValues[i] = top;
                }}
            }
            _yuitest_coverline("build/charts-base/charts-base.js", 10090);
if(!isNaN(h) && h > 0)
            {
                _yuitest_coverline("build/charts-base/charts-base.js", 10092);
left -= w/2;
                _yuitest_coverline("build/charts-base/charts-base.js", 10093);
if(groupMarkers)
                {
                    _yuitest_coverline("build/charts-base/charts-base.js", 10095);
dimensions.width[i] = w;
                    _yuitest_coverline("build/charts-base/charts-base.js", 10096);
dimensions.height[i] = h;
                    _yuitest_coverline("build/charts-base/charts-base.js", 10097);
xvalues.push(left);
                    _yuitest_coverline("build/charts-base/charts-base.js", 10098);
yvalues.push(top);
                }
                else
                {
                    _yuitest_coverline("build/charts-base/charts-base.js", 10102);
style.width = w;
                    _yuitest_coverline("build/charts-base/charts-base.js", 10103);
style.height = h;
                    _yuitest_coverline("build/charts-base/charts-base.js", 10104);
style.x = left;
                    _yuitest_coverline("build/charts-base/charts-base.js", 10105);
style.y = top;
                    _yuitest_coverline("build/charts-base/charts-base.js", 10106);
if(fillColors)
                    {
                        _yuitest_coverline("build/charts-base/charts-base.js", 10108);
style.fill.color = fillColors[i % fillColors.length];
                    }
                    _yuitest_coverline("build/charts-base/charts-base.js", 10110);
if(borderColors)
                    {
                        _yuitest_coverline("build/charts-base/charts-base.js", 10112);
style.border.color = borderColors[i % borderColors.length];
                    }
                    _yuitest_coverline("build/charts-base/charts-base.js", 10114);
marker = this.getMarker(style, graphOrder, i);
                }
            }
            else {_yuitest_coverline("build/charts-base/charts-base.js", 10117);
if(!groupMarkers)
            {
               _yuitest_coverline("build/charts-base/charts-base.js", 10119);
this._markers.push(null);
            }}
        }
        _yuitest_coverline("build/charts-base/charts-base.js", 10122);
if(groupMarkers)
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 10124);
this._createGroupMarker({
                fill: style.fill,
                border: style.border,
                dimensions: dimensions,
                xvalues: xvalues,
                yvalues: yvalues,
                shape: style.shape
            });
        }
        else
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 10135);
this._clearMarkerCache();
        }
    },

    /**
     * Resizes and positions markers based on a mouse interaction.
     *
     * @method updateMarkerState
     * @param {String} type state of the marker
     * @param {Number} i index of the marker
     * @protected
     */
    updateMarkerState: function(type, i)
    {
        _yuitest_coverfunc("build/charts-base/charts-base.js", "updateMarkerState", 10147);
_yuitest_coverline("build/charts-base/charts-base.js", 10149);
if(this._markers && this._markers[i])
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 10151);
var styles,
                markerStyles,
                state = this._getState(type),
                xcoords = this.get("xcoords"),
                marker = this._markers[i],
                offset = 0,
                fillColor,
                borderColor;
            _yuitest_coverline("build/charts-base/charts-base.js", 10159);
styles = this.get("styles").marker;
            _yuitest_coverline("build/charts-base/charts-base.js", 10160);
offset = styles.width * 0.5;
            _yuitest_coverline("build/charts-base/charts-base.js", 10161);
markerStyles = state == "off" || !styles[state] ? Y.clone(styles) : Y.clone(styles[state]);
            _yuitest_coverline("build/charts-base/charts-base.js", 10162);
markerStyles.height = marker.get("height");
            _yuitest_coverline("build/charts-base/charts-base.js", 10163);
markerStyles.x = (xcoords[i] - offset);
            _yuitest_coverline("build/charts-base/charts-base.js", 10164);
markerStyles.y = marker.get("y");
            _yuitest_coverline("build/charts-base/charts-base.js", 10165);
markerStyles.id = marker.get("id");
            _yuitest_coverline("build/charts-base/charts-base.js", 10166);
fillColor = markerStyles.fill.color;
            _yuitest_coverline("build/charts-base/charts-base.js", 10167);
borderColor = markerStyles.border.color;
            _yuitest_coverline("build/charts-base/charts-base.js", 10168);
if(Y_Lang.isArray(fillColor))
            {
                _yuitest_coverline("build/charts-base/charts-base.js", 10170);
markerStyles.fill.color = fillColor[i % fillColor.length];
            }
            else
            {
                _yuitest_coverline("build/charts-base/charts-base.js", 10174);
markerStyles.fill.color = this._getItemColor(markerStyles.fill.color, i);
            }
            _yuitest_coverline("build/charts-base/charts-base.js", 10176);
if(Y_Lang.isArray(borderColor))
            {
                _yuitest_coverline("build/charts-base/charts-base.js", 10178);
markerStyles.border.color = borderColor[i % borderColor.length];
            }
            else
            {
                _yuitest_coverline("build/charts-base/charts-base.js", 10182);
markerStyles.border.color = this._getItemColor(markerStyles.border.color, i);
            }
            _yuitest_coverline("build/charts-base/charts-base.js", 10184);
marker.set(markerStyles);
        }
    },

    /**
     * Gets the default values for the markers.
     *
     * @method _getPlotDefaults
     * @return Object
     * @protected
     */
    _getPlotDefaults: function()
    {
        _yuitest_coverfunc("build/charts-base/charts-base.js", "_getPlotDefaults", 10195);
_yuitest_coverline("build/charts-base/charts-base.js", 10197);
var defs = {
            fill:{
                type: "solid",
                alpha: 1,
                colors:null,
                alphas: null,
                ratios: null
            },
            border:{
                weight: 0,
                alpha: 1
            },
            width: 24,
            height: 24,
            shape: "rect",

            padding:{
                top: 0,
                left: 0,
                right: 0,
                bottom: 0
            }
        };
        _yuitest_coverline("build/charts-base/charts-base.js", 10220);
defs.fill.color = this._getDefaultColor(this.get("graphOrder"), "fill");
        _yuitest_coverline("build/charts-base/charts-base.js", 10221);
defs.border.color = this._getDefaultColor(this.get("graphOrder"), "border");
        _yuitest_coverline("build/charts-base/charts-base.js", 10222);
return defs;
    }
}, {
    ATTRS: {
        /**
         * Read-only attribute indicating the type of series.
         *
         * @attribute type
         * @type String
         * @default stackedColumn
         */
        type: {
            value: "stackedColumn"
        },

        /**
         * @attribute negativeBaseValues
         * @type Array
         * @default null
         * @private
         */
        negativeBaseValues: {
            value: null
        },

        /**
         * @attribute positiveBaseValues
         * @type Array
         * @default null
         * @private
         */
        positiveBaseValues: {
            value: null
        }

        /**
         * Style properties used for drawing markers. This attribute is inherited from `ColumnSeries`. Below are the default values:
         *  <dl>
         *      <dt>fill</dt><dd>A hash containing the following values:
         *          <dl>
         *              <dt>color</dt><dd>Color of the fill. The default value is determined by the order of the series on the graph. The color
         *              will be retrieved from the below array:<br/>
         *              `["#66007f", "#a86f41", "#295454", "#996ab2", "#e8cdb7", "#90bdbd","#000000","#c3b8ca", "#968373", "#678585"]`
         *              </dd>
         *              <dt>alpha</dt><dd>Number from 0 to 1 indicating the opacity of the marker fill. The default value is 1.</dd>
         *          </dl>
         *      </dd>
         *      <dt>border</dt><dd>A hash containing the following values:
         *          <dl>
         *              <dt>color</dt><dd>Color of the border. The default value is determined by the order of the series on the graph. The color
         *              will be retrieved from the below array:<br/>
         *              `["#205096", "#b38206", "#000000", "#94001e", "#9d6fa0", "#e55b00", "#5e85c9", "#adab9e", "#6ac291", "#006457"]`
         *              <dt>alpha</dt><dd>Number from 0 to 1 indicating the opacity of the marker border. The default value is 1.</dd>
         *              <dt>weight</dt><dd>Number indicating the width of the border. The default value is 1.</dd>
         *          </dl>
         *      </dd>
         *      <dt>width</dt><dd>indicates the width of the marker. The default value is 24.</dd>
         *      <dt>over</dt><dd>hash containing styles for markers when highlighted by a `mouseover` event. The default
         *      values for each style is null. When an over style is not set, the non-over value will be used. For example,
         *      the default value for `marker.over.fill.color` is equivalent to `marker.fill.color`.</dd>
         *  </dl>
         *
         * @attribute styles
         * @type Object
         */
    }
});

/**
 * The StackedBarSeries renders bar chart in which series are stacked horizontally to show
 * their contribution to the cumulative total.
 *
 * @module charts
 * @submodule charts-base
 * @class StackedBarSeries
 * @extends BarSeries
 * @uses StackingUtil
 * @constructor
 */
_yuitest_coverline("build/charts-base/charts-base.js", 10301);
Y.StackedBarSeries = Y.Base.create("stackedBarSeries", Y.BarSeries, [Y.StackingUtil], {
    /**
     * @protected
     *
     * Draws the series.
     *
     * @method drawSeries
     */
    drawSeries: function()
	{
        _yuitest_coverfunc("build/charts-base/charts-base.js", "drawSeries", 10309);
_yuitest_coverline("build/charts-base/charts-base.js", 10311);
if(this.get("xcoords").length < 1)
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 10313);
return;
        }

        _yuitest_coverline("build/charts-base/charts-base.js", 10316);
var isNumber = Y_Lang.isNumber,
            style = Y.clone(this.get("styles").marker),
            w = style.width,
            h = style.height,
            xcoords = this.get("xcoords"),
            ycoords = this.get("ycoords"),
            i = 0,
            len = xcoords.length,
            top = ycoords[0],
            type = this.get("type"),
            graph = this.get("graph"),
            seriesCollection = graph.seriesTypes[type],
            ratio,
            order = this.get("order"),
            graphOrder = this.get("graphOrder"),
            left,
            marker,
            lastCollection,
            negativeBaseValues,
            positiveBaseValues,
            fillColors,
            borderColors,
            useOrigin = order === 0,
            totalHeight = len * h,
            dimensions = {
                width: [],
                height: []
            },
            xvalues = [],
            yvalues = [],
            groupMarkers = this.get("groupMarkers");
        _yuitest_coverline("build/charts-base/charts-base.js", 10347);
if(Y_Lang.isArray(style.fill.color))
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 10349);
fillColors = style.fill.color.concat();
        }
        _yuitest_coverline("build/charts-base/charts-base.js", 10351);
if(Y_Lang.isArray(style.border.color))
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 10353);
borderColors = style.border.color.concat();
        }
        _yuitest_coverline("build/charts-base/charts-base.js", 10355);
this._createMarkerCache();
        _yuitest_coverline("build/charts-base/charts-base.js", 10356);
if(totalHeight > this.get("height"))
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 10358);
ratio = this.height/totalHeight;
            _yuitest_coverline("build/charts-base/charts-base.js", 10359);
h *= ratio;
            _yuitest_coverline("build/charts-base/charts-base.js", 10360);
h = Math.max(h, 1);
        }
        _yuitest_coverline("build/charts-base/charts-base.js", 10362);
if(!useOrigin)
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 10364);
lastCollection = seriesCollection[order - 1];
            _yuitest_coverline("build/charts-base/charts-base.js", 10365);
negativeBaseValues = lastCollection.get("negativeBaseValues");
            _yuitest_coverline("build/charts-base/charts-base.js", 10366);
positiveBaseValues = lastCollection.get("positiveBaseValues");
            _yuitest_coverline("build/charts-base/charts-base.js", 10367);
if(!negativeBaseValues || !positiveBaseValues)
            {
                _yuitest_coverline("build/charts-base/charts-base.js", 10369);
useOrigin = true;
                _yuitest_coverline("build/charts-base/charts-base.js", 10370);
positiveBaseValues = [];
                _yuitest_coverline("build/charts-base/charts-base.js", 10371);
negativeBaseValues = [];
            }
        }
        else
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 10376);
negativeBaseValues = [];
            _yuitest_coverline("build/charts-base/charts-base.js", 10377);
positiveBaseValues = [];
        }
        _yuitest_coverline("build/charts-base/charts-base.js", 10379);
this.set("negativeBaseValues", negativeBaseValues);
        _yuitest_coverline("build/charts-base/charts-base.js", 10380);
this.set("positiveBaseValues", positiveBaseValues);
        _yuitest_coverline("build/charts-base/charts-base.js", 10381);
for(i = 0; i < len; ++i)
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 10383);
top = ycoords[i];
            _yuitest_coverline("build/charts-base/charts-base.js", 10384);
left = xcoords[i];
            _yuitest_coverline("build/charts-base/charts-base.js", 10385);
if(!isNumber(top) || !isNumber(left))
            {
                _yuitest_coverline("build/charts-base/charts-base.js", 10387);
if(useOrigin)
                {
                    _yuitest_coverline("build/charts-base/charts-base.js", 10389);
positiveBaseValues[i] = this._leftOrigin;
                    _yuitest_coverline("build/charts-base/charts-base.js", 10390);
negativeBaseValues[i] = this._leftOrigin;
                }
                _yuitest_coverline("build/charts-base/charts-base.js", 10392);
this._markers.push(null);
                _yuitest_coverline("build/charts-base/charts-base.js", 10393);
continue;
            }
            _yuitest_coverline("build/charts-base/charts-base.js", 10395);
if(useOrigin)
            {
                _yuitest_coverline("build/charts-base/charts-base.js", 10397);
w = Math.abs(left - this._leftOrigin);
                _yuitest_coverline("build/charts-base/charts-base.js", 10398);
if(left > this._leftOrigin)
                {
                    _yuitest_coverline("build/charts-base/charts-base.js", 10400);
positiveBaseValues[i] = left;
                    _yuitest_coverline("build/charts-base/charts-base.js", 10401);
negativeBaseValues[i] = this._leftOrigin;
                    _yuitest_coverline("build/charts-base/charts-base.js", 10402);
left -= w;
                }
                else {_yuitest_coverline("build/charts-base/charts-base.js", 10404);
if(left < this._leftOrigin)
                {
                    _yuitest_coverline("build/charts-base/charts-base.js", 10406);
positiveBaseValues[i] = this._leftOrigin;
                    _yuitest_coverline("build/charts-base/charts-base.js", 10407);
negativeBaseValues[i] = left;
                }
                else
                {
                    _yuitest_coverline("build/charts-base/charts-base.js", 10411);
positiveBaseValues[i] = left;
                    _yuitest_coverline("build/charts-base/charts-base.js", 10412);
negativeBaseValues[i] = this._leftOrigin;
                }}
            }
            else
            {
                _yuitest_coverline("build/charts-base/charts-base.js", 10417);
if(left < this._leftOrigin)
                {
                    _yuitest_coverline("build/charts-base/charts-base.js", 10419);
left = negativeBaseValues[i] - (this._leftOrigin - xcoords[i]);
                    _yuitest_coverline("build/charts-base/charts-base.js", 10420);
w = negativeBaseValues[i] - left;
                    _yuitest_coverline("build/charts-base/charts-base.js", 10421);
negativeBaseValues[i] = left;
                }
                else {_yuitest_coverline("build/charts-base/charts-base.js", 10423);
if(left >= this._leftOrigin)
                {
                    _yuitest_coverline("build/charts-base/charts-base.js", 10425);
left += (positiveBaseValues[i] - this._leftOrigin);
                    _yuitest_coverline("build/charts-base/charts-base.js", 10426);
w = left - positiveBaseValues[i];
                    _yuitest_coverline("build/charts-base/charts-base.js", 10427);
positiveBaseValues[i] = left;
                    _yuitest_coverline("build/charts-base/charts-base.js", 10428);
left -= w;
                }}
            }
            _yuitest_coverline("build/charts-base/charts-base.js", 10431);
if(!isNaN(w) && w > 0)
            {
                _yuitest_coverline("build/charts-base/charts-base.js", 10433);
top -= h/2;
                _yuitest_coverline("build/charts-base/charts-base.js", 10434);
if(groupMarkers)
                {
                    _yuitest_coverline("build/charts-base/charts-base.js", 10436);
dimensions.width[i] = w;
                    _yuitest_coverline("build/charts-base/charts-base.js", 10437);
dimensions.height[i] = h;
                    _yuitest_coverline("build/charts-base/charts-base.js", 10438);
xvalues.push(left);
                    _yuitest_coverline("build/charts-base/charts-base.js", 10439);
yvalues.push(top);
                }
                else
                {
                    _yuitest_coverline("build/charts-base/charts-base.js", 10443);
style.width = w;
                    _yuitest_coverline("build/charts-base/charts-base.js", 10444);
style.height = h;
                    _yuitest_coverline("build/charts-base/charts-base.js", 10445);
style.x = left;
                    _yuitest_coverline("build/charts-base/charts-base.js", 10446);
style.y = top;
                    _yuitest_coverline("build/charts-base/charts-base.js", 10447);
if(fillColors)
                    {
                        _yuitest_coverline("build/charts-base/charts-base.js", 10449);
style.fill.color = fillColors[i % fillColors.length];
                    }
                    _yuitest_coverline("build/charts-base/charts-base.js", 10451);
if(borderColors)
                    {
                        _yuitest_coverline("build/charts-base/charts-base.js", 10453);
style.border.color = borderColors[i % borderColors.length];
                    }
                    _yuitest_coverline("build/charts-base/charts-base.js", 10455);
marker = this.getMarker(style, graphOrder, i);
                }
            }
            else {_yuitest_coverline("build/charts-base/charts-base.js", 10458);
if(!groupMarkers)
            {
                _yuitest_coverline("build/charts-base/charts-base.js", 10460);
this._markers.push(null);
            }}
        }
        _yuitest_coverline("build/charts-base/charts-base.js", 10463);
if(groupMarkers)
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 10465);
this._createGroupMarker({
                fill: style.fill,
                border: style.border,
                dimensions: dimensions,
                xvalues: xvalues,
                yvalues: yvalues,
                shape: style.shape
            });
        }
        else
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 10476);
this._clearMarkerCache();
        }
    },

    /**
     * @protected
     *
     * Resizes and positions markers based on a mouse interaction.
     *
     * @method updateMarkerState
     * @param {String} type state of the marker
     * @param {Number} i index of the marker
     */
    updateMarkerState: function(type, i)
    {
        _yuitest_coverfunc("build/charts-base/charts-base.js", "updateMarkerState", 10489);
_yuitest_coverline("build/charts-base/charts-base.js", 10491);
if(this._markers[i])
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 10493);
var state = this._getState(type),
                ycoords = this.get("ycoords"),
                marker = this._markers[i],
                styles = this.get("styles").marker,
                h = styles.height,
                markerStyles = state == "off" || !styles[state] ? Y.clone(styles) : Y.clone(styles[state]),
                fillColor,
                borderColor;
            _yuitest_coverline("build/charts-base/charts-base.js", 10501);
markerStyles.y = (ycoords[i] - h/2);
            _yuitest_coverline("build/charts-base/charts-base.js", 10502);
markerStyles.x = marker.get("x");
            _yuitest_coverline("build/charts-base/charts-base.js", 10503);
markerStyles.width = marker.get("width");
            _yuitest_coverline("build/charts-base/charts-base.js", 10504);
markerStyles.id = marker.get("id");
            _yuitest_coverline("build/charts-base/charts-base.js", 10505);
fillColor = markerStyles.fill.color;
            _yuitest_coverline("build/charts-base/charts-base.js", 10506);
borderColor = markerStyles.border.color;
            _yuitest_coverline("build/charts-base/charts-base.js", 10507);
if(Y_Lang.isArray(fillColor))
            {
                _yuitest_coverline("build/charts-base/charts-base.js", 10509);
markerStyles.fill.color = fillColor[i % fillColor.length];
            }
            else
            {
                _yuitest_coverline("build/charts-base/charts-base.js", 10513);
markerStyles.fill.color = this._getItemColor(markerStyles.fill.color, i);
            }
            _yuitest_coverline("build/charts-base/charts-base.js", 10515);
if(Y_Lang.isArray(borderColor))
            {
                _yuitest_coverline("build/charts-base/charts-base.js", 10517);
markerStyles.border.color = borderColor[i % borderColor.length];
            }
            else
            {
                _yuitest_coverline("build/charts-base/charts-base.js", 10521);
markerStyles.border.color = this._getItemColor(markerStyles.border.color, i);
            }
            _yuitest_coverline("build/charts-base/charts-base.js", 10523);
marker.set(markerStyles);
        }
    },

    /**
     * @protected
     *
     * Returns default values for the `styles` attribute.
     *
     * @method _getPlotDefaults
     * @return Object
     */
    _getPlotDefaults: function()
    {
        _yuitest_coverfunc("build/charts-base/charts-base.js", "_getPlotDefaults", 10535);
_yuitest_coverline("build/charts-base/charts-base.js", 10537);
var defs = {
            fill:{
                type: "solid",
                alpha: 1,
                colors:null,
                alphas: null,
                ratios: null
            },
            border:{
                weight: 0,
                alpha: 1
            },
            width: 24,
            height: 24,
            shape: "rect",

            padding:{
                top: 0,
                left: 0,
                right: 0,
                bottom: 0
            }
        };
        _yuitest_coverline("build/charts-base/charts-base.js", 10560);
defs.fill.color = this._getDefaultColor(this.get("graphOrder"), "fill");
        _yuitest_coverline("build/charts-base/charts-base.js", 10561);
defs.border.color = this._getDefaultColor(this.get("graphOrder"), "border");
        _yuitest_coverline("build/charts-base/charts-base.js", 10562);
return defs;
    }
}, {
    ATTRS: {
        /**
         * Read-only attribute indicating the type of series.
         *
         * @attribute type
         * @type String
         * @default stackedBar
         */
        type: {
            value: "stackedBar"
        },

        /**
         * Direction of the series
         *
         * @attribute direction
         * @type String
         * @default vertical
         */
        direction: {
            value: "vertical"
        },

        /**
         * @private
         *
         * @attribute negativeBaseValues
         * @type Array
         * @default null
         */
        negativeBaseValues: {
            value: null
        },

        /**
         * @private
         *
         * @attribute positiveBaseValues
         * @type Array
         * @default null
         */
        positiveBaseValues: {
            value: null
        }

        /**
         * Style properties used for drawing markers. This attribute is inherited from `BarSeries`. Below are the default values:
         *  <dl>
         *      <dt>fill</dt><dd>A hash containing the following values:
         *          <dl>
         *              <dt>color</dt><dd>Color of the fill. The default value is determined by the order of the series on the graph. The color
         *              will be retrieved from the below array:<br/>
         *              `["#66007f", "#a86f41", "#295454", "#996ab2", "#e8cdb7", "#90bdbd","#000000","#c3b8ca", "#968373", "#678585"]`
         *              </dd>
         *              <dt>alpha</dt><dd>Number from 0 to 1 indicating the opacity of the marker fill. The default value is 1.</dd>
         *          </dl>
         *      </dd>
         *      <dt>border</dt><dd>A hash containing the following values:
         *          <dl>
         *              <dt>color</dt><dd>Color of the border. The default value is determined by the order of the series on the graph. The color
         *              will be retrieved from the below array:<br/>
         *              `["#205096", "#b38206", "#000000", "#94001e", "#9d6fa0", "#e55b00", "#5e85c9", "#adab9e", "#6ac291", "#006457"]`
         *              <dt>alpha</dt><dd>Number from 0 to 1 indicating the opacity of the marker border. The default value is 1.</dd>
         *              <dt>weight</dt><dd>Number indicating the width of the border. The default value is 1.</dd>
         *          </dl>
         *      </dd>
         *      <dt>height</dt><dd>indicates the width of the marker. The default value is 24.</dd>
         *      <dt>over</dt><dd>hash containing styles for markers when highlighted by a `mouseover` event. The default
         *      values for each style is null. When an over style is not set, the non-over value will be used. For example,
         *      the default value for `marker.over.fill.color` is equivalent to `marker.fill.color`.</dd>
         *  </dl>
         *
         * @attribute styles
         * @type Object
         */
    }
});

/**
 * PieSeries visualizes data as a circular chart divided into wedges which represent data as a
 * percentage of a whole.
 *
 * @module charts
 * @submodule charts-base
 * @class PieSeries
 * @constructor
 * @extends MarkerSeries
 */
_yuitest_coverline("build/charts-base/charts-base.js", 10653);
Y.PieSeries = Y.Base.create("pieSeries", Y.MarkerSeries, [], {
    /**
     * Image map used for interactivity when rendered with canvas.
     *
     * @property _map
     * @type HTMLElement
     * @private
     */
    _map: null,

    /**
     * Image used for image map when rendered with canvas.
     *
     * @property _image
     * @type HTMLElement
     * @private
     */
    _image: null,

    /**
     * Creates or updates the image map when rendered with canvas.
     *
     * @method _setMap
     * @private
     */
    _setMap: function()
    {
        _yuitest_coverfunc("build/charts-base/charts-base.js", "_setMap", 10678);
_yuitest_coverline("build/charts-base/charts-base.js", 10680);
var id = "pieHotSpotMapi_" + Math.round(100000 * Math.random()),
            cb = this.get("graph").get("contentBox"),
            areaNode;
        _yuitest_coverline("build/charts-base/charts-base.js", 10683);
if(this._image)
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 10685);
cb.removeChild(this._image);
            _yuitest_coverline("build/charts-base/charts-base.js", 10686);
while(this._areaNodes && this._areaNodes.length > 0)
            {
                _yuitest_coverline("build/charts-base/charts-base.js", 10688);
areaNode = this._areaNodes.shift();
                _yuitest_coverline("build/charts-base/charts-base.js", 10689);
this._map.removeChild(areaNode);
            }
            _yuitest_coverline("build/charts-base/charts-base.js", 10691);
cb.removeChild(this._map);
        }
        _yuitest_coverline("build/charts-base/charts-base.js", 10693);
this._image = DOCUMENT.createElement("img");
        _yuitest_coverline("build/charts-base/charts-base.js", 10694);
this._image.src = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAYAAAABCAYAAAD9yd/wAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAABJJREFUeNpiZGBgSGPAAgACDAAIkABoFyloZQAAAABJRU5ErkJggg==";
        _yuitest_coverline("build/charts-base/charts-base.js", 10695);
cb.appendChild(this._image);
        _yuitest_coverline("build/charts-base/charts-base.js", 10696);
this._image.setAttribute("usemap", "#" + id);
        _yuitest_coverline("build/charts-base/charts-base.js", 10697);
this._image.style.zIndex = 3;
        _yuitest_coverline("build/charts-base/charts-base.js", 10698);
this._image.style.opacity = 0;
        _yuitest_coverline("build/charts-base/charts-base.js", 10699);
this._image.setAttribute("alt", "imagemap");
        _yuitest_coverline("build/charts-base/charts-base.js", 10700);
this._map = DOCUMENT.createElement("map");
        _yuitest_coverline("build/charts-base/charts-base.js", 10701);
this._map.style.zIndex = 5;
        _yuitest_coverline("build/charts-base/charts-base.js", 10702);
cb.appendChild(this._map);
        _yuitest_coverline("build/charts-base/charts-base.js", 10703);
this._map.setAttribute("name", id);
        _yuitest_coverline("build/charts-base/charts-base.js", 10704);
this._map.setAttribute("id", id);
        _yuitest_coverline("build/charts-base/charts-base.js", 10705);
this._areaNodes = [];
    },

    /**
     * Storage for `categoryDisplayName` attribute.
     *
     * @property _categoryDisplayName
     * @private
     */
    _categoryDisplayName: null,

    /**
     * Storage for `valueDisplayName` attribute.
     *
     * @property _valueDisplayName
     * @private
     */
    _valueDisplayName: null,

    /**
     * Adds event listeners.
     *
     * @method addListeners
     * @private
     */
    addListeners: function()
    {
        _yuitest_coverfunc("build/charts-base/charts-base.js", "addListeners", 10730);
_yuitest_coverline("build/charts-base/charts-base.js", 10732);
var categoryAxis = this.get("categoryAxis"),
            valueAxis = this.get("valueAxis");
        _yuitest_coverline("build/charts-base/charts-base.js", 10734);
if(categoryAxis)
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 10736);
categoryAxis.after("dataReady", Y.bind(this._categoryDataChangeHandler, this));
            _yuitest_coverline("build/charts-base/charts-base.js", 10737);
categoryAxis.after("dataUpdate", Y.bind(this._categoryDataChangeHandler, this));
        }
        _yuitest_coverline("build/charts-base/charts-base.js", 10739);
if(valueAxis)
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 10741);
valueAxis.after("dataReady", Y.bind(this._valueDataChangeHandler, this));
            _yuitest_coverline("build/charts-base/charts-base.js", 10742);
valueAxis.after("dataUpdate", Y.bind(this._valueDataChangeHandler, this));
        }
        _yuitest_coverline("build/charts-base/charts-base.js", 10744);
this.after("categoryAxisChange", this.categoryAxisChangeHandler);
        _yuitest_coverline("build/charts-base/charts-base.js", 10745);
this.after("valueAxisChange", this.valueAxisChangeHandler);
        _yuitest_coverline("build/charts-base/charts-base.js", 10746);
this.after("stylesChange", this._updateHandler);
    },

    /**
     * Draws the series.
     *
     * @method validate
     * @private
     */
    validate: function()
    {
        _yuitest_coverfunc("build/charts-base/charts-base.js", "validate", 10755);
_yuitest_coverline("build/charts-base/charts-base.js", 10757);
this.draw();
        _yuitest_coverline("build/charts-base/charts-base.js", 10758);
this._renderered = true;
    },

    /**
     * Event handler for the categoryAxisChange event.
     *
     * @method _categoryAxisChangeHandler
     * @param {Object} e Event object.
     * @private
     */
    _categoryAxisChangeHandler: function(e)
    {
        _yuitest_coverfunc("build/charts-base/charts-base.js", "_categoryAxisChangeHandler", 10768);
_yuitest_coverline("build/charts-base/charts-base.js", 10770);
var categoryAxis = this.get("categoryAxis");
        _yuitest_coverline("build/charts-base/charts-base.js", 10771);
categoryAxis.after("dataReady", Y.bind(this._categoryDataChangeHandler, this));
        _yuitest_coverline("build/charts-base/charts-base.js", 10772);
categoryAxis.after("dataUpdate", Y.bind(this._categoryDataChangeHandler, this));
    },

    /**
     * Event handler for the valueAxisChange event.
     *
     * @method _valueAxisChangeHandler
     * @param {Object} e Event object.
     * @private
     */
    _valueAxisChangeHandler: function(e)
    {
        _yuitest_coverfunc("build/charts-base/charts-base.js", "_valueAxisChangeHandler", 10782);
_yuitest_coverline("build/charts-base/charts-base.js", 10784);
var valueAxis = this.get("valueAxis");
        _yuitest_coverline("build/charts-base/charts-base.js", 10785);
valueAxis.after("dataReady", Y.bind(this._valueDataChangeHandler, this));
        _yuitest_coverline("build/charts-base/charts-base.js", 10786);
valueAxis.after("dataUpdate", Y.bind(this._valueDataChangeHandler, this));
    },

    /**
     * Constant used to generate unique id.
     *
     * @property GUID
     * @type String
     * @private
     */
    GUID: "pieseries",

    /**
     * Event handler for categoryDataChange event.
     *
     * @method _categoryDataChangeHandler
     * @param {Object} event Event object.
     * @private
     */
    _categoryDataChangeHandler: function(event)
    {
       _yuitest_coverfunc("build/charts-base/charts-base.js", "_categoryDataChangeHandler", 10805);
_yuitest_coverline("build/charts-base/charts-base.js", 10807);
if(this._rendered && this.get("categoryKey") && this.get("valueKey"))
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 10809);
this.draw();
        }
    },

    /**
     * Event handler for valueDataChange event.
     *
     * @method _valueDataChangeHandler
     * @param {Object} event Event object.
     * @private
     */
    _valueDataChangeHandler: function(event)
    {
        _yuitest_coverfunc("build/charts-base/charts-base.js", "_valueDataChangeHandler", 10820);
_yuitest_coverline("build/charts-base/charts-base.js", 10822);
if(this._rendered && this.get("categoryKey") && this.get("valueKey"))
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 10824);
this.draw();
        }
    },

    /**
     * Draws the series. Overrides the base implementation.
     *
     * @method draw
     * @protected
     */
    draw: function()
    {
        _yuitest_coverfunc("build/charts-base/charts-base.js", "draw", 10834);
_yuitest_coverline("build/charts-base/charts-base.js", 10836);
var graph = this.get("graph"),
            w = graph.get("width"),
            h = graph.get("height");
        _yuitest_coverline("build/charts-base/charts-base.js", 10839);
if(isFinite(w) && isFinite(h) && w > 0 && h > 0)
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 10841);
this._rendered = true;
            _yuitest_coverline("build/charts-base/charts-base.js", 10842);
if(this._drawing)
            {
                _yuitest_coverline("build/charts-base/charts-base.js", 10844);
this._callLater = true;
                _yuitest_coverline("build/charts-base/charts-base.js", 10845);
return;
            }
            _yuitest_coverline("build/charts-base/charts-base.js", 10847);
this._drawing = true;
            _yuitest_coverline("build/charts-base/charts-base.js", 10848);
this._callLater = false;
            _yuitest_coverline("build/charts-base/charts-base.js", 10849);
this.drawSeries();
            _yuitest_coverline("build/charts-base/charts-base.js", 10850);
this._drawing = false;
            _yuitest_coverline("build/charts-base/charts-base.js", 10851);
if(this._callLater)
            {
                _yuitest_coverline("build/charts-base/charts-base.js", 10853);
this.draw();
            }
            else
            {
                _yuitest_coverline("build/charts-base/charts-base.js", 10857);
this.fire("drawingComplete");
            }
        }
    },

    /**
     * Draws the markers
     *
     * @method drawPlots
     * @protected
     */
    drawPlots: function()
    {
        _yuitest_coverfunc("build/charts-base/charts-base.js", "drawPlots", 10868);
_yuitest_coverline("build/charts-base/charts-base.js", 10870);
var values = this.get("valueAxis").getDataByKey(this.get("valueKey")).concat(),
            catValues = this.get("categoryAxis").getDataByKey(this.get("categoryKey")).concat(),
            totalValue = 0,
            itemCount = values.length,
            styles = this.get("styles").marker,
            fillColors = styles.fill.colors,
            fillAlphas = styles.fill.alphas || ["1"],
            borderColors = styles.border.colors,
            borderWeights = [styles.border.weight],
            borderAlphas = [styles.border.alpha],
            tbw = borderWeights.concat(),
            tbc = borderColors.concat(),
            tba = borderAlphas.concat(),
            tfc,
            tfa,
            padding = styles.padding,
            graph = this.get("graph"),
            minDimension = Math.min(graph.get("width"), graph.get("height")),
            w = minDimension - (padding.left + padding.right),
            h = minDimension - (padding.top + padding.bottom),
            startAngle = -90,
            halfWidth = w / 2,
            halfHeight = h / 2,
            radius = Math.min(halfWidth, halfHeight),
            i = 0,
            value,
            angle = 0,
            lc,
            la,
            lw,
            wedgeStyle,
            marker,
            graphOrder = this.get("graphOrder"),
            isCanvas = Y.Graphic.NAME == "canvasGraphic";
        _yuitest_coverline("build/charts-base/charts-base.js", 10904);
for(; i < itemCount; ++i)
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 10906);
value = parseFloat(values[i]);

            _yuitest_coverline("build/charts-base/charts-base.js", 10908);
values.push(value);
            _yuitest_coverline("build/charts-base/charts-base.js", 10909);
if(!isNaN(value))
            {
                _yuitest_coverline("build/charts-base/charts-base.js", 10911);
totalValue += value;
            }
        }

        _yuitest_coverline("build/charts-base/charts-base.js", 10915);
tfc = fillColors ? fillColors.concat() : null;
        _yuitest_coverline("build/charts-base/charts-base.js", 10916);
tfa = fillAlphas ? fillAlphas.concat() : null;
        _yuitest_coverline("build/charts-base/charts-base.js", 10917);
this._createMarkerCache();
        _yuitest_coverline("build/charts-base/charts-base.js", 10918);
if(isCanvas)
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 10920);
this._setMap();
            _yuitest_coverline("build/charts-base/charts-base.js", 10921);
this._image.width = w;
            _yuitest_coverline("build/charts-base/charts-base.js", 10922);
this._image.height = h;
        }
        _yuitest_coverline("build/charts-base/charts-base.js", 10924);
for(i = 0; i < itemCount; i++)
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 10926);
value = values[i];
            _yuitest_coverline("build/charts-base/charts-base.js", 10927);
if(totalValue === 0)
            {
                _yuitest_coverline("build/charts-base/charts-base.js", 10929);
angle = 360 / values.length;
            }
            else
            {
                _yuitest_coverline("build/charts-base/charts-base.js", 10933);
angle = 360 * (value / totalValue);
            }
            _yuitest_coverline("build/charts-base/charts-base.js", 10935);
if(tfc && tfc.length < 1)
            {
                _yuitest_coverline("build/charts-base/charts-base.js", 10937);
tfc = fillColors.concat();
            }
            _yuitest_coverline("build/charts-base/charts-base.js", 10939);
if(tfa && tfa.length < 1)
            {
                _yuitest_coverline("build/charts-base/charts-base.js", 10941);
tfa = fillAlphas.concat();
            }
            _yuitest_coverline("build/charts-base/charts-base.js", 10943);
if(tbw && tbw.length < 1)
            {
                _yuitest_coverline("build/charts-base/charts-base.js", 10945);
tbw = borderWeights.concat();
            }
            _yuitest_coverline("build/charts-base/charts-base.js", 10947);
if(tbw && tbc.length < 1)
            {
                _yuitest_coverline("build/charts-base/charts-base.js", 10949);
tbc = borderColors.concat();
            }
            _yuitest_coverline("build/charts-base/charts-base.js", 10951);
if(tba && tba.length < 1)
            {
                _yuitest_coverline("build/charts-base/charts-base.js", 10953);
tba = borderAlphas.concat();
            }
            _yuitest_coverline("build/charts-base/charts-base.js", 10955);
lw = tbw ? tbw.shift() : null;
            _yuitest_coverline("build/charts-base/charts-base.js", 10956);
lc = tbc ? tbc.shift() : null;
            _yuitest_coverline("build/charts-base/charts-base.js", 10957);
la = tba ? tba.shift() : null;
            _yuitest_coverline("build/charts-base/charts-base.js", 10958);
startAngle += angle;
            _yuitest_coverline("build/charts-base/charts-base.js", 10959);
wedgeStyle = {
                border: {
                    color:lc,
                    weight:lw,
                    alpha:la
                },
                fill: {
                    color:tfc ? tfc.shift() : this._getDefaultColor(i, "slice"),
                    alpha:tfa ? tfa.shift() : null
                },
                type: "pieslice",
                arc: angle,
                radius: radius,
                startAngle: startAngle,
                cx: halfWidth,
                cy: halfHeight,
                width: w,
                height: h
            };
            _yuitest_coverline("build/charts-base/charts-base.js", 10978);
marker = this.getMarker(wedgeStyle, graphOrder, i);
            _yuitest_coverline("build/charts-base/charts-base.js", 10979);
if(isCanvas)
            {
                _yuitest_coverline("build/charts-base/charts-base.js", 10981);
this._addHotspot(wedgeStyle, graphOrder, i);
            }
        }
        _yuitest_coverline("build/charts-base/charts-base.js", 10984);
this._clearMarkerCache();
    },

    /**
     *  Adds an interactive map when rendering in canvas.
     *
     *  @method _addHotspot
     *  @param {Object} cfg Object containing data used to draw the hotspot
     *  @param {Number} seriesIndex Index of series in the `seriesCollection`.
     *  @param {Number} index Index of the marker using the hotspot.
     *  @private
     */
    _addHotspot: function(cfg, seriesIndex, index)
    {
        _yuitest_coverfunc("build/charts-base/charts-base.js", "_addHotspot", 10996);
_yuitest_coverline("build/charts-base/charts-base.js", 10998);
var areaNode = DOCUMENT.createElement("area"),
            i = 1,
            x = cfg.cx,
            y = cfg.cy,
            arc = cfg.arc,
            startAngle = cfg.startAngle - arc,
            endAngle = cfg.startAngle,
            radius = cfg.radius,
            ax = x + Math.cos(startAngle / 180 * Math.PI) * radius,
            ay = y + Math.sin(startAngle / 180 * Math.PI) * radius,
            bx = x + Math.cos(endAngle / 180 * Math.PI) * radius,
            by = y + Math.sin(endAngle / 180 * Math.PI) * radius,
            numPoints = Math.floor(arc/10) - 1,
            divAngle = (arc/(Math.floor(arc/10)) / 180) * Math.PI,
            angleCoord = Math.atan((ay - y)/(ax - x)),
            pts = x + ", " + y + ", " + ax + ", " + ay,
            cosAng,
            sinAng,
            multDivAng;
        _yuitest_coverline("build/charts-base/charts-base.js", 11017);
for(i = 1; i <= numPoints; ++i)
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 11019);
multDivAng = divAngle * i;
            _yuitest_coverline("build/charts-base/charts-base.js", 11020);
cosAng = Math.cos(angleCoord + multDivAng);
            _yuitest_coverline("build/charts-base/charts-base.js", 11021);
sinAng = Math.sin(angleCoord + multDivAng);
            _yuitest_coverline("build/charts-base/charts-base.js", 11022);
if(startAngle <= 90)
            {
                _yuitest_coverline("build/charts-base/charts-base.js", 11024);
pts += ", " + (x + (radius * Math.cos(angleCoord + (divAngle * i))));
                _yuitest_coverline("build/charts-base/charts-base.js", 11025);
pts += ", " + (y + (radius * Math.sin(angleCoord + (divAngle * i))));
            }
            else
            {
                _yuitest_coverline("build/charts-base/charts-base.js", 11029);
pts += ", " + (x - (radius * Math.cos(angleCoord + (divAngle * i))));
                _yuitest_coverline("build/charts-base/charts-base.js", 11030);
pts += ", " + (y - (radius * Math.sin(angleCoord + (divAngle * i))));
            }
        }
        _yuitest_coverline("build/charts-base/charts-base.js", 11033);
pts += ", " + bx + ", " + by;
        _yuitest_coverline("build/charts-base/charts-base.js", 11034);
pts += ", " + x + ", " + y;
        _yuitest_coverline("build/charts-base/charts-base.js", 11035);
this._map.appendChild(areaNode);
        _yuitest_coverline("build/charts-base/charts-base.js", 11036);
areaNode.setAttribute("class", SERIES_MARKER);
        _yuitest_coverline("build/charts-base/charts-base.js", 11037);
areaNode.setAttribute("id", "hotSpot_" + seriesIndex + "_" + index);
        _yuitest_coverline("build/charts-base/charts-base.js", 11038);
areaNode.setAttribute("shape", "polygon");
        _yuitest_coverline("build/charts-base/charts-base.js", 11039);
areaNode.setAttribute("coords", pts);
        _yuitest_coverline("build/charts-base/charts-base.js", 11040);
this._areaNodes.push(areaNode);

    },

    /**
     * Resizes and positions markers based on a mouse interaction.
     *
     * @method updateMarkerState
     * @param {String} type state of the marker
     * @param {Number} i index of the marker
     * @protected
     */
    updateMarkerState: function(type, i)
    {
        _yuitest_coverfunc("build/charts-base/charts-base.js", "updateMarkerState", 11052);
_yuitest_coverline("build/charts-base/charts-base.js", 11054);
if(this._markers[i])
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 11056);
var state = this._getState(type),
                markerStyles,
                indexStyles,
                marker = this._markers[i],
                styles = this.get("styles").marker;
            _yuitest_coverline("build/charts-base/charts-base.js", 11061);
markerStyles = state == "off" || !styles[state] ? styles : styles[state];
            _yuitest_coverline("build/charts-base/charts-base.js", 11062);
indexStyles = this._mergeStyles(markerStyles, {});
            _yuitest_coverline("build/charts-base/charts-base.js", 11063);
indexStyles.fill.color = indexStyles.fill.colors[i % indexStyles.fill.colors.length];
            _yuitest_coverline("build/charts-base/charts-base.js", 11064);
indexStyles.fill.alpha = indexStyles.fill.alphas[i % indexStyles.fill.alphas.length];
            _yuitest_coverline("build/charts-base/charts-base.js", 11065);
marker.set(indexStyles);
        }
    },

    /**
     * Creates a shape to be used as a marker.
     *
     * @method _createMarker
     * @param {Object} styles Hash of style properties.
     * @param {Number} order Order of the series.
     * @param {Number} index Index within the series associated with the marker.
     * @return Shape
     * @private
     */
    _createMarker: function(styles, order, index)
    {
        _yuitest_coverfunc("build/charts-base/charts-base.js", "_createMarker", 11079);
_yuitest_coverline("build/charts-base/charts-base.js", 11081);
var graphic = this.get("graphic"),
            marker,
            cfg = Y.clone(styles);
        _yuitest_coverline("build/charts-base/charts-base.js", 11084);
graphic.set("autoDraw", false);
        _yuitest_coverline("build/charts-base/charts-base.js", 11085);
marker = graphic.addShape(cfg);
        _yuitest_coverline("build/charts-base/charts-base.js", 11086);
marker.addClass(SERIES_MARKER);
        _yuitest_coverline("build/charts-base/charts-base.js", 11087);
return marker;
    },

    /**
     * Creates a cache of markers for reuse.
     *
     * @method _createMarkerCache
     * @private
     */
    _clearMarkerCache: function()
    {
        _yuitest_coverfunc("build/charts-base/charts-base.js", "_clearMarkerCache", 11096);
_yuitest_coverline("build/charts-base/charts-base.js", 11098);
var len = this._markerCache.length,
            i = 0,
            marker;
        _yuitest_coverline("build/charts-base/charts-base.js", 11101);
for(; i < len; ++i)
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 11103);
marker = this._markerCache[i];
            _yuitest_coverline("build/charts-base/charts-base.js", 11104);
if(marker)
            {
                _yuitest_coverline("build/charts-base/charts-base.js", 11106);
marker.destroy();
            }
        }
        _yuitest_coverline("build/charts-base/charts-base.js", 11109);
this._markerCache = [];
    },

    /**
     * Gets the default style values for the markers.
     *
     * @method _getPlotDefaults
     * @return Object
     * @private
     */
    _getPlotDefaults: function()
    {
         _yuitest_coverfunc("build/charts-base/charts-base.js", "_getPlotDefaults", 11119);
_yuitest_coverline("build/charts-base/charts-base.js", 11121);
var defs = {
            padding:{
                top: 0,
                left: 0,
                right: 0,
                bottom: 0
            },
            fill:{
                alphas:["1"]
            },
            border: {
                weight: 0,
                alpha: 1
            }
        };
        _yuitest_coverline("build/charts-base/charts-base.js", 11136);
defs.fill.colors = this._defaultSliceColors;
        _yuitest_coverline("build/charts-base/charts-base.js", 11137);
defs.border.colors = this._defaultBorderColors;
        _yuitest_coverline("build/charts-base/charts-base.js", 11138);
return defs;
    },

    /**
     * Collection of default colors used for lines in a series when not specified by user.
     *
     * @property _defaultLineColors
     * @type Array
     * @protected
     */
    _defaultLineColors:["#426ab3", "#d09b2c", "#000000", "#b82837", "#b384b5", "#ff7200", "#779de3", "#cbc8ba", "#7ed7a6", "#007a6c"],

    /**
     * Collection of default colors used for marker fills in a series when not specified by user.
     *
     * @property _defaultFillColors
     * @type Array
     * @protected
     */
    _defaultFillColors:["#6084d0", "#eeb647", "#6c6b5f", "#d6484f", "#ce9ed1", "#ff9f3b", "#93b7ff", "#e0ddd0", "#94ecba", "#309687"],

    /**
     * Collection of default colors used for marker borders in a series when not specified by user.
     *
     * @property _defaultBorderColors
     * @type Array
     * @protected
     */
    _defaultBorderColors:["#205096", "#b38206", "#000000", "#94001e", "#9d6fa0", "#e55b00", "#5e85c9", "#adab9e", "#6ac291", "#006457"],

    /**
     * Collection of default colors used for area fills, histogram fills and pie fills in a series when not specified by user.
     *
     * @property _defaultSliceColors
     * @type Array
     * @protected
     */
    _defaultSliceColors: ["#66007f", "#a86f41", "#295454", "#996ab2", "#e8cdb7", "#90bdbd","#000000","#c3b8ca", "#968373", "#678585"],

    /**
     * Colors used if style colors are not specified
     *
     * @method _getDefaultColor
     * @param {Number} index Index indicating the series order.
     * @param {String} type Indicates which type of object needs the color.
     * @return String
     * @protected
     */
    _getDefaultColor: function(index, type)
    {
        _yuitest_coverfunc("build/charts-base/charts-base.js", "_getDefaultColor", 11186);
_yuitest_coverline("build/charts-base/charts-base.js", 11188);
var colors = {
                line: this._defaultLineColors,
                fill: this._defaultFillColors,
                border: this._defaultBorderColors,
                slice: this._defaultSliceColors
            },
            col = colors[type],
            l = col.length;
        _yuitest_coverline("build/charts-base/charts-base.js", 11196);
index = index || 0;
        _yuitest_coverline("build/charts-base/charts-base.js", 11197);
if(index >= l)
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 11199);
index = index % l;
        }
        _yuitest_coverline("build/charts-base/charts-base.js", 11201);
type = type || "fill";
        _yuitest_coverline("build/charts-base/charts-base.js", 11202);
return colors[type][index];
    }
}, {
    ATTRS: {
        /**
         * Read-only attribute indicating the type of series.
         *
         * @attribute type
         * @type String
         * @default pie
         */
        type: {
            value: "pie"
        },

        /**
         * Order of this instance of this `type`.
         *
         * @attribute order
         * @type Number
         */
        order: {},

        /**
         * Reference to the `Graph` in which the series is drawn into.
         *
         * @attribute graph
         * @type Graph
         */
        graph: {},

        /**
         * Reference to the `Axis` instance used for assigning
         * category values to the graph.
         *
         * @attribute categoryAxis
         * @type Axis
         */
        categoryAxis: {
            value: null,

            validator: function(value)
            {
                _yuitest_coverfunc("build/charts-base/charts-base.js", "validator", 11243);
_yuitest_coverline("build/charts-base/charts-base.js", 11245);
return value !== this.get("categoryAxis");
            }
        },

        /**
         * Reference to the `Axis` instance used for assigning
         * series values to the graph.
         *
         * @attribute categoryAxis
         * @type Axis
         */
        valueAxis: {
            value: null,

            validator: function(value)
            {
                _yuitest_coverfunc("build/charts-base/charts-base.js", "validator", 11259);
_yuitest_coverline("build/charts-base/charts-base.js", 11261);
return value !== this.get("valueAxis");
            }
        },

        /**
         * Indicates which array to from the hash of value arrays in
         * the category `Axis` instance.
         *
         * @attribute categoryKey
         * @type String
         */
        categoryKey: {
            value: null,

            validator: function(value)
            {
                _yuitest_coverfunc("build/charts-base/charts-base.js", "validator", 11275);
_yuitest_coverline("build/charts-base/charts-base.js", 11277);
return value !== this.get("categoryKey");
            }
        },
        /**
         * Indicates which array to from the hash of value arrays in
         * the value `Axis` instance.
         *
         * @attribute valueKey
         * @type String
         */
        valueKey: {
            value: null,

            validator: function(value)
            {
                _yuitest_coverfunc("build/charts-base/charts-base.js", "validator", 11290);
_yuitest_coverline("build/charts-base/charts-base.js", 11292);
return value !== this.get("valueKey");
            }
        },

        /**
         * Name used for for displaying category data
         *
         * @attribute categoryDisplayName
         * @type String
         */
        categoryDisplayName: {
            setter: function(val)
            {
                _yuitest_coverfunc("build/charts-base/charts-base.js", "setter", 11303);
_yuitest_coverline("build/charts-base/charts-base.js", 11305);
this._categoryDisplayName = val;
                _yuitest_coverline("build/charts-base/charts-base.js", 11306);
return val;
            },

            getter: function()
            {
                _yuitest_coverfunc("build/charts-base/charts-base.js", "getter", 11309);
_yuitest_coverline("build/charts-base/charts-base.js", 11311);
return this._categoryDisplayName || this.get("categoryKey");
            }
        },

        /**
         * Name used for for displaying value data
         *
         * @attribute valueDisplayName
         * @type String
         */
        valueDisplayName: {
            setter: function(val)
            {
                _yuitest_coverfunc("build/charts-base/charts-base.js", "setter", 11322);
_yuitest_coverline("build/charts-base/charts-base.js", 11324);
this._valueDisplayName = val;
                _yuitest_coverline("build/charts-base/charts-base.js", 11325);
return val;
            },

            getter: function()
            {
                _yuitest_coverfunc("build/charts-base/charts-base.js", "getter", 11328);
_yuitest_coverline("build/charts-base/charts-base.js", 11330);
return this._valueDisplayName || this.get("valueKey");
            }
        },

        /**
         * @attribute slices
         * @type Array
         * @private
         */
        slices: null

        /**
         * Style properties used for drawing markers. This attribute is inherited from `MarkerSeries`. Below are  the default
         * values:
         *  <dl>
         *      <dt>fill</dt><dd>A hash containing the following values:
         *          <dl>
         *              <dt>colors</dt><dd>An array of colors to be used for the marker fills. The color for each marker  is
         *              retrieved from the array below:<br/>
         *              `["#66007f", "#a86f41", "#295454", "#996ab2", "#e8cdb7", "#90bdbd","#000000","#c3b8ca", "#968373", "#678585"]`
         *              </dd>
         *              <dt>alphas</dt><dd>An array of alpha references (Number from 0 to 1) indicating the opacity of each marker
         *              fill. The default value is [1].</dd>
         *          </dl>
         *      </dd>
         *      <dt>border</dt><dd>A hash containing the following values:
         *          <dl>
         *              <dt>color</dt><dd>An array of colors to be used for the marker borders. The color for each marker is
         *              retrieved from the array below:<br/>
         *              `["#205096", "#b38206", "#000000", "#94001e", "#9d6fa0", "#e55b00", "#5e85c9", "#adab9e", "#6ac291", "#006457"]`
         *              <dt>alpha</dt><dd>Number from 0 to 1 indicating the opacity of the marker border. The default value is 1.</dd>
         *              <dt>weight</dt><dd>Number indicating the width of the border. The default value is 1.</dd>
         *          </dl>
         *      </dd>
         *      <dt>over</dt><dd>hash containing styles for markers when highlighted by a `mouseover` event. The default
         *      values for each style is null. When an over style is not set, the non-over value will be used. For example,
         *      the default value for `marker.over.fill.color` is equivalent to `marker.fill.color`.</dd>
         *  </dl>
         *
         * @attribute styles
         * @type Object
         */
    }
});
/**
 * Gridlines draws gridlines on a Graph.
 *
 * @module charts
 * @submodule charts-base
 * @class Gridlines
 * @constructor
 * @extends Base
 * @uses Renderer
 */
_yuitest_coverline("build/charts-base/charts-base.js", 11384);
Y.Gridlines = Y.Base.create("gridlines", Y.Base, [Y.Renderer], {
    /**
     * Reference to the `Path` element used for drawing Gridlines.
     *
     * @property _path
     * @type Path
     * @private
     */
    _path: null,

    /**
     * Removes the Gridlines.
     *
     * @method remove
     * @private
     */
    remove: function()
    {
        _yuitest_coverfunc("build/charts-base/charts-base.js", "remove", 11400);
_yuitest_coverline("build/charts-base/charts-base.js", 11402);
var path = this._path;
        _yuitest_coverline("build/charts-base/charts-base.js", 11403);
if(path)
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 11405);
path.destroy();
        }
    },

    /**
     * Draws the gridlines
     *
     * @method draw
     * @protected
     */
    draw: function()
    {
        _yuitest_coverfunc("build/charts-base/charts-base.js", "draw", 11415);
_yuitest_coverline("build/charts-base/charts-base.js", 11417);
if(this.get("axis") && this.get("graph"))
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 11419);
this._drawGridlines();
        }
    },

    /**
     * Algorithm for drawing gridlines
     *
     * @method _drawGridlines
     * @private
     */
    _drawGridlines: function()
    {
        _yuitest_coverfunc("build/charts-base/charts-base.js", "_drawGridlines", 11429);
_yuitest_coverline("build/charts-base/charts-base.js", 11431);
var path,
            axis = this.get("axis"),
            axisPosition = axis.get("position"),
            points,
            i = 0,
            l,
            direction = this.get("direction"),
            graph = this.get("graph"),
            w = graph.get("width"),
            h = graph.get("height"),
            line = this.get("styles").line,
            color = line.color,
            weight = line.weight,
            alpha = line.alpha,
            lineFunction = direction == "vertical" ? this._verticalLine : this._horizontalLine;
        _yuitest_coverline("build/charts-base/charts-base.js", 11446);
if(isFinite(w) && isFinite(h) && w > 0 && h > 0)
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 11448);
if(axisPosition != "none" && axis && axis.get("tickPoints"))
            {
                _yuitest_coverline("build/charts-base/charts-base.js", 11450);
points = axis.get("tickPoints");
                _yuitest_coverline("build/charts-base/charts-base.js", 11451);
l = points.length;
            }
            else
            {
                _yuitest_coverline("build/charts-base/charts-base.js", 11455);
points = [];
                _yuitest_coverline("build/charts-base/charts-base.js", 11456);
l = axis.get("styles").majorUnit.count;
                _yuitest_coverline("build/charts-base/charts-base.js", 11457);
for(; i < l; ++i)
                {
                    _yuitest_coverline("build/charts-base/charts-base.js", 11459);
points[i] = {
                        x: w * (i/(l-1)),
                        y: h * (i/(l-1))
                    };
                }
                _yuitest_coverline("build/charts-base/charts-base.js", 11464);
i = 0;
            }
            _yuitest_coverline("build/charts-base/charts-base.js", 11466);
path = graph.get("gridlines");
            _yuitest_coverline("build/charts-base/charts-base.js", 11467);
path.set("width", w);
            _yuitest_coverline("build/charts-base/charts-base.js", 11468);
path.set("height", h);
            _yuitest_coverline("build/charts-base/charts-base.js", 11469);
path.set("stroke", {
                weight: weight,
                color: color,
                opacity: alpha
            });
            _yuitest_coverline("build/charts-base/charts-base.js", 11474);
for(; i < l; ++i)
            {
                _yuitest_coverline("build/charts-base/charts-base.js", 11476);
lineFunction(path, points[i], w, h);
            }
            _yuitest_coverline("build/charts-base/charts-base.js", 11478);
path.end();
        }
    },

    /**
     * Algorithm for horizontal lines.
     *
     * @method _horizontalLine
     * @param {Path} path Reference to path element
     * @param {Object} pt Coordinates corresponding to a major unit of an axis.
     * @param {Number} w Width of the Graph
     * @param {Number} h Height of the Graph
     * @private
     */
    _horizontalLine: function(path, pt, w, h)
    {
        _yuitest_coverfunc("build/charts-base/charts-base.js", "_horizontalLine", 11492);
_yuitest_coverline("build/charts-base/charts-base.js", 11494);
path.moveTo(0, pt.y);
        _yuitest_coverline("build/charts-base/charts-base.js", 11495);
path.lineTo(w, pt.y);
    },

    /**
     * Algorithm for vertical lines.
     *
     * @method _verticalLine
     * @param {Path} path Reference to path element
     * @param {Object} pt Coordinates corresponding to a major unit of an axis.
     * @param {Number} w Width of the Graph
     * @param {Number} h Height of the Graph
     * @private
     */
    _verticalLine: function(path, pt, w, h)
    {
        _yuitest_coverfunc("build/charts-base/charts-base.js", "_verticalLine", 11508);
_yuitest_coverline("build/charts-base/charts-base.js", 11510);
path.moveTo(pt.x, 0);
        _yuitest_coverline("build/charts-base/charts-base.js", 11511);
path.lineTo(pt.x, h);
    },

    /**
     * Gets the default value for the `styles` attribute. Overrides
     * base implementation.
     *
     * @method _getDefaultStyles
     * @return Object
     * @protected
     */
    _getDefaultStyles: function()
    {
        _yuitest_coverfunc("build/charts-base/charts-base.js", "_getDefaultStyles", 11522);
_yuitest_coverline("build/charts-base/charts-base.js", 11524);
var defs = {
            line: {
                color:"#f0efe9",
                weight: 1,
                alpha: 1
            }
        };
        _yuitest_coverline("build/charts-base/charts-base.js", 11531);
return defs;
    }

},
{
    ATTRS: {
        /**
         * Indicates the direction of the gridline.
         *
         * @attribute direction
         * @type String
         */
        direction: {},

        /**
         * Indicate the `Axis` in which to bind
         * the gridlines.
         *
         * @attribute axis
         * @type Axis
         */
        axis: {},

        /**
         * Indicates the `Graph` in which the gridlines
         * are drawn.
         *
         * @attribute graph
         * @type Graph
         */
        graph: {}
    }
});
/**
 * Graph manages and contains series instances for a `CartesianChart`
 * instance.
 *
 * @module charts
 * @submodule charts-base
 * @class Graph
 * @constructor
 * @extends Widget
 * @uses Renderer
 */
_yuitest_coverline("build/charts-base/charts-base.js", 11575);
Y.Graph = Y.Base.create("graph", Y.Widget, [Y.Renderer], {
    /**
     * @method bindUI
     * @private
     */
    bindUI: function()
    {
        _yuitest_coverfunc("build/charts-base/charts-base.js", "bindUI", 11580);
_yuitest_coverline("build/charts-base/charts-base.js", 11582);
var bb = this.get("boundingBox");
        _yuitest_coverline("build/charts-base/charts-base.js", 11583);
bb.setStyle("position", "absolute");
        _yuitest_coverline("build/charts-base/charts-base.js", 11584);
this.after("widthChange", this._sizeChangeHandler);
        _yuitest_coverline("build/charts-base/charts-base.js", 11585);
this.after("heightChange", this._sizeChangeHandler);
        _yuitest_coverline("build/charts-base/charts-base.js", 11586);
this.after("stylesChange", this._updateStyles);
        _yuitest_coverline("build/charts-base/charts-base.js", 11587);
this.after("groupMarkersChange", this._drawSeries);
    },

    /**
     * @method syncUI
     * @private
     */
    syncUI: function()
    {
        _yuitest_coverfunc("build/charts-base/charts-base.js", "syncUI", 11594);
_yuitest_coverline("build/charts-base/charts-base.js", 11596);
var background,
            cb,
            bg,
            sc = this.get("seriesCollection"),
            series,
            i = 0,
            len = sc ? sc.length : 0,
            hgl = this.get("horizontalGridlines"),
            vgl = this.get("verticalGridlines");
        _yuitest_coverline("build/charts-base/charts-base.js", 11605);
if(this.get("showBackground"))
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 11607);
background = this.get("background");
            _yuitest_coverline("build/charts-base/charts-base.js", 11608);
cb = this.get("contentBox");
            _yuitest_coverline("build/charts-base/charts-base.js", 11609);
bg = this.get("styles").background;
            _yuitest_coverline("build/charts-base/charts-base.js", 11610);
bg.stroke = bg.border;
            _yuitest_coverline("build/charts-base/charts-base.js", 11611);
bg.stroke.opacity = bg.stroke.alpha;
            _yuitest_coverline("build/charts-base/charts-base.js", 11612);
bg.fill.opacity = bg.fill.alpha;
            _yuitest_coverline("build/charts-base/charts-base.js", 11613);
bg.width = this.get("width");
            _yuitest_coverline("build/charts-base/charts-base.js", 11614);
bg.height = this.get("height");
            _yuitest_coverline("build/charts-base/charts-base.js", 11615);
bg.type = bg.shape;
            _yuitest_coverline("build/charts-base/charts-base.js", 11616);
background.set(bg);
        }
        _yuitest_coverline("build/charts-base/charts-base.js", 11618);
for(; i < len; ++i)
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 11620);
series = sc[i];
            _yuitest_coverline("build/charts-base/charts-base.js", 11621);
if(series instanceof Y.CartesianSeries)
            {
                _yuitest_coverline("build/charts-base/charts-base.js", 11623);
series.render();
            }
        }
        _yuitest_coverline("build/charts-base/charts-base.js", 11626);
if(hgl && hgl instanceof Y.Gridlines)
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 11628);
hgl.draw();
        }
        _yuitest_coverline("build/charts-base/charts-base.js", 11630);
if(vgl && vgl instanceof Y.Gridlines)
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 11632);
vgl.draw();
        }
    },

    /**
     * Object of arrays containing series mapped to a series type.
     *
     * @property seriesTypes
     * @type Object
     * @private
     */
    seriesTypes: null,

    /**
     * Returns a series instance based on an index.
     *
     * @method getSeriesByIndex
     * @param {Number} val index of the series
     * @return CartesianSeries
     */
    getSeriesByIndex: function(val)
    {
        _yuitest_coverfunc("build/charts-base/charts-base.js", "getSeriesByIndex", 11652);
_yuitest_coverline("build/charts-base/charts-base.js", 11654);
var col = this.get("seriesCollection"),
            series;
        _yuitest_coverline("build/charts-base/charts-base.js", 11656);
if(col && col.length > val)
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 11658);
series = col[val];
        }
        _yuitest_coverline("build/charts-base/charts-base.js", 11660);
return series;
    },

    /**
     * Returns a series instance based on a key value.
     *
     * @method getSeriesByKey
     * @param {String} val key value of the series
     * @return CartesianSeries
     */
    getSeriesByKey: function(val)
    {
        _yuitest_coverfunc("build/charts-base/charts-base.js", "getSeriesByKey", 11670);
_yuitest_coverline("build/charts-base/charts-base.js", 11672);
var obj = this._seriesDictionary,
            series;
        _yuitest_coverline("build/charts-base/charts-base.js", 11674);
if(obj && obj.hasOwnProperty(val))
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 11676);
series = obj[val];
        }
        _yuitest_coverline("build/charts-base/charts-base.js", 11678);
return series;
    },

    /**
     * Adds dispatcher to a `_dispatcher` used to
     * to ensure all series have redrawn before for firing event.
     *
     * @method addDispatcher
     * @param {CartesianSeries} val series instance to add
     * @protected
     */
    addDispatcher: function(val)
    {
        _yuitest_coverfunc("build/charts-base/charts-base.js", "addDispatcher", 11689);
_yuitest_coverline("build/charts-base/charts-base.js", 11691);
if(!this._dispatchers)
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 11693);
this._dispatchers = [];
        }
        _yuitest_coverline("build/charts-base/charts-base.js", 11695);
this._dispatchers.push(val);
    },

    /**
     * Collection of series to be displayed in the graph.
     *
     * @property _seriesCollection
     * @type Array
     * @private
     */
    _seriesCollection: null,

    /**
     * Object containing key value pairs of `CartesianSeries` instances.
     *
     * @property _seriesDictionary
     * @type Object
     * @private
     */
    _seriesDictionary: null,

    /**
     * Parses series instances to be displayed in the graph.
     *
     * @method _parseSeriesCollection
     * @param {Array} Collection of `CartesianSeries` instances or objects container `CartesianSeries` attributes values.
     * @private
     */
    _parseSeriesCollection: function(val)
    {
        _yuitest_coverfunc("build/charts-base/charts-base.js", "_parseSeriesCollection", 11723);
_yuitest_coverline("build/charts-base/charts-base.js", 11725);
if(!val)
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 11727);
return;
        }
        _yuitest_coverline("build/charts-base/charts-base.js", 11729);
var len = val.length,
            i = 0,
            series,
            seriesKey;
        _yuitest_coverline("build/charts-base/charts-base.js", 11733);
this._seriesCollection = [];
        _yuitest_coverline("build/charts-base/charts-base.js", 11734);
this._seriesDictionary = {};
        _yuitest_coverline("build/charts-base/charts-base.js", 11735);
this.seriesTypes = [];
        _yuitest_coverline("build/charts-base/charts-base.js", 11736);
for(; i < len; ++i)
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 11738);
series = val[i];
            _yuitest_coverline("build/charts-base/charts-base.js", 11739);
if(!(series instanceof Y.CartesianSeries) && !(series instanceof Y.PieSeries))
            {
                _yuitest_coverline("build/charts-base/charts-base.js", 11741);
this._createSeries(series);
                _yuitest_coverline("build/charts-base/charts-base.js", 11742);
continue;
            }
            _yuitest_coverline("build/charts-base/charts-base.js", 11744);
this._addSeries(series);
        }
        _yuitest_coverline("build/charts-base/charts-base.js", 11746);
len = this._seriesCollection.length;
        _yuitest_coverline("build/charts-base/charts-base.js", 11747);
for(i = 0; i < len; ++i)
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 11749);
series = this.get("seriesCollection")[i];
            _yuitest_coverline("build/charts-base/charts-base.js", 11750);
seriesKey = series.get("direction") == "horizontal" ? "yKey" : "xKey";
            _yuitest_coverline("build/charts-base/charts-base.js", 11751);
this._seriesDictionary[series.get(seriesKey)] = series;
        }
    },

    /**
     * Adds a series to the graph.
     *
     * @method _addSeries
     * @param {CartesianSeries} series Series to add to the graph.
     * @private
     */
    _addSeries: function(series)
    {
        _yuitest_coverfunc("build/charts-base/charts-base.js", "_addSeries", 11762);
_yuitest_coverline("build/charts-base/charts-base.js", 11764);
var type = series.get("type"),
            seriesCollection = this.get("seriesCollection"),
            graphSeriesLength = seriesCollection.length,
            seriesTypes = this.seriesTypes,
            typeSeriesCollection;
        _yuitest_coverline("build/charts-base/charts-base.js", 11769);
if(!series.get("graph"))
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 11771);
series.set("graph", this);
        }
        _yuitest_coverline("build/charts-base/charts-base.js", 11773);
seriesCollection.push(series);
        _yuitest_coverline("build/charts-base/charts-base.js", 11774);
if(!seriesTypes.hasOwnProperty(type))
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 11776);
this.seriesTypes[type] = [];
        }
        _yuitest_coverline("build/charts-base/charts-base.js", 11778);
typeSeriesCollection = this.seriesTypes[type];
        _yuitest_coverline("build/charts-base/charts-base.js", 11779);
series.set("graphOrder", graphSeriesLength);
        _yuitest_coverline("build/charts-base/charts-base.js", 11780);
series.set("order", typeSeriesCollection.length);
        _yuitest_coverline("build/charts-base/charts-base.js", 11781);
typeSeriesCollection.push(series);
        _yuitest_coverline("build/charts-base/charts-base.js", 11782);
this.addDispatcher(series);
        _yuitest_coverline("build/charts-base/charts-base.js", 11783);
series.after("drawingComplete", Y.bind(this._drawingCompleteHandler, this));
        _yuitest_coverline("build/charts-base/charts-base.js", 11784);
this.fire("seriesAdded", series);
    },

    /**
     * Creates a `CartesianSeries` instance from an object containing attribute key value pairs. The key value pairs include
     * attributes for the specific series and a type value which defines the type of series to be used.
     *
     * @method createSeries
     * @param {Object} seriesData Series attribute key value pairs.
     * @private
     */
    _createSeries: function(seriesData)
    {
        _yuitest_coverfunc("build/charts-base/charts-base.js", "_createSeries", 11795);
_yuitest_coverline("build/charts-base/charts-base.js", 11797);
var type = seriesData.type,
            seriesCollection = this.get("seriesCollection"),
            seriesTypes = this.seriesTypes,
            typeSeriesCollection,
            seriesType,
            series;
            _yuitest_coverline("build/charts-base/charts-base.js", 11803);
seriesData.graph = this;
        _yuitest_coverline("build/charts-base/charts-base.js", 11804);
if(!seriesTypes.hasOwnProperty(type))
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 11806);
seriesTypes[type] = [];
        }
        _yuitest_coverline("build/charts-base/charts-base.js", 11808);
typeSeriesCollection = seriesTypes[type];
        _yuitest_coverline("build/charts-base/charts-base.js", 11809);
seriesData.graph = this;
        _yuitest_coverline("build/charts-base/charts-base.js", 11810);
seriesData.order = typeSeriesCollection.length;
        _yuitest_coverline("build/charts-base/charts-base.js", 11811);
seriesData.graphOrder = seriesCollection.length;
        _yuitest_coverline("build/charts-base/charts-base.js", 11812);
seriesType = this._getSeries(seriesData.type);
        _yuitest_coverline("build/charts-base/charts-base.js", 11813);
series = new seriesType(seriesData);
        _yuitest_coverline("build/charts-base/charts-base.js", 11814);
this.addDispatcher(series);
        _yuitest_coverline("build/charts-base/charts-base.js", 11815);
series.after("drawingComplete", Y.bind(this._drawingCompleteHandler, this));
        _yuitest_coverline("build/charts-base/charts-base.js", 11816);
typeSeriesCollection.push(series);
        _yuitest_coverline("build/charts-base/charts-base.js", 11817);
seriesCollection.push(series);
        _yuitest_coverline("build/charts-base/charts-base.js", 11818);
if(this.get("rendered"))
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 11820);
series.render();
        }
    },

    /**
     * String reference for pre-defined `Series` classes.
     *
     * @property _seriesMap
     * @type Object
     * @private
     */
    _seriesMap: {
        line : Y.LineSeries,
        column : Y.ColumnSeries,
        bar : Y.BarSeries,
        area :  Y.AreaSeries,
        candlestick : Y.CandlestickSeries,
        ohlc : Y.OHLCSeries,
        stackedarea : Y.StackedAreaSeries,
        stackedline : Y.StackedLineSeries,
        stackedcolumn : Y.StackedColumnSeries,
        stackedbar : Y.StackedBarSeries,
        markerseries : Y.MarkerSeries,
        spline : Y.SplineSeries,
        areaspline : Y.AreaSplineSeries,
        stackedspline : Y.StackedSplineSeries,
        stackedareaspline : Y.StackedAreaSplineSeries,
        stackedmarkerseries : Y.StackedMarkerSeries,
        pie : Y.PieSeries,
        combo : Y.ComboSeries,
        stackedcombo : Y.StackedComboSeries,
        combospline : Y.ComboSplineSeries,
        stackedcombospline : Y.StackedComboSplineSeries
    },

    /**
     * Returns a specific `CartesianSeries` class based on key value from a look up table of a direct reference to a
     * class. When specifying a key value, the following options are available:
     *
     *  <table>
     *      <tr><th>Key Value</th><th>Class</th></tr>
     *      <tr><td>line</td><td>Y.LineSeries</td></tr>
     *      <tr><td>column</td><td>Y.ColumnSeries</td></tr>
     *      <tr><td>bar</td><td>Y.BarSeries</td></tr>
     *      <tr><td>area</td><td>Y.AreaSeries</td></tr>
     *      <tr><td>stackedarea</td><td>Y.StackedAreaSeries</td></tr>
     *      <tr><td>stackedline</td><td>Y.StackedLineSeries</td></tr>
     *      <tr><td>stackedcolumn</td><td>Y.StackedColumnSeries</td></tr>
     *      <tr><td>stackedbar</td><td>Y.StackedBarSeries</td></tr>
     *      <tr><td>markerseries</td><td>Y.MarkerSeries</td></tr>
     *      <tr><td>spline</td><td>Y.SplineSeries</td></tr>
     *      <tr><td>areaspline</td><td>Y.AreaSplineSeries</td></tr>
     *      <tr><td>stackedspline</td><td>Y.StackedSplineSeries</td></tr>
     *      <tr><td>stackedareaspline</td><td>Y.StackedAreaSplineSeries</td></tr>
     *      <tr><td>stackedmarkerseries</td><td>Y.StackedMarkerSeries</td></tr>
     *      <tr><td>pie</td><td>Y.PieSeries</td></tr>
     *      <tr><td>combo</td><td>Y.ComboSeries</td></tr>
     *      <tr><td>stackedcombo</td><td>Y.StackedComboSeries</td></tr>
     *      <tr><td>combospline</td><td>Y.ComboSplineSeries</td></tr>
     *      <tr><td>stackedcombospline</td><td>Y.StackedComboSplineSeries</td></tr>
     *  </table>
     *
     * When referencing a class directly, you can specify any of the above classes or any custom class that extends
     * `CartesianSeries` or `PieSeries`.
     *
     * @method _getSeries
     * @param {String | Object} type Series type.
     * @return CartesianSeries
     * @private
     */
    _getSeries: function(type)
    {
        _yuitest_coverfunc("build/charts-base/charts-base.js", "_getSeries", 11890);
_yuitest_coverline("build/charts-base/charts-base.js", 11892);
var seriesClass;
        _yuitest_coverline("build/charts-base/charts-base.js", 11893);
if(Y_Lang.isString(type))
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 11895);
seriesClass = this._seriesMap[type];
        }
        else
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 11899);
seriesClass = type;
        }
        _yuitest_coverline("build/charts-base/charts-base.js", 11901);
return seriesClass;
    },

    /**
     * Event handler for marker events.
     *
     * @method _markerEventHandler
     * @param {Object} e Event object.
     * @private
     */
    _markerEventHandler: function(e)
    {
        _yuitest_coverfunc("build/charts-base/charts-base.js", "_markerEventHandler", 11911);
_yuitest_coverline("build/charts-base/charts-base.js", 11913);
var type = e.type,
            markerNode = e.currentTarget,
            strArr = markerNode.getAttribute("id").split("_"),
            series = this.getSeriesByIndex(strArr[1]),
            index = strArr[2];
        _yuitest_coverline("build/charts-base/charts-base.js", 11918);
series.updateMarkerState(type, index);
    },

    /**
     * Collection of `CartesianSeries` instances to be redrawn.
     *
     * @property _dispatchers
     * @type Array
     * @private
     */
    _dispatchers: null,

    /**
     * Updates the `Graph` styles.
     *
     * @method _updateStyles
     * @private
     */
    _updateStyles: function()
    {
        _yuitest_coverfunc("build/charts-base/charts-base.js", "_updateStyles", 11936);
_yuitest_coverline("build/charts-base/charts-base.js", 11938);
var styles = this.get("styles").background,
            border = styles.border;
            _yuitest_coverline("build/charts-base/charts-base.js", 11940);
border.opacity = border.alpha;
            _yuitest_coverline("build/charts-base/charts-base.js", 11941);
styles.stroke = border;
            _yuitest_coverline("build/charts-base/charts-base.js", 11942);
styles.fill.opacity = styles.fill.alpha;
        _yuitest_coverline("build/charts-base/charts-base.js", 11943);
this.get("background").set(styles);
        _yuitest_coverline("build/charts-base/charts-base.js", 11944);
this._sizeChangeHandler();
    },

    /**
     * Event handler for size changes.
     *
     * @method _sizeChangeHandler
     * @param {Object} e Event object.
     * @private
     */
    _sizeChangeHandler: function(e)
    {
        _yuitest_coverfunc("build/charts-base/charts-base.js", "_sizeChangeHandler", 11954);
_yuitest_coverline("build/charts-base/charts-base.js", 11956);
var hgl = this.get("horizontalGridlines"),
            vgl = this.get("verticalGridlines"),
            w = this.get("width"),
            h = this.get("height"),
            bg = this.get("styles").background,
            weight,
            background;
        _yuitest_coverline("build/charts-base/charts-base.js", 11963);
if(bg && bg.border)
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 11965);
weight = bg.border.weight || 0;
        }
        _yuitest_coverline("build/charts-base/charts-base.js", 11967);
if(this.get("showBackground"))
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 11969);
background = this.get("background");
            _yuitest_coverline("build/charts-base/charts-base.js", 11970);
if(w && h)
            {
                _yuitest_coverline("build/charts-base/charts-base.js", 11972);
background.set("width", w);
                _yuitest_coverline("build/charts-base/charts-base.js", 11973);
background.set("height", h);
            }
        }
        _yuitest_coverline("build/charts-base/charts-base.js", 11976);
if(this._gridlines)
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 11978);
this._gridlines.clear();
        }
        _yuitest_coverline("build/charts-base/charts-base.js", 11980);
if(hgl && hgl instanceof Y.Gridlines)
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 11982);
hgl.draw();
        }
        _yuitest_coverline("build/charts-base/charts-base.js", 11984);
if(vgl && vgl instanceof Y.Gridlines)
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 11986);
vgl.draw();
        }
        _yuitest_coverline("build/charts-base/charts-base.js", 11988);
this._drawSeries();
    },

    /**
     * Draws each series.
     *
     * @method _drawSeries
     * @private
     */
    _drawSeries: function()
    {
        _yuitest_coverfunc("build/charts-base/charts-base.js", "_drawSeries", 11997);
_yuitest_coverline("build/charts-base/charts-base.js", 11999);
if(this._drawing)
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 12001);
this._callLater = true;
            _yuitest_coverline("build/charts-base/charts-base.js", 12002);
return;
        }
        _yuitest_coverline("build/charts-base/charts-base.js", 12004);
var sc,
            i,
            len,
            graphic = this.get("graphic");
        _yuitest_coverline("build/charts-base/charts-base.js", 12008);
graphic.set("autoDraw", false);
        _yuitest_coverline("build/charts-base/charts-base.js", 12009);
this._callLater = false;
        _yuitest_coverline("build/charts-base/charts-base.js", 12010);
this._drawing = true;
        _yuitest_coverline("build/charts-base/charts-base.js", 12011);
sc = this.get("seriesCollection");
        _yuitest_coverline("build/charts-base/charts-base.js", 12012);
i = 0;
        _yuitest_coverline("build/charts-base/charts-base.js", 12013);
len = sc ? sc.length : 0;
        _yuitest_coverline("build/charts-base/charts-base.js", 12014);
for(; i < len; ++i)
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 12016);
sc[i].draw();
            _yuitest_coverline("build/charts-base/charts-base.js", 12017);
if((!sc[i].get("xcoords") || !sc[i].get("ycoords")) && !sc[i] instanceof Y.PieSeries)
            {
                _yuitest_coverline("build/charts-base/charts-base.js", 12019);
this._callLater = true;
                _yuitest_coverline("build/charts-base/charts-base.js", 12020);
break;
            }
        }
        _yuitest_coverline("build/charts-base/charts-base.js", 12023);
this._drawing = false;
        _yuitest_coverline("build/charts-base/charts-base.js", 12024);
if(this._callLater)
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 12026);
this._drawSeries();
        }
    },

    /**
     * Event handler for series drawingComplete event.
     *
     * @method _drawingCompleteHandler
     * @param {Object} e Event object.
     * @private
     */
    _drawingCompleteHandler: function(e)
    {
        _yuitest_coverfunc("build/charts-base/charts-base.js", "_drawingCompleteHandler", 12037);
_yuitest_coverline("build/charts-base/charts-base.js", 12039);
var series = e.currentTarget,
            graphic,
            index = Y.Array.indexOf(this._dispatchers, series);
        _yuitest_coverline("build/charts-base/charts-base.js", 12042);
if(index > -1)
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 12044);
this._dispatchers.splice(index, 1);
        }
        _yuitest_coverline("build/charts-base/charts-base.js", 12046);
if(this._dispatchers.length < 1)
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 12048);
graphic = this.get("graphic");
            _yuitest_coverline("build/charts-base/charts-base.js", 12049);
if(!graphic.get("autoDraw"))
            {
                _yuitest_coverline("build/charts-base/charts-base.js", 12051);
graphic._redraw();
            }
            _yuitest_coverline("build/charts-base/charts-base.js", 12053);
this.fire("chartRendered");
        }
    },

    /**
     * Gets the default value for the `styles` attribute. Overrides
     * base implementation.
     *
     * @method _getDefaultStyles
     * @return Object
     * @protected
     */
    _getDefaultStyles: function()
    {
        _yuitest_coverfunc("build/charts-base/charts-base.js", "_getDefaultStyles", 12065);
_yuitest_coverline("build/charts-base/charts-base.js", 12067);
var defs = {
            background: {
                shape: "rect",
                fill:{
                    color:"#faf9f2"
                },
                border: {
                    color:"#dad8c9",
                    weight: 1
                }
            }
        };
        _yuitest_coverline("build/charts-base/charts-base.js", 12079);
return defs;
    },

    /**
     * Destructor implementation Graph class. Removes all Graphic instances from the widget.
     *
     * @method destructor
     * @protected
     */
    destructor: function()
    {
        _yuitest_coverfunc("build/charts-base/charts-base.js", "destructor", 12088);
_yuitest_coverline("build/charts-base/charts-base.js", 12090);
if(this._graphic)
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 12092);
this._graphic.destroy();
            _yuitest_coverline("build/charts-base/charts-base.js", 12093);
this._graphic = null;
        }
        _yuitest_coverline("build/charts-base/charts-base.js", 12095);
if(this._background)
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 12097);
this._background.get("graphic").destroy();
            _yuitest_coverline("build/charts-base/charts-base.js", 12098);
this._background = null;
        }
        _yuitest_coverline("build/charts-base/charts-base.js", 12100);
if(this._gridlines)
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 12102);
this._gridlines.get("graphic").destroy();
            _yuitest_coverline("build/charts-base/charts-base.js", 12103);
this._gridlines = null;
        }
    }
}, {
    ATTRS: {
        /**
         * The x-coordinate for the graph.
         *
         * @attribute x
         * @type Number
         * @protected
         */
        x: {
            setter: function(val)
            {
                _yuitest_coverfunc("build/charts-base/charts-base.js", "setter", 12116);
_yuitest_coverline("build/charts-base/charts-base.js", 12118);
this.get("boundingBox").setStyle("left", val + "px");
                _yuitest_coverline("build/charts-base/charts-base.js", 12119);
return val;
            }
        },

        /**
         * The y-coordinate for the graph.
         *
         * @attribute y
         * @type Number
         * @protected
         */
        y: {
            setter: function(val)
            {
                _yuitest_coverfunc("build/charts-base/charts-base.js", "setter", 12131);
_yuitest_coverline("build/charts-base/charts-base.js", 12133);
this.get("boundingBox").setStyle("top", val + "px");
                _yuitest_coverline("build/charts-base/charts-base.js", 12134);
return val;
            }
        },

        /**
         * Reference to the chart instance using the graph.
         *
         * @attribute chart
         * @type ChartBase
         * @readOnly
         */
        chart: {},

        /**
         * Collection of series. When setting the `seriesCollection` the array can contain a combination of either
         * `CartesianSeries` instances or object literals with properties that will define a series.
         *
         * @attribute seriesCollection
         * @type CartesianSeries
         */
        seriesCollection: {
            getter: function()
            {
                _yuitest_coverfunc("build/charts-base/charts-base.js", "getter", 12155);
_yuitest_coverline("build/charts-base/charts-base.js", 12157);
return this._seriesCollection;
            },

            setter: function(val)
            {
                _yuitest_coverfunc("build/charts-base/charts-base.js", "setter", 12160);
_yuitest_coverline("build/charts-base/charts-base.js", 12162);
this._parseSeriesCollection(val);
                _yuitest_coverline("build/charts-base/charts-base.js", 12163);
return this._seriesCollection;
            }
        },

        /**
         * Indicates whether the `Graph` has a background.
         *
         * @attribute showBackground
         * @type Boolean
         * @default true
         */
        showBackground: {
            value: true
        },

        /**
         * Read-only hash lookup for all series on in the `Graph`.
         *
         * @attribute seriesDictionary
         * @type Object
         * @readOnly
         */
        seriesDictionary: {
            readOnly: true,

            getter: function()
            {
                _yuitest_coverfunc("build/charts-base/charts-base.js", "getter", 12188);
_yuitest_coverline("build/charts-base/charts-base.js", 12190);
return this._seriesDictionary;
            }
        },

        /**
         * Reference to the horizontal `Gridlines` instance.
         *
         * @attribute horizontalGridlines
         * @type Gridlines
         * @default null
         */
        horizontalGridlines: {
            value: null,

            setter: function(val)
            {
                _yuitest_coverfunc("build/charts-base/charts-base.js", "setter", 12204);
_yuitest_coverline("build/charts-base/charts-base.js", 12206);
var gl = this.get("horizontalGridlines");
                _yuitest_coverline("build/charts-base/charts-base.js", 12207);
if(gl && gl instanceof Y.Gridlines)
                {
                    _yuitest_coverline("build/charts-base/charts-base.js", 12209);
gl.remove();
                }
                _yuitest_coverline("build/charts-base/charts-base.js", 12211);
if(val instanceof Y.Gridlines)
                {
                    _yuitest_coverline("build/charts-base/charts-base.js", 12213);
gl = val;
                    _yuitest_coverline("build/charts-base/charts-base.js", 12214);
val.set("graph", this);
                    _yuitest_coverline("build/charts-base/charts-base.js", 12215);
return val;
                }
                else {_yuitest_coverline("build/charts-base/charts-base.js", 12217);
if(val && val.axis)
                {
                    _yuitest_coverline("build/charts-base/charts-base.js", 12219);
gl = new Y.Gridlines({direction:"horizontal", axis:val.axis, graph:this, styles:val.styles});
                    _yuitest_coverline("build/charts-base/charts-base.js", 12220);
return gl;
                }}
            }
        },

        /**
         * Reference to the vertical `Gridlines` instance.
         *
         * @attribute verticalGridlines
         * @type Gridlines
         * @default null
         */
        verticalGridlines: {
            value: null,

            setter: function(val)
            {
                _yuitest_coverfunc("build/charts-base/charts-base.js", "setter", 12235);
_yuitest_coverline("build/charts-base/charts-base.js", 12237);
var gl = this.get("verticalGridlines");
                _yuitest_coverline("build/charts-base/charts-base.js", 12238);
if(gl && gl instanceof Y.Gridlines)
                {
                    _yuitest_coverline("build/charts-base/charts-base.js", 12240);
gl.remove();
                }
                _yuitest_coverline("build/charts-base/charts-base.js", 12242);
if(val instanceof Y.Gridlines)
                {
                    _yuitest_coverline("build/charts-base/charts-base.js", 12244);
gl = val;
                    _yuitest_coverline("build/charts-base/charts-base.js", 12245);
val.set("graph", this);
                    _yuitest_coverline("build/charts-base/charts-base.js", 12246);
return val;
                }
                else {_yuitest_coverline("build/charts-base/charts-base.js", 12248);
if(val && val.axis)
                {
                    _yuitest_coverline("build/charts-base/charts-base.js", 12250);
gl = new Y.Gridlines({direction:"vertical", axis:val.axis, graph:this, styles:val.styles});
                    _yuitest_coverline("build/charts-base/charts-base.js", 12251);
return gl;
                }}
            }
        },

        /**
         * Reference to graphic instance used for the background.
         *
         * @attribute background
         * @type Graphic
         * @readOnly
         */
        background: {
            getter: function()
            {
                _yuitest_coverfunc("build/charts-base/charts-base.js", "getter", 12264);
_yuitest_coverline("build/charts-base/charts-base.js", 12266);
if(!this._background)
                {
                    _yuitest_coverline("build/charts-base/charts-base.js", 12268);
this._backgroundGraphic = new Y.Graphic({render:this.get("contentBox")});
                    _yuitest_coverline("build/charts-base/charts-base.js", 12269);
this._backgroundGraphic.get("node").style.zIndex = 0;
                    _yuitest_coverline("build/charts-base/charts-base.js", 12270);
this._background = this._backgroundGraphic.addShape({type: "rect"});
                }
                _yuitest_coverline("build/charts-base/charts-base.js", 12272);
return this._background;
            }
        },

        /**
         * Reference to graphic instance used for gridlines.
         *
         * @attribute gridlines
         * @type Graphic
         * @readOnly
         */
        gridlines: {
            readOnly: true,

            getter: function()
            {
                _yuitest_coverfunc("build/charts-base/charts-base.js", "getter", 12286);
_yuitest_coverline("build/charts-base/charts-base.js", 12288);
if(!this._gridlines)
                {
                    _yuitest_coverline("build/charts-base/charts-base.js", 12290);
this._gridlinesGraphic = new Y.Graphic({render:this.get("contentBox")});
                    _yuitest_coverline("build/charts-base/charts-base.js", 12291);
this._gridlinesGraphic.get("node").style.zIndex = 1;
                    _yuitest_coverline("build/charts-base/charts-base.js", 12292);
this._gridlines = this._gridlinesGraphic.addShape({type: "path"});
                }
                _yuitest_coverline("build/charts-base/charts-base.js", 12294);
return this._gridlines;
            }
        },

        /**
         * Reference to graphic instance used for series.
         *
         * @attribute graphic
         * @type Graphic
         * @readOnly
         */
        graphic: {
            readOnly: true,

            getter: function()
            {
                _yuitest_coverfunc("build/charts-base/charts-base.js", "getter", 12308);
_yuitest_coverline("build/charts-base/charts-base.js", 12310);
if(!this._graphic)
                {
                    _yuitest_coverline("build/charts-base/charts-base.js", 12312);
this._graphic = new Y.Graphic({render:this.get("contentBox")});
                    _yuitest_coverline("build/charts-base/charts-base.js", 12313);
this._graphic.get("node").style.zIndex = 2;
                    _yuitest_coverline("build/charts-base/charts-base.js", 12314);
this._graphic.set("autoDraw", false);
                }
                _yuitest_coverline("build/charts-base/charts-base.js", 12316);
return this._graphic;
            }
        },

        /**
         * Indicates whether or not markers for a series will be grouped and rendered in a single complex shape instance.
         *
         * @attribute groupMarkers
         * @type Boolean
         */
        groupMarkers: {
            value: false
        }

        /**
         * Style properties used for drawing a background. Below are the default values:
         *  <dl>
         *      <dt>background</dt><dd>An object containing the following values:
         *          <dl>
         *              <dt>fill</dt><dd>Defines the style properties for the fill. Contains the following values:
         *                  <dl>
         *                      <dt>color</dt><dd>Color of the fill. The default value is #faf9f2.</dd>
         *                      <dt>alpha</dt><dd>Number from 0 to 1 indicating the opacity of the background fill.
         *                      The default value is 1.</dd>
         *                  </dl>
         *              </dd>
         *              <dt>border</dt><dd>Defines the style properties for the border. Contains the following values:
         *                  <dl>
         *                      <dt>color</dt><dd>Color of the border. The default value is #dad8c9.</dd>
         *                      <dt>alpha</dt><dd>Number from 0 to 1 indicating the opacity of the background border.
         *                      The default value is 1.</dd>
         *                      <dt>weight</dt><dd>Number indicating the width of the border. The default value is 1.</dd>
         *                  </dl>
         *              </dd>
         *          </dl>
         *      </dd>
         *  </dl>
         *
         * @attribute styles
         * @type Object
         */
    }
});
/**
 * The ChartBase class is an abstract class used to create charts.
 *
 * @module charts
 * @submodule charts-base
 * @class ChartBase
 * @constructor
 */
_yuitest_coverline("build/charts-base/charts-base.js", 12367);
function ChartBase() {}

_yuitest_coverline("build/charts-base/charts-base.js", 12369);
ChartBase.ATTRS = {
    /**
     * Data used to generate the chart.
     *
     * @attribute dataProvider
     * @type Array
     */
    dataProvider: {
        lazyAdd: false,

        valueFn: function()
        {
            _yuitest_coverfunc("build/charts-base/charts-base.js", "valueFn", 12379);
_yuitest_coverline("build/charts-base/charts-base.js", 12381);
var defDataProvider = [];
            _yuitest_coverline("build/charts-base/charts-base.js", 12382);
if(!this._seriesKeysExplicitlySet)
            {
                _yuitest_coverline("build/charts-base/charts-base.js", 12384);
this._seriesKeys = this._buildSeriesKeys(defDataProvider);
            }
            _yuitest_coverline("build/charts-base/charts-base.js", 12386);
return defDataProvider;
        },

        setter: function(val)
        {
            _yuitest_coverfunc("build/charts-base/charts-base.js", "setter", 12389);
_yuitest_coverline("build/charts-base/charts-base.js", 12391);
var dataProvider = this._setDataValues(val);
            _yuitest_coverline("build/charts-base/charts-base.js", 12392);
if(!this._seriesKeysExplicitlySet)
            {
                _yuitest_coverline("build/charts-base/charts-base.js", 12394);
this._seriesKeys = this._buildSeriesKeys(dataProvider);
            }
            _yuitest_coverline("build/charts-base/charts-base.js", 12396);
return dataProvider;
        }
    },

    /**
     * A collection of keys that map to the series axes. If no keys are set,
     * they will be generated automatically depending on the data structure passed into
     * the chart.
     *
     * @attribute seriesKeys
     * @type Array
     */
    seriesKeys: {
        getter: function()
        {
            _yuitest_coverfunc("build/charts-base/charts-base.js", "getter", 12409);
_yuitest_coverline("build/charts-base/charts-base.js", 12411);
return this._seriesKeys;
        },

        setter: function(val)
        {
            _yuitest_coverfunc("build/charts-base/charts-base.js", "setter", 12414);
_yuitest_coverline("build/charts-base/charts-base.js", 12416);
this._seriesKeysExplicitlySet = true;
            _yuitest_coverline("build/charts-base/charts-base.js", 12417);
this._seriesKeys = val;
            _yuitest_coverline("build/charts-base/charts-base.js", 12418);
return val;
        }
    },

    /**
     * Sets the `aria-label` for the chart.
     *
     * @attribute ariaLabel
     * @type String
     */
    ariaLabel: {
        value: "Chart Application",

        setter: function(val)
        {
            _yuitest_coverfunc("build/charts-base/charts-base.js", "setter", 12431);
_yuitest_coverline("build/charts-base/charts-base.js", 12433);
var cb = this.get("contentBox");
            _yuitest_coverline("build/charts-base/charts-base.js", 12434);
if(cb)
            {
                _yuitest_coverline("build/charts-base/charts-base.js", 12436);
cb.setAttribute("aria-label", val);
            }
            _yuitest_coverline("build/charts-base/charts-base.js", 12438);
return val;
        }
    },

    /**
     * Sets the aria description for the chart.
     *
     * @attribute ariaDescription
     * @type String
     */
    ariaDescription: {
        value: "Use the up and down keys to navigate between series. Use the left and right keys to navigate through items in a series.",

        setter: function(val)
        {
            _yuitest_coverfunc("build/charts-base/charts-base.js", "setter", 12451);
_yuitest_coverline("build/charts-base/charts-base.js", 12453);
if(this._description)
            {
                _yuitest_coverline("build/charts-base/charts-base.js", 12455);
this._description.setContent("");
                _yuitest_coverline("build/charts-base/charts-base.js", 12456);
this._description.appendChild(DOCUMENT.createTextNode(val));
            }
            _yuitest_coverline("build/charts-base/charts-base.js", 12458);
return val;
        }
    },

    /**
     * Reference to the default tooltip available for the chart.
     * <p>Contains the following properties:</p>
     *  <dl>
     *      <dt>node</dt><dd>Reference to the actual dom node</dd>
     *      <dt>showEvent</dt><dd>Event that should trigger the tooltip</dd>
     *      <dt>hideEvent</dt><dd>Event that should trigger the removal of a tooltip (can be an event or an array of events)</dd>
     *      <dt>styles</dt><dd>A hash of style properties that will be applied to the tooltip node</dd>
     *      <dt>show</dt><dd>Indicates whether or not to show the tooltip</dd>
     *      <dt>markerEventHandler</dt><dd>Displays and hides tooltip based on marker events</dd>
     *      <dt>planarEventHandler</dt><dd>Displays and hides tooltip based on planar events</dd>
     *      <dt>markerLabelFunction</dt><dd>Reference to the function used to format a marker event triggered tooltip's text.
     *      The method contains the following arguments:
     *  <dl>
     *      <dt>categoryItem</dt><dd>An object containing the following:
     *  <dl>
     *      <dt>axis</dt><dd>The axis to which the category is bound.</dd>
     *      <dt>displayName</dt><dd>The display name set to the category (defaults to key if not provided).</dd>
     *      <dt>key</dt><dd>The key of the category.</dd>
     *      <dt>value</dt><dd>The value of the category.</dd>
     *  </dl>
     *  </dd>
     *  <dt>valueItem</dt><dd>An object containing the following:
     *      <dl>
     *          <dt>axis</dt><dd>The axis to which the item's series is bound.</dd>
     *          <dt>displayName</dt><dd>The display name of the series. (defaults to key if not provided)</dd>
     *          <dt>key</dt><dd>The key for the series.</dd>
     *          <dt>value</dt><dd>The value for the series item.</dd>
     *      </dl>
     *  </dd>
     *  <dt>itemIndex</dt><dd>The index of the item within the series.</dd>
     *  <dt>series</dt><dd> The `CartesianSeries` instance of the item.</dd>
     *  <dt>seriesIndex</dt><dd>The index of the series in the `seriesCollection`.</dd>
     *  </dl>
     *  The method returns an `HTMLElement` which is written into the DOM using `appendChild`. If you override this method and choose
     *  to return an html string, you will also need to override the tooltip's `setTextFunction` method to accept an html string.
     *  </dd>
     *  <dt>planarLabelFunction</dt><dd>Reference to the function used to format a planar event triggered tooltip's text
     *  <dl>
     *      <dt>categoryAxis</dt><dd> `CategoryAxis` Reference to the categoryAxis of the chart.
     *      <dt>valueItems</dt><dd>Array of objects for each series that has a data point in the coordinate plane of the event. Each
     *      object contains the following data:
     *  <dl>
     *      <dt>axis</dt><dd>The value axis of the series.</dd>
     *      <dt>key</dt><dd>The key for the series.</dd>
     *      <dt>value</dt><dd>The value for the series item.</dd>
     *      <dt>displayName</dt><dd>The display name of the series. (defaults to key if not provided)</dd>
     *  </dl>
     *  </dd>
     *      <dt>index</dt><dd>The index of the item within its series.</dd>
     *      <dt>seriesArray</dt><dd>Array of series instances for each value item.</dd>
     *      <dt>seriesIndex</dt><dd>The index of the series in the `seriesCollection`.</dd>
     *  </dl>
     *  </dd>
     *  </dl>
     *  The method returns an `HTMLElement` which is written into the DOM using `appendChild`. If you override this method and choose
     *  to return an html string, you will also need to override the tooltip's `setTextFunction` method to accept an html string.
     *  </dd>
     *  <dt>setTextFunction</dt><dd>Method that writes content returned from `planarLabelFunction` or `markerLabelFunction` into the
     *  the tooltip node. Has the following signature:
     *  <dl>
     *      <dt>label</dt><dd>The `HTMLElement` that the content is to be added.</dd>
     *      <dt>val</dt><dd>The content to be rendered into tooltip. This can be a `String` or `HTMLElement`. If an HTML string is used,
     *      it will be rendered as a string.</dd>
     *  </dl>
     *  </dd>
     *  </dl>
     * @attribute tooltip
     * @type Object
     */
    tooltip: {
        valueFn: "_getTooltip",

        setter: function(val)
        {
            _yuitest_coverfunc("build/charts-base/charts-base.js", "setter", 12535);
_yuitest_coverline("build/charts-base/charts-base.js", 12537);
return this._updateTooltip(val);
        }
    },

    /**
     * The key value used for the chart's category axis.
     *
     * @attribute categoryKey
     * @type String
     * @default category
     */
    categoryKey: {
        value: "category"
    },

    /**
     * Indicates the type of axis to use for the category axis.
     *
     *  <dl>
     *      <dt>category</dt><dd>Specifies a `CategoryAxis`.</dd>
     *      <dt>time</dt><dd>Specifies a `TimeAxis</dd>
     *  </dl>
     *
     * @attribute categoryType
     * @type String
     * @default category
     */
    categoryType:{
        value:"category"
    },

    /**
     * Indicates the the type of interactions that will fire events.
     *
     *  <dl>
     *      <dt>marker</dt><dd>Events will be broadcasted when the mouse interacts with individual markers.</dd>
     *      <dt>planar</dt><dd>Events will be broadcasted when the mouse intersects the plane of any markers on the chart.</dd>
     *      <dt>none</dt><dd>No events will be broadcasted.</dd>
     *  </dl>
     *
     * @attribute interactionType
     * @type String
     * @default marker
     */
    interactionType: {
        value: "marker"
    },

    /**
     * Reference to all the axes in the chart.
     *
     * @attribute axesCollection
     * @type Array
     */
    axesCollection: {},

    /**
     * Reference to graph instance.
     *
     * @attribute graph
     * @type Graph
     */
    graph: {
        valueFn: "_getGraph"
    },

    /**
     * Indicates whether or not markers for a series will be grouped and rendered in a single complex shape instance.
     *
     * @attribute groupMarkers
     * @type Boolean
     */
    groupMarkers: {
        value: false
    }
};

_yuitest_coverline("build/charts-base/charts-base.js", 12614);
ChartBase.prototype = {
    /**
     * Handles groupMarkers change event.
     *
     * @method _groupMarkersChangeHandler
     * @param {Object} e Event object.
     * @private
     */
    _groupMarkersChangeHandler: function(e)
    {
        _yuitest_coverfunc("build/charts-base/charts-base.js", "_groupMarkersChangeHandler", 12622);
_yuitest_coverline("build/charts-base/charts-base.js", 12624);
var graph = this.get("graph"),
            useGroupMarkers = e.newVal;
        _yuitest_coverline("build/charts-base/charts-base.js", 12626);
if(graph)
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 12628);
graph.set("groupMarkers", useGroupMarkers);
        }
    },

    /**
     * Handler for itemRendered event.
     *
     * @method _itemRendered
     * @param {Object} e Event object.
     * @private
     */
    _itemRendered: function(e)
    {
        _yuitest_coverfunc("build/charts-base/charts-base.js", "_itemRendered", 12639);
_yuitest_coverline("build/charts-base/charts-base.js", 12641);
this._itemRenderQueue = this._itemRenderQueue.splice(1 + Y.Array.indexOf(this._itemRenderQueue, e.currentTarget), 1);
        _yuitest_coverline("build/charts-base/charts-base.js", 12642);
if(this._itemRenderQueue.length < 1)
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 12644);
this._redraw();
        }
    },

    /**
     * Default value function for the `Graph` attribute.
     *
     * @method _getGraph
     * @return Graph
     * @private
     */
    _getGraph: function()
    {
        _yuitest_coverfunc("build/charts-base/charts-base.js", "_getGraph", 12655);
_yuitest_coverline("build/charts-base/charts-base.js", 12657);
var graph = new Y.Graph({
            chart:this,
            groupMarkers: this.get("groupMarkers")
        });
        _yuitest_coverline("build/charts-base/charts-base.js", 12661);
graph.after("chartRendered", Y.bind(function(e) {
            _yuitest_coverfunc("build/charts-base/charts-base.js", "(anonymous 6)", 12661);
_yuitest_coverline("build/charts-base/charts-base.js", 12662);
this.fire("chartRendered");
        }, this));
        _yuitest_coverline("build/charts-base/charts-base.js", 12664);
return graph;
    },

    /**
     * Returns a series instance by index or key value.
     *
     * @method getSeries
     * @param val
     * @return CartesianSeries
     */
    getSeries: function(val)
    {
        _yuitest_coverfunc("build/charts-base/charts-base.js", "getSeries", 12674);
_yuitest_coverline("build/charts-base/charts-base.js", 12676);
var series = null,
            graph = this.get("graph");
        _yuitest_coverline("build/charts-base/charts-base.js", 12678);
if(graph)
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 12680);
if(Y_Lang.isNumber(val))
            {
                _yuitest_coverline("build/charts-base/charts-base.js", 12682);
series = graph.getSeriesByIndex(val);
            }
            else
            {
                _yuitest_coverline("build/charts-base/charts-base.js", 12686);
series = graph.getSeriesByKey(val);
            }
        }
        _yuitest_coverline("build/charts-base/charts-base.js", 12689);
return series;
    },

    /**
     * Returns an `Axis` instance by key reference. If the axis was explicitly set through the `axes` attribute,
     * the key will be the same as the key used in the `axes` object. For default axes, the key for
     * the category axis is the value of the `categoryKey` (`category`). For the value axis, the default
     * key is `values`.
     *
     * @method getAxisByKey
     * @param {String} val Key reference used to look up the axis.
     * @return Axis
     */
    getAxisByKey: function(val)
    {
        _yuitest_coverfunc("build/charts-base/charts-base.js", "getAxisByKey", 12702);
_yuitest_coverline("build/charts-base/charts-base.js", 12704);
var axis,
            axes = this.get("axes");
        _yuitest_coverline("build/charts-base/charts-base.js", 12706);
if(axes && axes.hasOwnProperty(val))
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 12708);
axis = axes[val];
        }
        _yuitest_coverline("build/charts-base/charts-base.js", 12710);
return axis;
    },

    /**
     * Returns the category axis for the chart.
     *
     * @method getCategoryAxis
     * @return Axis
     */
    getCategoryAxis: function()
    {
        _yuitest_coverfunc("build/charts-base/charts-base.js", "getCategoryAxis", 12719);
_yuitest_coverline("build/charts-base/charts-base.js", 12721);
var axis,
            key = this.get("categoryKey"),
            axes = this.get("axes");
        _yuitest_coverline("build/charts-base/charts-base.js", 12724);
if(axes.hasOwnProperty(key))
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 12726);
axis = axes[key];
        }
        _yuitest_coverline("build/charts-base/charts-base.js", 12728);
return axis;
    },

    /**
     * Default direction of the chart.
     *
     * @property _direction
     * @type String
     * @default horizontal
     * @private
     */
    _direction: "horizontal",

    /**
     * Storage for the `dataProvider` attribute.
     *
     * @property _dataProvider
     * @type Array
     * @private
     */
    _dataProvider: null,

    /**
     * Setter method for `dataProvider` attribute.
     *
     * @method _setDataValues
     * @param {Array} val Array to be set as `dataProvider`.
     * @return Array
     * @private
     */
    _setDataValues: function(val)
    {
        _yuitest_coverfunc("build/charts-base/charts-base.js", "_setDataValues", 12758);
_yuitest_coverline("build/charts-base/charts-base.js", 12760);
if(Y_Lang.isArray(val[0]))
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 12762);
var hash,
                dp = [],
                cats = val[0],
                i = 0,
                l = cats.length,
                n,
                sl = val.length;
            _yuitest_coverline("build/charts-base/charts-base.js", 12769);
for(; i < l; ++i)
            {
                _yuitest_coverline("build/charts-base/charts-base.js", 12771);
hash = {category:cats[i]};
                _yuitest_coverline("build/charts-base/charts-base.js", 12772);
for(n = 1; n < sl; ++n)
                {
                    _yuitest_coverline("build/charts-base/charts-base.js", 12774);
hash["series" + n] = val[n][i];
                }
                _yuitest_coverline("build/charts-base/charts-base.js", 12776);
dp[i] = hash;
            }
            _yuitest_coverline("build/charts-base/charts-base.js", 12778);
return dp;
        }
        _yuitest_coverline("build/charts-base/charts-base.js", 12780);
return val;
    },

    /**
     * Storage for `seriesCollection` attribute.
     *
     * @property _seriesCollection
     * @type Array
     * @private
     */
    _seriesCollection: null,

    /**
     * Setter method for `seriesCollection` attribute.
     *
     * @property _setSeriesCollection
     * @param {Array} val Array of either `CartesianSeries` instances or objects containing series attribute key value pairs.
     * @private
     */
    _setSeriesCollection: function(val)
    {
        _yuitest_coverfunc("build/charts-base/charts-base.js", "_setSeriesCollection", 12799);
_yuitest_coverline("build/charts-base/charts-base.js", 12801);
this._seriesCollection = val;
    },
    /**
     * Helper method that returns the axis class that a key references.
     *
     * @method _getAxisClass
     * @param {String} t The type of axis.
     * @return Axis
     * @private
     */
    _getAxisClass: function(t)
    {
        _yuitest_coverfunc("build/charts-base/charts-base.js", "_getAxisClass", 12811);
_yuitest_coverline("build/charts-base/charts-base.js", 12813);
return this._axisClass[t];
    },

    /**
     * Key value pairs of axis types.
     *
     * @property _axisClass
     * @type Object
     * @private
     */
    _axisClass: {
        stacked: Y.StackedAxis,
        numeric: Y.NumericAxis,
        category: Y.CategoryAxis,
        time: Y.TimeAxis
    },

    /**
     * Collection of axes.
     *
     * @property _axes
     * @type Array
     * @private
     */
    _axes: null,

    /**
     * @method initializer
     * @private
     */
    initializer: function()
    {
        _yuitest_coverfunc("build/charts-base/charts-base.js", "initializer", 12843);
_yuitest_coverline("build/charts-base/charts-base.js", 12845);
this._itemRenderQueue = [];
        _yuitest_coverline("build/charts-base/charts-base.js", 12846);
this._seriesIndex = -1;
        _yuitest_coverline("build/charts-base/charts-base.js", 12847);
this._itemIndex = -1;
        _yuitest_coverline("build/charts-base/charts-base.js", 12848);
this.after("dataProviderChange", this._dataProviderChangeHandler);
    },

    /**
     * @method renderUI
     * @private
     */
    renderUI: function()
    {
        _yuitest_coverfunc("build/charts-base/charts-base.js", "renderUI", 12855);
_yuitest_coverline("build/charts-base/charts-base.js", 12857);
var tt = this.get("tooltip"),
            bb = this.get("boundingBox"),
            cb = this.get("contentBox");
        //move the position = absolute logic to a class file
        _yuitest_coverline("build/charts-base/charts-base.js", 12861);
bb.setStyle("position", "absolute");
        _yuitest_coverline("build/charts-base/charts-base.js", 12862);
cb.setStyle("position", "absolute");
        _yuitest_coverline("build/charts-base/charts-base.js", 12863);
this._addAxes();
        _yuitest_coverline("build/charts-base/charts-base.js", 12864);
this._addSeries();
        _yuitest_coverline("build/charts-base/charts-base.js", 12865);
if(tt && tt.show)
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 12867);
this._addTooltip();
        }
        _yuitest_coverline("build/charts-base/charts-base.js", 12869);
this._setAriaElements(bb, cb);
    },

    /**
     * Creates an aria `live-region`, `aria-label` and `aria-describedby` for the Chart.
     *
     * @method _setAriaElements
     * @param {Node} cb Reference to the Chart's `contentBox` attribute.
     * @private
     */
    _setAriaElements: function(bb, cb)
    {
        _yuitest_coverfunc("build/charts-base/charts-base.js", "_setAriaElements", 12879);
_yuitest_coverline("build/charts-base/charts-base.js", 12881);
var description = this._getAriaOffscreenNode(),
            id = this.get("id") + "_description",
            liveRegion = this._getAriaOffscreenNode();
        _yuitest_coverline("build/charts-base/charts-base.js", 12884);
cb.set("tabIndex", 0);
        _yuitest_coverline("build/charts-base/charts-base.js", 12885);
cb.set("role", "img");
        _yuitest_coverline("build/charts-base/charts-base.js", 12886);
cb.setAttribute("aria-label", this.get("ariaLabel"));
        _yuitest_coverline("build/charts-base/charts-base.js", 12887);
cb.setAttribute("aria-describedby", id);
        _yuitest_coverline("build/charts-base/charts-base.js", 12888);
description.set("id", id);
        _yuitest_coverline("build/charts-base/charts-base.js", 12889);
description.set("tabIndex", -1);
        _yuitest_coverline("build/charts-base/charts-base.js", 12890);
description.appendChild(DOCUMENT.createTextNode(this.get("ariaDescription")));
        _yuitest_coverline("build/charts-base/charts-base.js", 12891);
liveRegion.set("id", "live-region");
        _yuitest_coverline("build/charts-base/charts-base.js", 12892);
liveRegion.set("aria-live", "polite");
        _yuitest_coverline("build/charts-base/charts-base.js", 12893);
liveRegion.set("aria-atomic", "true");
        _yuitest_coverline("build/charts-base/charts-base.js", 12894);
liveRegion.set("role", "status");
        _yuitest_coverline("build/charts-base/charts-base.js", 12895);
bb.setAttribute("role", "application");
        _yuitest_coverline("build/charts-base/charts-base.js", 12896);
bb.appendChild(description);
        _yuitest_coverline("build/charts-base/charts-base.js", 12897);
bb.appendChild(liveRegion);
        _yuitest_coverline("build/charts-base/charts-base.js", 12898);
this._description = description;
        _yuitest_coverline("build/charts-base/charts-base.js", 12899);
this._liveRegion = liveRegion;
    },

    /**
     * Sets a node offscreen for use as aria-description or aria-live-regin.
     *
     * @method _setOffscreen
     * @return Node
     * @private
     */
    _getAriaOffscreenNode: function()
    {
        _yuitest_coverfunc("build/charts-base/charts-base.js", "_getAriaOffscreenNode", 12909);
_yuitest_coverline("build/charts-base/charts-base.js", 12911);
var node = Y.Node.create("<div></div>"),
            ie = Y.UA.ie,
            clipRect = (ie && ie < 8) ? "rect(1px 1px 1px 1px)" : "rect(1px, 1px, 1px, 1px)";
        _yuitest_coverline("build/charts-base/charts-base.js", 12914);
node.setStyle("position", "absolute");
        _yuitest_coverline("build/charts-base/charts-base.js", 12915);
node.setStyle("height", "1px");
        _yuitest_coverline("build/charts-base/charts-base.js", 12916);
node.setStyle("width", "1px");
        _yuitest_coverline("build/charts-base/charts-base.js", 12917);
node.setStyle("overflow", "hidden");
        _yuitest_coverline("build/charts-base/charts-base.js", 12918);
node.setStyle("clip", clipRect);
        _yuitest_coverline("build/charts-base/charts-base.js", 12919);
return node;
    },

    /**
     * @method syncUI
     * @private
     */
    syncUI: function()
    {
        _yuitest_coverfunc("build/charts-base/charts-base.js", "syncUI", 12926);
_yuitest_coverline("build/charts-base/charts-base.js", 12928);
this._redraw();
    },

    /**
     * @method bindUI
     * @private
     */
    bindUI: function()
    {
        _yuitest_coverfunc("build/charts-base/charts-base.js", "bindUI", 12935);
_yuitest_coverline("build/charts-base/charts-base.js", 12937);
this.after("tooltipChange", Y.bind(this._tooltipChangeHandler, this));
        _yuitest_coverline("build/charts-base/charts-base.js", 12938);
this.after("widthChange", this._sizeChanged);
        _yuitest_coverline("build/charts-base/charts-base.js", 12939);
this.after("heightChange", this._sizeChanged);
        _yuitest_coverline("build/charts-base/charts-base.js", 12940);
this.after("groupMarkersChange", this._groupMarkersChangeHandler);
        _yuitest_coverline("build/charts-base/charts-base.js", 12941);
var tt = this.get("tooltip"),
            hideEvent = "mouseout",
            showEvent = "mouseover",
            cb = this.get("contentBox"),
            interactionType = this.get("interactionType"),
            i = 0,
            len,
            markerClassName = "." + SERIES_MARKER,
            isTouch = ((WINDOW && ("ontouchstart" in WINDOW)) && !(Y.UA.chrome && Y.UA.chrome < 6));
        _yuitest_coverline("build/charts-base/charts-base.js", 12950);
Y.on("keydown", Y.bind(function(e) {
            _yuitest_coverfunc("build/charts-base/charts-base.js", "(anonymous 7)", 12950);
_yuitest_coverline("build/charts-base/charts-base.js", 12951);
var key = e.keyCode,
                numKey = parseFloat(key),
                msg;
            _yuitest_coverline("build/charts-base/charts-base.js", 12954);
if(numKey > 36 && numKey < 41)
            {
                _yuitest_coverline("build/charts-base/charts-base.js", 12956);
e.halt();
                _yuitest_coverline("build/charts-base/charts-base.js", 12957);
msg = this._getAriaMessage(numKey);
                _yuitest_coverline("build/charts-base/charts-base.js", 12958);
this._liveRegion.setContent("");
                _yuitest_coverline("build/charts-base/charts-base.js", 12959);
this._liveRegion.appendChild(DOCUMENT.createTextNode(msg));
            }
        }, this), this.get("contentBox"));
        _yuitest_coverline("build/charts-base/charts-base.js", 12962);
if(interactionType == "marker")
        {
            //if touch capabilities, toggle tooltip on touchend. otherwise, the tooltip attribute's hideEvent/showEvent types.
            _yuitest_coverline("build/charts-base/charts-base.js", 12965);
hideEvent = tt.hideEvent;
            _yuitest_coverline("build/charts-base/charts-base.js", 12966);
showEvent = tt.showEvent;
            _yuitest_coverline("build/charts-base/charts-base.js", 12967);
if(isTouch)
            {
                _yuitest_coverline("build/charts-base/charts-base.js", 12969);
Y.delegate("touchend", Y.bind(this._markerEventDispatcher, this), cb, markerClassName);
                //hide active tooltip if the chart is touched
                _yuitest_coverline("build/charts-base/charts-base.js", 12971);
Y.on("touchend", Y.bind(function(e) {
                    _yuitest_coverfunc("build/charts-base/charts-base.js", "(anonymous 8)", 12971);
_yuitest_coverline("build/charts-base/charts-base.js", 12972);
e.halt(true);
                    _yuitest_coverline("build/charts-base/charts-base.js", 12973);
if(this._activeMarker)
                    {
                        _yuitest_coverline("build/charts-base/charts-base.js", 12975);
this._activeMarker = null;
                        _yuitest_coverline("build/charts-base/charts-base.js", 12976);
this.hideTooltip(e);
                    }
                }, this));
            }
            else
            {
                _yuitest_coverline("build/charts-base/charts-base.js", 12982);
Y.delegate("mouseenter", Y.bind(this._markerEventDispatcher, this), cb, markerClassName);
                _yuitest_coverline("build/charts-base/charts-base.js", 12983);
Y.delegate("mousedown", Y.bind(this._markerEventDispatcher, this), cb, markerClassName);
                _yuitest_coverline("build/charts-base/charts-base.js", 12984);
Y.delegate("mouseup", Y.bind(this._markerEventDispatcher, this), cb, markerClassName);
                _yuitest_coverline("build/charts-base/charts-base.js", 12985);
Y.delegate("mouseleave", Y.bind(this._markerEventDispatcher, this), cb, markerClassName);
                _yuitest_coverline("build/charts-base/charts-base.js", 12986);
Y.delegate("click", Y.bind(this._markerEventDispatcher, this), cb, markerClassName);
                _yuitest_coverline("build/charts-base/charts-base.js", 12987);
Y.delegate("mousemove", Y.bind(this._positionTooltip, this), cb, markerClassName);
            }
        }
        else {_yuitest_coverline("build/charts-base/charts-base.js", 12990);
if(interactionType == "planar")
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 12992);
if(isTouch)
            {
                _yuitest_coverline("build/charts-base/charts-base.js", 12994);
this._overlay.on("touchend", Y.bind(this._planarEventDispatcher, this));
            }
            else
            {
                _yuitest_coverline("build/charts-base/charts-base.js", 12998);
this._overlay.on("mousemove", Y.bind(this._planarEventDispatcher, this));
                _yuitest_coverline("build/charts-base/charts-base.js", 12999);
this.on("mouseout", this.hideTooltip);
            }
        }}
        _yuitest_coverline("build/charts-base/charts-base.js", 13002);
if(tt)
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 13004);
this.on("markerEvent:touchend", Y.bind(function(e) {
                _yuitest_coverfunc("build/charts-base/charts-base.js", "(anonymous 9)", 13004);
_yuitest_coverline("build/charts-base/charts-base.js", 13005);
var marker = e.series.get("markers")[e.index];
                _yuitest_coverline("build/charts-base/charts-base.js", 13006);
if(this._activeMarker && marker === this._activeMarker)
                {
                    _yuitest_coverline("build/charts-base/charts-base.js", 13008);
this._activeMarker = null;
                    _yuitest_coverline("build/charts-base/charts-base.js", 13009);
this.hideTooltip(e);
                }
                else
                {

                    _yuitest_coverline("build/charts-base/charts-base.js", 13014);
this._activeMarker = marker;
                    _yuitest_coverline("build/charts-base/charts-base.js", 13015);
tt.markerEventHandler.apply(this, [e]);
                }
            }, this));
            _yuitest_coverline("build/charts-base/charts-base.js", 13018);
if(hideEvent && showEvent && hideEvent == showEvent)
            {
                _yuitest_coverline("build/charts-base/charts-base.js", 13020);
this.on(interactionType + "Event:" + hideEvent, this.toggleTooltip);
            }
            else
            {
                _yuitest_coverline("build/charts-base/charts-base.js", 13024);
if(showEvent)
                {
                    _yuitest_coverline("build/charts-base/charts-base.js", 13026);
this.on(interactionType + "Event:" + showEvent, tt[interactionType + "EventHandler"]);
                }
                _yuitest_coverline("build/charts-base/charts-base.js", 13028);
if(hideEvent)
                {
                    _yuitest_coverline("build/charts-base/charts-base.js", 13030);
if(Y_Lang.isArray(hideEvent))
                    {
                        _yuitest_coverline("build/charts-base/charts-base.js", 13032);
len = hideEvent.length;
                        _yuitest_coverline("build/charts-base/charts-base.js", 13033);
for(; i < len; ++i)
                        {
                            _yuitest_coverline("build/charts-base/charts-base.js", 13035);
this.on(interactionType + "Event:" + hideEvent[i], this.hideTooltip);
                        }
                    }
                    _yuitest_coverline("build/charts-base/charts-base.js", 13038);
this.on(interactionType + "Event:" + hideEvent, this.hideTooltip);
                }
            }
        }
    },

    /**
     * Event handler for marker events.
     *
     * @method _markerEventDispatcher
     * @param {Object} e Event object.
     * @private
     */
    _markerEventDispatcher: function(e)
    {
        _yuitest_coverfunc("build/charts-base/charts-base.js", "_markerEventDispatcher", 13051);
_yuitest_coverline("build/charts-base/charts-base.js", 13053);
var type = e.type,
            cb = this.get("contentBox"),
            markerNode = e.currentTarget,
            strArr = markerNode.getAttribute("id").split("_"),
            index = strArr.pop(),
            seriesIndex = strArr.pop(),
            series = this.getSeries(parseInt(seriesIndex, 10)),
            items = this.getSeriesItems(series, index),
            isTouch = e && e.hasOwnProperty("changedTouches"),
            pageX = isTouch ? e.changedTouches[0].pageX : e.pageX,
            pageY = isTouch ? e.changedTouches[0].pageY : e.pageY,
            x = pageX - cb.getX(),
            y = pageY - cb.getY();
        _yuitest_coverline("build/charts-base/charts-base.js", 13066);
if(type == "mouseenter")
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 13068);
type = "mouseover";
        }
        else {_yuitest_coverline("build/charts-base/charts-base.js", 13070);
if(type == "mouseleave")
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 13072);
type = "mouseout";
        }}
        _yuitest_coverline("build/charts-base/charts-base.js", 13074);
series.updateMarkerState(type, index);
        _yuitest_coverline("build/charts-base/charts-base.js", 13075);
e.halt();
        /**
         * Broadcasts when `interactionType` is set to `marker` and a series marker has received a mouseover event.
         *
         *
         * @event markerEvent:mouseover
         * @preventable false
         * @param {EventFacade} e Event facade with the following additional
         *   properties:
         *  <dl>
         *      <dt>categoryItem</dt><dd>Hash containing information about the category `Axis`.</dd>
         *      <dt>valueItem</dt><dd>Hash containing information about the value `Axis`.</dd>
         *      <dt>node</dt><dd>The dom node of the marker.</dd>
         *      <dt>x</dt><dd>The x-coordinate of the mouse in relation to the Chart.</dd>
         *      <dt>y</dt><dd>The y-coordinate of the mouse in relation to the Chart.</dd>
         *      <dt>series</dt><dd>Reference to the series of the marker.</dd>
         *      <dt>index</dt><dd>Index of the marker in the series.</dd>
         *      <dt>seriesIndex</dt><dd>The `order` of the marker's series.</dd>
         *  </dl>
         */
        /**
         * Broadcasts when `interactionType` is set to `marker` and a series marker has received a mouseout event.
         *
         * @event markerEvent:mouseout
         * @preventable false
         * @param {EventFacade} e Event facade with the following additional
         *   properties:
         *  <dl>
         *      <dt>categoryItem</dt><dd>Hash containing information about the category `Axis`.</dd>
         *      <dt>valueItem</dt><dd>Hash containing information about the value `Axis`.</dd>
         *      <dt>node</dt><dd>The dom node of the marker.</dd>
         *      <dt>x</dt><dd>The x-coordinate of the mouse in relation to the Chart.</dd>
         *      <dt>y</dt><dd>The y-coordinate of the mouse in relation to the Chart.</dd>
         *      <dt>series</dt><dd>Reference to the series of the marker.</dd>
         *      <dt>index</dt><dd>Index of the marker in the series.</dd>
         *      <dt>seriesIndex</dt><dd>The `order` of the marker's series.</dd>
         *  </dl>
         */
        /**
         * Broadcasts when `interactionType` is set to `marker` and a series marker has received a mousedown event.
         *
         * @event markerEvent:mousedown
         * @preventable false
         * @param {EventFacade} e Event facade with the following additional
         *   properties:
         *  <dl>
         *      <dt>categoryItem</dt><dd>Hash containing information about the category `Axis`.</dd>
         *      <dt>valueItem</dt><dd>Hash containing information about the value `Axis`.</dd>
         *      <dt>node</dt><dd>The dom node of the marker.</dd>
         *      <dt>x</dt><dd>The x-coordinate of the mouse in relation to the Chart.</dd>
         *      <dt>y</dt><dd>The y-coordinate of the mouse in relation to the Chart.</dd>
         *      <dt>series</dt><dd>Reference to the series of the marker.</dd>
         *      <dt>index</dt><dd>Index of the marker in the series.</dd>
         *      <dt>seriesIndex</dt><dd>The `order` of the marker's series.</dd>
         *  </dl>
         */
        /**
         * Broadcasts when `interactionType` is set to `marker` and a series marker has received a mouseup event.
         *
         * @event markerEvent:mouseup
         * @preventable false
         * @param {EventFacade} e Event facade with the following additional
         *   properties:
         *  <dl>
         *      <dt>categoryItem</dt><dd>Hash containing information about the category `Axis`.</dd>
         *      <dt>valueItem</dt><dd>Hash containing information about the value `Axis`.</dd>
         *      <dt>node</dt><dd>The dom node of the marker.</dd>
         *      <dt>x</dt><dd>The x-coordinate of the mouse in relation to the Chart.</dd>
         *      <dt>y</dt><dd>The y-coordinate of the mouse in relation to the Chart.</dd>
         *      <dt>series</dt><dd>Reference to the series of the marker.</dd>
         *      <dt>index</dt><dd>Index of the marker in the series.</dd>
         *      <dt>seriesIndex</dt><dd>The `order` of the marker's series.</dd>
         *  </dl>
         */
        /**
         * Broadcasts when `interactionType` is set to `marker` and a series marker has received a click event.
         *
         * @event markerEvent:click
         * @preventable false
         * @param {EventFacade} e Event facade with the following additional
         *   properties:
         *  <dl>
         *      <dt>categoryItem</dt><dd>Hash containing information about the category `Axis`.</dd>
         *      <dt>valueItem</dt><dd>Hash containing information about the value `Axis`.</dd>
         *      <dt>node</dt><dd>The dom node of the marker.</dd>
         *      <dt>x</dt><dd>The x-coordinate of the mouse in relation to the Chart.</dd>
         *      <dt>y</dt><dd>The y-coordinate of the mouse in relation to the Chart.</dd>
         *      <dt>pageX</dt><dd>The x location of the event on the page (including scroll)</dd>
         *      <dt>pageY</dt><dd>The y location of the event on the page (including scroll)</dd>
         *      <dt>series</dt><dd>Reference to the series of the marker.</dd>
         *      <dt>index</dt><dd>Index of the marker in the series.</dd>
         *      <dt>seriesIndex</dt><dd>The `order` of the marker's series.</dd>
         *      <dt>originEvent</dt><dd>Underlying dom event.</dd>
         *  </dl>
         */
        _yuitest_coverline("build/charts-base/charts-base.js", 13170);
this.fire("markerEvent:" + type, {
            originEvent: e,
            pageX:pageX,
            pageY:pageY,
            categoryItem:items.category,
            valueItem:items.value,
            node:markerNode,
            x:x,
            y:y,
            series:series,
            index:index,
            seriesIndex:seriesIndex
        });
    },

    /**
     * Event handler for dataProviderChange.
     *
     * @method _dataProviderChangeHandler
     * @param {Object} e Event object.
     * @private
     */
    _dataProviderChangeHandler: function(e)
    {
        _yuitest_coverfunc("build/charts-base/charts-base.js", "_dataProviderChangeHandler", 13192);
_yuitest_coverline("build/charts-base/charts-base.js", 13194);
var dataProvider = e.newVal,
            axes,
            i,
            axis;
        _yuitest_coverline("build/charts-base/charts-base.js", 13198);
this._seriesIndex = -1;
        _yuitest_coverline("build/charts-base/charts-base.js", 13199);
this._itemIndex = -1;
        _yuitest_coverline("build/charts-base/charts-base.js", 13200);
if(this instanceof Y.CartesianChart)
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 13202);
this.set("axes", this.get("axes"));
            _yuitest_coverline("build/charts-base/charts-base.js", 13203);
this.set("seriesCollection", this.get("seriesCollection"));
        }
        _yuitest_coverline("build/charts-base/charts-base.js", 13205);
axes = this.get("axes");
        _yuitest_coverline("build/charts-base/charts-base.js", 13206);
if(axes)
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 13208);
for(i in axes)
            {
                _yuitest_coverline("build/charts-base/charts-base.js", 13210);
if(axes.hasOwnProperty(i))
                {
                    _yuitest_coverline("build/charts-base/charts-base.js", 13212);
axis = axes[i];
                    _yuitest_coverline("build/charts-base/charts-base.js", 13213);
if(axis instanceof Y.Axis)
                    {
                        _yuitest_coverline("build/charts-base/charts-base.js", 13215);
if(axis.get("position") != "none")
                        {
                            _yuitest_coverline("build/charts-base/charts-base.js", 13217);
this._addToAxesRenderQueue(axis);
                        }
                        _yuitest_coverline("build/charts-base/charts-base.js", 13219);
axis.set("dataProvider", dataProvider);
                    }
                }
            }
        }
    },

    /**
     * Event listener for toggling the tooltip. If a tooltip is visible, hide it. If not, it
     * will create and show a tooltip based on the event object.
     *
     * @method toggleTooltip
     * @param {Object} e Event object.
     */
    toggleTooltip: function(e)
    {
        _yuitest_coverfunc("build/charts-base/charts-base.js", "toggleTooltip", 13233);
_yuitest_coverline("build/charts-base/charts-base.js", 13235);
var tt = this.get("tooltip");
        _yuitest_coverline("build/charts-base/charts-base.js", 13236);
if(tt.visible)
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 13238);
this.hideTooltip();
        }
        else
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 13242);
tt.markerEventHandler.apply(this, [e]);
        }
    },

    /**
     * Shows a tooltip
     *
     * @method _showTooltip
     * @param {String} msg Message to dispaly in the tooltip.
     * @param {Number} x x-coordinate
     * @param {Number} y y-coordinate
     * @private
     */
    _showTooltip: function(msg, x, y)
    {
        _yuitest_coverfunc("build/charts-base/charts-base.js", "_showTooltip", 13255);
_yuitest_coverline("build/charts-base/charts-base.js", 13257);
var tt = this.get("tooltip"),
            node = tt.node;
        _yuitest_coverline("build/charts-base/charts-base.js", 13259);
if(msg)
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 13261);
tt.visible = true;
            _yuitest_coverline("build/charts-base/charts-base.js", 13262);
tt.setTextFunction(node, msg);
            _yuitest_coverline("build/charts-base/charts-base.js", 13263);
node.setStyle("top", y + "px");
            _yuitest_coverline("build/charts-base/charts-base.js", 13264);
node.setStyle("left", x + "px");
            _yuitest_coverline("build/charts-base/charts-base.js", 13265);
node.setStyle("visibility", "visible");
        }
    },

    /**
     * Positions the tooltip
     *
     * @method _positionTooltip
     * @param {Object} e Event object.
     * @private
     */
    _positionTooltip: function(e)
    {
        _yuitest_coverfunc("build/charts-base/charts-base.js", "_positionTooltip", 13276);
_yuitest_coverline("build/charts-base/charts-base.js", 13278);
var tt = this.get("tooltip"),
            node = tt.node,
            cb = this.get("contentBox"),
            x = (e.pageX + 10) - cb.getX(),
            y = (e.pageY + 10) - cb.getY();
        _yuitest_coverline("build/charts-base/charts-base.js", 13283);
if(node)
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 13285);
node.setStyle("left", x + "px");
            _yuitest_coverline("build/charts-base/charts-base.js", 13286);
node.setStyle("top", y + "px");
        }
    },

    /**
     * Hides the default tooltip
     *
     * @method hideTooltip
     */
    hideTooltip: function()
    {
        _yuitest_coverfunc("build/charts-base/charts-base.js", "hideTooltip", 13295);
_yuitest_coverline("build/charts-base/charts-base.js", 13297);
var tt = this.get("tooltip"),
            node = tt.node;
        _yuitest_coverline("build/charts-base/charts-base.js", 13299);
tt.visible = false;
        _yuitest_coverline("build/charts-base/charts-base.js", 13300);
node.set("innerHTML", "");
        _yuitest_coverline("build/charts-base/charts-base.js", 13301);
node.setStyle("left", -10000);
        _yuitest_coverline("build/charts-base/charts-base.js", 13302);
node.setStyle("top", -10000);
        _yuitest_coverline("build/charts-base/charts-base.js", 13303);
node.setStyle("visibility", "hidden");
    },

    /**
     * Adds a tooltip to the dom.
     *
     * @method _addTooltip
     * @private
     */
    _addTooltip: function()
    {
        _yuitest_coverfunc("build/charts-base/charts-base.js", "_addTooltip", 13312);
_yuitest_coverline("build/charts-base/charts-base.js", 13314);
var tt = this.get("tooltip"),
            id = this.get("id") + "_tooltip",
            cb = this.get("contentBox"),
            oldNode = DOCUMENT.getElementById(id);
        _yuitest_coverline("build/charts-base/charts-base.js", 13318);
if(oldNode)
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 13320);
cb.removeChild(oldNode);
        }
        _yuitest_coverline("build/charts-base/charts-base.js", 13322);
tt.node.set("id", id);
        _yuitest_coverline("build/charts-base/charts-base.js", 13323);
tt.node.setStyle("visibility", "hidden");
        _yuitest_coverline("build/charts-base/charts-base.js", 13324);
cb.appendChild(tt.node);
    },

    /**
     * Updates the tooltip attribute.
     *
     * @method _updateTooltip
     * @param {Object} val Object containing properties for the tooltip.
     * @return Object
     * @private
     */
    _updateTooltip: function(val)
    {
        _yuitest_coverfunc("build/charts-base/charts-base.js", "_updateTooltip", 13335);
_yuitest_coverline("build/charts-base/charts-base.js", 13337);
var tt = this.get("tooltip") || this._getTooltip(),
            i,
            styles,
            node,
            props = {
                markerLabelFunction:"markerLabelFunction",
                planarLabelFunction:"planarLabelFunction",
                setTextFunction:"setTextFunction",
                showEvent:"showEvent",
                hideEvent:"hideEvent",
                markerEventHandler:"markerEventHandler",
                planarEventHandler:"planarEventHandler",
                show:"show"
            };
        _yuitest_coverline("build/charts-base/charts-base.js", 13351);
if(Y_Lang.isObject(val))
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 13353);
styles = val.styles;
            _yuitest_coverline("build/charts-base/charts-base.js", 13354);
node = Y.one(val.node) || tt.node;
            _yuitest_coverline("build/charts-base/charts-base.js", 13355);
if(styles)
            {
                _yuitest_coverline("build/charts-base/charts-base.js", 13357);
for(i in styles)
                {
                    _yuitest_coverline("build/charts-base/charts-base.js", 13359);
if(styles.hasOwnProperty(i))
                    {
                        _yuitest_coverline("build/charts-base/charts-base.js", 13361);
node.setStyle(i, styles[i]);
                    }
                }
            }
            _yuitest_coverline("build/charts-base/charts-base.js", 13365);
for(i in props)
            {
                _yuitest_coverline("build/charts-base/charts-base.js", 13367);
if(val.hasOwnProperty(i))
                {
                    _yuitest_coverline("build/charts-base/charts-base.js", 13369);
tt[i] = val[i];
                }
            }
            _yuitest_coverline("build/charts-base/charts-base.js", 13372);
tt.node = node;
        }
        _yuitest_coverline("build/charts-base/charts-base.js", 13374);
return tt;
    },

    /**
     * Default getter for `tooltip` attribute.
     *
     * @method _getTooltip
     * @return Object
     * @private
     */
    _getTooltip: function()
    {
        _yuitest_coverfunc("build/charts-base/charts-base.js", "_getTooltip", 13384);
_yuitest_coverline("build/charts-base/charts-base.js", 13386);
var node = DOCUMENT.createElement("div"),
            tooltipClass = _getClassName("chart-tooltip"),
            tt = {
                setTextFunction: this._setText,
                markerLabelFunction: this._tooltipLabelFunction,
                planarLabelFunction: this._planarLabelFunction,
                show: true,
                hideEvent: "mouseout",
                showEvent: "mouseover",
                markerEventHandler: function(e)
                {
                    _yuitest_coverfunc("build/charts-base/charts-base.js", "markerEventHandler", 13395);
_yuitest_coverline("build/charts-base/charts-base.js", 13397);
var tt = this.get("tooltip"),
                    msg = tt.markerLabelFunction.apply(this, [e.categoryItem, e.valueItem, e.index, e.series, e.seriesIndex]);
                    _yuitest_coverline("build/charts-base/charts-base.js", 13399);
this._showTooltip(msg, e.x + 10, e.y + 10);
                },
                planarEventHandler: function(e)
                {
                    _yuitest_coverfunc("build/charts-base/charts-base.js", "planarEventHandler", 13401);
_yuitest_coverline("build/charts-base/charts-base.js", 13403);
var tt = this.get("tooltip"),
                        msg ,
                        categoryAxis = this.get("categoryAxis");
                    _yuitest_coverline("build/charts-base/charts-base.js", 13406);
msg = tt.planarLabelFunction.apply(this, [categoryAxis, e.valueItem, e.index, e.items, e.seriesIndex]);
                    _yuitest_coverline("build/charts-base/charts-base.js", 13407);
this._showTooltip(msg, e.x + 10, e.y + 10);
                }
            };
        _yuitest_coverline("build/charts-base/charts-base.js", 13410);
node = Y.one(node);
        _yuitest_coverline("build/charts-base/charts-base.js", 13411);
node.set("id", this.get("id") + "_tooltip");
        _yuitest_coverline("build/charts-base/charts-base.js", 13412);
node.setStyle("fontSize", "85%");
        _yuitest_coverline("build/charts-base/charts-base.js", 13413);
node.setStyle("opacity", "0.83");
        _yuitest_coverline("build/charts-base/charts-base.js", 13414);
node.setStyle("position", "absolute");
        _yuitest_coverline("build/charts-base/charts-base.js", 13415);
node.setStyle("paddingTop", "2px");
        _yuitest_coverline("build/charts-base/charts-base.js", 13416);
node.setStyle("paddingRight", "5px");
        _yuitest_coverline("build/charts-base/charts-base.js", 13417);
node.setStyle("paddingBottom", "4px");
        _yuitest_coverline("build/charts-base/charts-base.js", 13418);
node.setStyle("paddingLeft", "2px");
        _yuitest_coverline("build/charts-base/charts-base.js", 13419);
node.setStyle("backgroundColor", "#fff");
        _yuitest_coverline("build/charts-base/charts-base.js", 13420);
node.setStyle("border", "1px solid #dbdccc");
        _yuitest_coverline("build/charts-base/charts-base.js", 13421);
node.setStyle("pointerEvents", "none");
        _yuitest_coverline("build/charts-base/charts-base.js", 13422);
node.setStyle("zIndex", 3);
        _yuitest_coverline("build/charts-base/charts-base.js", 13423);
node.setStyle("whiteSpace", "noWrap");
        _yuitest_coverline("build/charts-base/charts-base.js", 13424);
node.setStyle("visibility", "hidden");
        _yuitest_coverline("build/charts-base/charts-base.js", 13425);
node.addClass(tooltipClass);
        _yuitest_coverline("build/charts-base/charts-base.js", 13426);
tt.node = Y.one(node);
        _yuitest_coverline("build/charts-base/charts-base.js", 13427);
return tt;
    },

    /**
     * Formats tooltip text when `interactionType` is `planar`.
     *
     * @method _planarLabelFunction
     * @param {Axis} categoryAxis Reference to the categoryAxis of the chart.
     * @param {Array} valueItems Array of objects for each series that has a data point in the coordinate plane of the event.
     * Each object contains the following data:
     *  <dl>
     *      <dt>axis</dt><dd>The value axis of the series.</dd>
     *      <dt>key</dt><dd>The key for the series.</dd>
     *      <dt>value</dt><dd>The value for the series item.</dd>
     *      <dt>displayName</dt><dd>The display name of the series. (defaults to key if not provided)</dd>
     *  </dl>
     *  @param {Number} index The index of the item within its series.
     *  @param {Array} seriesArray Array of series instances for each value item.
     *  @param {Number} seriesIndex The index of the series in the `seriesCollection`.
     *  @return {String | HTML}
     * @private
     */
    _planarLabelFunction: function(categoryAxis, valueItems, index, seriesArray, seriesIndex)
    {
        _yuitest_coverfunc("build/charts-base/charts-base.js", "_planarLabelFunction", 13449);
_yuitest_coverline("build/charts-base/charts-base.js", 13451);
var msg = DOCUMENT.createElement("div"),
            valueItem,
            i = 0,
            len = seriesArray.length,
            axis,
            categoryValue,
            seriesValue,
            series;
        _yuitest_coverline("build/charts-base/charts-base.js", 13459);
if(categoryAxis)
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 13461);
categoryValue = categoryAxis.get("labelFunction").apply(this, [categoryAxis.getKeyValueAt(this.get("categoryKey"), index), categoryAxis.get("labelFormat")]);
            _yuitest_coverline("build/charts-base/charts-base.js", 13462);
if(!Y_Lang.isObject(categoryValue))
            {
                _yuitest_coverline("build/charts-base/charts-base.js", 13464);
categoryValue = DOCUMENT.createTextNode(categoryValue);
            }
            _yuitest_coverline("build/charts-base/charts-base.js", 13466);
msg.appendChild(categoryValue);
        }

        _yuitest_coverline("build/charts-base/charts-base.js", 13469);
for(; i < len; ++i)
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 13471);
series = seriesArray[i];
            _yuitest_coverline("build/charts-base/charts-base.js", 13472);
if(series.get("visible"))
            {
                _yuitest_coverline("build/charts-base/charts-base.js", 13474);
valueItem = valueItems[i];
                _yuitest_coverline("build/charts-base/charts-base.js", 13475);
axis = valueItem.axis;
                _yuitest_coverline("build/charts-base/charts-base.js", 13476);
seriesValue =  axis.get("labelFunction").apply(this, [axis.getKeyValueAt(valueItem.key, index), axis.get("labelFormat")]);
                _yuitest_coverline("build/charts-base/charts-base.js", 13477);
msg.appendChild(DOCUMENT.createElement("br"));
                _yuitest_coverline("build/charts-base/charts-base.js", 13478);
msg.appendChild(DOCUMENT.createTextNode(valueItem.displayName));
                _yuitest_coverline("build/charts-base/charts-base.js", 13479);
msg.appendChild(DOCUMENT.createTextNode(": "));
                _yuitest_coverline("build/charts-base/charts-base.js", 13480);
if(!Y_Lang.isObject(seriesValue))
                {
                    _yuitest_coverline("build/charts-base/charts-base.js", 13482);
seriesValue = DOCUMENT.createTextNode(seriesValue);
                }
                _yuitest_coverline("build/charts-base/charts-base.js", 13484);
msg.appendChild(seriesValue);
            }
        }
        _yuitest_coverline("build/charts-base/charts-base.js", 13487);
return msg;
    },

    /**
     * Formats tooltip text when `interactionType` is `marker`.
     *
     * @method _tooltipLabelFunction
     * @param {Object} categoryItem An object containing the following:
     *  <dl>
     *      <dt>axis</dt><dd>The axis to which the category is bound.</dd>
     *      <dt>displayName</dt><dd>The display name set to the category (defaults to key if not provided)</dd>
     *      <dt>key</dt><dd>The key of the category.</dd>
     *      <dt>value</dt><dd>The value of the category</dd>
     *  </dl>
     * @param {Object} valueItem An object containing the following:
     *  <dl>
     *      <dt>axis</dt><dd>The axis to which the item's series is bound.</dd>
     *      <dt>displayName</dt><dd>The display name of the series. (defaults to key if not provided)</dd>
     *      <dt>key</dt><dd>The key for the series.</dd>
     *      <dt>value</dt><dd>The value for the series item.</dd>
     *  </dl>
     * @param {Number} itemIndex The index of the item within the series.
     * @param {CartesianSeries} series The `CartesianSeries` instance of the item.
     * @param {Number} seriesIndex The index of the series in the `seriesCollection`.
     * @return {String | HTML}
     * @private
     */
    _tooltipLabelFunction: function(categoryItem, valueItem, itemIndex, series, seriesIndex)
    {
        _yuitest_coverfunc("build/charts-base/charts-base.js", "_tooltipLabelFunction", 13514);
_yuitest_coverline("build/charts-base/charts-base.js", 13516);
var msg = DOCUMENT.createElement("div"),
            categoryValue = categoryItem.axis.get("labelFunction").apply(this, [categoryItem.value, categoryItem.axis.get("labelFormat")]),
            seriesValue = valueItem.axis.get("labelFunction").apply(this, [valueItem.value, valueItem.axis.get("labelFormat")]);
        _yuitest_coverline("build/charts-base/charts-base.js", 13519);
msg.appendChild(DOCUMENT.createTextNode(categoryItem.displayName));
        _yuitest_coverline("build/charts-base/charts-base.js", 13520);
msg.appendChild(DOCUMENT.createTextNode(": "));
        _yuitest_coverline("build/charts-base/charts-base.js", 13521);
if(!Y_Lang.isObject(categoryValue))
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 13523);
categoryValue = DOCUMENT.createTextNode(categoryValue);
        }
        _yuitest_coverline("build/charts-base/charts-base.js", 13525);
msg.appendChild(categoryValue);
        _yuitest_coverline("build/charts-base/charts-base.js", 13526);
msg.appendChild(DOCUMENT.createElement("br"));
        _yuitest_coverline("build/charts-base/charts-base.js", 13527);
msg.appendChild(DOCUMENT.createTextNode(valueItem.displayName));
        _yuitest_coverline("build/charts-base/charts-base.js", 13528);
msg.appendChild(DOCUMENT.createTextNode(": "));
        _yuitest_coverline("build/charts-base/charts-base.js", 13529);
if(!Y_Lang.isObject(seriesValue))
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 13531);
seriesValue = DOCUMENT.createTextNode(seriesValue);
        }
        _yuitest_coverline("build/charts-base/charts-base.js", 13533);
msg.appendChild(seriesValue);
        _yuitest_coverline("build/charts-base/charts-base.js", 13534);
return msg;
    },

    /**
     * Event handler for the tooltipChange.
     *
     * @method _tooltipChangeHandler
     * @param {Object} e Event object.
     * @private
     */
    _tooltipChangeHandler: function(e)
    {
        _yuitest_coverfunc("build/charts-base/charts-base.js", "_tooltipChangeHandler", 13544);
_yuitest_coverline("build/charts-base/charts-base.js", 13546);
if(this.get("tooltip"))
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 13548);
var tt = this.get("tooltip"),
                node = tt.node,
                show = tt.show,
                cb = this.get("contentBox");
            _yuitest_coverline("build/charts-base/charts-base.js", 13552);
if(node && show)
            {
                _yuitest_coverline("build/charts-base/charts-base.js", 13554);
if(!cb.contains(node))
                {
                    _yuitest_coverline("build/charts-base/charts-base.js", 13556);
this._addTooltip();
                }
            }
        }
    },

    /**
     * Updates the content of text field. This method writes a value into a text field using
     * `appendChild`. If the value is a `String`, it is converted to a `TextNode` first.
     *
     * @method _setText
     * @param label {HTMLElement} label to be updated
     * @param val {String} value with which to update the label
     * @private
     */
    _setText: function(textField, val)
    {
        _yuitest_coverfunc("build/charts-base/charts-base.js", "_setText", 13571);
_yuitest_coverline("build/charts-base/charts-base.js", 13573);
textField.setContent("");
        _yuitest_coverline("build/charts-base/charts-base.js", 13574);
if(Y_Lang.isNumber(val))
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 13576);
val = val + "";
        }
        else {_yuitest_coverline("build/charts-base/charts-base.js", 13578);
if(!val)
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 13580);
val = "";
        }}
        _yuitest_coverline("build/charts-base/charts-base.js", 13582);
if(IS_STRING(val))
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 13584);
val = DOCUMENT.createTextNode(val);
        }
        _yuitest_coverline("build/charts-base/charts-base.js", 13586);
textField.appendChild(val);
    },

    /**
     * Returns all the keys contained in a  `dataProvider`.
     *
     * @method _getAllKeys
     * @param {Array} dp Collection of objects to be parsed.
     * @return Object
     */
    _getAllKeys: function(dp)
    {
        _yuitest_coverfunc("build/charts-base/charts-base.js", "_getAllKeys", 13596);
_yuitest_coverline("build/charts-base/charts-base.js", 13598);
var i = 0,
            len = dp.length,
            item,
            key,
            keys = {};
        _yuitest_coverline("build/charts-base/charts-base.js", 13603);
for(; i < len; ++i)
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 13605);
item = dp[i];
            _yuitest_coverline("build/charts-base/charts-base.js", 13606);
for(key in item)
            {
                _yuitest_coverline("build/charts-base/charts-base.js", 13608);
if(item.hasOwnProperty(key))
                {
                    _yuitest_coverline("build/charts-base/charts-base.js", 13610);
keys[key] = true;
                }
            }
        }
        _yuitest_coverline("build/charts-base/charts-base.js", 13614);
return keys;
    },

    /**
     * Constructs seriesKeys if not explicitly specified.
     *
     * @method _buildSeriesKeys
     * @param {Array} dataProvider The dataProvider for the chart.
     * @return Array
     * @private
     */
    _buildSeriesKeys: function(dataProvider)
    {
        _yuitest_coverfunc("build/charts-base/charts-base.js", "_buildSeriesKeys", 13625);
_yuitest_coverline("build/charts-base/charts-base.js", 13627);
var allKeys,
            catKey = this.get("categoryKey"),
            keys = [],
            i;
        _yuitest_coverline("build/charts-base/charts-base.js", 13631);
if(this._seriesKeysExplicitlySet)
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 13633);
return this._seriesKeys;
        }
        _yuitest_coverline("build/charts-base/charts-base.js", 13635);
allKeys = this._getAllKeys(dataProvider);
        _yuitest_coverline("build/charts-base/charts-base.js", 13636);
for(i in allKeys)
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 13638);
if(allKeys.hasOwnProperty(i) && i != catKey)
            {
                _yuitest_coverline("build/charts-base/charts-base.js", 13640);
keys.push(i);
            }
        }
        _yuitest_coverline("build/charts-base/charts-base.js", 13643);
return keys;
    }
};
_yuitest_coverline("build/charts-base/charts-base.js", 13646);
Y.ChartBase = ChartBase;
/**
 * The CartesianChart class creates a chart with horizontal and vertical axes.
 *
 * @module charts
 * @submodule charts-base
 * @class CartesianChart
 * @extends ChartBase
 * @constructor
 */
_yuitest_coverline("build/charts-base/charts-base.js", 13656);
Y.CartesianChart = Y.Base.create("cartesianChart", Y.Widget, [Y.ChartBase], {
    /**
     * @method renderUI
     * @private
     */
    renderUI: function()
    {
        _yuitest_coverfunc("build/charts-base/charts-base.js", "renderUI", 13661);
_yuitest_coverline("build/charts-base/charts-base.js", 13663);
var bb = this.get("boundingBox"),
            cb = this.get("contentBox"),
            tt = this.get("tooltip"),
            overlay,
            overlayClass = _getClassName("overlay");
        //move the position = absolute logic to a class file
        _yuitest_coverline("build/charts-base/charts-base.js", 13669);
bb.setStyle("position", "absolute");
        _yuitest_coverline("build/charts-base/charts-base.js", 13670);
cb.setStyle("position", "absolute");
        _yuitest_coverline("build/charts-base/charts-base.js", 13671);
this._addAxes();
        _yuitest_coverline("build/charts-base/charts-base.js", 13672);
this._addGridlines();
        _yuitest_coverline("build/charts-base/charts-base.js", 13673);
this._addSeries();
        _yuitest_coverline("build/charts-base/charts-base.js", 13674);
if(tt && tt.show)
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 13676);
this._addTooltip();
        }
        //If there is a style definition. Force them to set.
        _yuitest_coverline("build/charts-base/charts-base.js", 13679);
this.get("styles");
        _yuitest_coverline("build/charts-base/charts-base.js", 13680);
if(this.get("interactionType") == "planar")
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 13682);
overlay = DOCUMENT.createElement("div");
            _yuitest_coverline("build/charts-base/charts-base.js", 13683);
this.get("contentBox").appendChild(overlay);
            _yuitest_coverline("build/charts-base/charts-base.js", 13684);
this._overlay = Y.one(overlay);
            _yuitest_coverline("build/charts-base/charts-base.js", 13685);
this._overlay.set("id", this.get("id") + "_overlay");
            _yuitest_coverline("build/charts-base/charts-base.js", 13686);
this._overlay.setStyle("position", "absolute");
            _yuitest_coverline("build/charts-base/charts-base.js", 13687);
this._overlay.setStyle("background", "#fff");
            _yuitest_coverline("build/charts-base/charts-base.js", 13688);
this._overlay.setStyle("opacity", 0);
            _yuitest_coverline("build/charts-base/charts-base.js", 13689);
this._overlay.addClass(overlayClass);
            _yuitest_coverline("build/charts-base/charts-base.js", 13690);
this._overlay.setStyle("zIndex", 4);
        }
        _yuitest_coverline("build/charts-base/charts-base.js", 13692);
this._setAriaElements(bb, cb);
        _yuitest_coverline("build/charts-base/charts-base.js", 13693);
this._redraw();
    },

    /**
     * When `interactionType` is set to `planar`, listens for mouse move events and fires `planarEvent:mouseover` or `planarEvent:mouseout`
     * depending on the position of the mouse in relation to data points on the `Chart`.
     *
     * @method _planarEventDispatcher
     * @param {Object} e Event object.
     * @private
     */
    _planarEventDispatcher: function(e)
    {
        _yuitest_coverfunc("build/charts-base/charts-base.js", "_planarEventDispatcher", 13704);
_yuitest_coverline("build/charts-base/charts-base.js", 13706);
var graph = this.get("graph"),
            bb = this.get("boundingBox"),
            cb = graph.get("contentBox"),
            isTouch = e && e.hasOwnProperty("changedTouches"),
            pageX = isTouch ? e.changedTouches[0].pageX : e.pageX,
            pageY = isTouch ? e.changedTouches[0].pageY : e.pageY,
            posX = pageX - bb.getX(),
            posY = pageY - bb.getY(),
            offset = {
                x: pageX - cb.getX(),
                y: pageY - cb.getY()
            },
            sc = graph.get("seriesCollection"),
            series,
            i = 0,
            index,
            oldIndex = this._selectedIndex,
            item,
            items = [],
            categoryItems = [],
            valueItems = [],
            direction = this.get("direction"),
            hasMarkers,
            catAxis,
            valAxis,
            coord,
            //data columns and area data could be created on a graph level
            markerPlane,
            len,
            coords;
        _yuitest_coverline("build/charts-base/charts-base.js", 13736);
e.halt(true);
        _yuitest_coverline("build/charts-base/charts-base.js", 13737);
if(direction == "horizontal")
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 13739);
catAxis = "x";
            _yuitest_coverline("build/charts-base/charts-base.js", 13740);
valAxis = "y";
        }
        else
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 13744);
valAxis = "x";
            _yuitest_coverline("build/charts-base/charts-base.js", 13745);
catAxis = "y";
        }
        _yuitest_coverline("build/charts-base/charts-base.js", 13747);
coord = offset[catAxis];
        _yuitest_coverline("build/charts-base/charts-base.js", 13748);
if(sc)
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 13750);
len = sc.length;
            _yuitest_coverline("build/charts-base/charts-base.js", 13751);
while(i < len && !markerPlane)
            {
                _yuitest_coverline("build/charts-base/charts-base.js", 13753);
if(sc[i])
                {
                    _yuitest_coverline("build/charts-base/charts-base.js", 13755);
markerPlane = sc[i].get(catAxis + "MarkerPlane");
                }
                _yuitest_coverline("build/charts-base/charts-base.js", 13757);
i++;
            }
        }
        _yuitest_coverline("build/charts-base/charts-base.js", 13760);
if(markerPlane)
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 13762);
len = markerPlane.length;
            _yuitest_coverline("build/charts-base/charts-base.js", 13763);
for(i = 0; i < len; ++i)
            {
                _yuitest_coverline("build/charts-base/charts-base.js", 13765);
if(coord <= markerPlane[i].end && coord >= markerPlane[i].start)
                {
                    _yuitest_coverline("build/charts-base/charts-base.js", 13767);
index = i;
                    _yuitest_coverline("build/charts-base/charts-base.js", 13768);
break;
                }
            }
            _yuitest_coverline("build/charts-base/charts-base.js", 13771);
len = sc.length;
            _yuitest_coverline("build/charts-base/charts-base.js", 13772);
for(i = 0; i < len; ++i)
            {
                _yuitest_coverline("build/charts-base/charts-base.js", 13774);
series = sc[i];
                _yuitest_coverline("build/charts-base/charts-base.js", 13775);
coords = series.get(valAxis + "coords");
                _yuitest_coverline("build/charts-base/charts-base.js", 13776);
hasMarkers = series.get("markers");
                _yuitest_coverline("build/charts-base/charts-base.js", 13777);
if(hasMarkers && !isNaN(oldIndex) && oldIndex > -1)
                {
                    _yuitest_coverline("build/charts-base/charts-base.js", 13779);
series.updateMarkerState("mouseout", oldIndex);
                }
                _yuitest_coverline("build/charts-base/charts-base.js", 13781);
if(coords && coords[index] > -1)
                {
                    _yuitest_coverline("build/charts-base/charts-base.js", 13783);
if(hasMarkers && !isNaN(index) && index > -1)
                    {
                        _yuitest_coverline("build/charts-base/charts-base.js", 13785);
series.updateMarkerState("mouseover", index);
                    }
                    _yuitest_coverline("build/charts-base/charts-base.js", 13787);
item = this.getSeriesItems(series, index);
                    _yuitest_coverline("build/charts-base/charts-base.js", 13788);
categoryItems.push(item.category);
                    _yuitest_coverline("build/charts-base/charts-base.js", 13789);
valueItems.push(item.value);
                    _yuitest_coverline("build/charts-base/charts-base.js", 13790);
items.push(series);
                }

            }
            _yuitest_coverline("build/charts-base/charts-base.js", 13794);
this._selectedIndex = index;

            /**
             * Broadcasts when `interactionType` is set to `planar` and a series' marker plane has received a mouseover event.
             *
             *
             * @event planarEvent:mouseover
             * @preventable false
             * @param {EventFacade} e Event facade with the following additional
             *   properties:
             *  <dl>
             *      <dt>categoryItem</dt><dd>An array of hashes, each containing information about the category `Axis` of each marker
             *      whose plane has been intersected.</dd>
             *      <dt>valueItem</dt><dd>An array of hashes, each containing information about the value `Axis` of each marker whose
             *      plane has been intersected.</dd>
             *      <dt>x</dt><dd>The x-coordinate of the mouse in relation to the Chart.</dd>
             *      <dt>y</dt><dd>The y-coordinate of the mouse in relation to the Chart.</dd>
             *      <dt>pageX</dt><dd>The x location of the event on the page (including scroll)</dd>
             *      <dt>pageY</dt><dd>The y location of the event on the page (including scroll)</dd>
             *      <dt>items</dt><dd>An array including all the series which contain a marker whose plane has been intersected.</dd>
             *      <dt>index</dt><dd>Index of the markers in their respective series.</dd>
             *      <dt>originEvent</dt><dd>Underlying dom event.</dd>
             *  </dl>
             */
            /**
             * Broadcasts when `interactionType` is set to `planar` and a series' marker plane has received a mouseout event.
             *
             * @event planarEvent:mouseout
             * @preventable false
             * @param {EventFacade} e
             */
            _yuitest_coverline("build/charts-base/charts-base.js", 13825);
if(index > -1)
            {
                _yuitest_coverline("build/charts-base/charts-base.js", 13827);
this.fire("planarEvent:mouseover", {
                    categoryItem:categoryItems,
                    valueItem:valueItems,
                    x:posX,
                    y:posY,
                    pageX:pageX,
                    pageY:pageY,
                    items:items,
                    index:index,
                    originEvent:e
                });
            }
            else
            {
                _yuitest_coverline("build/charts-base/charts-base.js", 13841);
this.fire("planarEvent:mouseout");
            }
        }
    },

    /**
     * Indicates the default series type for the chart.
     *
     * @property _type
     * @type {String}
     * @private
     */
    _type: "combo",

    /**
     * Queue of axes instances that will be updated. This method is used internally to determine when all axes have been updated.
     *
     * @property _itemRenderQueue
     * @type Array
     * @private
     */
    _itemRenderQueue: null,

    /**
     * Adds an `Axis` instance to the `_itemRenderQueue`.
     *
     * @method _addToAxesRenderQueue
     * @param {Axis} axis An `Axis` instance.
     * @private
     */
    _addToAxesRenderQueue: function(axis)
    {
        _yuitest_coverfunc("build/charts-base/charts-base.js", "_addToAxesRenderQueue", 13871);
_yuitest_coverline("build/charts-base/charts-base.js", 13873);
if(!this._itemRenderQueue)
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 13875);
this._itemRenderQueue = [];
        }
        _yuitest_coverline("build/charts-base/charts-base.js", 13877);
if(Y.Array.indexOf(this._itemRenderQueue, axis) < 0)
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 13879);
this._itemRenderQueue.push(axis);
        }
    },

    /**
     * Adds axis instance to the appropriate array based on position
     *
     * @method _addToAxesCollection
     * @param {String} position The position of the axis
     * @param {Axis} axis The `Axis` instance
     */
    _addToAxesCollection: function(position, axis)
    {
        _yuitest_coverfunc("build/charts-base/charts-base.js", "_addToAxesCollection", 13890);
_yuitest_coverline("build/charts-base/charts-base.js", 13892);
var axesCollection = this.get(position + "AxesCollection");
        _yuitest_coverline("build/charts-base/charts-base.js", 13893);
if(!axesCollection)
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 13895);
axesCollection = [];
            _yuitest_coverline("build/charts-base/charts-base.js", 13896);
this.set(position + "AxesCollection", axesCollection);
        }
        _yuitest_coverline("build/charts-base/charts-base.js", 13898);
axesCollection.push(axis);
    },

    /**
     * Returns the default value for the `seriesCollection` attribute.
     *
     * @method _getDefaultSeriesCollection
     * @param {Array} val Array containing either `CartesianSeries` instances or objects containing data to construct series instances.
     * @return Array
     * @private
     */
    _getDefaultSeriesCollection: function()
    {
        _yuitest_coverfunc("build/charts-base/charts-base.js", "_getDefaultSeriesCollection", 13909);
_yuitest_coverline("build/charts-base/charts-base.js", 13911);
var seriesCollection,
            dataProvider = this.get("dataProvider");
        _yuitest_coverline("build/charts-base/charts-base.js", 13913);
if(dataProvider)
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 13915);
seriesCollection = this._parseSeriesCollection();
        }
        _yuitest_coverline("build/charts-base/charts-base.js", 13917);
return seriesCollection;
    },

    /**
     * Parses and returns a series collection from an object and default properties.
     *
     * @method _parseSeriesCollection
     * @param {Object} val Object contain properties for series being set.
     * @return Object
     * @private
     */
    _parseSeriesCollection: function(val)
    {
        _yuitest_coverfunc("build/charts-base/charts-base.js", "_parseSeriesCollection", 13928);
_yuitest_coverline("build/charts-base/charts-base.js", 13930);
var dir = this.get("direction"),
            sc = [],
            catAxis,
            valAxis,
            tempKeys = [],
            series,
            seriesKeys = this.get("seriesKeys").concat(),
            i,
            index,
            l,
            type = this.get("type"),
            key,
            catKey,
            seriesKey,
            graph,
            orphans = [],
            categoryKey = this.get("categoryKey"),
            showMarkers = this.get("showMarkers"),
            showAreaFill = this.get("showAreaFill"),
            showLines = this.get("showLines");
        _yuitest_coverline("build/charts-base/charts-base.js", 13950);
val = val || [];
        _yuitest_coverline("build/charts-base/charts-base.js", 13951);
if(dir == "vertical")
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 13953);
catAxis = "yAxis";
            _yuitest_coverline("build/charts-base/charts-base.js", 13954);
catKey = "yKey";
            _yuitest_coverline("build/charts-base/charts-base.js", 13955);
valAxis = "xAxis";
            _yuitest_coverline("build/charts-base/charts-base.js", 13956);
seriesKey = "xKey";
        }
        else
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 13960);
catAxis = "xAxis";
            _yuitest_coverline("build/charts-base/charts-base.js", 13961);
catKey = "xKey";
            _yuitest_coverline("build/charts-base/charts-base.js", 13962);
valAxis = "yAxis";
            _yuitest_coverline("build/charts-base/charts-base.js", 13963);
seriesKey = "yKey";
        }
        _yuitest_coverline("build/charts-base/charts-base.js", 13965);
l = val.length;
        _yuitest_coverline("build/charts-base/charts-base.js", 13966);
while(val && val.length > 0)
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 13968);
series = val.shift();
            _yuitest_coverline("build/charts-base/charts-base.js", 13969);
key = this._getBaseAttribute(series, seriesKey);
            _yuitest_coverline("build/charts-base/charts-base.js", 13970);
if(key)
            {
                _yuitest_coverline("build/charts-base/charts-base.js", 13972);
index = Y.Array.indexOf(seriesKeys, key);
                _yuitest_coverline("build/charts-base/charts-base.js", 13973);
if(index > -1)
                {
                    _yuitest_coverline("build/charts-base/charts-base.js", 13975);
seriesKeys.splice(index, 1);
                    _yuitest_coverline("build/charts-base/charts-base.js", 13976);
tempKeys.push(key);
                    _yuitest_coverline("build/charts-base/charts-base.js", 13977);
sc.push(series);
                }
                else
                {
                    _yuitest_coverline("build/charts-base/charts-base.js", 13981);
orphans.push(series);
                }
            }
            else
            {
                _yuitest_coverline("build/charts-base/charts-base.js", 13986);
orphans.push(series);
            }
        }
        _yuitest_coverline("build/charts-base/charts-base.js", 13989);
while(orphans.length > 0)
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 13991);
series = orphans.shift();
            _yuitest_coverline("build/charts-base/charts-base.js", 13992);
if(seriesKeys.length > 0)
            {
                _yuitest_coverline("build/charts-base/charts-base.js", 13994);
key = seriesKeys.shift();
                _yuitest_coverline("build/charts-base/charts-base.js", 13995);
this._setBaseAttribute(series, seriesKey, key);
                _yuitest_coverline("build/charts-base/charts-base.js", 13996);
tempKeys.push(key);
                _yuitest_coverline("build/charts-base/charts-base.js", 13997);
sc.push(series);
            }
            else {_yuitest_coverline("build/charts-base/charts-base.js", 13999);
if(series instanceof Y.CartesianSeries)
            {
                _yuitest_coverline("build/charts-base/charts-base.js", 14001);
series.destroy(true);
            }}
        }
        _yuitest_coverline("build/charts-base/charts-base.js", 14004);
if(seriesKeys.length > 0)
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 14006);
tempKeys = tempKeys.concat(seriesKeys);
        }
        _yuitest_coverline("build/charts-base/charts-base.js", 14008);
l = tempKeys.length;
        _yuitest_coverline("build/charts-base/charts-base.js", 14009);
for(i = 0; i < l; ++i)
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 14011);
series = sc[i] || {type:type};
            _yuitest_coverline("build/charts-base/charts-base.js", 14012);
if(series instanceof Y.CartesianSeries)
            {
                _yuitest_coverline("build/charts-base/charts-base.js", 14014);
this._parseSeriesAxes(series);
                _yuitest_coverline("build/charts-base/charts-base.js", 14015);
continue;
            }

            _yuitest_coverline("build/charts-base/charts-base.js", 14018);
series[catKey] = series[catKey] || categoryKey;
            _yuitest_coverline("build/charts-base/charts-base.js", 14019);
series[seriesKey] = series[seriesKey] || seriesKeys.shift();
            _yuitest_coverline("build/charts-base/charts-base.js", 14020);
series[catAxis] = this._getCategoryAxis();
            _yuitest_coverline("build/charts-base/charts-base.js", 14021);
series[valAxis] = this._getSeriesAxis(series[seriesKey]);

            _yuitest_coverline("build/charts-base/charts-base.js", 14023);
series.type = series.type || type;
            _yuitest_coverline("build/charts-base/charts-base.js", 14024);
series.direction = series.direction || dir;

            _yuitest_coverline("build/charts-base/charts-base.js", 14026);
if((series.type == "combo" || series.type == "stackedcombo" || series.type == "combospline" || series.type == "stackedcombospline"))
            {
                _yuitest_coverline("build/charts-base/charts-base.js", 14028);
if(showAreaFill !== null)
                {
                    _yuitest_coverline("build/charts-base/charts-base.js", 14030);
series.showAreaFill = (series.showAreaFill !== null && series.showAreaFill !== undefined) ? series.showAreaFill : showAreaFill;
                }
                _yuitest_coverline("build/charts-base/charts-base.js", 14032);
if(showMarkers !== null)
                {
                    _yuitest_coverline("build/charts-base/charts-base.js", 14034);
series.showMarkers = (series.showMarkers !== null && series.showMarkers !== undefined) ? series.showMarkers : showMarkers;
                }
                _yuitest_coverline("build/charts-base/charts-base.js", 14036);
if(showLines !== null)
                {
                    _yuitest_coverline("build/charts-base/charts-base.js", 14038);
series.showLines = (series.showLines !== null && series.showLines !== undefined) ? series.showLines : showLines;
                }
            }
            _yuitest_coverline("build/charts-base/charts-base.js", 14041);
sc[i] = series;
        }
        _yuitest_coverline("build/charts-base/charts-base.js", 14043);
if(sc)
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 14045);
graph = this.get("graph");
            _yuitest_coverline("build/charts-base/charts-base.js", 14046);
graph.set("seriesCollection", sc);
            _yuitest_coverline("build/charts-base/charts-base.js", 14047);
sc = graph.get("seriesCollection");
        }
        _yuitest_coverline("build/charts-base/charts-base.js", 14049);
return sc;
    },

    /**
     * Parse and sets the axes for a series instance.
     *
     * @method _parseSeriesAxes
     * @param {CartesianSeries} series A `CartesianSeries` instance.
     * @private
     */
    _parseSeriesAxes: function(series)
    {
        _yuitest_coverfunc("build/charts-base/charts-base.js", "_parseSeriesAxes", 14059);
_yuitest_coverline("build/charts-base/charts-base.js", 14061);
var axes = this.get("axes"),
            xAxis = series.get("xAxis"),
            yAxis = series.get("yAxis"),
            YAxis = Y.Axis,
            axis;
        _yuitest_coverline("build/charts-base/charts-base.js", 14066);
if(xAxis && !(xAxis instanceof YAxis) && Y_Lang.isString(xAxis) && axes.hasOwnProperty(xAxis))
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 14068);
axis = axes[xAxis];
            _yuitest_coverline("build/charts-base/charts-base.js", 14069);
if(axis instanceof YAxis)
            {
                _yuitest_coverline("build/charts-base/charts-base.js", 14071);
series.set("xAxis", axis);
            }
        }
        _yuitest_coverline("build/charts-base/charts-base.js", 14074);
if(yAxis && !(yAxis instanceof YAxis) && Y_Lang.isString(yAxis) && axes.hasOwnProperty(yAxis))
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 14076);
axis = axes[yAxis];
            _yuitest_coverline("build/charts-base/charts-base.js", 14077);
if(axis instanceof YAxis)
            {
                _yuitest_coverline("build/charts-base/charts-base.js", 14079);
series.set("yAxis", axis);
            }
        }

    },

    /**
     * Returns the category axis instance for the chart.
     *
     * @method _getCategoryAxis
     * @return Axis
     * @private
     */
    _getCategoryAxis: function()
    {
        _yuitest_coverfunc("build/charts-base/charts-base.js", "_getCategoryAxis", 14092);
_yuitest_coverline("build/charts-base/charts-base.js", 14094);
var axis,
            axes = this.get("axes"),
            categoryAxisName = this.get("categoryAxisName") || this.get("categoryKey");
        _yuitest_coverline("build/charts-base/charts-base.js", 14097);
axis = axes[categoryAxisName];
        _yuitest_coverline("build/charts-base/charts-base.js", 14098);
return axis;
    },

    /**
     * Returns the value axis for a series.
     *
     * @method _getSeriesAxis
     * @param {String} key The key value used to determine the axis instance.
     * @return Axis
     * @private
     */
    _getSeriesAxis:function(key, axisName)
    {
        _yuitest_coverfunc("build/charts-base/charts-base.js", "_getSeriesAxis", 14109);
_yuitest_coverline("build/charts-base/charts-base.js", 14111);
var axes = this.get("axes"),
            i,
            keys,
            axis;
        _yuitest_coverline("build/charts-base/charts-base.js", 14115);
if(axes)
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 14117);
if(axisName && axes.hasOwnProperty(axisName))
            {
                _yuitest_coverline("build/charts-base/charts-base.js", 14119);
axis = axes[axisName];
            }
            else
            {
                _yuitest_coverline("build/charts-base/charts-base.js", 14123);
for(i in axes)
                {
                    _yuitest_coverline("build/charts-base/charts-base.js", 14125);
if(axes.hasOwnProperty(i))
                    {
                        _yuitest_coverline("build/charts-base/charts-base.js", 14127);
keys = axes[i].get("keys");
                        _yuitest_coverline("build/charts-base/charts-base.js", 14128);
if(keys && keys.hasOwnProperty(key))
                        {
                            _yuitest_coverline("build/charts-base/charts-base.js", 14130);
axis = axes[i];
                            _yuitest_coverline("build/charts-base/charts-base.js", 14131);
break;
                        }
                    }
                }
            }
        }
        _yuitest_coverline("build/charts-base/charts-base.js", 14137);
return axis;
    },

    /**
     * Gets an attribute from an object, using a getter for Base objects and a property for object
     * literals. Used for determining attributes from series/axis references which can be an actual class instance
     * or a hash of properties that will be used to create a class instance.
     *
     * @method _getBaseAttribute
     * @param {Object} item Object or instance in which the attribute resides.
     * @param {String} key Attribute whose value will be returned.
     * @return Object
     * @private
     */
    _getBaseAttribute: function(item, key)
    {
        _yuitest_coverfunc("build/charts-base/charts-base.js", "_getBaseAttribute", 14151);
_yuitest_coverline("build/charts-base/charts-base.js", 14153);
if(item instanceof Y.Base)
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 14155);
return item.get(key);
        }
        _yuitest_coverline("build/charts-base/charts-base.js", 14157);
if(item.hasOwnProperty(key))
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 14159);
return item[key];
        }
        _yuitest_coverline("build/charts-base/charts-base.js", 14161);
return null;
    },

    /**
     * Sets an attribute on an object, using a setter of Base objects and a property for object
     * literals. Used for setting attributes on a Base class, either directly or to be stored in an object literal
     * for use at instantiation.
     *
     * @method _setBaseAttribute
     * @param {Object} item Object or instance in which the attribute resides.
     * @param {String} key Attribute whose value will be assigned.
     * @param {Object} value Value to be assigned to the attribute.
     * @private
     */
    _setBaseAttribute: function(item, key, value)
    {
        _yuitest_coverfunc("build/charts-base/charts-base.js", "_setBaseAttribute", 14175);
_yuitest_coverline("build/charts-base/charts-base.js", 14177);
if(item instanceof Y.Base)
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 14179);
item.set(key, value);
        }
        else
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 14183);
item[key] = value;
        }
    },

    /**
     * Creates `Axis` instances.
     *
     * @method _setAxes
     * @param {Object} val Object containing `Axis` instances or objects in which to construct `Axis` instances.
     * @return Object
     * @private
     */
    _setAxes: function(val)
    {
        _yuitest_coverfunc("build/charts-base/charts-base.js", "_setAxes", 14195);
_yuitest_coverline("build/charts-base/charts-base.js", 14197);
var hash = this._parseAxes(val),
            axes = {},
            axesAttrs = {
                edgeOffset: "edgeOffset",
                position: "position",
                overlapGraph:"overlapGraph",
                labelFunction:"labelFunction",
                labelFunctionScope:"labelFunctionScope",
                labelFormat:"labelFormat",
                appendLabelFunction: "appendLabelFunction",
                appendTitleFunction: "appendTitleFunction",
                maximum:"maximum",
                minimum:"minimum",
                roundingMethod:"roundingMethod",
                alwaysShowZero:"alwaysShowZero",
                title:"title",
                width:"width",
                height:"height"
            },
            dp = this.get("dataProvider"),
            ai,
            i,
            pos,
            axis,
            axisPosition,
            dh,
            axisClass,
            config,
            axesCollection;
        _yuitest_coverline("build/charts-base/charts-base.js", 14226);
for(i in hash)
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 14228);
if(hash.hasOwnProperty(i))
            {
                _yuitest_coverline("build/charts-base/charts-base.js", 14230);
dh = hash[i];
                _yuitest_coverline("build/charts-base/charts-base.js", 14231);
if(dh instanceof Y.Axis)
                {
                    _yuitest_coverline("build/charts-base/charts-base.js", 14233);
axis = dh;
                }
                else
                {
                    _yuitest_coverline("build/charts-base/charts-base.js", 14237);
axis = null;
                    _yuitest_coverline("build/charts-base/charts-base.js", 14238);
config = {};
                    _yuitest_coverline("build/charts-base/charts-base.js", 14239);
config.dataProvider = dh.dataProvider || dp;
                    _yuitest_coverline("build/charts-base/charts-base.js", 14240);
config.keys = dh.keys;

                    _yuitest_coverline("build/charts-base/charts-base.js", 14242);
if(dh.hasOwnProperty("roundingUnit"))
                    {
                        _yuitest_coverline("build/charts-base/charts-base.js", 14244);
config.roundingUnit = dh.roundingUnit;
                    }
                    _yuitest_coverline("build/charts-base/charts-base.js", 14246);
pos = dh.position;
                    _yuitest_coverline("build/charts-base/charts-base.js", 14247);
if(dh.styles)
                    {
                        _yuitest_coverline("build/charts-base/charts-base.js", 14249);
config.styles = dh.styles;
                    }
                    _yuitest_coverline("build/charts-base/charts-base.js", 14251);
config.position = dh.position;
                    _yuitest_coverline("build/charts-base/charts-base.js", 14252);
for(ai in axesAttrs)
                    {
                        _yuitest_coverline("build/charts-base/charts-base.js", 14254);
if(axesAttrs.hasOwnProperty(ai) && dh.hasOwnProperty(ai))
                        {
                            _yuitest_coverline("build/charts-base/charts-base.js", 14256);
config[ai] = dh[ai];
                        }
                    }

                    //only check for existing axis if we constructed the default axes already
                    _yuitest_coverline("build/charts-base/charts-base.js", 14261);
if(val)
                    {
                        _yuitest_coverline("build/charts-base/charts-base.js", 14263);
axis = this.getAxisByKey(i);
                    }

                    _yuitest_coverline("build/charts-base/charts-base.js", 14266);
if(axis && axis instanceof Y.Axis)
                    {
                        _yuitest_coverline("build/charts-base/charts-base.js", 14268);
axisPosition = axis.get("position");
                        _yuitest_coverline("build/charts-base/charts-base.js", 14269);
if(pos != axisPosition)
                        {
                            _yuitest_coverline("build/charts-base/charts-base.js", 14271);
if(axisPosition != "none")
                            {
                                _yuitest_coverline("build/charts-base/charts-base.js", 14273);
axesCollection = this.get(axisPosition + "AxesCollection");
                                _yuitest_coverline("build/charts-base/charts-base.js", 14274);
axesCollection.splice(Y.Array.indexOf(axesCollection, axis), 1);
                            }
                            _yuitest_coverline("build/charts-base/charts-base.js", 14276);
if(pos != "none")
                            {
                                _yuitest_coverline("build/charts-base/charts-base.js", 14278);
this._addToAxesCollection(pos, axis);
                            }
                        }
                        _yuitest_coverline("build/charts-base/charts-base.js", 14281);
axis.setAttrs(config);
                    }
                    else
                    {
                        _yuitest_coverline("build/charts-base/charts-base.js", 14285);
axisClass = this._getAxisClass(dh.type);
                        _yuitest_coverline("build/charts-base/charts-base.js", 14286);
axis = new axisClass(config);
                        _yuitest_coverline("build/charts-base/charts-base.js", 14287);
axis.after("axisRendered", Y.bind(this._itemRendered, this));
                    }
                }

                _yuitest_coverline("build/charts-base/charts-base.js", 14291);
if(axis)
                {
                    _yuitest_coverline("build/charts-base/charts-base.js", 14293);
axesCollection = this.get(pos + "AxesCollection");
                    _yuitest_coverline("build/charts-base/charts-base.js", 14294);
if(axesCollection && Y.Array.indexOf(axesCollection, axis) > 0)
                    {
                        _yuitest_coverline("build/charts-base/charts-base.js", 14296);
axis.set("overlapGraph", false);
                    }
                    _yuitest_coverline("build/charts-base/charts-base.js", 14298);
axes[i] = axis;
                }
            }
        }
        _yuitest_coverline("build/charts-base/charts-base.js", 14302);
return axes;
    },

    /**
     * Adds axes to the chart.
     *
     * @method _addAxes
     * @private
     */
    _addAxes: function()
    {
        _yuitest_coverfunc("build/charts-base/charts-base.js", "_addAxes", 14311);
_yuitest_coverline("build/charts-base/charts-base.js", 14313);
var axes = this.get("axes"),
            i,
            axis,
            pos,
            w = this.get("width"),
            h = this.get("height"),
            node = Y.Node.one(this._parentNode);
        _yuitest_coverline("build/charts-base/charts-base.js", 14320);
if(!this._axesCollection)
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 14322);
this._axesCollection = [];
        }
        _yuitest_coverline("build/charts-base/charts-base.js", 14324);
for(i in axes)
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 14326);
if(axes.hasOwnProperty(i))
            {
                _yuitest_coverline("build/charts-base/charts-base.js", 14328);
axis = axes[i];
                _yuitest_coverline("build/charts-base/charts-base.js", 14329);
if(axis instanceof Y.Axis)
                {
                    _yuitest_coverline("build/charts-base/charts-base.js", 14331);
if(!w)
                    {
                        _yuitest_coverline("build/charts-base/charts-base.js", 14333);
this.set("width", node.get("offsetWidth"));
                        _yuitest_coverline("build/charts-base/charts-base.js", 14334);
w = this.get("width");
                    }
                    _yuitest_coverline("build/charts-base/charts-base.js", 14336);
if(!h)
                    {
                        _yuitest_coverline("build/charts-base/charts-base.js", 14338);
this.set("height", node.get("offsetHeight"));
                        _yuitest_coverline("build/charts-base/charts-base.js", 14339);
h = this.get("height");
                    }
                    _yuitest_coverline("build/charts-base/charts-base.js", 14341);
this._addToAxesRenderQueue(axis);
                    _yuitest_coverline("build/charts-base/charts-base.js", 14342);
pos = axis.get("position");
                    _yuitest_coverline("build/charts-base/charts-base.js", 14343);
if(!this.get(pos + "AxesCollection"))
                    {
                        _yuitest_coverline("build/charts-base/charts-base.js", 14345);
this.set(pos + "AxesCollection", [axis]);
                    }
                    else
                    {
                        _yuitest_coverline("build/charts-base/charts-base.js", 14349);
this.get(pos + "AxesCollection").push(axis);
                    }
                    _yuitest_coverline("build/charts-base/charts-base.js", 14351);
this._axesCollection.push(axis);
                    _yuitest_coverline("build/charts-base/charts-base.js", 14352);
if(axis.get("keys").hasOwnProperty(this.get("categoryKey")))
                    {
                        _yuitest_coverline("build/charts-base/charts-base.js", 14354);
this.set("categoryAxis", axis);
                    }
                    _yuitest_coverline("build/charts-base/charts-base.js", 14356);
axis.render(this.get("contentBox"));
                }
            }
        }
    },

    /**
     * Renders the Graph.
     *
     * @method _addSeries
     * @private
     */
    _addSeries: function()
    {
        _yuitest_coverfunc("build/charts-base/charts-base.js", "_addSeries", 14368);
_yuitest_coverline("build/charts-base/charts-base.js", 14370);
var graph = this.get("graph"),
            sc = this.get("seriesCollection");
        _yuitest_coverline("build/charts-base/charts-base.js", 14372);
graph.render(this.get("contentBox"));

    },

    /**
     * Adds gridlines to the chart.
     *
     * @method _addGridlines
     * @private
     */
    _addGridlines: function()
    {
        _yuitest_coverfunc("build/charts-base/charts-base.js", "_addGridlines", 14382);
_yuitest_coverline("build/charts-base/charts-base.js", 14384);
var graph = this.get("graph"),
            hgl = this.get("horizontalGridlines"),
            vgl = this.get("verticalGridlines"),
            direction = this.get("direction"),
            leftAxesCollection = this.get("leftAxesCollection"),
            rightAxesCollection = this.get("rightAxesCollection"),
            bottomAxesCollection = this.get("bottomAxesCollection"),
            topAxesCollection = this.get("topAxesCollection"),
            seriesAxesCollection,
            catAxis = this.get("categoryAxis"),
            hAxis,
            vAxis;
        _yuitest_coverline("build/charts-base/charts-base.js", 14396);
if(this._axesCollection)
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 14398);
seriesAxesCollection = this._axesCollection.concat();
            _yuitest_coverline("build/charts-base/charts-base.js", 14399);
seriesAxesCollection.splice(Y.Array.indexOf(seriesAxesCollection, catAxis), 1);
        }
        _yuitest_coverline("build/charts-base/charts-base.js", 14401);
if(hgl)
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 14403);
if(leftAxesCollection && leftAxesCollection[0])
            {
                _yuitest_coverline("build/charts-base/charts-base.js", 14405);
hAxis = leftAxesCollection[0];
            }
            else {_yuitest_coverline("build/charts-base/charts-base.js", 14407);
if(rightAxesCollection && rightAxesCollection[0])
            {
                _yuitest_coverline("build/charts-base/charts-base.js", 14409);
hAxis = rightAxesCollection[0];
            }
            else
            {
                _yuitest_coverline("build/charts-base/charts-base.js", 14413);
hAxis = direction == "horizontal" ? catAxis : seriesAxesCollection[0];
            }}
            _yuitest_coverline("build/charts-base/charts-base.js", 14415);
if(!this._getBaseAttribute(hgl, "axis") && hAxis)
            {
                _yuitest_coverline("build/charts-base/charts-base.js", 14417);
this._setBaseAttribute(hgl, "axis", hAxis);
            }
            _yuitest_coverline("build/charts-base/charts-base.js", 14419);
if(this._getBaseAttribute(hgl, "axis"))
            {
                _yuitest_coverline("build/charts-base/charts-base.js", 14421);
graph.set("horizontalGridlines", hgl);
            }
        }
        _yuitest_coverline("build/charts-base/charts-base.js", 14424);
if(vgl)
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 14426);
if(bottomAxesCollection && bottomAxesCollection[0])
            {
                _yuitest_coverline("build/charts-base/charts-base.js", 14428);
vAxis = bottomAxesCollection[0];
            }
            else {_yuitest_coverline("build/charts-base/charts-base.js", 14430);
if (topAxesCollection && topAxesCollection[0])
            {
                _yuitest_coverline("build/charts-base/charts-base.js", 14432);
vAxis = topAxesCollection[0];
            }
            else
            {
                _yuitest_coverline("build/charts-base/charts-base.js", 14436);
vAxis = direction == "vertical" ? catAxis : seriesAxesCollection[0];
            }}
            _yuitest_coverline("build/charts-base/charts-base.js", 14438);
if(!this._getBaseAttribute(vgl, "axis") && vAxis)
            {
                _yuitest_coverline("build/charts-base/charts-base.js", 14440);
this._setBaseAttribute(vgl, "axis", vAxis);
            }
            _yuitest_coverline("build/charts-base/charts-base.js", 14442);
if(this._getBaseAttribute(vgl, "axis"))
            {
                _yuitest_coverline("build/charts-base/charts-base.js", 14444);
graph.set("verticalGridlines", vgl);
            }
        }
    },

    /**
     * Default Function for the axes attribute.
     *
     * @method _getDefaultAxes
     * @return Object
     * @private
     */
    _getDefaultAxes: function()
    {
        _yuitest_coverfunc("build/charts-base/charts-base.js", "_getDefaultAxes", 14456);
_yuitest_coverline("build/charts-base/charts-base.js", 14458);
var axes;
        _yuitest_coverline("build/charts-base/charts-base.js", 14459);
if(this.get("dataProvider"))
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 14461);
axes = this._parseAxes();
        }
        _yuitest_coverline("build/charts-base/charts-base.js", 14463);
return axes;
    },

    /**
     * Generates and returns a key-indexed object containing `Axis` instances or objects used to create `Axis` instances.
     *
     * @method _parseAxes
     * @param {Object} axes Object containing `Axis` instances or `Axis` attributes.
     * @return Object
     * @private
     */
    _parseAxes: function(axes)
    {
        _yuitest_coverfunc("build/charts-base/charts-base.js", "_parseAxes", 14474);
_yuitest_coverline("build/charts-base/charts-base.js", 14476);
var catKey = this.get("categoryKey"),
            axis,
            attr,
            keys,
            newAxes = {},
            claimedKeys = [],
            categoryAxisName = this.get("categoryAxisName") || this.get("categoryKey"),
            valueAxisName = this.get("valueAxisName"),
            seriesKeys = this.get("seriesKeys").concat(),
            i,
            l,
            ii,
            ll,
            cIndex,
            direction = this.get("direction"),
            seriesPosition,
            categoryPosition,
            valueAxes = [],
            seriesAxis = this.get("stacked") ? "stacked" : "numeric";
        _yuitest_coverline("build/charts-base/charts-base.js", 14495);
if(direction == "vertical")
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 14497);
seriesPosition = "bottom";
            _yuitest_coverline("build/charts-base/charts-base.js", 14498);
categoryPosition = "left";
        }
        else
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 14502);
seriesPosition = "left";
            _yuitest_coverline("build/charts-base/charts-base.js", 14503);
categoryPosition = "bottom";
        }
        _yuitest_coverline("build/charts-base/charts-base.js", 14505);
if(axes)
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 14507);
for(i in axes)
            {
                _yuitest_coverline("build/charts-base/charts-base.js", 14509);
if(axes.hasOwnProperty(i))
                {
                    _yuitest_coverline("build/charts-base/charts-base.js", 14511);
axis = axes[i];
                    _yuitest_coverline("build/charts-base/charts-base.js", 14512);
keys = this._getBaseAttribute(axis, "keys");
                    _yuitest_coverline("build/charts-base/charts-base.js", 14513);
attr = this._getBaseAttribute(axis, "type");
                    _yuitest_coverline("build/charts-base/charts-base.js", 14514);
if(attr == "time" || attr == "category")
                    {
                        _yuitest_coverline("build/charts-base/charts-base.js", 14516);
categoryAxisName = i;
                        _yuitest_coverline("build/charts-base/charts-base.js", 14517);
this.set("categoryAxisName", i);
                        _yuitest_coverline("build/charts-base/charts-base.js", 14518);
if(Y_Lang.isArray(keys) && keys.length > 0)
                        {
                            _yuitest_coverline("build/charts-base/charts-base.js", 14520);
catKey = keys[0];
                            _yuitest_coverline("build/charts-base/charts-base.js", 14521);
this.set("categoryKey", catKey);
                        }
                        _yuitest_coverline("build/charts-base/charts-base.js", 14523);
newAxes[i] = axis;
                    }
                    else {_yuitest_coverline("build/charts-base/charts-base.js", 14525);
if(i == categoryAxisName)
                    {
                        _yuitest_coverline("build/charts-base/charts-base.js", 14527);
newAxes[i] = axis;
                    }
                    else
                    {
                        _yuitest_coverline("build/charts-base/charts-base.js", 14531);
newAxes[i] = axis;
                        _yuitest_coverline("build/charts-base/charts-base.js", 14532);
if(i != valueAxisName && keys && Y_Lang.isArray(keys))
                        {
                            _yuitest_coverline("build/charts-base/charts-base.js", 14534);
ll = keys.length;
                            _yuitest_coverline("build/charts-base/charts-base.js", 14535);
for(ii = 0; ii < ll; ++ii)
                            {
                                _yuitest_coverline("build/charts-base/charts-base.js", 14537);
claimedKeys.push(keys[ii]);
                            }
                            _yuitest_coverline("build/charts-base/charts-base.js", 14539);
valueAxes.push(newAxes[i]);
                        }
                        _yuitest_coverline("build/charts-base/charts-base.js", 14541);
if(!(this._getBaseAttribute(newAxes[i], "type")))
                        {
                            _yuitest_coverline("build/charts-base/charts-base.js", 14543);
this._setBaseAttribute(newAxes[i], "type", seriesAxis);
                        }
                        _yuitest_coverline("build/charts-base/charts-base.js", 14545);
if(!(this._getBaseAttribute(newAxes[i], "position")))
                        {
                            _yuitest_coverline("build/charts-base/charts-base.js", 14547);
this._setBaseAttribute(newAxes[i], "position", this._getDefaultAxisPosition(newAxes[i], valueAxes, seriesPosition));
                        }
                    }}
                }
            }
        }
        _yuitest_coverline("build/charts-base/charts-base.js", 14553);
cIndex = Y.Array.indexOf(seriesKeys, catKey);
        _yuitest_coverline("build/charts-base/charts-base.js", 14554);
if(cIndex > -1)
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 14556);
seriesKeys.splice(cIndex, 1);
        }
        _yuitest_coverline("build/charts-base/charts-base.js", 14558);
l = claimedKeys.length;
        _yuitest_coverline("build/charts-base/charts-base.js", 14559);
for(i = 0; i < l; ++i)
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 14561);
cIndex = Y.Array.indexOf(seriesKeys, claimedKeys[i]);
            _yuitest_coverline("build/charts-base/charts-base.js", 14562);
if(cIndex > -1)
            {
                _yuitest_coverline("build/charts-base/charts-base.js", 14564);
seriesKeys.splice(cIndex, 1);
            }
        }
        _yuitest_coverline("build/charts-base/charts-base.js", 14567);
if(!newAxes.hasOwnProperty(categoryAxisName))
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 14569);
newAxes[categoryAxisName] = {};
        }
        _yuitest_coverline("build/charts-base/charts-base.js", 14571);
if(!(this._getBaseAttribute(newAxes[categoryAxisName], "keys")))
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 14573);
this._setBaseAttribute(newAxes[categoryAxisName], "keys", [catKey]);
        }

        _yuitest_coverline("build/charts-base/charts-base.js", 14576);
if(!(this._getBaseAttribute(newAxes[categoryAxisName], "position")))
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 14578);
this._setBaseAttribute(newAxes[categoryAxisName], "position", categoryPosition);
        }

        _yuitest_coverline("build/charts-base/charts-base.js", 14581);
if(!(this._getBaseAttribute(newAxes[categoryAxisName], "type")))
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 14583);
this._setBaseAttribute(newAxes[categoryAxisName], "type", this.get("categoryType"));
        }
        _yuitest_coverline("build/charts-base/charts-base.js", 14585);
if(!newAxes.hasOwnProperty(valueAxisName) && seriesKeys && seriesKeys.length > 0)
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 14587);
newAxes[valueAxisName] = {keys:seriesKeys};
            _yuitest_coverline("build/charts-base/charts-base.js", 14588);
valueAxes.push(newAxes[valueAxisName]);
        }
        _yuitest_coverline("build/charts-base/charts-base.js", 14590);
if(claimedKeys.length > 0)
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 14592);
if(seriesKeys.length > 0)
            {
                _yuitest_coverline("build/charts-base/charts-base.js", 14594);
seriesKeys = claimedKeys.concat(seriesKeys);
            }
            else
            {
                _yuitest_coverline("build/charts-base/charts-base.js", 14598);
seriesKeys = claimedKeys;
            }
        }
        _yuitest_coverline("build/charts-base/charts-base.js", 14601);
if(newAxes.hasOwnProperty(valueAxisName))
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 14603);
if(!(this._getBaseAttribute(newAxes[valueAxisName], "position")))
            {
                _yuitest_coverline("build/charts-base/charts-base.js", 14605);
this._setBaseAttribute(newAxes[valueAxisName], "position", this._getDefaultAxisPosition(newAxes[valueAxisName], valueAxes, seriesPosition));
            }
            _yuitest_coverline("build/charts-base/charts-base.js", 14607);
this._setBaseAttribute(newAxes[valueAxisName], "type", seriesAxis);
            _yuitest_coverline("build/charts-base/charts-base.js", 14608);
this._setBaseAttribute(newAxes[valueAxisName], "keys", seriesKeys);
        }
        _yuitest_coverline("build/charts-base/charts-base.js", 14610);
if(!this._seriesKeysExplicitlySet)
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 14612);
this._seriesKeys = seriesKeys;
        }
        _yuitest_coverline("build/charts-base/charts-base.js", 14614);
return newAxes;
    },

    /**
     * Determines the position of an axis when one is not specified.
     *
     * @method _getDefaultAxisPosition
     * @param {Axis} axis `Axis` instance.
     * @param {Array} valueAxes Array of `Axis` instances.
     * @param {String} position Default position depending on the direction of the chart and type of axis.
     * @return String
     * @private
     */
    _getDefaultAxisPosition: function(axis, valueAxes, position)
    {
        _yuitest_coverfunc("build/charts-base/charts-base.js", "_getDefaultAxisPosition", 14627);
_yuitest_coverline("build/charts-base/charts-base.js", 14629);
var direction = this.get("direction"),
            i = Y.Array.indexOf(valueAxes, axis);

        _yuitest_coverline("build/charts-base/charts-base.js", 14632);
if(valueAxes[i - 1] && valueAxes[i - 1].position)
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 14634);
if(direction == "horizontal")
            {
                _yuitest_coverline("build/charts-base/charts-base.js", 14636);
if(valueAxes[i - 1].position == "left")
                {
                    _yuitest_coverline("build/charts-base/charts-base.js", 14638);
position = "right";
                }
                else {_yuitest_coverline("build/charts-base/charts-base.js", 14640);
if(valueAxes[i - 1].position == "right")
                {
                    _yuitest_coverline("build/charts-base/charts-base.js", 14642);
position = "left";
                }}
            }
            else
            {
                _yuitest_coverline("build/charts-base/charts-base.js", 14647);
if (valueAxes[i -1].position == "bottom")
                {
                    _yuitest_coverline("build/charts-base/charts-base.js", 14649);
position = "top";
                }
                else
                {
                    _yuitest_coverline("build/charts-base/charts-base.js", 14653);
position = "bottom";
                }
            }
        }
        _yuitest_coverline("build/charts-base/charts-base.js", 14657);
return position;
    },


    /**
     * Returns an object literal containing a categoryItem and a valueItem for a given series index. Below is the structure of each:
     *
     * @method getSeriesItems
     * @param {CartesianSeries} series Reference to a series.
     * @param {Number} index Index of the specified item within a series.
     * @return Object An object literal containing the following:
     *
     *  <dl>
     *      <dt>categoryItem</dt><dd>Object containing the following data related to the category axis of the series.
     *  <dl>
     *      <dt>axis</dt><dd>Reference to the category axis of the series.</dd>
     *      <dt>key</dt><dd>Category key for the series.</dd>
     *      <dt>value</dt><dd>Value on the axis corresponding to the series index.</dd>
     *  </dl>
     *      </dd>
     *      <dt>valueItem</dt><dd>Object containing the following data related to the category axis of the series.
     *  <dl>
     *      <dt>axis</dt><dd>Reference to the value axis of the series.</dd>
     *      <dt>key</dt><dd>Value key for the series.</dd>
     *      <dt>value</dt><dd>Value on the axis corresponding to the series index.</dd>
     *  </dl>
     *      </dd>
     *  </dl>
     */
    getSeriesItems: function(series, index)
    {
        _yuitest_coverfunc("build/charts-base/charts-base.js", "getSeriesItems", 14686);
_yuitest_coverline("build/charts-base/charts-base.js", 14688);
var xAxis = series.get("xAxis"),
            yAxis = series.get("yAxis"),
            xKey = series.get("xKey"),
            yKey = series.get("yKey"),
            categoryItem,
            valueItem;
        _yuitest_coverline("build/charts-base/charts-base.js", 14694);
if(this.get("direction") == "vertical")
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 14696);
categoryItem = {
                axis:yAxis,
                key:yKey,
                value:yAxis.getKeyValueAt(yKey, index)
            };
            _yuitest_coverline("build/charts-base/charts-base.js", 14701);
valueItem = {
                axis:xAxis,
                key:xKey,
                value: xAxis.getKeyValueAt(xKey, index)
            };
        }
        else
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 14709);
valueItem = {
                axis:yAxis,
                key:yKey,
                value:yAxis.getKeyValueAt(yKey, index)
            };
            _yuitest_coverline("build/charts-base/charts-base.js", 14714);
categoryItem = {
                axis:xAxis,
                key:xKey,
                value: xAxis.getKeyValueAt(xKey, index)
            };
        }
        _yuitest_coverline("build/charts-base/charts-base.js", 14720);
categoryItem.displayName = series.get("categoryDisplayName");
        _yuitest_coverline("build/charts-base/charts-base.js", 14721);
valueItem.displayName = series.get("valueDisplayName");
        _yuitest_coverline("build/charts-base/charts-base.js", 14722);
categoryItem.value = categoryItem.axis.getKeyValueAt(categoryItem.key, index);
        _yuitest_coverline("build/charts-base/charts-base.js", 14723);
valueItem.value = valueItem.axis.getKeyValueAt(valueItem.key, index);
        _yuitest_coverline("build/charts-base/charts-base.js", 14724);
return {category:categoryItem, value:valueItem};
    },

    /**
     * Handler for sizeChanged event.
     *
     * @method _sizeChanged
     * @param {Object} e Event object.
     * @private
     */
    _sizeChanged: function(e)
    {
        _yuitest_coverfunc("build/charts-base/charts-base.js", "_sizeChanged", 14734);
_yuitest_coverline("build/charts-base/charts-base.js", 14736);
if(this._axesCollection)
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 14738);
var ac = this._axesCollection,
                i = 0,
                l = ac.length;
            _yuitest_coverline("build/charts-base/charts-base.js", 14741);
for(; i < l; ++i)
            {
                _yuitest_coverline("build/charts-base/charts-base.js", 14743);
this._addToAxesRenderQueue(ac[i]);
            }
            _yuitest_coverline("build/charts-base/charts-base.js", 14745);
this._redraw();
        }
    },

    /**
     * Returns the maximum distance in pixels that the extends outside the top bounds of all vertical axes.
     *
     * @method _getTopOverflow
     * @param {Array} set1 Collection of axes to check.
     * @param {Array} set2 Seconf collection of axes to check.
     * @param {Number} width Width of the axes
     * @return Number
     * @private
     */
    _getTopOverflow: function(set1, set2, height)
    {
        _yuitest_coverfunc("build/charts-base/charts-base.js", "_getTopOverflow", 14759);
_yuitest_coverline("build/charts-base/charts-base.js", 14761);
var i = 0,
            len,
            overflow = 0,
            axis;
        _yuitest_coverline("build/charts-base/charts-base.js", 14765);
if(set1)
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 14767);
len = set1.length;
            _yuitest_coverline("build/charts-base/charts-base.js", 14768);
for(; i < len; ++i)
            {
                _yuitest_coverline("build/charts-base/charts-base.js", 14770);
axis = set1[i];
                _yuitest_coverline("build/charts-base/charts-base.js", 14771);
overflow = Math.max(overflow, Math.abs(axis.getMaxLabelBounds().top) - (axis.getEdgeOffset(axis.get("styles").majorTicks.count, height) * 0.5));
            }
        }
        _yuitest_coverline("build/charts-base/charts-base.js", 14774);
if(set2)
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 14776);
i = 0;
            _yuitest_coverline("build/charts-base/charts-base.js", 14777);
len = set2.length;
            _yuitest_coverline("build/charts-base/charts-base.js", 14778);
for(; i < len; ++i)
            {
                _yuitest_coverline("build/charts-base/charts-base.js", 14780);
axis = set2[i];
                _yuitest_coverline("build/charts-base/charts-base.js", 14781);
overflow = Math.max(overflow, Math.abs(axis.getMaxLabelBounds().top) - (axis.getEdgeOffset(axis.get("styles").majorTicks.count, height) * 0.5));
            }
        }
        _yuitest_coverline("build/charts-base/charts-base.js", 14784);
return overflow;
    },

    /**
     * Returns the maximum distance in pixels that the extends outside the right bounds of all horizontal axes.
     *
     * @method _getRightOverflow
     * @param {Array} set1 Collection of axes to check.
     * @param {Array} set2 Seconf collection of axes to check.
     * @param {Number} width Width of the axes
     * @return Number
     * @private
     */
    _getRightOverflow: function(set1, set2, width)
    {
        _yuitest_coverfunc("build/charts-base/charts-base.js", "_getRightOverflow", 14797);
_yuitest_coverline("build/charts-base/charts-base.js", 14799);
var i = 0,
            len,
            overflow = 0,
            axis;
        _yuitest_coverline("build/charts-base/charts-base.js", 14803);
if(set1)
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 14805);
len = set1.length;
            _yuitest_coverline("build/charts-base/charts-base.js", 14806);
for(; i < len; ++i)
            {
                _yuitest_coverline("build/charts-base/charts-base.js", 14808);
axis = set1[i];
                _yuitest_coverline("build/charts-base/charts-base.js", 14809);
overflow = Math.max(overflow, axis.getMaxLabelBounds().right - (axis.getEdgeOffset(axis.get("styles").majorTicks.count, width) * 0.5));
            }
        }
        _yuitest_coverline("build/charts-base/charts-base.js", 14812);
if(set2)
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 14814);
i = 0;
            _yuitest_coverline("build/charts-base/charts-base.js", 14815);
len = set2.length;
            _yuitest_coverline("build/charts-base/charts-base.js", 14816);
for(; i < len; ++i)
            {
                _yuitest_coverline("build/charts-base/charts-base.js", 14818);
axis = set2[i];
                _yuitest_coverline("build/charts-base/charts-base.js", 14819);
overflow = Math.max(overflow, axis.getMaxLabelBounds().right - (axis.getEdgeOffset(axis.get("styles").majorTicks.count, width) * 0.5));
            }
        }
        _yuitest_coverline("build/charts-base/charts-base.js", 14822);
return overflow;
    },

    /**
     * Returns the maximum distance in pixels that the extends outside the left bounds of all horizontal axes.
     *
     * @method _getLeftOverflow
     * @param {Array} set1 Collection of axes to check.
     * @param {Array} set2 Seconf collection of axes to check.
     * @param {Number} width Width of the axes
     * @return Number
     * @private
     */
    _getLeftOverflow: function(set1, set2, width)
    {
        _yuitest_coverfunc("build/charts-base/charts-base.js", "_getLeftOverflow", 14835);
_yuitest_coverline("build/charts-base/charts-base.js", 14837);
var i = 0,
            len,
            overflow = 0,
            axis;
        _yuitest_coverline("build/charts-base/charts-base.js", 14841);
if(set1)
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 14843);
len = set1.length;
            _yuitest_coverline("build/charts-base/charts-base.js", 14844);
for(; i < len; ++i)
            {
                _yuitest_coverline("build/charts-base/charts-base.js", 14846);
axis = set1[i];
                _yuitest_coverline("build/charts-base/charts-base.js", 14847);
overflow = Math.max(overflow, Math.abs(axis.getMinLabelBounds().left) - (axis.getEdgeOffset(axis.get("styles").majorTicks.count, width) * 0.5));
            }
        }
        _yuitest_coverline("build/charts-base/charts-base.js", 14850);
if(set2)
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 14852);
i = 0;
            _yuitest_coverline("build/charts-base/charts-base.js", 14853);
len = set2.length;
            _yuitest_coverline("build/charts-base/charts-base.js", 14854);
for(; i < len; ++i)
            {
                _yuitest_coverline("build/charts-base/charts-base.js", 14856);
axis = set2[i];
                _yuitest_coverline("build/charts-base/charts-base.js", 14857);
overflow = Math.max(overflow, Math.abs(axis.getMinLabelBounds().left) - (axis.getEdgeOffset(axis.get("styles").majorTicks.count, width) * 0.5));
            }
        }
        _yuitest_coverline("build/charts-base/charts-base.js", 14860);
return overflow;
    },

    /**
     * Returns the maximum distance in pixels that the extends outside the bottom bounds of all vertical axes.
     *
     * @method _getBottomOverflow
     * @param {Array} set1 Collection of axes to check.
     * @param {Array} set2 Seconf collection of axes to check.
     * @param {Number} height Height of the axes
     * @return Number
     * @private
     */
    _getBottomOverflow: function(set1, set2, height)
    {
        _yuitest_coverfunc("build/charts-base/charts-base.js", "_getBottomOverflow", 14873);
_yuitest_coverline("build/charts-base/charts-base.js", 14875);
var i = 0,
            len,
            overflow = 0,
            axis;
        _yuitest_coverline("build/charts-base/charts-base.js", 14879);
if(set1)
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 14881);
len = set1.length;
            _yuitest_coverline("build/charts-base/charts-base.js", 14882);
for(; i < len; ++i)
            {
                _yuitest_coverline("build/charts-base/charts-base.js", 14884);
axis = set1[i];
                _yuitest_coverline("build/charts-base/charts-base.js", 14885);
overflow = Math.max(overflow, axis.getMinLabelBounds().bottom - (axis.getEdgeOffset(axis.get("styles").majorTicks.count, height) * 0.5));
            }
        }
        _yuitest_coverline("build/charts-base/charts-base.js", 14888);
if(set2)
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 14890);
i = 0;
            _yuitest_coverline("build/charts-base/charts-base.js", 14891);
len = set2.length;
            _yuitest_coverline("build/charts-base/charts-base.js", 14892);
for(; i < len; ++i)
            {
                _yuitest_coverline("build/charts-base/charts-base.js", 14894);
axis = set2[i];
                _yuitest_coverline("build/charts-base/charts-base.js", 14895);
overflow = Math.max(overflow, axis.getMinLabelBounds().bottom - (axis.getEdgeOffset(axis.get("styles").majorTicks.count, height) * 0.5));
            }
        }
        _yuitest_coverline("build/charts-base/charts-base.js", 14898);
return overflow;
    },

    /**
     * Redraws and position all the components of the chart instance.
     *
     * @method _redraw
     * @private
     */
    _redraw: function()
    {
        _yuitest_coverfunc("build/charts-base/charts-base.js", "_redraw", 14907);
_yuitest_coverline("build/charts-base/charts-base.js", 14909);
if(this._drawing)
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 14911);
this._callLater = true;
            _yuitest_coverline("build/charts-base/charts-base.js", 14912);
return;
        }
        _yuitest_coverline("build/charts-base/charts-base.js", 14914);
this._drawing = true;
        _yuitest_coverline("build/charts-base/charts-base.js", 14915);
this._callLater = false;
        _yuitest_coverline("build/charts-base/charts-base.js", 14916);
var w = this.get("width"),
            h = this.get("height"),
            leftPaneWidth = 0,
            rightPaneWidth = 0,
            topPaneHeight = 0,
            bottomPaneHeight = 0,
            leftAxesCollection = this.get("leftAxesCollection"),
            rightAxesCollection = this.get("rightAxesCollection"),
            topAxesCollection = this.get("topAxesCollection"),
            bottomAxesCollection = this.get("bottomAxesCollection"),
            i = 0,
            l,
            axis,
            graphOverflow = "visible",
            graph = this.get("graph"),
            topOverflow,
            bottomOverflow,
            leftOverflow,
            rightOverflow,
            graphWidth,
            graphHeight,
            graphX,
            graphY,
            allowContentOverflow = this.get("allowContentOverflow"),
            diff,
            rightAxesXCoords,
            leftAxesXCoords,
            topAxesYCoords,
            bottomAxesYCoords,
            graphRect = {};
        _yuitest_coverline("build/charts-base/charts-base.js", 14946);
if(leftAxesCollection)
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 14948);
leftAxesXCoords = [];
            _yuitest_coverline("build/charts-base/charts-base.js", 14949);
l = leftAxesCollection.length;
            _yuitest_coverline("build/charts-base/charts-base.js", 14950);
for(i = l - 1; i > -1; --i)
            {
                _yuitest_coverline("build/charts-base/charts-base.js", 14952);
leftAxesXCoords.unshift(leftPaneWidth);
                _yuitest_coverline("build/charts-base/charts-base.js", 14953);
leftPaneWidth += leftAxesCollection[i].get("width");
            }
        }
        _yuitest_coverline("build/charts-base/charts-base.js", 14956);
if(rightAxesCollection)
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 14958);
rightAxesXCoords = [];
            _yuitest_coverline("build/charts-base/charts-base.js", 14959);
l = rightAxesCollection.length;
            _yuitest_coverline("build/charts-base/charts-base.js", 14960);
i = 0;
            _yuitest_coverline("build/charts-base/charts-base.js", 14961);
for(i = l - 1; i > -1; --i)
            {
                _yuitest_coverline("build/charts-base/charts-base.js", 14963);
rightPaneWidth += rightAxesCollection[i].get("width");
                _yuitest_coverline("build/charts-base/charts-base.js", 14964);
rightAxesXCoords.unshift(w - rightPaneWidth);
            }
        }
        _yuitest_coverline("build/charts-base/charts-base.js", 14967);
if(topAxesCollection)
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 14969);
topAxesYCoords = [];
            _yuitest_coverline("build/charts-base/charts-base.js", 14970);
l = topAxesCollection.length;
            _yuitest_coverline("build/charts-base/charts-base.js", 14971);
for(i = l - 1; i > -1; --i)
            {
                _yuitest_coverline("build/charts-base/charts-base.js", 14973);
topAxesYCoords.unshift(topPaneHeight);
                _yuitest_coverline("build/charts-base/charts-base.js", 14974);
topPaneHeight += topAxesCollection[i].get("height");
            }
        }
        _yuitest_coverline("build/charts-base/charts-base.js", 14977);
if(bottomAxesCollection)
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 14979);
bottomAxesYCoords = [];
            _yuitest_coverline("build/charts-base/charts-base.js", 14980);
l = bottomAxesCollection.length;
            _yuitest_coverline("build/charts-base/charts-base.js", 14981);
for(i = l - 1; i > -1; --i)
            {
                _yuitest_coverline("build/charts-base/charts-base.js", 14983);
bottomPaneHeight += bottomAxesCollection[i].get("height");
                _yuitest_coverline("build/charts-base/charts-base.js", 14984);
bottomAxesYCoords.unshift(h - bottomPaneHeight);
            }
        }

        _yuitest_coverline("build/charts-base/charts-base.js", 14988);
graphWidth = w - (leftPaneWidth + rightPaneWidth);
        _yuitest_coverline("build/charts-base/charts-base.js", 14989);
graphHeight = h - (bottomPaneHeight + topPaneHeight);
        _yuitest_coverline("build/charts-base/charts-base.js", 14990);
graphRect.left = leftPaneWidth;
        _yuitest_coverline("build/charts-base/charts-base.js", 14991);
graphRect.top = topPaneHeight;
        _yuitest_coverline("build/charts-base/charts-base.js", 14992);
graphRect.bottom = h - bottomPaneHeight;
        _yuitest_coverline("build/charts-base/charts-base.js", 14993);
graphRect.right = w - rightPaneWidth;
        _yuitest_coverline("build/charts-base/charts-base.js", 14994);
if(!allowContentOverflow)
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 14996);
topOverflow = this._getTopOverflow(leftAxesCollection, rightAxesCollection);
            _yuitest_coverline("build/charts-base/charts-base.js", 14997);
bottomOverflow = this._getBottomOverflow(leftAxesCollection, rightAxesCollection);
            _yuitest_coverline("build/charts-base/charts-base.js", 14998);
leftOverflow = this._getLeftOverflow(bottomAxesCollection, topAxesCollection);
            _yuitest_coverline("build/charts-base/charts-base.js", 14999);
rightOverflow = this._getRightOverflow(bottomAxesCollection, topAxesCollection);

            _yuitest_coverline("build/charts-base/charts-base.js", 15001);
diff = topOverflow - topPaneHeight;
            _yuitest_coverline("build/charts-base/charts-base.js", 15002);
if(diff > 0)
            {
                _yuitest_coverline("build/charts-base/charts-base.js", 15004);
graphRect.top = topOverflow;
                _yuitest_coverline("build/charts-base/charts-base.js", 15005);
if(topAxesYCoords)
                {
                    _yuitest_coverline("build/charts-base/charts-base.js", 15007);
i = 0;
                    _yuitest_coverline("build/charts-base/charts-base.js", 15008);
l = topAxesYCoords.length;
                    _yuitest_coverline("build/charts-base/charts-base.js", 15009);
for(; i < l; ++i)
                    {
                        _yuitest_coverline("build/charts-base/charts-base.js", 15011);
topAxesYCoords[i] += diff;
                    }
                }
            }

            _yuitest_coverline("build/charts-base/charts-base.js", 15016);
diff = bottomOverflow - bottomPaneHeight;
            _yuitest_coverline("build/charts-base/charts-base.js", 15017);
if(diff > 0)
            {
                _yuitest_coverline("build/charts-base/charts-base.js", 15019);
graphRect.bottom = h - bottomOverflow;
                _yuitest_coverline("build/charts-base/charts-base.js", 15020);
if(bottomAxesYCoords)
                {
                    _yuitest_coverline("build/charts-base/charts-base.js", 15022);
i = 0;
                    _yuitest_coverline("build/charts-base/charts-base.js", 15023);
l = bottomAxesYCoords.length;
                    _yuitest_coverline("build/charts-base/charts-base.js", 15024);
for(; i < l; ++i)
                    {
                        _yuitest_coverline("build/charts-base/charts-base.js", 15026);
bottomAxesYCoords[i] -= diff;
                    }
                }
            }

            _yuitest_coverline("build/charts-base/charts-base.js", 15031);
diff = leftOverflow - leftPaneWidth;
            _yuitest_coverline("build/charts-base/charts-base.js", 15032);
if(diff > 0)
            {
                _yuitest_coverline("build/charts-base/charts-base.js", 15034);
graphRect.left = leftOverflow;
                _yuitest_coverline("build/charts-base/charts-base.js", 15035);
if(leftAxesXCoords)
                {
                    _yuitest_coverline("build/charts-base/charts-base.js", 15037);
i = 0;
                    _yuitest_coverline("build/charts-base/charts-base.js", 15038);
l = leftAxesXCoords.length;
                    _yuitest_coverline("build/charts-base/charts-base.js", 15039);
for(; i < l; ++i)
                    {
                        _yuitest_coverline("build/charts-base/charts-base.js", 15041);
leftAxesXCoords[i] += diff;
                    }
                }
            }

            _yuitest_coverline("build/charts-base/charts-base.js", 15046);
diff = rightOverflow - rightPaneWidth;
            _yuitest_coverline("build/charts-base/charts-base.js", 15047);
if(diff > 0)
            {
                _yuitest_coverline("build/charts-base/charts-base.js", 15049);
graphRect.right = w - rightOverflow;
                _yuitest_coverline("build/charts-base/charts-base.js", 15050);
if(rightAxesXCoords)
                {
                    _yuitest_coverline("build/charts-base/charts-base.js", 15052);
i = 0;
                    _yuitest_coverline("build/charts-base/charts-base.js", 15053);
l = rightAxesXCoords.length;
                    _yuitest_coverline("build/charts-base/charts-base.js", 15054);
for(; i < l; ++i)
                    {
                        _yuitest_coverline("build/charts-base/charts-base.js", 15056);
rightAxesXCoords[i] -= diff;
                    }
                }
            }
        }
        _yuitest_coverline("build/charts-base/charts-base.js", 15061);
graphWidth = graphRect.right - graphRect.left;
        _yuitest_coverline("build/charts-base/charts-base.js", 15062);
graphHeight = graphRect.bottom - graphRect.top;
        _yuitest_coverline("build/charts-base/charts-base.js", 15063);
graphX = graphRect.left;
        _yuitest_coverline("build/charts-base/charts-base.js", 15064);
graphY = graphRect.top;
        _yuitest_coverline("build/charts-base/charts-base.js", 15065);
if(topAxesCollection)
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 15067);
l = topAxesCollection.length;
            _yuitest_coverline("build/charts-base/charts-base.js", 15068);
i = 0;
            _yuitest_coverline("build/charts-base/charts-base.js", 15069);
for(; i < l; i++)
            {
                _yuitest_coverline("build/charts-base/charts-base.js", 15071);
axis = topAxesCollection[i];
                _yuitest_coverline("build/charts-base/charts-base.js", 15072);
if(axis.get("width") !== graphWidth)
                {
                    _yuitest_coverline("build/charts-base/charts-base.js", 15074);
axis.set("width", graphWidth);
                }
                _yuitest_coverline("build/charts-base/charts-base.js", 15076);
axis.get("boundingBox").setStyle("left", graphX + "px");
                _yuitest_coverline("build/charts-base/charts-base.js", 15077);
axis.get("boundingBox").setStyle("top", topAxesYCoords[i] + "px");
            }
            _yuitest_coverline("build/charts-base/charts-base.js", 15079);
if(axis._hasDataOverflow())
            {
                _yuitest_coverline("build/charts-base/charts-base.js", 15081);
graphOverflow = "hidden";
            }
        }
        _yuitest_coverline("build/charts-base/charts-base.js", 15084);
if(bottomAxesCollection)
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 15086);
l = bottomAxesCollection.length;
            _yuitest_coverline("build/charts-base/charts-base.js", 15087);
i = 0;
            _yuitest_coverline("build/charts-base/charts-base.js", 15088);
for(; i < l; i++)
            {
                _yuitest_coverline("build/charts-base/charts-base.js", 15090);
axis = bottomAxesCollection[i];
                _yuitest_coverline("build/charts-base/charts-base.js", 15091);
if(axis.get("width") !== graphWidth)
                {
                    _yuitest_coverline("build/charts-base/charts-base.js", 15093);
axis.set("width", graphWidth);
                }
                _yuitest_coverline("build/charts-base/charts-base.js", 15095);
axis.get("boundingBox").setStyle("left", graphX + "px");
                _yuitest_coverline("build/charts-base/charts-base.js", 15096);
axis.get("boundingBox").setStyle("top", bottomAxesYCoords[i] + "px");
            }
            _yuitest_coverline("build/charts-base/charts-base.js", 15098);
if(axis._hasDataOverflow())
            {
                _yuitest_coverline("build/charts-base/charts-base.js", 15100);
graphOverflow = "hidden";
            }
        }
        _yuitest_coverline("build/charts-base/charts-base.js", 15103);
if(leftAxesCollection)
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 15105);
l = leftAxesCollection.length;
            _yuitest_coverline("build/charts-base/charts-base.js", 15106);
i = 0;
            _yuitest_coverline("build/charts-base/charts-base.js", 15107);
for(; i < l; ++i)
            {
                _yuitest_coverline("build/charts-base/charts-base.js", 15109);
axis = leftAxesCollection[i];
                _yuitest_coverline("build/charts-base/charts-base.js", 15110);
axis.get("boundingBox").setStyle("top", graphY + "px");
                _yuitest_coverline("build/charts-base/charts-base.js", 15111);
axis.get("boundingBox").setStyle("left", leftAxesXCoords[i] + "px");
                _yuitest_coverline("build/charts-base/charts-base.js", 15112);
if(axis.get("height") !== graphHeight)
                {
                    _yuitest_coverline("build/charts-base/charts-base.js", 15114);
axis.set("height", graphHeight);
                }
            }
            _yuitest_coverline("build/charts-base/charts-base.js", 15117);
if(axis._hasDataOverflow())
            {
                _yuitest_coverline("build/charts-base/charts-base.js", 15119);
graphOverflow = "hidden";
            }
        }
        _yuitest_coverline("build/charts-base/charts-base.js", 15122);
if(rightAxesCollection)
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 15124);
l = rightAxesCollection.length;
            _yuitest_coverline("build/charts-base/charts-base.js", 15125);
i = 0;
            _yuitest_coverline("build/charts-base/charts-base.js", 15126);
for(; i < l; ++i)
            {
                _yuitest_coverline("build/charts-base/charts-base.js", 15128);
axis = rightAxesCollection[i];
                _yuitest_coverline("build/charts-base/charts-base.js", 15129);
axis.get("boundingBox").setStyle("top", graphY + "px");
                _yuitest_coverline("build/charts-base/charts-base.js", 15130);
axis.get("boundingBox").setStyle("left", rightAxesXCoords[i] + "px");
                _yuitest_coverline("build/charts-base/charts-base.js", 15131);
if(axis.get("height") !== graphHeight)
                {
                    _yuitest_coverline("build/charts-base/charts-base.js", 15133);
axis.set("height", graphHeight);
                }
            }
            _yuitest_coverline("build/charts-base/charts-base.js", 15136);
if(axis._hasDataOverflow())
            {
                _yuitest_coverline("build/charts-base/charts-base.js", 15138);
graphOverflow = "hidden";
            }
        }
        _yuitest_coverline("build/charts-base/charts-base.js", 15141);
this._drawing = false;
        _yuitest_coverline("build/charts-base/charts-base.js", 15142);
if(this._callLater)
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 15144);
this._redraw();
            _yuitest_coverline("build/charts-base/charts-base.js", 15145);
return;
        }
        _yuitest_coverline("build/charts-base/charts-base.js", 15147);
if(graph)
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 15149);
graph.get("boundingBox").setStyle("left", graphX + "px");
            _yuitest_coverline("build/charts-base/charts-base.js", 15150);
graph.get("boundingBox").setStyle("top", graphY + "px");
            _yuitest_coverline("build/charts-base/charts-base.js", 15151);
graph.set("width", graphWidth);
            _yuitest_coverline("build/charts-base/charts-base.js", 15152);
graph.set("height", graphHeight);
            _yuitest_coverline("build/charts-base/charts-base.js", 15153);
graph.get("boundingBox").setStyle("overflow", graphOverflow);
        }

        _yuitest_coverline("build/charts-base/charts-base.js", 15156);
if(this._overlay)
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 15158);
this._overlay.setStyle("left", graphX + "px");
            _yuitest_coverline("build/charts-base/charts-base.js", 15159);
this._overlay.setStyle("top", graphY + "px");
            _yuitest_coverline("build/charts-base/charts-base.js", 15160);
this._overlay.setStyle("width", graphWidth + "px");
            _yuitest_coverline("build/charts-base/charts-base.js", 15161);
this._overlay.setStyle("height", graphHeight + "px");
        }
    },

    /**
     * Destructor implementation for the CartesianChart class. Calls destroy on all axes, series and the Graph instance.
     * Removes the tooltip and overlay HTML elements.
     *
     * @method destructor
     * @protected
     */
    destructor: function()
    {
        _yuitest_coverfunc("build/charts-base/charts-base.js", "destructor", 15172);
_yuitest_coverline("build/charts-base/charts-base.js", 15174);
var graph = this.get("graph"),
            i = 0,
            len,
            seriesCollection = this.get("seriesCollection"),
            axesCollection = this._axesCollection,
            tooltip = this.get("tooltip").node;
        _yuitest_coverline("build/charts-base/charts-base.js", 15180);
if(this._description)
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 15182);
this._description.empty();
            _yuitest_coverline("build/charts-base/charts-base.js", 15183);
this._description.remove(true);
        }
        _yuitest_coverline("build/charts-base/charts-base.js", 15185);
if(this._liveRegion)
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 15187);
this._liveRegion.empty();
            _yuitest_coverline("build/charts-base/charts-base.js", 15188);
this._liveRegion.remove(true);
        }
        _yuitest_coverline("build/charts-base/charts-base.js", 15190);
len = seriesCollection ? seriesCollection.length : 0;
        _yuitest_coverline("build/charts-base/charts-base.js", 15191);
for(; i < len; ++i)
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 15193);
if(seriesCollection[i] instanceof Y.CartesianSeries)
            {
                _yuitest_coverline("build/charts-base/charts-base.js", 15195);
seriesCollection[i].destroy(true);
            }
        }
        _yuitest_coverline("build/charts-base/charts-base.js", 15198);
len = axesCollection ? axesCollection.length : 0;
        _yuitest_coverline("build/charts-base/charts-base.js", 15199);
for(i = 0; i < len; ++i)
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 15201);
if(axesCollection[i] instanceof Y.Axis)
            {
                _yuitest_coverline("build/charts-base/charts-base.js", 15203);
axesCollection[i].destroy(true);
            }
        }
        _yuitest_coverline("build/charts-base/charts-base.js", 15206);
if(graph)
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 15208);
graph.destroy(true);
        }
        _yuitest_coverline("build/charts-base/charts-base.js", 15210);
if(tooltip)
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 15212);
tooltip.empty();
            _yuitest_coverline("build/charts-base/charts-base.js", 15213);
tooltip.remove(true);
        }
        _yuitest_coverline("build/charts-base/charts-base.js", 15215);
if(this._overlay)
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 15217);
this._overlay.empty();
            _yuitest_coverline("build/charts-base/charts-base.js", 15218);
this._overlay.remove(true);
        }
    },

    /**
     * Returns the appropriate message based on the key press.
     *
     * @method _getAriaMessage
     * @param {Number} key The keycode that was pressed.
     * @return String
     */
    _getAriaMessage: function(key)
    {
        _yuitest_coverfunc("build/charts-base/charts-base.js", "_getAriaMessage", 15229);
_yuitest_coverline("build/charts-base/charts-base.js", 15231);
var msg = "",
            series,
            items,
            categoryItem,
            valueItem,
            seriesIndex = this._seriesIndex,
            itemIndex = this._itemIndex,
            seriesCollection = this.get("seriesCollection"),
            len = seriesCollection.length,
            dataLength;
        _yuitest_coverline("build/charts-base/charts-base.js", 15241);
if(key % 2 === 0)
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 15243);
if(len > 1)
            {
                _yuitest_coverline("build/charts-base/charts-base.js", 15245);
if(key === 38)
                {
                    _yuitest_coverline("build/charts-base/charts-base.js", 15247);
seriesIndex = seriesIndex < 1 ? len - 1 : seriesIndex - 1;
                }
                else {_yuitest_coverline("build/charts-base/charts-base.js", 15249);
if(key === 40)
                {
                    _yuitest_coverline("build/charts-base/charts-base.js", 15251);
seriesIndex = seriesIndex >= len - 1 ? 0 : seriesIndex + 1;
                }}
                _yuitest_coverline("build/charts-base/charts-base.js", 15253);
this._itemIndex = -1;
            }
            else
            {
                _yuitest_coverline("build/charts-base/charts-base.js", 15257);
seriesIndex = 0;
            }
            _yuitest_coverline("build/charts-base/charts-base.js", 15259);
this._seriesIndex = seriesIndex;
            _yuitest_coverline("build/charts-base/charts-base.js", 15260);
series = this.getSeries(parseInt(seriesIndex, 10));
            _yuitest_coverline("build/charts-base/charts-base.js", 15261);
msg = series.get("valueDisplayName") + " series.";
        }
        else
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 15265);
if(seriesIndex > -1)
            {
                _yuitest_coverline("build/charts-base/charts-base.js", 15267);
msg = "";
                _yuitest_coverline("build/charts-base/charts-base.js", 15268);
series = this.getSeries(parseInt(seriesIndex, 10));
            }
            else
            {
                _yuitest_coverline("build/charts-base/charts-base.js", 15272);
seriesIndex = 0;
                _yuitest_coverline("build/charts-base/charts-base.js", 15273);
this._seriesIndex = seriesIndex;
                _yuitest_coverline("build/charts-base/charts-base.js", 15274);
series = this.getSeries(parseInt(seriesIndex, 10));
                _yuitest_coverline("build/charts-base/charts-base.js", 15275);
msg = series.get("valueDisplayName") + " series.";
            }
            _yuitest_coverline("build/charts-base/charts-base.js", 15277);
dataLength = series._dataLength ? series._dataLength : 0;
            _yuitest_coverline("build/charts-base/charts-base.js", 15278);
if(key === 37)
            {
                _yuitest_coverline("build/charts-base/charts-base.js", 15280);
itemIndex = itemIndex > 0 ? itemIndex - 1 : dataLength - 1;
            }
            else {_yuitest_coverline("build/charts-base/charts-base.js", 15282);
if(key === 39)
            {
                _yuitest_coverline("build/charts-base/charts-base.js", 15284);
itemIndex = itemIndex >= dataLength - 1 ? 0 : itemIndex + 1;
            }}
            _yuitest_coverline("build/charts-base/charts-base.js", 15286);
this._itemIndex = itemIndex;
            _yuitest_coverline("build/charts-base/charts-base.js", 15287);
items = this.getSeriesItems(series, itemIndex);
            _yuitest_coverline("build/charts-base/charts-base.js", 15288);
categoryItem = items.category;
            _yuitest_coverline("build/charts-base/charts-base.js", 15289);
valueItem = items.value;
            _yuitest_coverline("build/charts-base/charts-base.js", 15290);
if(categoryItem && valueItem && categoryItem.value && valueItem.value)
            {
                _yuitest_coverline("build/charts-base/charts-base.js", 15292);
msg += categoryItem.displayName + ": " + categoryItem.axis.formatLabel.apply(this, [categoryItem.value, categoryItem.axis.get("labelFormat")]) + ", ";
                _yuitest_coverline("build/charts-base/charts-base.js", 15293);
msg += valueItem.displayName + ": " + valueItem.axis.formatLabel.apply(this, [valueItem.value, valueItem.axis.get("labelFormat")]) + ", ";
            }
           else
            {
                _yuitest_coverline("build/charts-base/charts-base.js", 15297);
msg += "No data available.";
            }
            _yuitest_coverline("build/charts-base/charts-base.js", 15299);
msg += (itemIndex + 1) + " of " + dataLength + ". ";
        }
        _yuitest_coverline("build/charts-base/charts-base.js", 15301);
return msg;
    }
}, {
    ATTRS: {
        /**
         * Indicates whether axis labels are allowed to overflow beyond the bounds of the chart's content box.
         *
         * @attribute allowContentOverflow
         * @type Boolean
         */
        allowContentOverflow: {
            value: false
        },

        /**
         * Style object for the axes.
         *
         * @attribute axesStyles
         * @type Object
         * @private
         */
        axesStyles: {
            getter: function()
            {
                _yuitest_coverfunc("build/charts-base/charts-base.js", "getter", 15323);
_yuitest_coverline("build/charts-base/charts-base.js", 15325);
var axes = this.get("axes"),
                    i,
                    styles = this._axesStyles;
                _yuitest_coverline("build/charts-base/charts-base.js", 15328);
if(axes)
                {
                    _yuitest_coverline("build/charts-base/charts-base.js", 15330);
for(i in axes)
                    {
                        _yuitest_coverline("build/charts-base/charts-base.js", 15332);
if(axes.hasOwnProperty(i) && axes[i] instanceof Y.Axis)
                        {
                            _yuitest_coverline("build/charts-base/charts-base.js", 15334);
if(!styles)
                            {
                                _yuitest_coverline("build/charts-base/charts-base.js", 15336);
styles = {};
                            }
                            _yuitest_coverline("build/charts-base/charts-base.js", 15338);
styles[i] = axes[i].get("styles");
                        }
                    }
                }
                _yuitest_coverline("build/charts-base/charts-base.js", 15342);
return styles;
            },

            setter: function(val)
            {
                _yuitest_coverfunc("build/charts-base/charts-base.js", "setter", 15345);
_yuitest_coverline("build/charts-base/charts-base.js", 15347);
var axes = this.get("axes"),
                    i;
                _yuitest_coverline("build/charts-base/charts-base.js", 15349);
for(i in val)
                {
                    _yuitest_coverline("build/charts-base/charts-base.js", 15351);
if(val.hasOwnProperty(i) && axes.hasOwnProperty(i))
                    {
                        _yuitest_coverline("build/charts-base/charts-base.js", 15353);
this._setBaseAttribute(axes[i], "styles", val[i]);
                    }
                }
            }
        },

        /**
         * Style object for the series
         *
         * @attribute seriesStyles
         * @type Object
         * @private
         */
        seriesStyles: {
            getter: function()
            {
                _yuitest_coverfunc("build/charts-base/charts-base.js", "getter", 15367);
_yuitest_coverline("build/charts-base/charts-base.js", 15369);
var styles = this._seriesStyles,
                    graph = this.get("graph"),
                    dict,
                    i;
                _yuitest_coverline("build/charts-base/charts-base.js", 15373);
if(graph)
                {
                    _yuitest_coverline("build/charts-base/charts-base.js", 15375);
dict = graph.get("seriesDictionary");
                    _yuitest_coverline("build/charts-base/charts-base.js", 15376);
if(dict)
                    {
                        _yuitest_coverline("build/charts-base/charts-base.js", 15378);
styles = {};
                        _yuitest_coverline("build/charts-base/charts-base.js", 15379);
for(i in dict)
                        {
                            _yuitest_coverline("build/charts-base/charts-base.js", 15381);
if(dict.hasOwnProperty(i))
                            {
                                _yuitest_coverline("build/charts-base/charts-base.js", 15383);
styles[i] = dict[i].get("styles");
                            }
                        }
                    }
                }
                _yuitest_coverline("build/charts-base/charts-base.js", 15388);
return styles;
            },

            setter: function(val)
            {
                _yuitest_coverfunc("build/charts-base/charts-base.js", "setter", 15391);
_yuitest_coverline("build/charts-base/charts-base.js", 15393);
var i,
                    l,
                    s;

                _yuitest_coverline("build/charts-base/charts-base.js", 15397);
if(Y_Lang.isArray(val))
                {
                    _yuitest_coverline("build/charts-base/charts-base.js", 15399);
s = this.get("seriesCollection");
                    _yuitest_coverline("build/charts-base/charts-base.js", 15400);
i = 0;
                    _yuitest_coverline("build/charts-base/charts-base.js", 15401);
l = val.length;

                    _yuitest_coverline("build/charts-base/charts-base.js", 15403);
for(; i < l; ++i)
                    {
                        _yuitest_coverline("build/charts-base/charts-base.js", 15405);
this._setBaseAttribute(s[i], "styles", val[i]);
                    }
                }
                else
                {
                    _yuitest_coverline("build/charts-base/charts-base.js", 15410);
for(i in val)
                    {
                        _yuitest_coverline("build/charts-base/charts-base.js", 15412);
if(val.hasOwnProperty(i))
                        {
                            _yuitest_coverline("build/charts-base/charts-base.js", 15414);
s = this.getSeries(i);
                            _yuitest_coverline("build/charts-base/charts-base.js", 15415);
this._setBaseAttribute(s, "styles", val[i]);
                        }
                    }
                }
            }
        },

        /**
         * Styles for the graph.
         *
         * @attribute graphStyles
         * @type Object
         * @private
         */
        graphStyles: {
            getter: function()
            {
                _yuitest_coverfunc("build/charts-base/charts-base.js", "getter", 15430);
_yuitest_coverline("build/charts-base/charts-base.js", 15432);
var graph = this.get("graph");
                _yuitest_coverline("build/charts-base/charts-base.js", 15433);
if(graph)
                {
                    _yuitest_coverline("build/charts-base/charts-base.js", 15435);
return(graph.get("styles"));
                }
                _yuitest_coverline("build/charts-base/charts-base.js", 15437);
return this._graphStyles;
            },

            setter: function(val)
            {
                _yuitest_coverfunc("build/charts-base/charts-base.js", "setter", 15440);
_yuitest_coverline("build/charts-base/charts-base.js", 15442);
var graph = this.get("graph");
                _yuitest_coverline("build/charts-base/charts-base.js", 15443);
this._setBaseAttribute(graph, "styles", val);
            }

        },

        /**
         * Style properties for the chart. Contains a key indexed hash of the following:
         *  <dl>
         *      <dt>series</dt><dd>A key indexed hash containing references to the `styles` attribute for each series in the chart.
         *      Specific style attributes vary depending on the series:
         *      <ul>
         *          <li><a href="AreaSeries.html#attr_styles">AreaSeries</a></li>
         *          <li><a href="BarSeries.html#attr_styles">BarSeries</a></li>
         *          <li><a href="ColumnSeries.html#attr_styles">ColumnSeries</a></li>
         *          <li><a href="ComboSeries.html#attr_styles">ComboSeries</a></li>
         *          <li><a href="LineSeries.html#attr_styles">LineSeries</a></li>
         *          <li><a href="MarkerSeries.html#attr_styles">MarkerSeries</a></li>
         *          <li><a href="SplineSeries.html#attr_styles">SplineSeries</a></li>
         *      </ul>
         *      </dd>
         *      <dt>axes</dt><dd>A key indexed hash containing references to the `styles` attribute for each axes in the chart. Specific
         *      style attributes can be found in the <a href="Axis.html#attr_styles">Axis</a> class.</dd>
         *      <dt>graph</dt><dd>A reference to the `styles` attribute in the chart. Specific style attributes can be found in the
         *      <a href="Graph.html#attr_styles">Graph</a> class.</dd>
         *  </dl>
         *
         * @attribute styles
         * @type Object
         */
        styles: {
            getter: function()
            {
                _yuitest_coverfunc("build/charts-base/charts-base.js", "getter", 15473);
_yuitest_coverline("build/charts-base/charts-base.js", 15475);
var styles = {
                    axes: this.get("axesStyles"),
                    series: this.get("seriesStyles"),
                    graph: this.get("graphStyles")
                };
                _yuitest_coverline("build/charts-base/charts-base.js", 15480);
return styles;
            },
            setter: function(val)
            {
                _yuitest_coverfunc("build/charts-base/charts-base.js", "setter", 15482);
_yuitest_coverline("build/charts-base/charts-base.js", 15484);
if(val.hasOwnProperty("axes"))
                {
                    _yuitest_coverline("build/charts-base/charts-base.js", 15486);
if(this.get("axesStyles"))
                    {
                        _yuitest_coverline("build/charts-base/charts-base.js", 15488);
this.set("axesStyles", val.axes);
                    }
                    else
                    {
                        _yuitest_coverline("build/charts-base/charts-base.js", 15492);
this._axesStyles = val.axes;
                    }
                }
                _yuitest_coverline("build/charts-base/charts-base.js", 15495);
if(val.hasOwnProperty("series"))
                {
                    _yuitest_coverline("build/charts-base/charts-base.js", 15497);
if(this.get("seriesStyles"))
                    {
                        _yuitest_coverline("build/charts-base/charts-base.js", 15499);
this.set("seriesStyles", val.series);
                    }
                    else
                    {
                        _yuitest_coverline("build/charts-base/charts-base.js", 15503);
this._seriesStyles = val.series;
                    }
                }
                _yuitest_coverline("build/charts-base/charts-base.js", 15506);
if(val.hasOwnProperty("graph"))
                {
                    _yuitest_coverline("build/charts-base/charts-base.js", 15508);
this.set("graphStyles", val.graph);
                }
            }
        },

        /**
         * Axes to appear in the chart. This can be a key indexed hash of axis instances or object literals
         * used to construct the appropriate axes.
         *
         * @attribute axes
         * @type Object
         */
        axes: {
            valueFn: "_getDefaultAxes",

            setter: function(val)
            {
                _yuitest_coverfunc("build/charts-base/charts-base.js", "setter", 15523);
_yuitest_coverline("build/charts-base/charts-base.js", 15525);
if(this.get("dataProvider"))
                {
                    _yuitest_coverline("build/charts-base/charts-base.js", 15527);
val = this._setAxes(val);
                }
                _yuitest_coverline("build/charts-base/charts-base.js", 15529);
return val;
            }
        },

        /**
         * Collection of series to appear on the chart. This can be an array of Series instances or object literals
         * used to construct the appropriate series.
         *
         * @attribute seriesCollection
         * @type Array
         */
        seriesCollection: {
            valueFn: "_getDefaultSeriesCollection",

            setter: function(val)
            {
                _yuitest_coverfunc("build/charts-base/charts-base.js", "setter", 15543);
_yuitest_coverline("build/charts-base/charts-base.js", 15545);
if(this.get("dataProvider"))
                {
                    _yuitest_coverline("build/charts-base/charts-base.js", 15547);
val = this._parseSeriesCollection(val);
                }
                _yuitest_coverline("build/charts-base/charts-base.js", 15549);
return val;
            }
        },

        /**
         * Reference to the left-aligned axes for the chart.
         *
         * @attribute leftAxesCollection
         * @type Array
         * @private
         */
        leftAxesCollection: {},

        /**
         * Reference to the bottom-aligned axes for the chart.
         *
         * @attribute bottomAxesCollection
         * @type Array
         * @private
         */
        bottomAxesCollection: {},

        /**
         * Reference to the right-aligned axes for the chart.
         *
         * @attribute rightAxesCollection
         * @type Array
         * @private
         */
        rightAxesCollection: {},

        /**
         * Reference to the top-aligned axes for the chart.
         *
         * @attribute topAxesCollection
         * @type Array
         * @private
         */
        topAxesCollection: {},

        /**
         * Indicates whether or not the chart is stacked.
         *
         * @attribute stacked
         * @type Boolean
         */
        stacked: {
            value: false
        },

        /**
         * Direction of chart's category axis when there is no series collection specified. Charts can
         * be horizontal or vertical. When the chart type is column, the chart is horizontal.
         * When the chart type is bar, the chart is vertical.
         *
         * @attribute direction
         * @type String
         */
        direction: {
            getter: function()
            {
                _yuitest_coverfunc("build/charts-base/charts-base.js", "getter", 15608);
_yuitest_coverline("build/charts-base/charts-base.js", 15610);
var type = this.get("type");
                _yuitest_coverline("build/charts-base/charts-base.js", 15611);
if(type == "bar")
                {
                    _yuitest_coverline("build/charts-base/charts-base.js", 15613);
return "vertical";
                }
                else {_yuitest_coverline("build/charts-base/charts-base.js", 15615);
if(type == "column")
                {
                    _yuitest_coverline("build/charts-base/charts-base.js", 15617);
return "horizontal";
                }}
                _yuitest_coverline("build/charts-base/charts-base.js", 15619);
return this._direction;
            },

            setter: function(val)
            {
                _yuitest_coverfunc("build/charts-base/charts-base.js", "setter", 15622);
_yuitest_coverline("build/charts-base/charts-base.js", 15624);
this._direction = val;
                _yuitest_coverline("build/charts-base/charts-base.js", 15625);
return this._direction;
            }
        },

        /**
         * Indicates whether or not an area is filled in a combo chart.
         *
         * @attribute showAreaFill
         * @type Boolean
         */
        showAreaFill: {},

        /**
         * Indicates whether to display markers in a combo chart.
         *
         * @attribute showMarkers
         * @type Boolean
         */
        showMarkers:{},

        /**
         * Indicates whether to display lines in a combo chart.
         *
         * @attribute showLines
         * @type Boolean
         */
        showLines:{},

        /**
         * Indicates the key value used to identify a category axis in the `axes` hash. If
         * not specified, the categoryKey attribute value will be used.
         *
         * @attribute categoryAxisName
         * @type String
         */
        categoryAxisName: {
        },

        /**
         * Indicates the key value used to identify a the series axis when an axis not generated.
         *
         * @attribute valueAxisName
         * @type String
         */
        valueAxisName: {
            value: "values"
        },

        /**
         * Reference to the horizontalGridlines for the chart.
         *
         * @attribute horizontalGridlines
         * @type Gridlines
         */
        horizontalGridlines: {
            getter: function()
            {
                _yuitest_coverfunc("build/charts-base/charts-base.js", "getter", 15680);
_yuitest_coverline("build/charts-base/charts-base.js", 15682);
var graph = this.get("graph");
                _yuitest_coverline("build/charts-base/charts-base.js", 15683);
if(graph)
                {
                    _yuitest_coverline("build/charts-base/charts-base.js", 15685);
return graph.get("horizontalGridlines");
                }
                _yuitest_coverline("build/charts-base/charts-base.js", 15687);
return this._horizontalGridlines;
            },
            setter: function(val)
            {
                _yuitest_coverfunc("build/charts-base/charts-base.js", "setter", 15689);
_yuitest_coverline("build/charts-base/charts-base.js", 15691);
var graph = this.get("graph");
                _yuitest_coverline("build/charts-base/charts-base.js", 15692);
if(val && !Y_Lang.isObject(val))
                {
                    _yuitest_coverline("build/charts-base/charts-base.js", 15694);
val = {};
                }
                _yuitest_coverline("build/charts-base/charts-base.js", 15696);
if(graph)
                {
                    _yuitest_coverline("build/charts-base/charts-base.js", 15698);
graph.set("horizontalGridlines", val);
                }
                else
                {
                    _yuitest_coverline("build/charts-base/charts-base.js", 15702);
this._horizontalGridlines = val;
                }
            }
        },

        /**
         * Reference to the verticalGridlines for the chart.
         *
         * @attribute verticalGridlines
         * @type Gridlines
         */
        verticalGridlines: {
            getter: function()
            {
                _yuitest_coverfunc("build/charts-base/charts-base.js", "getter", 15714);
_yuitest_coverline("build/charts-base/charts-base.js", 15716);
var graph = this.get("graph");
                _yuitest_coverline("build/charts-base/charts-base.js", 15717);
if(graph)
                {
                    _yuitest_coverline("build/charts-base/charts-base.js", 15719);
return graph.get("verticalGridlines");
                }
                _yuitest_coverline("build/charts-base/charts-base.js", 15721);
return this._verticalGridlines;
            },
            setter: function(val)
            {
                _yuitest_coverfunc("build/charts-base/charts-base.js", "setter", 15723);
_yuitest_coverline("build/charts-base/charts-base.js", 15725);
var graph = this.get("graph");
                _yuitest_coverline("build/charts-base/charts-base.js", 15726);
if(val && !Y_Lang.isObject(val))
                {
                    _yuitest_coverline("build/charts-base/charts-base.js", 15728);
val = {};
                }
                _yuitest_coverline("build/charts-base/charts-base.js", 15730);
if(graph)
                {
                    _yuitest_coverline("build/charts-base/charts-base.js", 15732);
graph.set("verticalGridlines", val);
                }
                else
                {
                    _yuitest_coverline("build/charts-base/charts-base.js", 15736);
this._verticalGridlines = val;
                }
            }
        },

        /**
         * Type of chart when there is no series collection specified.
         *
         * @attribute type
         * @type String
         */
        type: {
            getter: function()
            {
                _yuitest_coverfunc("build/charts-base/charts-base.js", "getter", 15748);
_yuitest_coverline("build/charts-base/charts-base.js", 15750);
if(this.get("stacked"))
                {
                    _yuitest_coverline("build/charts-base/charts-base.js", 15752);
return "stacked" + this._type;
                }
                _yuitest_coverline("build/charts-base/charts-base.js", 15754);
return this._type;
            },

            setter: function(val)
            {
                _yuitest_coverfunc("build/charts-base/charts-base.js", "setter", 15757);
_yuitest_coverline("build/charts-base/charts-base.js", 15759);
if(this._type == "bar")
                {
                    _yuitest_coverline("build/charts-base/charts-base.js", 15761);
if(val != "bar")
                    {
                        _yuitest_coverline("build/charts-base/charts-base.js", 15763);
this.set("direction", "horizontal");
                    }
                }
                else
                {
                    _yuitest_coverline("build/charts-base/charts-base.js", 15768);
if(val == "bar")
                    {
                        _yuitest_coverline("build/charts-base/charts-base.js", 15770);
this.set("direction", "vertical");
                    }
                }
                _yuitest_coverline("build/charts-base/charts-base.js", 15773);
this._type = val;
                _yuitest_coverline("build/charts-base/charts-base.js", 15774);
return this._type;
            }
        },

        /**
         * Reference to the category axis used by the chart.
         *
         * @attribute categoryAxis
         * @type Axis
         */
        categoryAxis:{}
    }
});
/**
 * The PieChart class creates a pie chart
 *
 * @module charts
 * @submodule charts-base
 * @class PieChart
 * @extends ChartBase
 * @constructor
 */
_yuitest_coverline("build/charts-base/charts-base.js", 15796);
Y.PieChart = Y.Base.create("pieChart", Y.Widget, [Y.ChartBase], {
    /**
     * Calculates and returns a `seriesCollection`.
     *
     * @method _getSeriesCollection
     * @return Array
     * @private
     */
    _getSeriesCollection: function()
    {
        _yuitest_coverfunc("build/charts-base/charts-base.js", "_getSeriesCollection", 15804);
_yuitest_coverline("build/charts-base/charts-base.js", 15806);
if(this._seriesCollection)
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 15808);
return this._seriesCollection;
        }
        _yuitest_coverline("build/charts-base/charts-base.js", 15810);
var axes = this.get("axes"),
            sc = [],
            seriesKeys,
            i = 0,
            l,
            type = this.get("type"),
            key,
            catAxis = "categoryAxis",
            catKey = "categoryKey",
            valAxis = "valueAxis",
            seriesKey = "valueKey";
        _yuitest_coverline("build/charts-base/charts-base.js", 15821);
if(axes)
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 15823);
seriesKeys = axes.values.get("keyCollection");
            _yuitest_coverline("build/charts-base/charts-base.js", 15824);
key = axes.category.get("keyCollection")[0];
            _yuitest_coverline("build/charts-base/charts-base.js", 15825);
l = seriesKeys.length;
            _yuitest_coverline("build/charts-base/charts-base.js", 15826);
for(; i < l; ++i)
            {
                _yuitest_coverline("build/charts-base/charts-base.js", 15828);
sc[i] = {type:type};
                _yuitest_coverline("build/charts-base/charts-base.js", 15829);
sc[i][catAxis] = "category";
                _yuitest_coverline("build/charts-base/charts-base.js", 15830);
sc[i][valAxis] = "values";
                _yuitest_coverline("build/charts-base/charts-base.js", 15831);
sc[i][catKey] = key;
                _yuitest_coverline("build/charts-base/charts-base.js", 15832);
sc[i][seriesKey] = seriesKeys[i];
            }
        }
        _yuitest_coverline("build/charts-base/charts-base.js", 15835);
this._seriesCollection = sc;
        _yuitest_coverline("build/charts-base/charts-base.js", 15836);
return sc;
    },

    /**
     * Creates `Axis` instances.
     *
     * @method _parseAxes
     * @param {Object} val Object containing `Axis` instances or objects in which to construct `Axis` instances.
     * @return Object
     * @private
     */
    _parseAxes: function(hash)
    {
        _yuitest_coverfunc("build/charts-base/charts-base.js", "_parseAxes", 15847);
_yuitest_coverline("build/charts-base/charts-base.js", 15849);
if(!this._axes)
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 15851);
this._axes = {};
        }
        _yuitest_coverline("build/charts-base/charts-base.js", 15853);
var i, pos, axis, dh, config, axisClass,
            type = this.get("type"),
            w = this.get("width"),
            h = this.get("height"),
            node = Y.Node.one(this._parentNode);
        _yuitest_coverline("build/charts-base/charts-base.js", 15858);
if(!w)
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 15860);
this.set("width", node.get("offsetWidth"));
            _yuitest_coverline("build/charts-base/charts-base.js", 15861);
w = this.get("width");
        }
        _yuitest_coverline("build/charts-base/charts-base.js", 15863);
if(!h)
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 15865);
this.set("height", node.get("offsetHeight"));
            _yuitest_coverline("build/charts-base/charts-base.js", 15866);
h = this.get("height");
        }
        _yuitest_coverline("build/charts-base/charts-base.js", 15868);
for(i in hash)
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 15870);
if(hash.hasOwnProperty(i))
            {
                _yuitest_coverline("build/charts-base/charts-base.js", 15872);
dh = hash[i];
                _yuitest_coverline("build/charts-base/charts-base.js", 15873);
pos = type == "pie" ? "none" : dh.position;
                _yuitest_coverline("build/charts-base/charts-base.js", 15874);
axisClass = this._getAxisClass(dh.type);
                _yuitest_coverline("build/charts-base/charts-base.js", 15875);
config = {dataProvider:this.get("dataProvider")};
                _yuitest_coverline("build/charts-base/charts-base.js", 15876);
if(dh.hasOwnProperty("roundingUnit"))
                {
                    _yuitest_coverline("build/charts-base/charts-base.js", 15878);
config.roundingUnit = dh.roundingUnit;
                }
                _yuitest_coverline("build/charts-base/charts-base.js", 15880);
config.keys = dh.keys;
                _yuitest_coverline("build/charts-base/charts-base.js", 15881);
config.width = w;
                _yuitest_coverline("build/charts-base/charts-base.js", 15882);
config.height = h;
                _yuitest_coverline("build/charts-base/charts-base.js", 15883);
config.position = pos;
                _yuitest_coverline("build/charts-base/charts-base.js", 15884);
config.styles = dh.styles;
                _yuitest_coverline("build/charts-base/charts-base.js", 15885);
axis = new axisClass(config);
                _yuitest_coverline("build/charts-base/charts-base.js", 15886);
axis.on("axisRendered", Y.bind(this._itemRendered, this));
                _yuitest_coverline("build/charts-base/charts-base.js", 15887);
this._axes[i] = axis;
            }
        }
    },

    /**
     * Adds axes to the chart.
     *
     * @method _addAxes
     * @private
     */
    _addAxes: function()
    {
        _yuitest_coverfunc("build/charts-base/charts-base.js", "_addAxes", 15898);
_yuitest_coverline("build/charts-base/charts-base.js", 15900);
var axes = this.get("axes"),
            i,
            axis,
            p;
        _yuitest_coverline("build/charts-base/charts-base.js", 15904);
if(!axes)
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 15906);
this.set("axes", this._getDefaultAxes());
            _yuitest_coverline("build/charts-base/charts-base.js", 15907);
axes = this.get("axes");
        }
        _yuitest_coverline("build/charts-base/charts-base.js", 15909);
if(!this._axesCollection)
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 15911);
this._axesCollection = [];
        }
        _yuitest_coverline("build/charts-base/charts-base.js", 15913);
for(i in axes)
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 15915);
if(axes.hasOwnProperty(i))
            {
                _yuitest_coverline("build/charts-base/charts-base.js", 15917);
axis = axes[i];
                _yuitest_coverline("build/charts-base/charts-base.js", 15918);
p = axis.get("position");
                _yuitest_coverline("build/charts-base/charts-base.js", 15919);
if(!this.get(p + "AxesCollection"))
                {
                    _yuitest_coverline("build/charts-base/charts-base.js", 15921);
this.set(p + "AxesCollection", [axis]);
                }
                else
                {
                    _yuitest_coverline("build/charts-base/charts-base.js", 15925);
this.get(p + "AxesCollection").push(axis);
                }
                _yuitest_coverline("build/charts-base/charts-base.js", 15927);
this._axesCollection.push(axis);
            }
        }
    },

    /**
     * Renders the Graph.
     *
     * @method _addSeries
     * @private
     */
    _addSeries: function()
    {
        _yuitest_coverfunc("build/charts-base/charts-base.js", "_addSeries", 15938);
_yuitest_coverline("build/charts-base/charts-base.js", 15940);
var graph = this.get("graph"),
            seriesCollection = this.get("seriesCollection");
        _yuitest_coverline("build/charts-base/charts-base.js", 15942);
this._parseSeriesAxes(seriesCollection);
        _yuitest_coverline("build/charts-base/charts-base.js", 15943);
graph.set("showBackground", false);
        _yuitest_coverline("build/charts-base/charts-base.js", 15944);
graph.set("width", this.get("width"));
        _yuitest_coverline("build/charts-base/charts-base.js", 15945);
graph.set("height", this.get("height"));
        _yuitest_coverline("build/charts-base/charts-base.js", 15946);
graph.set("seriesCollection", seriesCollection);
        _yuitest_coverline("build/charts-base/charts-base.js", 15947);
this._seriesCollection = graph.get("seriesCollection");
        _yuitest_coverline("build/charts-base/charts-base.js", 15948);
graph.render(this.get("contentBox"));
    },

    /**
     * Parse and sets the axes for the chart.
     *
     * @method _parseSeriesAxes
     * @param {Array} c A collection `PieSeries` instance.
     * @private
     */
    _parseSeriesAxes: function(c)
    {
        _yuitest_coverfunc("build/charts-base/charts-base.js", "_parseSeriesAxes", 15958);
_yuitest_coverline("build/charts-base/charts-base.js", 15960);
var i = 0,
            len = c.length,
            s,
            axes = this.get("axes"),
            axis;
        _yuitest_coverline("build/charts-base/charts-base.js", 15965);
for(; i < len; ++i)
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 15967);
s = c[i];
            _yuitest_coverline("build/charts-base/charts-base.js", 15968);
if(s)
            {
                //If series is an actual series instance,
                //replace axes attribute string ids with axes
                _yuitest_coverline("build/charts-base/charts-base.js", 15972);
if(s instanceof Y.PieSeries)
                {
                    _yuitest_coverline("build/charts-base/charts-base.js", 15974);
axis = s.get("categoryAxis");
                    _yuitest_coverline("build/charts-base/charts-base.js", 15975);
if(axis && !(axis instanceof Y.Axis))
                    {
                        _yuitest_coverline("build/charts-base/charts-base.js", 15977);
s.set("categoryAxis", axes[axis]);
                    }
                    _yuitest_coverline("build/charts-base/charts-base.js", 15979);
axis = s.get("valueAxis");
                    _yuitest_coverline("build/charts-base/charts-base.js", 15980);
if(axis && !(axis instanceof Y.Axis))
                    {
                        _yuitest_coverline("build/charts-base/charts-base.js", 15982);
s.set("valueAxis", axes[axis]);
                    }
                    _yuitest_coverline("build/charts-base/charts-base.js", 15984);
continue;
                }
                _yuitest_coverline("build/charts-base/charts-base.js", 15986);
s.categoryAxis = axes.category;
                _yuitest_coverline("build/charts-base/charts-base.js", 15987);
s.valueAxis = axes.values;
                _yuitest_coverline("build/charts-base/charts-base.js", 15988);
if(!s.type)
                {
                    _yuitest_coverline("build/charts-base/charts-base.js", 15990);
s.type = this.get("type");
                }
            }
        }
    },

    /**
     * Generates and returns a key-indexed object containing `Axis` instances or objects used to create `Axis` instances.
     *
     * @method _getDefaultAxes
     * @return Object
     * @private
     */
    _getDefaultAxes: function()
    {
        _yuitest_coverfunc("build/charts-base/charts-base.js", "_getDefaultAxes", 16003);
_yuitest_coverline("build/charts-base/charts-base.js", 16005);
var catKey = this.get("categoryKey"),
            seriesKeys = this.get("seriesKeys").concat(),
            seriesAxis = "numeric";
        _yuitest_coverline("build/charts-base/charts-base.js", 16008);
return {
            values:{
                keys:seriesKeys,
                type:seriesAxis
            },
            category:{
                keys:[catKey],
                type:this.get("categoryType")
            }
        };
    },

    /**
     * Returns an object literal containing a categoryItem and a valueItem for a given series index.
     *
     * @method getSeriesItem
     * @param series Reference to a series.
     * @param index Index of the specified item within a series.
     * @return Object
     */
    getSeriesItems: function(series, index)
    {
        _yuitest_coverfunc("build/charts-base/charts-base.js", "getSeriesItems", 16028);
_yuitest_coverline("build/charts-base/charts-base.js", 16030);
var categoryItem = {
                axis: series.get("categoryAxis"),
                key: series.get("categoryKey"),
                displayName: series.get("categoryDisplayName")
            },
            valueItem = {
                axis: series.get("valueAxis"),
                key: series.get("valueKey"),
                displayName: series.get("valueDisplayName")
            };
        _yuitest_coverline("build/charts-base/charts-base.js", 16040);
categoryItem.value = categoryItem.axis.getKeyValueAt(categoryItem.key, index);
        _yuitest_coverline("build/charts-base/charts-base.js", 16041);
valueItem.value = valueItem.axis.getKeyValueAt(valueItem.key, index);
        _yuitest_coverline("build/charts-base/charts-base.js", 16042);
return {category:categoryItem, value:valueItem};
    },

    /**
     * Handler for sizeChanged event.
     *
     * @method _sizeChanged
     * @param {Object} e Event object.
     * @private
     */
    _sizeChanged: function(e)
    {
        _yuitest_coverfunc("build/charts-base/charts-base.js", "_sizeChanged", 16052);
_yuitest_coverline("build/charts-base/charts-base.js", 16054);
this._redraw();
    },

    /**
     * Redraws the chart instance.
     *
     * @method _redraw
     * @private
     */
    _redraw: function()
    {
        _yuitest_coverfunc("build/charts-base/charts-base.js", "_redraw", 16063);
_yuitest_coverline("build/charts-base/charts-base.js", 16065);
var graph = this.get("graph"),
            w = this.get("width"),
            h = this.get("height"),
            dimension;
        _yuitest_coverline("build/charts-base/charts-base.js", 16069);
if(graph)
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 16071);
dimension = Math.min(w, h);
            _yuitest_coverline("build/charts-base/charts-base.js", 16072);
graph.set("width", dimension);
            _yuitest_coverline("build/charts-base/charts-base.js", 16073);
graph.set("height", dimension);
        }
    },

    /**
     * Formats tooltip text for a pie chart.
     *
     * @method _tooltipLabelFunction
     * @param {Object} categoryItem An object containing the following:
     *  <dl>
     *      <dt>axis</dt><dd>The axis to which the category is bound.</dd>
     *      <dt>displayName</dt><dd>The display name set to the category (defaults to key if not provided)</dd>
     *      <dt>key</dt><dd>The key of the category.</dd>
     *      <dt>value</dt><dd>The value of the category</dd>
     *  </dl>
     * @param {Object} valueItem An object containing the following:
     *  <dl>
     *      <dt>axis</dt><dd>The axis to which the item's series is bound.</dd>
     *      <dt>displayName</dt><dd>The display name of the series. (defaults to key if not provided)</dd>
     *      <dt>key</dt><dd>The key for the series.</dd>
     *      <dt>value</dt><dd>The value for the series item.</dd>
     *  </dl>
     * @param {Number} itemIndex The index of the item within the series.
     * @param {CartesianSeries} series The `PieSeries` instance of the item.
     * @param {Number} seriesIndex The index of the series in the `seriesCollection`.
     * @return {HTML}
     * @private
     */
    _tooltipLabelFunction: function(categoryItem, valueItem, itemIndex, series, seriesIndex)
    {
        _yuitest_coverfunc("build/charts-base/charts-base.js", "_tooltipLabelFunction", 16101);
_yuitest_coverline("build/charts-base/charts-base.js", 16103);
var msg = DOCUMENT.createElement("div"),
            total = series.getTotalValues(),
            pct = Math.round((valueItem.value / total) * 10000)/100;
        _yuitest_coverline("build/charts-base/charts-base.js", 16106);
msg.appendChild(DOCUMENT.createTextNode(categoryItem.displayName +
        ": " + categoryItem.axis.get("labelFunction").apply(this, [categoryItem.value, categoryItem.axis.get("labelFormat")])));
        _yuitest_coverline("build/charts-base/charts-base.js", 16108);
msg.appendChild(DOCUMENT.createElement("br"));
        _yuitest_coverline("build/charts-base/charts-base.js", 16109);
msg.appendChild(DOCUMENT.createTextNode(valueItem.displayName +
        ": " + valueItem.axis.get("labelFunction").apply(this, [valueItem.value, valueItem.axis.get("labelFormat")])));
        _yuitest_coverline("build/charts-base/charts-base.js", 16111);
msg.appendChild(DOCUMENT.createElement("br"));
        _yuitest_coverline("build/charts-base/charts-base.js", 16112);
msg.appendChild(DOCUMENT.createTextNode(pct + "%"));
        _yuitest_coverline("build/charts-base/charts-base.js", 16113);
return msg;
    },

    /**
     * Returns the appropriate message based on the key press.
     *
     * @method _getAriaMessage
     * @param {Number} key The keycode that was pressed.
     * @return String
     */
    _getAriaMessage: function(key)
    {
        _yuitest_coverfunc("build/charts-base/charts-base.js", "_getAriaMessage", 16123);
_yuitest_coverline("build/charts-base/charts-base.js", 16125);
var msg = "",
            categoryItem,
            items,
            series,
            valueItem,
            seriesIndex = 0,
            itemIndex = this._itemIndex,
            seriesCollection = this.get("seriesCollection"),
            len,
            total,
            pct,
            markers;
        _yuitest_coverline("build/charts-base/charts-base.js", 16137);
series = this.getSeries(parseInt(seriesIndex, 10));
        _yuitest_coverline("build/charts-base/charts-base.js", 16138);
markers = series.get("markers");
        _yuitest_coverline("build/charts-base/charts-base.js", 16139);
len = markers && markers.length ? markers.length : 0;
        _yuitest_coverline("build/charts-base/charts-base.js", 16140);
if(key === 37)
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 16142);
itemIndex = itemIndex > 0 ? itemIndex - 1 : len - 1;
        }
        else {_yuitest_coverline("build/charts-base/charts-base.js", 16144);
if(key === 39)
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 16146);
itemIndex = itemIndex >= len - 1 ? 0 : itemIndex + 1;
        }}
        _yuitest_coverline("build/charts-base/charts-base.js", 16148);
this._itemIndex = itemIndex;
        _yuitest_coverline("build/charts-base/charts-base.js", 16149);
items = this.getSeriesItems(series, itemIndex);
        _yuitest_coverline("build/charts-base/charts-base.js", 16150);
categoryItem = items.category;
        _yuitest_coverline("build/charts-base/charts-base.js", 16151);
valueItem = items.value;
        _yuitest_coverline("build/charts-base/charts-base.js", 16152);
total = series.getTotalValues();
        _yuitest_coverline("build/charts-base/charts-base.js", 16153);
pct = Math.round((valueItem.value / total) * 10000)/100;
        _yuitest_coverline("build/charts-base/charts-base.js", 16154);
if(categoryItem && valueItem)
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 16156);
msg += categoryItem.displayName + ": " + categoryItem.axis.formatLabel.apply(this, [categoryItem.value, categoryItem.axis.get("labelFormat")]) + ", ";
            _yuitest_coverline("build/charts-base/charts-base.js", 16157);
msg += valueItem.displayName + ": " + valueItem.axis.formatLabel.apply(this, [valueItem.value, valueItem.axis.get("labelFormat")]) + ", ";
            _yuitest_coverline("build/charts-base/charts-base.js", 16158);
msg += "Percent of total " + valueItem.displayName + ": " + pct + "%,";
        }
        else
        {
            _yuitest_coverline("build/charts-base/charts-base.js", 16162);
msg += "No data available,";
        }
        _yuitest_coverline("build/charts-base/charts-base.js", 16164);
msg += (itemIndex + 1) + " of " + len + ". ";
        _yuitest_coverline("build/charts-base/charts-base.js", 16165);
return msg;
    }
}, {
    ATTRS: {
        /**
         * Sets the aria description for the chart.
         *
         * @attribute ariaDescription
         * @type String
         */
        ariaDescription: {
            value: "Use the left and right keys to navigate through items.",

            setter: function(val)
            {
                _yuitest_coverfunc("build/charts-base/charts-base.js", "setter", 16178);
_yuitest_coverline("build/charts-base/charts-base.js", 16180);
if(this._description)
                {
                    _yuitest_coverline("build/charts-base/charts-base.js", 16182);
this._description.setContent("");
                    _yuitest_coverline("build/charts-base/charts-base.js", 16183);
this._description.appendChild(DOCUMENT.createTextNode(val));
                }
                _yuitest_coverline("build/charts-base/charts-base.js", 16185);
return val;
            }
        },

        /**
         * Axes to appear in the chart.
         *
         * @attribute axes
         * @type Object
         */
        axes: {
            getter: function()
            {
                _yuitest_coverfunc("build/charts-base/charts-base.js", "getter", 16196);
_yuitest_coverline("build/charts-base/charts-base.js", 16198);
return this._axes;
            },

            setter: function(val)
            {
                _yuitest_coverfunc("build/charts-base/charts-base.js", "setter", 16201);
_yuitest_coverline("build/charts-base/charts-base.js", 16203);
this._parseAxes(val);
            }
        },

        /**
         * Collection of series to appear on the chart. This can be an array of Series instances or object literals
         * used to describe a Series instance.
         *
         * @attribute seriesCollection
         * @type Array
         */
        seriesCollection: {
            getter: function()
            {
                _yuitest_coverfunc("build/charts-base/charts-base.js", "getter", 16215);
_yuitest_coverline("build/charts-base/charts-base.js", 16217);
return this._getSeriesCollection();
            },

            setter: function(val)
            {
                _yuitest_coverfunc("build/charts-base/charts-base.js", "setter", 16220);
_yuitest_coverline("build/charts-base/charts-base.js", 16222);
return this._setSeriesCollection(val);
            }
        },

        /**
         * Type of chart when there is no series collection specified.
         *
         * @attribute type
         * @type String
         */
        type: {
            value: "pie"
        }
    }
});


}, '@VERSION@', {"requires": ["dom", "datatype-number", "datatype-date", "event-custom", "event-mouseenter", "event-touch", "widget", "widget-position", "widget-stack", "graphics"]});
