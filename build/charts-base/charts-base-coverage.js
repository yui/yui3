if (typeof _yuitest_coverage == "undefined"){
    _yuitest_coverage = {};
    _yuitest_coverline = function(src, line){
        var coverage = _yuitest_coverage[src];
        if (!coverage.lines[line]){
            coverage.calledLines++;
        }
        coverage.lines[line]++;
    };
    _yuitest_coverfunc = function(src, name, line){
        var coverage = _yuitest_coverage[src],
            funcId = name + ":" + line;
        if (!coverage.functions[funcId]){
            coverage.calledFunctions++;
        }
        coverage.functions[funcId]++;
    };
}
_yuitest_coverage["/build/charts-base/charts-base.js"] = {
    lines: {},
    functions: {},
    coveredLines: 0,
    calledLines: 0,
    coveredFunctions: 0,
    calledFunctions: 0,
    path: "/build/charts-base/charts-base.js",
    code: []
};
_yuitest_coverage["/build/charts-base/charts-base.js"].code=["YUI.add('charts-base', function(Y) {","","/**"," * The Charts widget provides an api for displaying data"," * graphically."," *"," * @module charts"," * @main charts"," */","","/**"," * The charts-base submodule contains the core functionality for the charts module."," *"," * @module charts"," * @submodule charts-base"," */","var CONFIG = Y.config,","    WINDOW = CONFIG.win,","    DOCUMENT = CONFIG.doc,","    Y_Lang = Y.Lang,","    IS_STRING = Y_Lang.isString,","    LeftAxisLayout,","    RightAxisLayout,","    BottomAxisLayout,","    TopAxisLayout,","    _getClassName = Y.ClassNameManager.getClassName,","    SERIES_MARKER = _getClassName(\"seriesmarker\"),","    ShapeGroup,","    CircleGroup,","    RectGroup,","    EllipseGroup,","    DiamondGroup;","","/**"," * Abstract class for creating groups of shapes with the same styles and dimensions."," *"," * @class ShapeGroup"," * @constructor"," */"," ShapeGroup = function(cfg)"," {","    ShapeGroup.superclass.constructor.apply(this, arguments);"," };","    "," ShapeGroup.NAME = \"shapeGroup\";",""," Y.extend(ShapeGroup, Y.Path, {    ","    /**","     * Updates the shape.","     *","     * @method _draw","     * @private","     */","    _draw: function()","    {","        var xvalues = this.get(\"xvalues\"),","            yvalues = this.get(\"yvalues\"),","            x,","            y,","            xRad,","            yRad,","            i = 0,","            len,","            attrs = [],","            dimensions = this.get(\"dimensions\"),","            width = dimensions.width,","            height = dimensions.height,","            radius = dimensions.radius,","            yRadius = dimensions.yRadius,","            id = this.get(\"id\"),","            className = this.node.className,","            widthIsArray = Y_Lang.isArray(width),","            heightIsArray = Y_Lang.isArray(height),","            radiusIsArray = Y_Lang.isArray(radius),","            yRadiusIsArray = Y_Lang.isArray(yRadius);","        if(xvalues && yvalues && xvalues.length > 0)","        {","            this.clear();","","            len = xvalues.length;","            for(; i < len; ++i)","            {","                x = xvalues[i];","                y = yvalues[i];","                xRad = radiusIsArray ? radius[i] : radius;","                yRad = yRadiusIsArray ? yRadius[i] : yRadius;","                if(!isNaN(x) && !isNaN(y) && !isNaN(xRad))","                {","                    this.drawShape({","                        x: x,","                        y: y,","                        width: widthIsArray ? width[i] : width,","                        height: heightIsArray ? height[i] : height,","                        radius: xRad,","                        yRadius: yRad ","                    });","                    this.closePath();","                    attrs[i] = {","                        id: id + \"_\" + i,","                        className: className,","                        coords: (x - this._left) + \", \" + (y - this._top)  + \", \" + radius,","                        shape: \"circle\"","                    };","                }","            }","            this._closePath();","        }","    },","","    /**","     * Parses and array of lengths into radii","     *","     * @method _getRadiusCollection","     * @param {Array} val Array of lengths","     * @return Array","     * @private","     */","    _getRadiusCollection: function(val)","    {","        var i = 0,","            len = val.length,","            radii = [];","        for(; i < len; ++i)","        {   ","            radii[i] = val[i] * 0.5;","        }","        return radii;","    }"," });","    ","ShapeGroup.ATTRS = Y.merge(Y.Path.ATTRS, {","    dimensions: {","        getter: function()","        {","            var dimensions = this._dimensions,","                radius,","                yRadius,","                width,","                height;","            if(dimensions.hasOwnProperty(\"radius\"))","            {","                return dimensions;","            }","            else","            {","                width = dimensions.width;","                height = dimensions.height;","                radius = Y_Lang.isArray(width) ? this._getRadiusCollection(width) : (width * 0.5);","                yRadius = Y_Lang.isArray(height) ? this._getRadiusCollection(height) : (height * 0.5);","                return {","                    width: width,","                    height: height,","                    radius: radius,","                    yRadius: yRadius","                };","            }","        },","","        setter: function(val)","        {","            this._dimensions = val;","            return val;","        }","    },","    xvalues: {","        getter: function()","        {","            return this._xvalues;","        },","        setter: function(val)","        {","            this._xvalues = val;","        }","    },","    yvalues: {","        getter: function()","        {","            return this._yvalues;","        },","        setter: function(val)","        {","            this._yvalues = val;","        }","    }","});","Y.ShapeGroup = ShapeGroup;","/**"," * Abstract class for creating groups of circles with the same styles and dimensions."," *"," * @module charts"," * @submodule charts-base"," * @class CircleGroup"," * @constructor"," */"," CircleGroup = function(cfg)"," {","    CircleGroup.superclass.constructor.apply(this, arguments);"," };","    "," CircleGroup.NAME = \"circleGroup\";",""," Y.extend(CircleGroup, Y.ShapeGroup, {    ","    /**","     * Algorithm for drawing shape.","     *","     * @method drawShape","     * @param {Object} cfg Parameters used to draw the shape.","     */","    drawShape: function(cfg)","    {","        this.drawCircle(cfg.x, cfg.y, cfg.radius);","    }"," });","","CircleGroup.ATTRS = Y.merge(Y.ShapeGroup.ATTRS, {","    dimensions: {","        getter: function()","        {","            var dimensions = this._dimensions,","                radius,","                yRadius,","                width,","                height;","            if(dimensions.hasOwnProperty(\"radius\"))","            {","                return dimensions;","            }","            else","            {","                width = dimensions.width;","                height = dimensions.height;","                radius = Y_Lang.isArray(width) ? this._getRadiusCollection(width) : (width * 0.5);","                yRadius = radius;","                return {","                    width: width,","                    height: height,","                    radius: radius,","                    yRadius: yRadius","                };","            }","        }","    }","});","    ","CircleGroup.ATTRS = Y.ShapeGroup.ATTRS;","Y.CircleGroup = CircleGroup;","/**"," * Abstract class for creating groups of rects with the same styles and dimensions."," *"," * @module charts"," * @submodule charts-base"," * @class GroupRect"," * @constructor"," */"," RectGroup = function(cfg)"," {","    RectGroup.superclass.constructor.apply(this, arguments);"," };","    "," RectGroup.NAME = \"rectGroup\";",""," Y.extend(RectGroup, Y.ShapeGroup, {    ","    /**","     * Updates the rect.","     *","     * @method _draw","     * @private","     */","    drawShape: function(cfg)","    {","        this.drawRect(cfg.x, cfg.y, cfg.width, cfg.height);","    }"," });","    ","RectGroup.ATTRS = Y.ShapeGroup.ATTRS;","Y.RectGroup = RectGroup;","/**"," * Abstract class for creating groups of diamonds with the same styles and dimensions."," *"," * @module charts"," * @submodule charts-base"," * @class GroupDiamond"," * @constructor"," */"," DiamondGroup = function(cfg)"," {","    DiamondGroup.superclass.constructor.apply(this, arguments);"," };","    "," DiamondGroup.NAME = \"diamondGroup\";",""," Y.extend(DiamondGroup, Y.ShapeGroup, {    ","    /**","     * Updates the diamond.","     *","     * @method _draw","     * @private","     */","    drawShape: function(cfg)","    {","        this.drawDiamond(cfg.x, cfg.y, cfg.width, cfg.height);","    }"," });","    ","DiamondGroup.ATTRS = Y.ShapeGroup.ATTRS;","Y.DiamondGroup = DiamondGroup;","/**"," * Abstract class for creating groups of diamonds with the same styles and dimensions."," *"," * @module charts"," * @submodule charts-base"," * @class EllipseGroup"," * @constructor"," */"," EllipseGroup = function(cfg)"," {","    EllipseGroup.superclass.constructor.apply(this, arguments);"," };","    "," EllipseGroup.NAME = \"diamondGroup\";",""," Y.extend(EllipseGroup, Y.ShapeGroup, {    ","    /**","     * Updates the diamond.","     *","     * @method _draw","     * @private","     */","    drawShape: function(cfg)","    {","        this.drawEllipse(cfg.x, cfg.y, cfg.width, cfg.height);","    }"," });","    ","EllipseGroup.ATTRS = Y.ShapeGroup.ATTRS;","Y.EllipseGroup = EllipseGroup;","/**"," * The Renderer class is a base class for chart components that use the `styles`"," * attribute."," *"," * @module charts"," * @submodule charts-base"," * @class Renderer"," * @constructor"," */","function Renderer(){}","","Renderer.ATTRS = {","        /**","         * Style properties for class","         * ","         * @attribute styles","         * @type Object","         */","        styles:","        {","            getter: function()","            {","                this._styles = this._styles || this._getDefaultStyles();","                return this._styles;","            },","","            setter: function(val)","            {","                this._styles = this._setStyles(val);","            }","        },","        ","        /**","         * The graphic in which drawings will be rendered.","         *","         * @attribute graphic","         * @type Graphic","         */","        graphic: {}","};","Renderer.NAME = \"renderer\";","","Renderer.prototype = {","    /**","     * Storage for `styles` attribute.","     *","     * @property _styles","     * @type Object","     * @private","     */","	_styles: null,","	","    /**","     * Method used by `styles` setter.","     *","     * @method _setStyles","     * @param {Object} newStyles Hash of properties to update.","     * @return Object","     * @protected","     */","	_setStyles: function(newstyles)","	{","		var styles = this.get(\"styles\");","        return this._mergeStyles(newstyles, styles);","	},","    ","    /**","     * Merges to object literals so that only specified properties are ","     * overwritten.","     *","     * @method _mergeStyles","     * @param {Object} a Hash of new styles","     * @param {Object} b Hash of original styles","     * @return Object","     * @protected","     */","    _mergeStyles: function(a, b)","    {","        if(!b)","        {","            b = {};","        }","        var newstyles = Y.merge(b, {});","        Y.Object.each(a, function(value, key, a)","        {","            if(b.hasOwnProperty(key) && Y_Lang.isObject(value) && !Y_Lang.isFunction(value) && !Y_Lang.isArray(value))","            {","                newstyles[key] = this._mergeStyles(value, b[key]);","            }","            else","            {","                newstyles[key] = value;","            }","        }, this);","        return newstyles;","    },","","    /**","     * Gets the default value for the `styles` attribute. ","     *","     * @method _getDefaultStyles","     * @return Object","     * @protected","     */","    _getDefaultStyles: function()","    {","        return {padding:{","            top:0,","            right: 0,","            bottom: 0,","            left: 0","        }};","    }","};","","Y.augment(Renderer, Y.Attribute);","Y.Renderer = Renderer;","","/**"," * Algorithmic strategy for rendering a left axis."," *"," * @module charts"," * @submodule charts-base"," * @class LeftAxisLayout"," * @constructor"," */","LeftAxisLayout = function() {};","","LeftAxisLayout.prototype = {","    /**","     *  Default margins for text fields.","     *","     *  @private","     *  @method _getDefaultMargins","     *  @return Object","     */","    _getDefaultMargins: function() ","    {","        return {","            top: 0,","            left: 0,","            right: 4,","            bottom: 0","        };","    },","","    /**","     * Sets the length of the tick on either side of the axis line.","     *","     * @method setTickOffset","     * @protected","     */","    setTickOffsets: function()","    {","        var host = this,","            majorTicks = host.get(\"styles\").majorTicks,","            tickLength = majorTicks.length,","            halfTick = tickLength * 0.5,","            display = majorTicks.display;","        host.set(\"topTickOffset\",  0);","        host.set(\"bottomTickOffset\",  0);","        ","        switch(display)","        {","            case \"inside\" :","                host.set(\"rightTickOffset\",  tickLength);","                host.set(\"leftTickOffset\", 0);","            break;","            case \"outside\" : ","                host.set(\"rightTickOffset\", 0);","                host.set(\"leftTickOffset\",  tickLength);","            break;","            case \"cross\":","                host.set(\"rightTickOffset\", halfTick); ","                host.set(\"leftTickOffset\",  halfTick);","            break;","            default:","                host.set(\"rightTickOffset\", 0);","                host.set(\"leftTickOffset\", 0);","            break;","        }","    },","    ","    /**","     * Draws a tick","     *","     * @method drawTick","     * @param {Path} path reference to the path `Path` element in which to draw the tick.","     * @param {Object} pt Point on the axis in which the tick will intersect.","     * @param {Object} tickStyle Hash of properties to apply to the tick.","     * @protected","     */","    drawTick: function(path, pt, tickStyles)","    {","        var host = this,","            style = host.get(\"styles\"),","            padding = style.padding,","            tickLength = tickStyles.length,","            start = {x:padding.left, y:pt.y},","            end = {x:tickLength + padding.left, y:pt.y};","        host.drawLine(path, start, end);","    },","","    /**","     * Calculates the coordinates for the first point on an axis.","     *","     * @method getLineStart","     * @return {Object}","     * @protected","     */","    getLineStart: function()","    {","        var style = this.get(\"styles\"),","            padding = style.padding,","            majorTicks = style.majorTicks,","            tickLength = majorTicks.length,","            display = majorTicks.display,","            pt = {x:padding.left, y:0};","        if(display === \"outside\")","        {","            pt.x += tickLength;","        }","        else if(display === \"cross\")","        {","            pt.x += tickLength/2;","        }","        return pt; ","    },","    ","    /**","     * Calculates the point for a label.","     *","     * @method getLabelPoint","     * @param {Object} point Point on the axis in which the tick will intersect.","     * @return {Object} ","     * @protected","     */","    getLabelPoint: function(point)","    {","        return {x:point.x - this.get(\"leftTickOffset\"), y:point.y};","    },","    ","    /**","     * Updates the value for the `maxLabelSize` for use in calculating total size.","     *","     * @method updateMaxLabelSize","     * @param {HTMLElement} label to measure","     * @protected","     */","    updateMaxLabelSize: function(labelWidth, labelHeight)","    {","        var host = this,","            props = this._labelRotationProps,","            rot = props.rot,","            absRot = props.absRot,","            sinRadians = props.sinRadians,","            cosRadians = props.cosRadians,","            max;","        if(rot === 0)","        {","            max = labelWidth;","        }","        else if(absRot === 90)","        {","            max = labelHeight;","        }","        else","        {","            max = (cosRadians * labelWidth) + (sinRadians * labelHeight);","        }","        host._maxLabelSize = Math.max(host._maxLabelSize, max);","    },","    ","    /**","     * Determines the available label width when the axis width has been explicitly set.","     *","     * @method getExplicitlySized","     * @return Boolean","     * @protected","     */","    getExplicitlySized: function(styles)","    {","        if(this._explicitWidth)","        {","            var host = this,","                w = host._explicitWidth,","                totalTitleSize = host._totalTitleSize,","                leftTickOffset = host.get(\"leftTickOffset\"),","                margin = styles.label.margin.right;","            host._maxLabelSize =  w - (leftTickOffset + margin + totalTitleSize);","            return true;","        }","        return false;","    },","","    /**","     * Rotate and position title.","     *","     * @method positionTitle","     * @param {HTMLElement} label to rotate position","     * @protected","     */","    positionTitle: function(label)","    {","        var host = this,","            bounds = host._titleBounds,","            margin = host.get(\"styles\").title.margin,","            props = host._titleRotationProps,","            w = bounds.right - bounds.left,","            labelWidth = label.offsetWidth,","            labelHeight = label.offsetHeight,","            x = (labelWidth * -0.5) + (w * 0.5),","            y = (host.get(\"height\") * 0.5) - (labelHeight * 0.5);","        props.labelWidth = labelWidth;","        props.labelHeight = labelHeight;","        if(margin && margin.left)","        {","            x += margin.left;","        }","        props.x = x;","        props.y = y;","        props.transformOrigin = [0.5, 0.5];","        host._rotate(label, props);","    },","","    /**","     * Rotate and position labels.","     *","     * @method positionLabel","     * @param {HTMLElement} label to rotate position","     * @param {Object} pt hash containing the x and y coordinates in which the label will be positioned","     * against.","     * @protected","     */","    positionLabel: function(label, pt, styles, i)","    {","        var host = this,","            tickOffset = host.get(\"leftTickOffset\"),","            totalTitleSize = this._totalTitleSize,","            leftOffset = pt.x + totalTitleSize - tickOffset,","            topOffset = pt.y,","            props = this._labelRotationProps,","            rot = props.rot,","            absRot = props.absRot,","            maxLabelSize = host._maxLabelSize,","            labelWidth = this._labelWidths[i],","            labelHeight = this._labelHeights[i];","        if(rot === 0)","        {","            leftOffset -= labelWidth;","            topOffset -= labelHeight * 0.5;","        }","        else if(rot === 90)","        {","            leftOffset -= labelWidth * 0.5;","        }","        else if(rot === -90)","        {","            leftOffset -= labelWidth * 0.5;","            topOffset -= labelHeight;","        }","        else","        {","            leftOffset -= labelWidth + (labelHeight * absRot/360);","            topOffset -= labelHeight * 0.5;","        }","        props.labelWidth = labelWidth;","        props.labelHeight = labelHeight;","        props.x = Math.round(maxLabelSize + leftOffset);","        props.y = Math.round(topOffset);","        this._rotate(label, props);","    },","","    /**","     * Adjusts the coordinates of an axis label based on the rotation.","     *","     * @method _setRotationCoords","     * @param {Object} props Coordinates, dimension and rotation properties of the label.","     * @protected","     */","    _setRotationCoords: function(props)","    {","        var rot = props.rot,","            absRot = props.absRot,","            leftOffset,","            topOffset,","            labelWidth = props.labelWidth,","            labelHeight = props.labelHeight;","        if(rot === 0)","        {","            leftOffset = labelWidth;","            topOffset = labelHeight * 0.5;","        }","        else if(rot === 90)","        {","            topOffset = 0;","            leftOffset = labelWidth * 0.5;","        }","        else if(rot === -90)","        {","            leftOffset = labelWidth * 0.5;","            topOffset = labelHeight;","        }","        else","        {","            leftOffset = labelWidth + (labelHeight * absRot/360);","            topOffset = labelHeight * 0.5;","        }","        props.x -= leftOffset;","        props.y -= topOffset;","    },","","    /**","     * Returns the transformOrigin to use for an axis label based on the position of the axis ","     * and the rotation of the label.","     *","     * @method _getTransformOrigin","     * @param {Number} rot The rotation (in degrees) of the label.","     * @return Array","     * @protected","     */","    _getTransformOrigin: function(rot)","    {","        var transformOrigin;","        if(rot === 0)","        {","            transformOrigin = [0, 0];","        }","        else if(rot === 90)","        {","            transformOrigin = [0.5, 0];","        }","        else if(rot === -90)","        {","            transformOrigin = [0.5, 1];","        }","        else","        {","            transformOrigin = [1, 0.5];","        }","        return transformOrigin;","    },","","    /**","     * Adjust the position of the Axis widget's content box for internal axes.","     *","     * @method offsetNodeForTick","     * @param {Node} cb Content box of the Axis.","     * @protected","     */","    offsetNodeForTick: function(cb)","    {","    },","","    /**","     * Sets the width of the axis based on its contents.","     *","     * @method setCalculatedSize","     * @protected","     */","    setCalculatedSize: function()","    {","        var host = this,","            graphic = this.get(\"graphic\"),","            style = host.get(\"styles\"),","            label = style.label,","            tickOffset = host.get(\"leftTickOffset\"),","            max = host._maxLabelSize,","            totalTitleSize = this._totalTitleSize,","            ttl = Math.round(totalTitleSize + tickOffset + max + label.margin.right);","        if(this._explicitWidth)","        {","            ttl = this._explicitWidth;","        }","        this.set(\"calculatedWidth\", ttl);","        graphic.set(\"x\", ttl - tickOffset);","    }","};","","Y.LeftAxisLayout = LeftAxisLayout;","/**"," * RightAxisLayout contains algorithms for rendering a right axis."," *"," * @module charts"," * @submodule charts-base"," * @class RightAxisLayout"," * @constructor"," */","RightAxisLayout = function(){};","","RightAxisLayout.prototype = {","    /**","     *  Default margins for text fields.","     *","     *  @private","     *  @method _getDefaultMargins","     *  @return Object","     */","    _getDefaultMargins: function() ","    {","        return {","            top: 0,","            left: 4,","            right: 0,","            bottom: 0","        };","    },","","    /**","     * Sets the length of the tick on either side of the axis line.","     *","     * @method setTickOffset","     * @protected","     */","    setTickOffsets: function()","    {","        var host = this,","            majorTicks = host.get(\"styles\").majorTicks,","            tickLength = majorTicks.length,","            halfTick = tickLength * 0.5,","            display = majorTicks.display;","        host.set(\"topTickOffset\",  0);","        host.set(\"bottomTickOffset\",  0);","        ","        switch(display)","        {","            case \"inside\" :","                host.set(\"leftTickOffset\", tickLength);","                host.set(\"rightTickOffset\", 0);","            break;","            case \"outside\" : ","                host.set(\"leftTickOffset\", 0);","                host.set(\"rightTickOffset\", tickLength);","            break;","            case \"cross\" :","                host.set(\"rightTickOffset\", halfTick);","                host.set(\"leftTickOffset\", halfTick);","            break;","            default:","                host.set(\"leftTickOffset\", 0);","                host.set(\"rightTickOffset\", 0);","            break;","        }","    },","","    /**","     * Draws a tick","     *","     * @method drawTick","     * @param {Path} path reference to the path `Path` element in which to draw the tick.","     * @param {Object} pt Point on the axis in which the tick will intersect.","     * @param {Object) tickStyle Hash of properties to apply to the tick.","     * @protected","     */","    drawTick: function(path, pt, tickStyles)","    {","        var host = this,","            style = host.get(\"styles\"),","            padding = style.padding,","            tickLength = tickStyles.length,","            start = {x:padding.left, y:pt.y},","            end = {x:padding.left + tickLength, y:pt.y};","        host.drawLine(path, start, end);","    },","    ","    /**","     * Calculates the coordinates for the first point on an axis.","     *","     * @method getLineStart","     * @return {Object}","     * @protected","     */","    getLineStart: function()","    {","        var host = this,","            style = host.get(\"styles\"),","            padding = style.padding,","            majorTicks = style.majorTicks,","            tickLength = majorTicks.length,","            display = majorTicks.display,","            pt = {x:padding.left, y:padding.top};","        if(display === \"inside\")","        {","            pt.x += tickLength;","        }","        else if(display === \"cross\")","        {","            pt.x += tickLength/2;","        }","        return pt;","    },","    ","    /**","     * Calculates the point for a label.","     *","     * @method getLabelPoint","     * @param {Object} point Point on the axis in which the tick will intersect.","     * @return {Object} ","     * @protected","     */","    getLabelPoint: function(point)","    {","        return {x:point.x + this.get(\"rightTickOffset\"), y:point.y};","    },","    ","    /**","     * Updates the value for the `maxLabelSize` for use in calculating total size.","     *","     * @method updateMaxLabelSize","     * @param {HTMLElement} label to measure","     * @protected","     */","    updateMaxLabelSize: function(labelWidth, labelHeight)","    {","        var host = this,","            props = this._labelRotationProps,","            rot = props.rot,","            absRot = props.absRot,","            sinRadians = props.sinRadians,","            cosRadians = props.cosRadians,","            max;","        if(rot === 0)","        {","            max = labelWidth;","        }","        else if(absRot === 90)","        {","            max = labelHeight;","        }","        else","        {","            max = (cosRadians * labelWidth) + (sinRadians * labelHeight);","        }","        host._maxLabelSize = Math.max(host._maxLabelSize, max);","    },","    ","    /**","     * Determines the available label width when the axis width has been explicitly set.","     *","     * @method getExplicitlySized","     * @return Boolean","     * @protected","     */","    getExplicitlySized: function(styles)","    {","        if(this._explicitWidth)","        {","            var host = this,","                w = host._explicitWidth,","                totalTitleSize = this._totalTitleSize,","                rightTickOffset = host.get(\"rightTickOffset\"),","                margin = styles.label.margin.right;","            host._maxLabelSize =  w - (rightTickOffset + margin + totalTitleSize);","            return true;","        }","        return false;","    },","","    /**","     * Rotate and position title.","     *","     * @method positionTitle","     * @param {HTMLElement} label to rotate position","     * @protected","     */","    positionTitle: function(label)","    {","        var host = this,","            bounds = host._titleBounds,","            margin = host.get(\"styles\").title.margin,","            props = host._titleRotationProps,","            labelWidth = label.offsetWidth,","            labelHeight = label.offsetHeight,","            w = bounds.right - bounds.left,","            x = this.get(\"width\") - (labelWidth * 0.5) - (w * 0.5),","            y = (host.get(\"height\") * 0.5) - (labelHeight * 0.5);","        props.labelWidth = labelWidth;","        props.labelHeight = labelHeight;","        if(margin && margin.right)","        {","            x -= margin.left;","        }","        props.x = x;","        props.y = y;","        props.transformOrigin = [0.5, 0.5];","        host._rotate(label, props);","    },","","    /**","     * Rotate and position labels.","     *","     * @method positionLabel","     * @param {HTMLElement} label to rotate position","     * @param {Object} pt hash containing the x and y coordinates in which the label will be positioned","     * against.","     * @protected","     */","    positionLabel: function(label, pt, styles, i)","    {","        var host = this,","            tickOffset = host.get(\"rightTickOffset\"),","            labelStyles = styles.label,","            margin = 0,","            leftOffset = pt.x,","            topOffset = pt.y,","            props = this._labelRotationProps,","            rot = props.rot,","            absRot = props.absRot,","            labelWidth = this._labelWidths[i],","            labelHeight = this._labelHeights[i];","        if(labelStyles.margin && labelStyles.margin.left)","        {","            margin = labelStyles.margin.left;","        }","        if(rot === 0)","        {","            topOffset -= labelHeight * 0.5;","        }","        else if(rot === 90)","        {","            leftOffset -= labelWidth * 0.5;","            topOffset -= labelHeight;","        }","        else if(rot === -90)","        {","            leftOffset -= labelWidth * 0.5;","        }","        else","        {","            topOffset -= labelHeight * 0.5;","            leftOffset += labelHeight/2 * absRot/90;","        }","        leftOffset += margin;","        leftOffset += tickOffset;","        props.labelWidth = labelWidth;","        props.labelHeight = labelHeight;","        props.x = Math.round(leftOffset);","        props.y = Math.round(topOffset);","        this._rotate(label, props);","    },"," ","    /**","     * Adjusts the coordinates of an axis label based on the rotation.","     *","     * @method _setRotationCoords","     * @param {Object} props Coordinates, dimension and rotation properties of the label.","     * @protected","     */","    _setRotationCoords: function(props)","    {","        var rot = props.rot,","            absRot = props.absRot,","            leftOffset = 0,","            topOffset = 0,","            labelWidth = props.labelWidth,","            labelHeight = props.labelHeight;","        if(rot === 0)","        {","            topOffset = labelHeight * 0.5;","        }","        else if(rot === 90)","        {","            leftOffset = labelWidth * 0.5;","            topOffset = labelHeight;","        }","        else if(rot === -90)","        {","            leftOffset = labelWidth * 0.5;","        }","        else","        {","            topOffset = labelHeight * 0.5;","            leftOffset = labelHeight/2 * absRot/90;","        }","        props.x -= leftOffset;","        props.y -= topOffset;","    },","   ","    /**","     * Returns the transformOrigin to use for an axis label based on the position of the axis ","     * and the rotation of the label.","     *","     * @method _getTransformOrigin","     * @param {Number} rot The rotation (in degrees) of the label.","     * @return Array","     * @protected","     */","    _getTransformOrigin: function(rot)","    {","        var transformOrigin;","        if(rot === 0)","        {","            transformOrigin = [0, 0];","        }","        else if(rot === 90)","        {","            transformOrigin = [0.5, 1];","        }","        else if(rot === -90)","        {","            transformOrigin = [0.5, 0];","        }","        else","        {","            transformOrigin = [0, 0.5];","        }","        return transformOrigin;","    },","","    /**","     * Adjusts position for inner ticks.","     *","     * @method offsetNodeForTick","     * @param {Node} cb contentBox of the axis","     * @protected","     */","    offsetNodeForTick: function(cb)","    {","        var host = this,","            tickOffset = host.get(\"leftTickOffset\"),","            offset = 0 - tickOffset;","        cb.setStyle(\"left\", offset);","    },","","    /**","     * Assigns a height based on the size of the contents.","     *","     * @method setCalculatedSize","     * @protected","     */","    setCalculatedSize: function()","    {","        var host = this,","            styles = host.get(\"styles\"),","            labelStyle = styles.label,","            totalTitleSize = this._totalTitleSize,","            ttl = Math.round(host.get(\"rightTickOffset\") + host._maxLabelSize + totalTitleSize + labelStyle.margin.left);","        if(this._explicitWidth)","        {","            ttl = this._explicitWidth;","        }","        host.set(\"calculatedWidth\", ttl);","        host.get(\"contentBox\").setStyle(\"width\", ttl);","    }","};","","Y.RightAxisLayout = RightAxisLayout;","/**"," * Contains algorithms for rendering a bottom axis."," *"," * @module charts"," * @submodule charts-base"," * @class BottomAxisLayout"," * @Constructor"," */","BottomAxisLayout = function(){};","","BottomAxisLayout.prototype = {","    /**","     *  Default margins for text fields.","     *","     *  @private","     *  @method _getDefaultMargins","     *  @return Object","     */","    _getDefaultMargins: function() ","    {","        return {","            top: 4,","            left: 0,","            right: 0,","            bottom: 0","        };","    },","","    /**","     * Sets the length of the tick on either side of the axis line.","     *","     * @method setTickOffsets","     * @protected","     */","    setTickOffsets: function()","    {","        var host = this,","            majorTicks = host.get(\"styles\").majorTicks,","            tickLength = majorTicks.length,","            halfTick = tickLength * 0.5,","            display = majorTicks.display;","        host.set(\"leftTickOffset\",  0);","        host.set(\"rightTickOffset\",  0);","","        switch(display)","        {","            case \"inside\" :","                host.set(\"topTickOffset\", tickLength);","                host.set(\"bottomTickOffset\", 0);","            break;","            case \"outside\" : ","                host.set(\"topTickOffset\", 0);","                host.set(\"bottomTickOffset\", tickLength);","            break;","            case \"cross\":","                host.set(\"topTickOffset\",  halfTick);","                host.set(\"bottomTickOffset\",  halfTick);","            break;","            default:","                host.set(\"topTickOffset\", 0);","                host.set(\"bottomTickOffset\", 0);","            break;","        }","    },","","    /**","     * Calculates the coordinates for the first point on an axis.","     *","     * @method getLineStart","     * @protected","     */","    getLineStart: function()","    {","        var style = this.get(\"styles\"),","            padding = style.padding,","            majorTicks = style.majorTicks,","            tickLength = majorTicks.length,","            display = majorTicks.display,","            pt = {x:0, y:padding.top};","        if(display === \"inside\")","        {","            pt.y += tickLength;","        }","        else if(display === \"cross\")","        {","            pt.y += tickLength/2;","        }","        return pt; ","    },","    ","    /**","     * Draws a tick","     *","     * @method drawTick","     * @param {Path} path reference to the path `Path` element in which to draw the tick.","     * @param {Object} pt hash containing x and y coordinates","     * @param {Object} tickStyles hash of properties used to draw the tick","     * @protected","     */","    drawTick: function(path, pt, tickStyles)","    {","        var host = this,","            style = host.get(\"styles\"),","            padding = style.padding,","            tickLength = tickStyles.length,","            start = {x:pt.x, y:padding.top},","            end = {x:pt.x, y:tickLength + padding.top};","        host.drawLine(path, start, end);","    },","","    /**","     * Calculates the point for a label.","     *","     * @method getLabelPoint","     * @param {Object} pt Object containing x and y coordinates","     * @return Object","     * @protected","     */","    getLabelPoint: function(point)","    {","        return {x:point.x, y:point.y + this.get(\"bottomTickOffset\")};","    },","    ","    /**","     * Updates the value for the `maxLabelSize` for use in calculating total size.","     *","     * @method updateMaxLabelSize","     * @param {HTMLElement} label to measure","     * @protected","     */","    updateMaxLabelSize: function(labelWidth, labelHeight)","    {","        var host = this,","            props = this._labelRotationProps,","            rot = props.rot,","            absRot = props.absRot,","            sinRadians = props.sinRadians,","            cosRadians = props.cosRadians,","            max;","        if(rot === 0)","        {","            max = labelHeight;","        }","        else if(absRot === 90)","        {","            max = labelWidth;","        }","        else","        {","            max = (sinRadians * labelWidth) + (cosRadians * labelHeight); ","        }","        host._maxLabelSize = Math.max(host._maxLabelSize, max);","    },","    ","    /**","     * Determines the available label height when the axis width has been explicitly set.","     *","     * @method getExplicitlySized","     * @return Boolean","     * @protected","     */","    getExplicitlySized: function(styles)","    {","        if(this._explicitHeight)","        {","            var host = this,","                h = host._explicitHeight,","                totalTitleSize = host._totalTitleSize,","                bottomTickOffset = host.get(\"bottomTickOffset\"),","                margin = styles.label.margin.right;","            host._maxLabelSize =  h - (bottomTickOffset + margin + totalTitleSize);","            return true;","        }","        return false;","    },","","    /**","     * Rotate and position title.","     *","     * @method positionTitle","     * @param {HTMLElement} label to rotate position","     * @protected","     */","    positionTitle: function(label)","    {","        var host = this,","            bounds = host._titleBounds,","            margin = host.get(\"styles\").title.margin,","            props = host._titleRotationProps,","            h = bounds.bottom - bounds.top,","            labelWidth = label.offsetWidth,","            labelHeight = label.offsetHeight,","            x = (host.get(\"width\") * 0.5) - (labelWidth * 0.5),","            y = host.get(\"height\") - labelHeight/2 - h/2;","        props.labelWidth = labelWidth;","        props.labelHeight = labelHeight;","        if(margin && margin.bottom)","        {","            y -= margin.bottom;","        }","        props.x = x;","        props.y = y;","        props.transformOrigin = [0.5, 0.5];","        host._rotate(label, props);","    },","    ","    /**","     * Rotate and position labels.","     *","     * @method positionLabel","     * @param {HTMLElement} label to rotate position","     * @param {Object} pt hash containing the x and y coordinates in which the label will be positioned","     * against.","     * @protected","     */","    positionLabel: function(label, pt, styles, i)","    {","        var host = this,","            tickOffset = host.get(\"bottomTickOffset\"),","            labelStyles = styles.label,","            margin = 0,","            props = host._labelRotationProps,","            rot = props.rot,","            absRot = props.absRot,","            leftOffset = Math.round(pt.x),","            topOffset = Math.round(pt.y),","            labelWidth = host._labelWidths[i],","            labelHeight = host._labelHeights[i];","        if(labelStyles.margin && labelStyles.margin.top)","        {","            margin = labelStyles.margin.top;","        }","        if(rot > 0)","        {","            topOffset -= labelHeight/2 * rot/90;","        }","        else if(rot < 0)","        {","            leftOffset -= labelWidth;","            topOffset -= labelHeight/2 * absRot/90;","        }","        else","        {","            leftOffset -= labelWidth * 0.5;","        }","        topOffset += margin;","        topOffset += tickOffset;","        props.labelWidth = labelWidth;","        props.labelHeight = labelHeight;","        props.x = leftOffset;","        props.y = topOffset;","        host._rotate(label, props);","    },","    ","    /**","     * Adjusts the coordinates of an axis label based on the rotation.","     *","     * @method _setRotationCoords","     * @param {Object} props Coordinates, dimension and rotation properties of the label.","     * @protected","     */","    _setRotationCoords: function(props)","    {","        var rot = props.rot,","            absRot = props.absRot,","            labelWidth = props.labelWidth,","            labelHeight = props.labelHeight,","            leftOffset,","            topOffset;","","        if(rot > 0)","        {","            leftOffset = 0;","            topOffset = labelHeight/2 * rot/90;","        }","        else if(rot < 0)","        {","            leftOffset = labelWidth;","            topOffset = labelHeight/2 * absRot/90;","        }","        else","        {","            leftOffset = labelWidth * 0.5;","            topOffset = 0;","        }","        props.x -= leftOffset;","        props.y -= topOffset;","    },","","    /**","     * Returns the transformOrigin to use for an axis label based on the position of the axis ","     * and the rotation of the label.","     *","     * @method _getTransformOrigin","     * @param {Number} rot The rotation (in degrees) of the label.","     * @return Array","     * @protected","     */","    _getTransformOrigin: function(rot)","    {","        var transformOrigin;","        if(rot > 0)","        {","            transformOrigin = [0, 0.5];","        }","        else if(rot < 0)","        {","            transformOrigin = [1, 0.5];","        }","        else","        {","            transformOrigin = [0, 0];","        }","        return transformOrigin;","    },","","    /**","     * Adjusts position for inner ticks.","     *","     * @method offsetNodeForTick","     * @param {Node} cb contentBox of the axis","     * @protected","     */","    offsetNodeForTick: function(cb)","    {","        var host = this;","        host.get(\"contentBox\").setStyle(\"top\", 0 - host.get(\"topTickOffset\"));","    },","","    /**","     * Assigns a height based on the size of the contents.","     *","     * @method setCalculatedSize","     * @protected","     */","    setCalculatedSize: function()","    {","        var host = this,","            styles = host.get(\"styles\"),","            labelStyle = styles.label,","            totalTitleSize = host._totalTitleSize,","            ttl = Math.round(host.get(\"bottomTickOffset\") + host._maxLabelSize + labelStyle.margin.top + totalTitleSize);","        if(host._explicitHeight)","        {","            ttl = host._explicitHeight;","        }","        host.set(\"calculatedHeight\", ttl);","    }","};","Y.BottomAxisLayout = BottomAxisLayout;","/**"," * Contains algorithms for rendering a top axis."," *"," * @module charts"," * @submodule charts-base"," * @class TopAxisLayout"," * @constructor"," */","TopAxisLayout = function(){};","","TopAxisLayout.prototype = {","    /**","     *  Default margins for text fields.","     *","     *  @private","     *  @method _getDefaultMargins","     *  @return Object","     */","    _getDefaultMargins: function() ","    {","        return {","            top: 0,","            left: 0,","            right: 0,","            bottom: 4","        };","    },","    ","    /**","     * Sets the length of the tick on either side of the axis line.","     *","     * @method setTickOffsets","     * @protected","     */","    setTickOffsets: function()","    {","        var host = this,","            majorTicks = host.get(\"styles\").majorTicks,","            tickLength = majorTicks.length,","            halfTick = tickLength * 0.5,","            display = majorTicks.display;","        host.set(\"leftTickOffset\",  0);","        host.set(\"rightTickOffset\",  0);","        switch(display)","        {","            case \"inside\" :","                host.set(\"bottomTickOffset\", tickLength);","                host.set(\"topTickOffset\", 0);","            break;","            case \"outside\" : ","                host.set(\"bottomTickOffset\", 0);","                host.set(\"topTickOffset\",  tickLength);","            break;","            case \"cross\" :","                host.set(\"topTickOffset\", halfTick);","                host.set(\"bottomTickOffset\", halfTick);","            break;","            default:","                host.set(\"topTickOffset\", 0);","                host.set(\"bottomTickOffset\", 0);","            break;","        }","    },","","    /**","     * Calculates the coordinates for the first point on an axis.","     *","     * @method getLineStart","     * @protected","     */","    getLineStart: function()","    {","        var host = this,","            style = host.get(\"styles\"),","            padding = style.padding,","            majorTicks = style.majorTicks,","            tickLength = majorTicks.length,","            display = majorTicks.display,","            pt = {x:0, y:padding.top};","        if(display === \"outside\")","        {","            pt.y += tickLength;","        }","        else if(display === \"cross\")","        {","            pt.y += tickLength/2;","        }","        return pt; ","    },","    ","    /**","     * Draws a tick","     *","     * @method drawTick","     * @param {Path} path reference to the path `Path` element in which to draw the tick.","     * @param {Object} pt hash containing x and y coordinates","     * @param {Object} tickStyles hash of properties used to draw the tick","     * @protected","     */","    drawTick: function(path, pt, tickStyles)","    {","        var host = this,","            style = host.get(\"styles\"),","            padding = style.padding,","            tickLength = tickStyles.length,","            start = {x:pt.x, y:padding.top},","            end = {x:pt.x, y:tickLength + padding.top};","        host.drawLine(path, start, end);","    },","    ","    /**","     * Calculates the point for a label.","     *","     * @method getLabelPoint","     * @param {Object} pt hash containing x and y coordinates","     * @return Object","     * @protected","     */","    getLabelPoint: function(pt)","    {","        return {x:pt.x, y:pt.y - this.get(\"topTickOffset\")};","    },","    ","    /**","     * Updates the value for the `maxLabelSize` for use in calculating total size.","     *","     * @method updateMaxLabelSize","     * @param {HTMLElement} label to measure","     * @protected","     */","    updateMaxLabelSize: function(labelWidth, labelHeight)","    {","        var host = this,","            props = this._labelRotationProps,","            rot = props.rot,","            absRot = props.absRot,","            sinRadians = props.sinRadians,","            cosRadians = props.cosRadians,","            max;","        if(rot === 0)","        {","            max = labelHeight;","        }","        else if(absRot === 90)","        {","            max = labelWidth;","        }","        else","        {","            max = (sinRadians * labelWidth) + (cosRadians * labelHeight); ","        }","        host._maxLabelSize = Math.max(host._maxLabelSize, max);","    },","","    /**","     * Determines the available label height when the axis width has been explicitly set.","     *","     * @method getExplicitlySized","     * @return Boolean","     * @protected","     */","    getExplicitlySized: function(styles)","    {","        if(this._explicitHeight)","        {","            var host = this,","                h = host._explicitHeight,","                totalTitleSize = host._totalTitleSize,","                topTickOffset = host.get(\"topTickOffset\"),","                margin = styles.label.margin.right;","            host._maxLabelSize =  h - (topTickOffset + margin + totalTitleSize);","            return true;","        }","        return false;","    },","","    /**","     * Rotate and position title.","     *","     * @method positionTitle","     * @param {HTMLElement} label to rotate position","     * @protected","     */","    positionTitle: function(label)","    {","        var host = this,","            bounds = host._titleBounds,","            margin = host.get(\"styles\").title.margin,","            props = host._titleRotationProps,","            labelWidth = label.offsetWidth,","            labelHeight = label.offsetHeight,","            h = bounds.bottom - bounds.top,","            x = (host.get(\"width\") * 0.5) - (labelWidth * 0.5),","            y = h/2 - labelHeight/2;","        props.labelWidth = labelWidth;","        props.labelHeight = labelHeight;","        if(margin && margin.top)","        {","            y += margin.top;","        }","        props.x = x;","        props.y = y;","        props.transformOrigin = [0.5, 0.5];","        host._rotate(label, props);","    },","","    /**","     * Rotate and position labels.","     *","     * @method positionLabel","     * @param {HTMLElement} label to rotate position","     * @param {Object} pt hash containing the x and y coordinates in which the label will be positioned","     * against.","     * @protected","     */","    positionLabel: function(label, pt, styles, i)","    {","        var host = this,","            totalTitleSize = this._totalTitleSize,","            maxLabelSize = host._maxLabelSize,","            leftOffset = pt.x,","            topOffset = pt.y + totalTitleSize + maxLabelSize,","            props = this._labelRotationProps,","            rot = props.rot,","            absRot = props.absRot,","            labelWidth = this._labelWidths[i],","            labelHeight = this._labelHeights[i];","        if(rot === 0)","        {","            leftOffset -= labelWidth * 0.5;","            topOffset -= labelHeight;","        }","        else","        {","            if(rot === 90)","            {","                leftOffset -= labelWidth;","                topOffset -= (labelHeight * 0.5);","            }","            else if (rot === -90)","            {","                topOffset -= (labelHeight * 0.5);","            }    ","            else if(rot > 0)","            {","                leftOffset -= labelWidth;","                topOffset -= labelHeight - (labelHeight * rot/180);","            }","            else","            {","                topOffset -= labelHeight - (labelHeight * absRot/180);","            }","        }","        props.x = Math.round(leftOffset);","        props.y = Math.round(topOffset);","        props.labelWidth = labelWidth;","        props.labelHeight = labelHeight;","        this._rotate(label, props);","    },","","    /**","     * Adjusts the coordinates of an axis label based on the rotation.","     *","     * @method _setRotationCoords","     * @param {Object} props Coordinates, dimension and rotation properties of the label.","     * @protected","     */","    _setRotationCoords: function(props)","    {","        var rot = props.rot,","            absRot = props.absRot,","            labelWidth = props.labelWidth,","            labelHeight = props.labelHeight,","            leftOffset,","            topOffset;","        if(rot === 0)","        {","            leftOffset = labelWidth * 0.5;","            topOffset = labelHeight;","        }","        else","        {","            if(rot === 90)","            {","                leftOffset = labelWidth;","                topOffset = (labelHeight * 0.5);","            }","            else if (rot === -90)","            {","                topOffset = (labelHeight * 0.5);","            }    ","            else if(rot > 0)","            {","                leftOffset = labelWidth;","                topOffset = labelHeight - (labelHeight * rot/180);","            }","            else","            {","                topOffset = labelHeight - (labelHeight * absRot/180);","            }","        }","        props.x -= leftOffset;","        props.y -= topOffset;","    },","","    /**","     * Returns the transformOrigin to use for an axis label based on the position of the axis ","     * and the rotation of the label.","     *","     * @method _getTransformOrigin","     * @param {Number} rot The rotation (in degrees) of the label.","     * @return Array","     * @protected","     */","    _getTransformOrigin: function(rot)","    {","        var transformOrigin;","        if(rot === 0)","        {","            transformOrigin = [0, 0];","        }","        else","        {","            if(rot === 90)","            {","                transformOrigin = [1, 0.5];","            }","            else if (rot === -90)","            {","                transformOrigin = [0, 0.5];","            }    ","            else if(rot > 0)","            {","                transformOrigin = [1, 0.5];","            }","            else","            {","                transformOrigin = [0, 0.5];","            }","        }","        return transformOrigin;","    },","","    /**","     * Adjusts position for inner ticks.","     *","     * @method offsetNodeForTick","     * @param {Node} cb contentBox of the axis","     * @protected","     */","    offsetNodeForTick: function(cb)","    {","    },","","    /**","     * Assigns a height based on the size of the contents.","     *","     * @method setCalculatedSize","     * @protected","     */","    setCalculatedSize: function()","    {","        var host = this,","            graphic = host.get(\"graphic\"),","            styles = host.get(\"styles\"),","            labelMargin = styles.label.margin,","            totalLabelSize = labelMargin.bottom + host._maxLabelSize,","            totalTitleSize = host._totalTitleSize,","            topTickOffset = this.get(\"topTickOffset\"),","            ttl = Math.round(topTickOffset + totalLabelSize + totalTitleSize);","        if(this._explicitHeight)","        {","           ttl = this._explicitWidth; ","        }","        host.set(\"calculatedHeight\", ttl);","        graphic.set(\"y\", ttl - topTickOffset);","    }","};","Y.TopAxisLayout = TopAxisLayout;","","/**"," * The Axis class. Generates axes for a chart."," *"," * @module charts"," * @submodule charts-base"," * @class Axis"," * @extends Widget"," * @uses Renderer"," * @constructor"," * @param {Object} config (optional) Configuration parameters for the Chart."," */","Y.Axis = Y.Base.create(\"axis\", Y.Widget, [Y.Renderer], {","    /**","     * Storage for calculatedWidth value.","     *","     * @property _calculatedWidth","     * @type Number","     * @private","     */","    _calculatedWidth: 0,","","    /**","     * Storage for calculatedHeight value.","     *","     * @property _calculatedHeight","     * @type Number","     * @private","     */","    _calculatedHeight: 0,","","    /**","     * Handles change to the dataProvider","     * ","     * @method _dataChangeHandler","     * @param {Object} e Event object","     * @private","     */","    _dataChangeHandler: function(e)","    {","        if(this.get(\"rendered\"))","        {","            this._drawAxis();","        }","    },","","    /**","     * Handles change to the position attribute","     *","     * @method _positionChangeHandler","     * @param {Object} e Event object","     * @private","     */","    _positionChangeHandler: function(e)","    {","        this._updateGraphic(e.newVal);","        this._updateHandler();","    },","","    /**","     * Updates the the Graphic instance","     *","     * @method _updateGraphic","     * @param {String} position Position of axis ","     * @private","     */","    _updateGraphic: function(position)","    {","        var graphic = this.get(\"graphic\");","        if(position == \"none\")","        {","            if(graphic)","            {","                graphic.destroy();","            }","        }","        else","        {","            if(!graphic)","            {","                this._setCanvas();","            }","        }","    },","","    /**","     * Handles changes to axis.","     *","     * @method _updateHandler","     * @param {Object} e Event object","     * @private","     */","    _updateHandler: function(e)","    {","        if(this.get(\"rendered\"))","        {","            this._drawAxis();","        }","    },","   ","    /**","     * @method renderUI","     * @private","     */","    renderUI: function()","    {","        this._updateGraphic(this.get(\"position\"));","    },","","    /**","     * @method syncUI","     * @private","     */","    syncUI: function()","    {","        var layout = this._layout,","            defaultMargins,","            styles,","            label,","            title,","            i;","        if(layout)","        {","            defaultMargins = layout._getDefaultMargins();","            styles = this.get(\"styles\");","            label = styles.label.margin;","            title =styles.title.margin;","            //need to defaultMargins method to the layout classes.","            for(i in defaultMargins)","            {","                if(defaultMargins.hasOwnProperty(i))","                {","                    label[i] = label[i] === undefined ? defaultMargins[i] : label[i];","                    title[i] = title[i] === undefined ? defaultMargins[i] : title[i];","                }","            }","        }","        this._drawAxis();","    },","","    /**","     * Creates a graphic instance to be used for the axis line and ticks.","     *","     * @method _setCanvas","     * @private","     */","    _setCanvas: function()","    {","        var cb = this.get(\"contentBox\"),","            bb = this.get(\"boundingBox\"),","            p = this.get(\"position\"),","            pn = this._parentNode,","            w = this.get(\"width\"),","            h = this.get(\"height\");","        bb.setStyle(\"position\", \"absolute\");","        bb.setStyle(\"zIndex\", 2);","        w = w ? w + \"px\" : pn.getStyle(\"width\");","        h = h ? h + \"px\" : pn.getStyle(\"height\");","        if(p === \"top\" || p === \"bottom\")","        {","            cb.setStyle(\"width\", w);","        }","        else","        {","            cb.setStyle(\"height\", h);","        }","        cb.setStyle(\"position\", \"relative\");","        cb.setStyle(\"left\", \"0px\");","        cb.setStyle(\"top\", \"0px\");","        this.set(\"graphic\", new Y.Graphic());","        this.get(\"graphic\").render(cb);","    },","	","    /**","     * Gets the default value for the `styles` attribute. Overrides","     * base implementation.","     *","     * @method _getDefaultStyles","     * @return Object","     * @protected","     */","    _getDefaultStyles: function()","    {","        var axisstyles = {","            majorTicks: {","                display:\"inside\",","                length:4,","                color:\"#dad8c9\",","                weight:1,","                alpha:1","            },","            minorTicks: {","                display:\"none\",","                length:2,","                color:\"#dad8c9\",","                weight:1","            },","            line: {","                weight:1,","                color:\"#dad8c9\",","                alpha:1","            },","            majorUnit: {","                determinant:\"count\",","                count:11,","                distance:75","            },","            top: \"0px\",","            left: \"0px\",","            width: \"100px\",","            height: \"100px\",","            label: {","                color:\"#808080\",","                alpha: 1,","                fontSize:\"85%\",","                rotation: 0,","                margin: {","                    top: undefined,","                    right: undefined,","                    bottom: undefined,","                    left: undefined","                }","            },","            title: {","                color:\"#808080\",","                alpha: 1,","                fontSize:\"85%\",","                rotation: undefined,","                margin: {","                    top: undefined,","                    right: undefined,","                    bottom: undefined,","                    left: undefined","                }","            },","            hideOverlappingLabelTicks: false","        };","        ","        return Y.merge(Y.Renderer.prototype._getDefaultStyles(), axisstyles); ","    },","","    /**","     * Updates the axis when the size changes.","     *","     * @method _handleSizeChange","     * @param {Object} e Event object.","     * @private","     */","    _handleSizeChange: function(e)","    {","        var attrName = e.attrName,","            pos = this.get(\"position\"),","            vert = pos == \"left\" || pos == \"right\",","            cb = this.get(\"contentBox\"),","            hor = pos == \"bottom\" || pos == \"top\";","        cb.setStyle(\"width\", this.get(\"width\"));","        cb.setStyle(\"height\", this.get(\"height\"));","        if((hor && attrName == \"width\") || (vert && attrName == \"height\"))","        {","            this._drawAxis();","        }","    },","   ","    /**","     * Maps key values to classes containing layout algorithms","     *","     * @property _layoutClasses","     * @type Object","     * @private","     */","    _layoutClasses: ","    {","        top : TopAxisLayout,","        bottom: BottomAxisLayout,","        left: LeftAxisLayout,","        right : RightAxisLayout","    },","    ","    /**","     * Draws a line segment between 2 points","     *","     * @method drawLine","     * @param {Object} startPoint x and y coordinates for the start point of the line segment","     * @param {Object} endPoint x and y coordinates for the for the end point of the line segment","     * @param {Object} line styles (weight, color and alpha to be applied to the line segment)","     * @private","     */","    drawLine: function(path, startPoint, endPoint)","    {","        path.moveTo(startPoint.x, startPoint.y);","        path.lineTo(endPoint.x, endPoint.y);","    },","","    /**","     * Generates the properties necessary for rotating and positioning a text field.","     *","     * @method _getTextRotationProps","     * @param {Object} styles properties for the text field","     * @return Object","     * @private","     */","    _getTextRotationProps: function(styles)","    {","        if(styles.rotation === undefined)","        {","            switch(this.get(\"position\"))","            {","                case \"left\" :","                    styles.rotation = -90;","                break; ","                case \"right\" : ","                    styles.rotation = 90;","                break;","                default :","                    styles.rotation = 0;","                break;","            }","        }","        var rot =  Math.min(90, Math.max(-90, styles.rotation)),","            absRot = Math.abs(rot),","            radCon = Math.PI/180,","            sinRadians = parseFloat(parseFloat(Math.sin(absRot * radCon)).toFixed(8)),","            cosRadians = parseFloat(parseFloat(Math.cos(absRot * radCon)).toFixed(8));","        return {","            rot: rot,","            absRot: absRot,","            radCon: radCon,","            sinRadians: sinRadians,","            cosRadians: cosRadians,","            textAlpha: styles.alpha","        };","    },","","    /**","     * Draws an axis. ","     *","     * @method _drawAxis","     * @private","     */","    _drawAxis: function ()","    {","        if(this._drawing)","        {","            this._callLater = true;","            return;","        }","        this._drawing = true;","        this._callLater = false;","        if(this._layout)","        {","            var styles = this.get(\"styles\"),","                line = styles.line,","                labelStyles = styles.label,","                majorTickStyles = styles.majorTicks,","                drawTicks = majorTickStyles.display != \"none\",","                tickPoint,","                majorUnit = styles.majorUnit,","                len,","                majorUnitDistance,","                i = 0,","                layout = this._layout,","                layoutLength,","                position,","                lineStart,","                label,","                labelWidth,","                labelHeight,","                labelFunction = this.get(\"labelFunction\"),","                labelFunctionScope = this.get(\"labelFunctionScope\"),","                labelFormat = this.get(\"labelFormat\"),","                graphic = this.get(\"graphic\"),","                path = this.get(\"path\"),","                tickPath,","                explicitlySized;","            this._labelWidths = [];","            this._labelHeights = [];","            graphic.set(\"autoDraw\", false);","            path.clear();","            path.set(\"stroke\", {","                weight: line.weight, ","                color: line.color, ","                opacity: line.alpha","            });","            this._labelRotationProps = this._getTextRotationProps(labelStyles);","            this._labelRotationProps.transformOrigin = layout._getTransformOrigin(this._labelRotationProps.rot);","            layout.setTickOffsets.apply(this);","            layoutLength = this.getLength();","            lineStart = layout.getLineStart.apply(this);","            len = this.getTotalMajorUnits(majorUnit);","            majorUnitDistance = this.getMajorUnitDistance(len, layoutLength, majorUnit);","            this.set(\"edgeOffset\", this.getEdgeOffset(len, layoutLength) * 0.5);","            if(len < 1)","            {","                this._clearLabelCache();","            }","            else","            {","                tickPoint = this.getFirstPoint(lineStart);","                this.drawLine(path, lineStart, this.getLineEnd(tickPoint));","                if(drawTicks) ","                {","                    tickPath = this.get(\"tickPath\");","                    tickPath.clear();","                    tickPath.set(\"stroke\", {","                        weight: majorTickStyles.weight,","                        color: majorTickStyles.color,","                        opacity: majorTickStyles.alpha","                    });","                   layout.drawTick.apply(this, [tickPath, tickPoint, majorTickStyles]);","                }","                this._createLabelCache();","                this._tickPoints = [];","                this._maxLabelSize = 0; ","                this._totalTitleSize = 0;","                this._titleSize = 0;","                this._setTitle();","                explicitlySized = layout.getExplicitlySized.apply(this, [styles]);","                for(; i < len; ++i)","                {","                    if(drawTicks) ","                    {","                        layout.drawTick.apply(this, [tickPath, tickPoint, majorTickStyles]);","                    }","                    position = this.getPosition(tickPoint);","                    label = this.getLabel(tickPoint, labelStyles);","                    this._labels.push(label);","                    this._tickPoints.push({x:tickPoint.x, y:tickPoint.y});","                    this.get(\"appendLabelFunction\")(label, labelFunction.apply(labelFunctionScope, [this.getLabelByIndex(i, len), labelFormat]));","                    labelWidth = Math.round(label.offsetWidth);","                    labelHeight = Math.round(label.offsetHeight);","                    if(!explicitlySized)","                    {","                        this._layout.updateMaxLabelSize.apply(this, [labelWidth, labelHeight]);","                    }","                    this._labelWidths.push(labelWidth);","                    this._labelHeights.push(labelHeight);","                    tickPoint = this.getNextPoint(tickPoint, majorUnitDistance);","                }","                this._clearLabelCache();","                if(this.get(\"overlapGraph\"))","                {","                   layout.offsetNodeForTick.apply(this, [this.get(\"contentBox\")]);","                }","                layout.setCalculatedSize.apply(this);","                if(this._titleTextField)","                {","                    this._layout.positionTitle.apply(this, [this._titleTextField]);","                }","                for(i = 0; i < len; ++i)","                {","                    layout.positionLabel.apply(this, [this.get(\"labels\")[i], this._tickPoints[i], styles, i]);","                }","            }","        }","        this._drawing = false;","        if(this._callLater)","        {","            this._drawAxis();","        }","        else","        {","            this._updatePathElement();","            this.fire(\"axisRendered\");","        }","    },","    ","    /**","     * Calculates and sets the total size of a title.","     *","     * @method _setTotalTitleSize","     * @param {Object} styles Properties for the title field.","     * @private","     */","    _setTotalTitleSize: function(styles)","    {","        var title = this._titleTextField,","            w = title.offsetWidth,","            h = title.offsetHeight,","            rot = this._titleRotationProps.rot,","            bounds,","            size,","            margin = styles.margin,","            position = this.get(\"position\"),","            matrix = new Y.Matrix();","        matrix.rotate(rot);","        bounds = matrix.getContentRect(w, h);","        if(position == \"left\" || position == \"right\")","        {","            size = bounds.right - bounds.left;","            if(margin)","            {","                size += margin.left + margin.right;","            }","        }","        else","        {","            size = bounds.bottom - bounds.top;","            if(margin)","            {","                size += margin.top + margin.bottom;","            }","        }","        this._titleBounds = bounds;","        this._totalTitleSize = size;","    },","","    /**","     *  Updates path.","     *","     *  @method _updatePathElement","     *  @private","     */","    _updatePathElement: function()","    {","        var path = this._path,","            tickPath = this._tickPath,","            redrawGraphic = false,","            graphic = this.get(\"graphic\");","        if(path)","        {","            redrawGraphic = true;","            path.end();","        }","        if(tickPath)","        {","            redrawGraphic = true;","            tickPath.end();","        }","        if(redrawGraphic)","        {","            graphic._redraw();","        }","    },","","    /**","     * Updates the content and style properties for a title field.","     *","     * @method _updateTitle","     * @private","     */","    _setTitle: function()","    {","        var i,","            styles,","            customStyles,","            title = this.get(\"title\"),","            titleTextField = this._titleTextField,","            parentNode;","        if(title !== null && title !== undefined)","        {","            customStyles = {","                    rotation: \"rotation\",","                    margin: \"margin\",","                    alpha: \"alpha\"","            };","            styles = this.get(\"styles\").title;","            if(!titleTextField)","            {","                titleTextField = DOCUMENT.createElement('span');","                titleTextField.style.display = \"block\";","                titleTextField.style.whiteSpace = \"nowrap\";","                titleTextField.setAttribute(\"class\", \"axisTitle\");","                this.get(\"contentBox\").append(titleTextField);","            }","            else if(!DOCUMENT.createElementNS)","            {","                if(titleTextField.style.filter)","                {","                    titleTextField.style.filter = null;","                }","            }","            titleTextField.style.position = \"absolute\";","            for(i in styles)","            {","                if(styles.hasOwnProperty(i) && !customStyles.hasOwnProperty(i))","                {","                    titleTextField.style[i] = styles[i];","                }","            }","            this.get(\"appendTitleFunction\")(titleTextField, title);","            this._titleTextField = titleTextField;","            this._titleRotationProps = this._getTextRotationProps(styles);","            this._setTotalTitleSize(styles);","        }","        else if(titleTextField)","        {","            parentNode = titleTextField.parentNode;","            if(parentNode)","            {","                parentNode.removeChild(titleTextField);","            }","            this._titleTextField = null;","            this._totalTitleSize = 0;","        }","    },","","    /**","     * Creates or updates an axis label.","     *","     * @method getLabel","     * @param {Object} pt x and y coordinates for the label","     * @param {Object} styles styles applied to label","     * @return HTMLElement ","     * @private","     */","    getLabel: function(pt, styles)","    {","        var i,","            label,","            labelCache = this._labelCache,","            customStyles = {","                rotation: \"rotation\",","                margin: \"margin\",","                alpha: \"alpha\"","            };","        if(labelCache && labelCache.length > 0)","        {","            label = labelCache.shift();","        }","        else","        {","            label = DOCUMENT.createElement(\"span\");","            label.className = Y.Lang.trim([label.className, \"axisLabel\"].join(' '));","            this.get(\"contentBox\").append(label);","        }","        if(!DOCUMENT.createElementNS)","        {","            if(label.style.filter)","            {","                label.style.filter = null;","            }","        }","        label.style.display = \"block\";","        label.style.whiteSpace = \"nowrap\";","        label.style.position = \"absolute\";","        for(i in styles)","        {","            if(styles.hasOwnProperty(i) && !customStyles.hasOwnProperty(i))","            {","                label.style[i] = styles[i];","            }","        }","        return label;","    },","","    /**","     * Creates a cache of labels that can be re-used when the axis redraws.","     *","     * @method _createLabelCache","     * @private","     */","    _createLabelCache: function()","    {","        if(this._labels)","        {","            while(this._labels.length > 0)","            {","                this._labelCache.push(this._labels.shift());","            }","        }","        else","        {","            this._clearLabelCache();","        }","        this._labels = [];","    },","    ","    /**","     * Removes axis labels from the dom and clears the label cache.","     *","     * @method _clearLabelCache","     * @private","     */","    _clearLabelCache: function()","    {","        if(this._labelCache)","        {","            var len = this._labelCache.length,","                i = 0,","                label;","            for(; i < len; ++i)","            {","                label = this._labelCache[i];","                this._removeChildren(label);","                Y.Event.purgeElement(label, true);","                label.parentNode.removeChild(label);","            }","        }","        this._labelCache = [];","    },","","    /**","     * Gets the end point of an axis.","     *","     * @method getLineEnd","     * @return Object","     * @private ","     */","    getLineEnd: function(pt)","    {","        var w = this.get(\"width\"),","            h = this.get(\"height\"),","            pos = this.get(\"position\");","        if(pos === \"top\" || pos === \"bottom\")","        {","            return {x:w, y:pt.y};","        }","        else","        {","            return {x:pt.x, y:h};","        }","    },","","    /**","     * Calcuates the width or height of an axis depending on its direction.","     *","     * @method getLength","     * @return Number","     * @private","     */","    getLength: function()","    {","        var l,","            style = this.get(\"styles\"),","            padding = style.padding,","            w = this.get(\"width\"),","            h = this.get(\"height\"),","            pos = this.get(\"position\");","        if(pos === \"top\" || pos === \"bottom\")","        {","            l = w - (padding.left + padding.right);","        }","        else","        {","            l = h - (padding.top + padding.bottom);","        }","        return l;","    },","","    /**","     * Gets the position of the first point on an axis.","     *","     * @method getFirstPoint","     * @param {Object} pt Object containing x and y coordinates.","     * @return Object","     * @private","     */","    getFirstPoint:function(pt)","    {","        var style = this.get(\"styles\"),","            pos = this.get(\"position\"),","            padding = style.padding,","            np = {x:pt.x, y:pt.y};","        if(pos === \"top\" || pos === \"bottom\")","        {","            np.x += padding.left + this.get(\"edgeOffset\");","        }","        else","        {","            np.y += this.get(\"height\") - (padding.top + this.get(\"edgeOffset\"));","        }","        return np;","    },","","    /**","     * Gets the position of the next point on an axis.","     *","     * @method getNextPoint","     * @param {Object} point Object containing x and y coordinates.","     * @param {Number} majorUnitDistance Distance in pixels between ticks.","     * @return Object","     * @private","     */","    getNextPoint: function(point, majorUnitDistance)","    {","        var pos = this.get(\"position\");","        if(pos === \"top\" || pos === \"bottom\")","        {","            point.x = point.x + majorUnitDistance;		","        }","        else","        {","            point.y = point.y - majorUnitDistance;","        }","        return point;","    },","","    /**","     * Calculates the placement of last tick on an axis.","     *","     * @method getLastPoint","     * @return Object","     * @private ","     */","    getLastPoint: function()","    {","        var style = this.get(\"styles\"),","            padding = style.padding,","            w = this.get(\"width\"),","            pos = this.get(\"position\");","        if(pos === \"top\" || pos === \"bottom\")","        {","            return {x:w - padding.right, y:padding.top};","        }","        else","        {","            return {x:padding.left, y:padding.top};","        }","    },","","    /**","     * Calculates position on the axis.","     *","     * @method getPosition","     * @param {Object} point contains x and y values","     * @private ","     */","    getPosition: function(point)","    {","        var p,","            h = this.get(\"height\"),","            style = this.get(\"styles\"),","            padding = style.padding,","            pos = this.get(\"position\"),","            dataType = this.get(\"dataType\");","        if(pos === \"left\" || pos === \"right\") ","        {","            //Numeric data on a vertical axis is displayed from bottom to top.","            //Categorical and Timeline data is displayed from top to bottom.","            if(dataType === \"numeric\")","            {","                p = (h - (padding.top + padding.bottom)) - (point.y - padding.top);","            }","            else","            {","                p = point.y - padding.top;","            }","        }","        else","        {","            p = point.x - padding.left;","        }","        return p;","    },","","    /**","     * Rotates and positions a text field.","     *","     * @method _rotate","     * @param {HTMLElement} label text field to rotate and position","     * @param {Object} props properties to be applied to the text field. ","     * @private","     */","    _rotate: function(label, props)","    {","        var rot = props.rot,","            x = props.x,","            y = props.y,","            filterString,","            textAlpha,","            matrix = new Y.Matrix(),","            transformOrigin = props.transformOrigin || [0, 0],","            offsetRect;","        if(DOCUMENT.createElementNS)","        {","            matrix.translate(x, y);","            matrix.rotate(rot);","            label.style.MozTransformOrigin = (transformOrigin[0] * 100) + \"% \" + (transformOrigin[1] * 100) + \"%\";","            label.style.MozTransform = matrix.toCSSText();","            label.style.webkitTransformOrigin = (transformOrigin[0] * 100) + \"% \" + (transformOrigin[1] * 100) + \"%\";","            label.style.webkitTransform = matrix.toCSSText();","            label.style.msTransformOrigin = (transformOrigin[0] * 100) + \"% \" + (transformOrigin[1] * 100) + \"%\";","            label.style.msTransform = matrix.toCSSText();","            label.style.OTransformOrigin = (transformOrigin[0] * 100) + \"% \" + (transformOrigin[1] * 100) + \"%\";","            label.style.OTransform = matrix.toCSSText();","        }","        else","        {","            textAlpha = props.textAlpha;","            if(Y_Lang.isNumber(textAlpha) && textAlpha < 1 && textAlpha > -1 && !isNaN(textAlpha))","            {","                filterString = \"progid:DXImageTransform.Microsoft.Alpha(Opacity=\" + Math.round(textAlpha * 100) + \")\";","            }","            if(rot !== 0)","            {","                //ms filters kind of, sort of uses a transformOrigin of 0, 0. ","                //we'll translate the difference to create a true 0, 0 origin.","                matrix.rotate(rot);","                offsetRect = matrix.getContentRect(props.labelWidth, props.labelHeight);","                matrix.init();","                matrix.translate(offsetRect.left, offsetRect.top);","                matrix.translate(x, y);","                this._simulateRotateWithTransformOrigin(matrix, rot, transformOrigin, props.labelWidth, props.labelHeight);","                if(filterString)","                {","                    filterString += \" \";","                }","                else","                {","                    filterString = \"\"; ","                }","                filterString += matrix.toFilterText();","                label.style.left = matrix.dx + \"px\";","                label.style.top = matrix.dy + \"px\";","            }","            else","            {","                label.style.left = x + \"px\";","                label.style.top = y + \"px\";","            }","            if(filterString)","            {","                label.style.filter = filterString;","            }","        }","    },","    ","    /**","     * Simulates a rotation with a specified transformOrigin. ","     *","     * @method _simulateTransformOrigin","     * @param {Matrix} matrix Reference to a `Matrix` instance.","     * @param {Number} rot The rotation (in degrees) that will be performed on a matrix.","     * @param {Array} transformOrigin An array represeniting the origin in which to perform the transform. The first ","     * index represents the x origin and the second index represents the y origin.","     * @param {Number} w The width of the object that will be transformed.","     * @param {Number} h The height of the object that will be transformed.","     * @private","     */","    _simulateRotateWithTransformOrigin: function(matrix, rot, transformOrigin, w, h)","    {","        var transformX = transformOrigin[0] * w,","            transformY = transformOrigin[1] * h;","        transformX = !isNaN(transformX) ? transformX : 0;","        transformY = !isNaN(transformY) ? transformY : 0;","        matrix.translate(transformX, transformY);","        matrix.rotate(rot);","        matrix.translate(-transformX, -transformY);","    },","","    /**","     * Returns the coordinates (top, right, bottom, left) for the bounding box of the last label. ","     *","     * @method getMaxLabelBounds","     * @return Object","     */","    getMaxLabelBounds: function()","    {","        return this._getLabelBounds(this.getMaximumValue());","    },","","    /**","     * Returns the coordinates (top, right, bottom, left) for the bounding box of the first label. ","     *","     * @method getMinLabelBounds","     * @return Object","     */","    getMinLabelBounds: function()","    {","        return this._getLabelBounds(this.getMinimumValue());","    },","    ","    /**","     * Returns the coordinates (top, right, bottom, left) for the bounding box of a label. ","     *","     * @method _getLabelBounds","     * @param {String} Value of the label","     * @return Object","     * @private","     */","    _getLabelBounds: function(val)","    {","        var layout = this._layout,","            labelStyles = this.get(\"styles\").label,","            matrix = new Y.Matrix(),","            label,","            props = this._getTextRotationProps(labelStyles);","            props.transformOrigin = layout._getTransformOrigin(props.rot);","        label = this.getLabel({x: 0, y: 0}, labelStyles);","        this.get(\"appendLabelFunction\")(label, this.get(\"labelFunction\").apply(this, [val, this.get(\"labelFormat\")]));","        props.labelWidth = label.offsetWidth;","        props.labelHeight = label.offsetHeight;","        this._removeChildren(label);","        Y.Event.purgeElement(label, true);","        label.parentNode.removeChild(label);","        props.x = 0;","        props.y = 0;","        layout._setRotationCoords(props);","        matrix.translate(props.x, props.y);","        this._simulateRotateWithTransformOrigin(matrix, props.rot, props.transformOrigin, props.labelWidth, props.labelHeight);","        return matrix.getContentRect(props.labelWidth, props.labelHeight);","    },","","    /**","     * Removes all DOM elements from an HTML element. Used to clear out labels during detruction","     * phase.","     *","     * @method _removeChildren","     * @private","     */","    _removeChildren: function(node)","    {","        if(node.hasChildNodes())","        {","            var child;","            while(node.firstChild)","            {","                child = node.firstChild;","                this._removeChildren(child);","                node.removeChild(child);","            }","        }","    },","    ","    /**","     * Destructor implementation Axis class. Removes all labels and the Graphic instance from the widget.","     *","     * @method destructor","     * @protected","     */","    destructor: function()","    {","        var cb = this.get(\"contentBox\").getDOMNode(),","            labels = this.get(\"labels\"),","            graphic = this.get(\"graphic\"),","            label,","            len = labels ? labels.length : 0;","        if(len > 0)","        {","            while(labels.length > 0)","            {","                label = labels.shift();","                this._removeChildren(label);","                cb.removeChild(label);","                label = null;","            }","        }","        if(graphic)","        {","            graphic.destroy();","        }","    },","","    /**","     * Length in pixels of largest text bounding box. Used to calculate the height of the axis.","     *","     * @property maxLabelSize","     * @type Number","     * @protected","     */","    _maxLabelSize: 0,","    ","    /**","     * Updates the content of text field. This method writes a value into a text field using ","     * `appendChild`. If the value is a `String`, it is converted to a `TextNode` first. ","     *","     * @method _setText","     * @param label {HTMLElement} label to be updated","     * @param val {String} value with which to update the label","     * @private","     */","    _setText: function(textField, val)","    { ","        textField.innerHTML = \"\";","        if(Y_Lang.isNumber(val))","        {","            val = val + \"\";","        }","        else if(!val)","        {","            val = \"\";","        }","        if(IS_STRING(val))","        {","            val = DOCUMENT.createTextNode(val);","        }","        textField.appendChild(val);","    }","}, {","    ATTRS: ","    {","        /**","         * When set, defines the width of a vertical axis instance. By default, vertical axes automatically size based on their contents. When the","         * width attribute is set, the axis will not calculate its width. When the width attribute is explicitly set, axis labels will postion themselves off of the ","         * the inner edge of the axis and the title, if present, will position itself off of the outer edge. If a specified width is less than the sum of ","         * the axis' contents, excess content will overflow.","         *","         * @attribute width","         * @type Number","         */","        width: {","            lazyAdd: false,","","            getter: function() ","            {","                if(this._explicitWidth)","                {","                    return this._explicitWidth;        ","                }","                return this._calculatedWidth;","            },","","            setter: function(val)","            {","                this._explicitWidth = val;","                return val;","            }","        },","","        /**","         * When set, defines the height of a horizontal axis instance. By default, horizontal axes automatically size based on their contents. When the","         * height attribute is set, the axis will not calculate its height. When the height attribute is explicitly set, axis labels will postion themselves off of the ","         * the inner edge of the axis and the title, if present, will position itself off of the outer edge. If a specified height is less than the sum of ","         * the axis' contents, excess content will overflow.","         *","         * @attribute height","         * @type Number","         */","        height: {","            lazyAdd: false,","","            getter: function() ","            {","                if(this._explicitHeight)","                {","                    return this._explicitHeight;        ","                }","                return this._calculatedHeight;","            },","","            setter: function(val)","            {","                this._explicitHeight = val;","                return val;","            }","        },","","        /**","         * Calculated value of an axis' width. By default, the value is used internally for vertical axes. If the `width` attribute is explicitly set, this value will be ignored.","         *","         * @attribute calculatedWidth","         * @type Number","         * @private","         */","        calculatedWidth: {","            getter: function()","            {","                return this._calculatedWidth;","            },","","            setter: function(val)","            {","                this._calculatedWidth = val;","                return val;","            }","        },","","        /**","         * Calculated value of an axis' height. By default, the value is used internally for horizontal axes. If the `height` attribute is explicitly set, this value will be ignored.","         *","         * @attribute calculatedHeight","         * @type Number","         * @private","         */","        calculatedHeight: {","            getter: function()","            {","                return this._calculatedHeight;","            },","","            setter: function(val)","            {","                this._calculatedHeight = val;","                return val;","            }","        },","","        /**","         * Difference betweend the first/last tick and edge of axis.","         *","         * @attribute edgeOffset","         * @type Number","         * @protected","         */","        edgeOffset: ","        {","            value: 0","        },","","        /**","         * The graphic in which the axis line and ticks will be rendered.","         *","         * @attribute graphic","         * @type Graphic","         */","        graphic: {},","    ","        /**","         *  @attribute path","         *  @type Shape","         *  @readOnly","         *  @private","         */","        path: {","            readOnly: true,","","            getter: function()","            {","                if(!this._path)","                {","                    var graphic = this.get(\"graphic\");","                    if(graphic)","                    {","                        this._path = graphic.addShape({type:\"path\"});","                    }","                }","                return this._path;","            }","        },","","        /**","         *  @attribute tickPath","         *  @type Shape","         *  @readOnly","         *  @private","         */","        tickPath: {","            readOnly: true,","","            getter: function()","            {","                if(!this._tickPath)","                {","                    var graphic = this.get(\"graphic\");","                    if(graphic)","                    {","                        this._tickPath = graphic.addShape({type:\"path\"});","                    }","                }","                return this._tickPath;","            }","        },","        ","        /**","         * Contains the contents of the axis. ","         *","         * @attribute node","         * @type HTMLElement","         */","        node: {},","","        /**","         * Direction of the axis.","         *","         * @attribute position","         * @type String","         */","        position: {","            setter: function(val)","            {","                var layoutClass = this._layoutClasses[val];","                if(val && val != \"none\")","                {","                    this._layout = new layoutClass();","                }","                return val;","            }","        },","","        /**","         * Distance determined by the tick styles used to calculate the distance between the axis","         * line in relation to the top of the axis.","         *","         * @attribute topTickOffset","         * @type Number","         */","        topTickOffset: {","            value: 0","        },","","        /**","         * Distance determined by the tick styles used to calculate the distance between the axis","         * line in relation to the bottom of the axis.","         *","         * @attribute bottomTickOffset","         * @type Number","         */","        bottomTickOffset: {","            value: 0","        },","","        /**","         * Distance determined by the tick styles used to calculate the distance between the axis","         * line in relation to the left of the axis.","         *","         * @attribute leftTickOffset","         * @type Number","         */","        leftTickOffset: {","            value: 0","        },","","        /**","         * Distance determined by the tick styles used to calculate the distance between the axis","         * line in relation to the right side of the axis.","         *","         * @attribute rightTickOffset","         * @type Number","         */","        rightTickOffset: {","            value: 0","        },","        ","        /**","         * Collection of labels used to render the axis.","         *","         * @attribute labels","         * @type Array","         */","        labels: {","            readOnly: true,","            getter: function()","            {","                return this._labels;","            }","        },","","        /**","         * Collection of points used for placement of labels and ticks along the axis.","         *","         * @attribute tickPoints","         * @type Array","         */","        tickPoints: {","            readOnly: true,","","            getter: function()","            {","                if(this.get(\"position\") == \"none\")","                {","                    return this.get(\"styles\").majorUnit.count;","                }","                return this._tickPoints;","            }","        },","","        /**","         * Indicates whether the axis overlaps the graph. If an axis is the inner most axis on a given","         * position and the tick position is inside or cross, the axis will need to overlap the graph.","         *","         * @attribute overlapGraph","         * @type Boolean","         */","        overlapGraph: {","            value:true,","","            validator: function(val)","            {","                return Y_Lang.isBoolean(val);","            }","        },","","        /**","         * Object which should have by the labelFunction","         *","         * @attribute labelFunctionScope","         * @type Object","         */","        labelFunctionScope: {},","        ","        /**","         * Length in pixels of largest text bounding box. Used to calculate the height of the axis.","         *","         * @attribute maxLabelSize","         * @type Number","         * @protected","         */","        maxLabelSize: {","            getter: function()","            {","                return this._maxLabelSize;","            },","","            setter: function(val)","            {","                this._maxLabelSize = val;","                return val; ","            }","        },","        ","        /**","         *  Title for the axis. When specified, the title will display. The position of the title is determined by the axis position. ","         *  <dl>","         *      <dt>top</dt><dd>Appears above the axis and it labels. The default rotation is 0.</dd>","         *      <dt>right</dt><dd>Appears to the right of the axis and its labels. The default rotation is 90.</dd>","         *      <dt>bottom</dt><dd>Appears below the axis and its labels. The default rotation is 0.</dd>","         *      <dt>left</dt><dd>Appears to the left of the axis and its labels. The default rotation is -90.</dd>","         *  </dl>","         *","         *  @attribute title","         *  @type String","         */","        title: {","            value: null","        },","        ","        /**","         * Method used for formatting a label. This attribute allows for the default label formatting method to overridden. The method use would need","         * to implement the arguments below and return a `String` or `HTMLElement`. ","         * <dl>","         *      <dt>val</dt><dd>Label to be formatted. (`String`)</dd>","         *      <dt>format</dt><dd>Template for formatting label. (optional)</dd>","         * </dl>","         *","         * @attribute labelFunction","         * @type Function","         */","        labelFunction: {","            value: function(val, format)","            {","                return val;","            }","        },","        ","        /**","         * Function used to append an axis value to an axis label. This function has the following signature:","         *  <dl>","         *      <dt>textField</dt><dd>The axis label to be appended. (`HTMLElement`)</dd>","         *      <dt>val</dt><dd>The value to attach to the text field. This method will accept an `HTMLELement`","         *      or a `String`. This method does not use (`HTMLElement` | `String`)</dd>","         *  </dl>","         * The default method appends a value to the `HTMLElement` using the `appendChild` method. If the given ","         * value is a `String`, the method will convert the the value to a `textNode` before appending to the ","         * `HTMLElement`. This method will not convert an `HTMLString` to an `HTMLElement`. ","         *","         * @attribute appendLabelFunction","         * @type Function","         */","        appendLabelFunction: {","            valueFn: function()","            {","                return this._setText;","            }","        },","        ","        /**","         * Function used to append a title value to the title object. This function has the following signature:","         *  <dl>","         *      <dt>textField</dt><dd>The title text field to be appended. (`HTMLElement`)</dd>","         *      <dt>val</dt><dd>The value to attach to the text field. This method will accept an `HTMLELement`","         *      or a `String`. This method does not use (`HTMLElement` | `String`)</dd>","         *  </dl>","         * The default method appends a value to the `HTMLElement` using the `appendChild` method. If the given ","         * value is a `String`, the method will convert the the value to a `textNode` before appending to the ","         * `HTMLElement` element. This method will not convert an `HTMLString` to an `HTMLElement`. ","         *","         * @attribute appendTitleFunction","         * @type Function","         */","        appendTitleFunction: {","            valueFn: function()","            {","                return this._setText;","            }","        }","            ","        /**","         * Style properties used for drawing an axis. This attribute is inherited from `Renderer`. Below are the default values:","         *  <dl>","         *      <dt>majorTicks</dt><dd>Properties used for drawing ticks.","         *          <dl>","         *              <dt>display</dt><dd>Position of the tick. Possible values are `inside`, `outside`, `cross` and `none`. The","         *              default value is `inside`.</dd>","         *              <dt>length</dt><dd>The length (in pixels) of the tick. The default value is 4.</dd>","         *              <dt>color</dt><dd>The color of the tick. The default value is `#dad8c9`</dd>","         *              <dt>weight</dt><dd>Number indicating the width of the tick. The default value is 1.</dd>","         *              <dt>alpha</dt><dd>Number from 0 to 1 indicating the opacity of the tick. The default value is 1.</dd>","         *          </dl>","         *      </dd>","         *      <dt>line</dt><dd>Properties used for drawing the axis line. ","         *          <dl>","         *              <dt>weight</dt><dd>Number indicating the width of the axis line. The default value is 1.</dd>","         *              <dt>color</dt><dd>The color of the axis line. The default value is `#dad8c9`.</dd>","         *              <dt>alpha</dt><dd>Number from 0 to 1 indicating the opacity of the tick. The default value is 1.</dd>","         *          </dl>","         *      </dd>","         *      <dt>majorUnit</dt><dd>Properties used to calculate the `majorUnit` for the axis. ","         *          <dl>","         *              <dt>determinant</dt><dd>The algorithm used for calculating distance between ticks. The possible options are `count` and `distance`. If","         *              the `determinant` is `count`, the axis ticks will spaced so that a specified number of ticks appear on the axis. If the `determinant`","         *              is `distance`, the axis ticks will spaced out according to the specified distance. The default value is `count`.</dd>","         *              <dt>count</dt><dd>Number of ticks to appear on the axis when the `determinant` is `count`. The default value is 11.</dd>","         *              <dt>distance</dt><dd>The distance (in pixels) between ticks when the `determinant` is `distance`. The default value is 75.</dd>","         *          </dl>","         *      </dd>","         *      <dt>label</dt><dd>Properties and styles applied to the axis labels.","         *          <dl>","         *              <dt>color</dt><dd>The color of the labels. The default value is `#808080`.</dd>","         *              <dt>alpha</dt><dd>Number between 0 and 1 indicating the opacity of the labels. The default value is 1.</dd>","         *              <dt>fontSize</dt><dd>The font-size of the labels. The default value is 85%</dd>","         *              <dt>rotation</dt><dd>The rotation, in degrees (between -90 and 90) of the labels. The default value is 0.</dd>","         *              <dt>margin</dt><dd>The distance between the label and the axis/tick. Depending on the position of the `Axis`, only one of the properties used.","         *                  <dl>","         *                      <dt>top</dt><dd>Pixel value used for an axis with a `position` of `bottom`. The default value is 4.</dd>","         *                      <dt>right</dt><dd>Pixel value used for an axis with a `position` of `left`. The default value is 4.</dd>","         *                      <dt>bottom</dt><dd>Pixel value used for an axis with a `position` of `top`. The default value is 4.</dd>","         *                      <dt>left</dt><dd>Pixel value used for an axis with a `position` of `right`. The default value is 4.</dd>","         *                  </dl>","         *              </dd>","         *          </dl>","         *      </dd>","         *  </dl>","         *","         * @attribute styles","         * @type Object","         */","    }","});","/**"," * AxisType is an abstract class that manages the data for an axis."," *"," * @module charts"," * @submodule charts-base"," * @class AxisType"," * @constructor"," * @extends Axis"," */","Y.AxisType = Y.Base.create(\"baseAxis\", Y.Axis, [], {","    /**","     * @method initializer","     * @private","     */","    initializer: function()","    {","        this.after(\"dataReady\", Y.bind(this._dataChangeHandler, this));","        this.after(\"dataUpdate\", Y.bind(this._dataChangeHandler, this));","        this.after(\"minimumChange\", Y.bind(this._keyChangeHandler, this));","        this.after(\"maximumChange\", Y.bind(this._keyChangeHandler, this));","        this.after(\"keysChange\", this._keyChangeHandler);","        this.after(\"dataProviderChange\", this._dataProviderChangeHandler);","        this.after(\"alwaysShowZeroChange\", this._keyChangeHandler);","        this.after(\"roundingMethodChange\", this._keyChangeHandler);","    },","","    /**","     * @method bindUI","     * @private","     */","    bindUI: function()","    {","        this.after(\"stylesChange\", this._updateHandler);","        this.after(\"overlapGraphChange\", this._updateHandler);","        this.after(\"positionChange\", this._positionChangeHandler);","        this.after(\"widthChange\", this._handleSizeChange);","        this.after(\"heightChange\", this._handleSizeChange);","        this.after(\"calculatedWidthChange\", this._handleSizeChange);","        this.after(\"calculatedHeightChange\", this._handleSizeChange);","    },","","    /**","     * Handles changes to `dataProvider`.","     *","     * @method _dataProviderChangeHandler","     * @param {Object} e Event object.","     * @private","     */","    _dataProviderChangeHandler: function(e)","    {","        var keyCollection = this.get(\"keyCollection\").concat(),","            keys = this.get(\"keys\"),","            i;","        if(keys)","        {","            for(i in keys)","            {","                if(keys.hasOwnProperty(i))","                {","                    delete keys[i];","                }","            }","        }","        if(keyCollection && keyCollection.length)","        {","            this.set(\"keys\", keyCollection);","        }","    },","","    /**","     * Constant used to generate unique id.","     *","     * @property GUID","     * @type String","     * @private","     */","    GUID: \"yuibaseaxis\",","	","    /**","     * Type of data used in `Axis`.","     *","     * @property _type","     * @type String ","     * @readOnly","     * @private","     */","    _type: null,","	","    /**","     * Storage for `setMaximum` attribute.","     *","     * @property _setMaximum","     * @type Object","     * @private","     */","    _setMaximum: null,","	","    /**","     * Storage for `dataMaximum` attribute.","     *","     * @property _dataMaximum","     * @type Object","     * @private","     */","    _dataMaximum: null,","	","    /**","     * Storage for `setMinimum` attribute.","     *","     * @property _setMinimum","     * @type Object","     * @private","     */","    _setMinimum: null,","	","    /**","     * Reference to data array.","     *","     * @property _data","     * @type Array","     * @private","     */","    _data: null,","","    /**","     * Indicates whether the all data is up to date.","     *","     * @property _updateTotalDataFlag","     * @type Boolean","     * @private","     */","    _updateTotalDataFlag: true,","","    /**","     * Storage for `dataReady` attribute.","     *","     * @property _dataReady","     * @type Boolean","     * @readOnly","     * @private","     */","    _dataReady: false,","	","    /**","     * Adds an array to the key hash.","     *","     * @method addKey","     * @param value Indicates what key to use in retrieving","     * the array.","     */","    addKey: function (value)","	{","        this.set(\"keys\", value);","	},","","    /**","     * Gets an array of values based on a key.","     *","     * @method _getKeyArray","     * @param {String} key Value key associated with the data array.","     * @param {Array} data Array in which the data resides.","     * @return Array","     * @private","     */","    _getKeyArray: function(key, data)","    {","        var i = 0,","            obj,","            keyArray = [],","            len = data.length;","        for(; i < len; ++i)","        {","            obj = data[i];","            keyArray[i] = obj[key];","        }","        return keyArray;","    },","","    /**","     * Sets data by key","     *","     * @method _setDataByKey","     * @param {String} key Key value to use.","     * @param {Array} data Array to use.","     * @private ","     */","    _setDataByKey: function(key, data)","    {","        var i,","            obj, ","            arr = [], ","            dv = this._dataClone.concat(), ","            len = dv.length;","        for(i = 0; i < len; ++i)","        {","            obj = dv[i];","            arr[i] = obj[key];","        }","        this.get(\"keys\")[key] = arr;","        this._updateTotalDataFlag = true;","    },","","    /**","     * Updates the total data array.","     *","     * @method _updateTotalData","     * @private","     */","    _updateTotalData: function()","    {","		var keys = this.get(\"keys\"),","            i;","        this._data = [];","        for(i in keys)","        {","            if(keys.hasOwnProperty(i))","            {","                this._data = this._data.concat(keys[i]);","            }","        }","        this._updateTotalDataFlag = false;","    },","","    /**","     * Removes an array from the key hash.","     * ","     * @method removeKey","     * @param {String} value Indicates what key to use in removing from ","     * the hash.","     */","    removeKey: function(value)","    {","        var keys = this.get(\"keys\");","        if(keys.hasOwnProperty(value)) ","        {","            delete keys[value];","            this._keyChangeHandler();","        }","    },","","    /**","     * Returns a value based of a key value and an index.","     *","     * @method getKeyValueAt","     * @param {String} key value used to look up the correct array","     * @param {Number} index within the array","     * @return Number ","     */","    getKeyValueAt: function(key, index)","    {","        var value = NaN,","            keys = this.get(\"keys\");","        if(keys[key] && Y_Lang.isNumber(parseFloat(keys[key][index])))","        {","            value = keys[key][index];","        }","        return parseFloat(value);","    },","","    /**","     * Returns an array of values based on an identifier key.","     *","     * @method getDataByKey","     * @param {String} value value used to identify the array","     * @return Object","     */","    getDataByKey: function (value)","    {","        var keys = this.get(\"keys\");","        if(keys[value])","        {","            return keys[value];","        }","        return null;","    },","","    /**","     * Calculates the maximum and minimum values for the `Axis`.","     *","     * @method _updateMinAndMax","     * @private ","     */","    _updateMinAndMax: function() ","    {","        var data = this.get(\"data\"),","            max = 0,","            min = 0,","            len,","            num,","            i;","        if(data && data.length && data.length > 0)","        {","            len = data.length;","            max = min = data[0];","            if(len > 1)","            {","                for(i = 1; i < len; i++)","                {	","                    num = data[i];","                    if(isNaN(num))","                    {","                        continue;","                    }","                    max = Math.max(num, max);","                    min = Math.min(num, min);","                }","            }","        }","        this._dataMaximum = max;","        this._dataMinimum = min;","    },","","    /**","     * Returns the total number of majorUnits that will appear on an axis.","     *","     * @method getTotalMajorUnits","     * @return Number","     */","    getTotalMajorUnits: function()","    {","        var units,","            majorUnit = this.get(\"styles\").majorUnit,","            len = this.get(\"length\");","        if(majorUnit.determinant === \"count\") ","        {","            units = majorUnit.count;","        }","        else if(majorUnit.determinant === \"distance\") ","        {","            units = (len/majorUnit.distance) + 1;","        }","        return units; ","    },","","    /**","     * Returns the distance between major units on an axis.","     *","     * @method getMajorUnitDistance","     * @param {Number} len Number of ticks","     * @param {Number} uiLen Size of the axis.","     * @param {Object} majorUnit Hash of properties used to determine the majorUnit","     * @return Number","     */","    getMajorUnitDistance: function(len, uiLen, majorUnit)","    {","        var dist;","        if(majorUnit.determinant === \"count\")","        {","            dist = uiLen/(len - 1);","        }","        else if(majorUnit.determinant === \"distance\")","        {","            dist = majorUnit.distance;","        }","        return dist;","    },","    ","    /**","     * Gets the distance that the first and last ticks are offset from there respective","     * edges.","     *","     * @method getEdgeOffset","     * @param {Number} ct Number of ticks on the axis.","     * @param {Number} l Length (in pixels) of the axis.","     * @return Number","     */","    getEdgeOffset: function(ct, l)","    {","        return 0;","    },","","    /**","     * Calculates and returns a value based on the number of labels and the index of","     * the current label.","     *","     * @method getLabelByIndex","     * @param {Number} i Index of the label.","     * @param {Number} l Total number of labels.","     * @return String","     */","    getLabelByIndex: function(i, l)","    {","        var min = this.get(\"minimum\"),","            max = this.get(\"maximum\"),","            increm = (max - min)/(l-1),","            label;","            l -= 1;","        label = min + (i * increm);","        return label;","    },","","    /**","     * Updates the `Axis` after a change in keys.","     *","     * @method _keyChangeHandler","     * @param {Object} e Event object.","     * @private","     */","    _keyChangeHandler: function(e)","    {","        this._updateMinAndMax();","        this.fire(\"dataUpdate\");","    },","","    /**","     * Checks to see if data extends beyond the range of the axis. If so,","     * that data will need to be hidden. This method is internal, temporary and subject","     * to removal in the future.","     *","     * @method _hasDataOverflow","     * @protected","     * @return Boolean","     */","    _hasDataOverflow: function()","    {","        if(this.get(\"setMin\") || this.get(\"setMax\"))","        {","            return true;","        }","        return false;","    },","","    /**","     * Returns a string corresponding to the first label on an ","     * axis.","     *","     * @method getMinimumValue","     * @return String","     */","    getMinimumValue: function()","    {","        return this.get(\"minimum\");","    },","","    /**","     * Returns a string corresponding to the last label on an ","     * axis.","     *","     * @method getMaximumValue","     * @return String","     */","    getMaximumValue: function()","    {","        return this.get(\"maximum\");","    }","}, {","    ATTRS: {","        /**","         * Hash of array identifed by a string value.","         *","         * @attribute keys","         * @type Object","         */","        keys: {","            value: {},","","            setter: function(val)","            {","                var keys = {},","                    i, ","                    len,","                    data = this.get(\"dataProvider\");","                if(Y_Lang.isArray(val))","                {","                    len = val.length;","                    for(i = 0; i < len; ++i)","                    {","                        keys[val[i]] = this._getKeyArray(val[i], data);   ","                    }","                    ","                }","                else if(Y_Lang.isString(val))","                {","                    keys = this.get(\"keys\");","                    keys[val] = this._getKeyArray(val, data);","                }","                else","                {","                    for(i in val)","                    {","                        if(val.hasOwnProperty(i))","                        {","                            keys[i] = this._getKeyArray(i, data);","                        }","                    }","                }","	            this._updateTotalDataFlag = true;","                return keys;","            }","        },","","        /**","         *Indicates how to round unit values.","         *  <dl>","         *      <dt>niceNumber</dt><dd>Units will be smoothed based on the number of ticks and data range.</dd>","         *      <dt>auto</dt><dd>If the range is greater than 1, the units will be rounded.</dd>","         *      <dt>numeric value</dt><dd>Units will be equal to the numeric value.</dd>","         *      <dt>null</dt><dd>No rounding will occur.</dd>","         *  </dl>","         *","         * @attribute roundingMethod","         * @type String","         * @default niceNumber","         */","        roundingMethod: {","            value: \"niceNumber\"","        },","","        /**","         *Returns the type of axis data","         *  <dl>","         *      <dt>time</dt><dd>Manages time data</dd>","         *      <dt>stacked</dt><dd>Manages stacked numeric data</dd>      ","         *      <dt>numeric</dt><dd>Manages numeric data</dd>","         *      <dt>category</dt><dd>Manages categorical data</dd>","         *  </dl>","         *","         * @attribute type","         * @type String","         */","        type:","        {","            readOnly: true,","","            getter: function ()","            {","                return this._type;","            }","        },","","        /**","         * Instance of `ChartDataProvider` that the class uses","         * to build its own data.","         *","         * @attribute dataProvider","         * @type Array","         */","        dataProvider:{","            setter: function (value)","            {","                return value;","            }","        },","","        /**","         * The maximum value contained in the `data` array. Used for","         * `maximum` when `autoMax` is true.","         *","         * @attribute dataMaximum","         * @type Number","         */","        dataMaximum: {","            getter: function ()","            {","                if(!this._dataMaximum)","                {   ","                    this._updateMinAndMax();","                }","                return this._dataMaximum;","            }","        },","","        /**","         * The maximum value that will appear on an axis.","         *","         * @attribute maximum","         * @type Number","         */","        maximum: {","            lazyAdd: false,","","            getter: function ()","            {","                var max = this.get(\"dataMaximum\"),","                    min = this.get(\"minimum\");","                //If all values are zero, force a range so that the Axis and related series","                //will still render.","                if(min === 0 && max === 0)","                {","                    max = 10;","                }","                if(Y_Lang.isNumber(this._setMaximum))","                {","                    max = this._setMaximum;","                }","                return parseFloat(max);","            },","            setter: function (value)","            {","                this._setMaximum = parseFloat(value);","                return value;","            }","        },","","        /**","         * The minimum value contained in the `data` array. Used for","         * `minimum` when `autoMin` is true.","         *","         * @attribute dataMinimum","         * @type Number","         */","        dataMinimum: {","            getter: function ()","            {","                if(!this._dataMinimum)","                {","                    this._updateMinAndMax();","                }","                return this._dataMinimum;","            }","        },","","        /**","         * The minimum value that will appear on an axis.","         *","         * @attribute minimum","         * @type Number","         */","        minimum: {","            lazyAdd: false,","","            getter: function ()","            {","                var min = this.get(\"dataMinimum\");","                if(Y_Lang.isNumber(this._setMinimum))","                {","                    min = this._setMinimum;","                }","                return parseFloat(min);","            },","            setter: function(val)","            {","                this._setMinimum = parseFloat(val);","                return val;","            }","        },","","        /**","         * Determines whether the maximum is calculated or explicitly ","         * set by the user.","         *","         * @attribute setMax","         * @type Boolean","         */","        setMax: {","            readOnly: true,","","            getter: function()","            {","                return Y_Lang.isNumber(this._setMaximum);","            }","        },","","        /**","         * Determines whether the minimum is calculated or explicitly","         * set by the user.","         *","         * @attribute setMin","         * @type Boolean","         */","        setMin: {","            readOnly: true,","","            getter: function()","            {","                return Y_Lang.isNumber(this._setMinimum);","            }","        },","","        /**","         * Array of axis data","         *","         * @attribute data","         * @type Array","         */","        data: {","            getter: function ()","            {","                if(!this._data || this._updateTotalDataFlag)","                {","                    this._updateTotalData();","                }","                return this._data;","            }","        },","","        /**","         * Array containing all the keys in the axis.","        ","         * @attribute keyCollection","         * @type Array","         */","        keyCollection: {","            getter: function()","            {","                var keys = this.get(\"keys\"),","                    i, ","                    col = [];","                for(i in keys)","                {","                    if(keys.hasOwnProperty(i))","                    {","                        col.push(i);","                    }","                }","                return col;","            },","            readOnly: true","        }","    }","});","/**"," * NumericAxis manages numeric data on an axis."," *"," * @module charts"," * @submodule charts-base"," * @class NumericAxis"," * @constructor"," * @param {Object} config (optional) Configuration parameters for the Chart."," * @extends AxisType"," */","function NumericAxis(config)","{","	NumericAxis.superclass.constructor.apply(this, arguments);","}","","NumericAxis.NAME = \"numericAxis\";","","NumericAxis.ATTRS = {","    /**","     * Indicates whether 0 should always be displayed.","     *","     * @attribute alwaysShowZero","     * @type Boolean","     */","	alwaysShowZero: {","	    value: true	","	},","    ","    /**","     * Method used for formatting a label. This attribute allows for the default label formatting method to overridden. The method use would need","     * to implement the arguments below and return a `String` or an `HTMLElement`. The default implementation of the method returns a `String`. The output of this method","     * will be rendered to the DOM using `appendChild`. If you override the `labelFunction` method and return an html string, you will also need to override the Axis' ","     * `appendLabelFunction` to accept html as a `String`.","     * <dl>","     *      <dt>val</dt><dd>Label to be formatted. (`String`)</dd>","     *      <dt>format</dt><dd>Object containing properties used to format the label. (optional)</dd>","     * </dl>","     *","     * @attribute labelFunction","     * @type Function","     */","    labelFunction: { ","        value: function(val, format)","        {","            if(format)","            {","                return Y.DataType.Number.format(val, format);","            }","            return val;","        }","    },","","    /**","     * Object containing properties used by the `labelFunction` to format a","     * label.","     *","     * @attribute labelFormat","     * @type Object","     */","    labelFormat: {","        value: {","            prefix: \"\",","            thousandsSeparator: \"\",","            decimalSeparator: \"\",","            decimalPlaces: \"0\",","            suffix: \"\"","        }","    }","};","","Y.extend(NumericAxis, Y.AxisType,","{","    /**","     * Formats a label based on the axis type and optionally specified format.","     *","     * @method formatLabel","     * @param {Object} value","     * @param {Object} format Pattern used to format the value.","     * @return String","     */","    formatLabel: function(val, format)","    {","        if(format)","        {","            return Y.DataType.Number.format(val, format);","        }","        return val;","    },","","    /**","     * Returns the sum of all values per key.","     *","     * @method getTotalByKey","     * @param {String} key The identifier for the array whose values will be calculated.","     * @return Number","     */","    getTotalByKey: function(key)","    {","        var total = 0,","            values = this.getDataByKey(key),","            i = 0,","            val,","            len = values ? values.length : 0;","        for(; i < len; ++i)","        {","           val = parseFloat(values[i]);","           if(!isNaN(val))","           {","                total += val;","           }","        }","        return total;","    },","","    /**","     * Type of data used in `Axis`.","     *","     * @property _type","     * @readOnly","     * @private","     */","    _type: \"numeric\",","","    /**","     * Helper method for getting a `roundingUnit` when calculating the minimum and maximum values.","     *","     * @method _getMinimumUnit","     * @param {Number} max Maximum number","     * @param {Number} min Minimum number","     * @param {Number} units Number of units on the axis","     * @return Number","     * @private","     */","    _getMinimumUnit:function(max, min, units)","    {","        return this._getNiceNumber(Math.ceil((max - min)/units));","    },","","    /**","     * Calculates a nice rounding unit based on the range.","     *","     * @method _getNiceNumber","     * @param {Number} roundingUnit The calculated rounding unit.","     * @return Number","     * @private","     */","    _getNiceNumber: function(roundingUnit)","    {","        var tempMajorUnit = roundingUnit,","            order = Math.ceil(Math.log(tempMajorUnit) * 0.4342944819032518),","            roundedMajorUnit = Math.pow(10, order),","            roundedDiff;","","        if (roundedMajorUnit / 2 >= tempMajorUnit) ","        {","            roundedDiff = Math.floor((roundedMajorUnit / 2 - tempMajorUnit) / (Math.pow(10,order-1)/2));","            tempMajorUnit = roundedMajorUnit/2 - roundedDiff*Math.pow(10,order-1)/2;","        }","        else ","        {","            tempMajorUnit = roundedMajorUnit;","        }","        if(!isNaN(tempMajorUnit))","        {","            return tempMajorUnit;","        }","        return roundingUnit;","","    },","","    /**","     * Calculates the maximum and minimum values for the `Axis`.","     *","     * @method _updateMinAndMax","     * @private ","     */","    _updateMinAndMax: function()","    {","        var data = this.get(\"data\"),","            max, ","            min,","            len,","            num,","            i = 0,","            key,","            setMax = this.get(\"setMax\"),","            setMin = this.get(\"setMin\");","        if(!setMax || !setMin)","        {","            if(data && data.length && data.length > 0)","            {","                len = data.length;","                for(; i < len; i++)","                {	","                    num = data[i];","                    if(isNaN(num))","                    {","                        if(Y_Lang.isObject(num))","                        {","                            min = max = 0;","                            //hloc values","                            for(key in num)","                            {","                               if(num.hasOwnProperty(key))","                               {","                                    max = Math.max(num[key], max);","                                    min = Math.min(num[key], min);","                               }","                            }","                        }","                        max = setMax ? this._setMaximum : max;","                        min = setMin ? this._setMinimum : min;","                        continue;","                    }","                    ","                    if(setMin)","                    {","                        min = this._setMinimum;","                    }","                    else if(min === undefined)","                    {","                        min = num;","                    }","                    else","                    {","                        min = Math.min(num, min); ","                    }","                    if(setMax)","                    {","                        max = this._setMaximum;","                    }","                    else if(max === undefined)","                    {","                        max = num;","                    }","                    else","                    {","                        max = Math.max(num, max);","                    }","                    ","                    this._actualMaximum = max;","                    this._actualMinimum = min;","                }","            }","            this._roundMinAndMax(min, max, setMin, setMax);","        }","    },","","    /**","     * Rounds the mimimum and maximum values based on the `roundingUnit` attribute.","     *","     * @method _roundMinAndMax","     * @param {Number} min Minimum value","     * @param {Number} max Maximum value","     * @private","     */","    _roundMinAndMax: function(min, max, setMin, setMax)","    {","        var roundingUnit,","            minimumRange,","            minGreaterThanZero = min >= 0,","            maxGreaterThanZero = max > 0,","            dataRangeGreater,","            maxRound,","            minRound,","            topTicks,","            botTicks,","            tempMax,","            tempMin,","            units = this.getTotalMajorUnits() - 1,","            alwaysShowZero = this.get(\"alwaysShowZero\"),","            roundingMethod = this.get(\"roundingMethod\"),","            useIntegers = (max - min)/units >= 1;","        if(roundingMethod)","        {","            if(roundingMethod == \"niceNumber\")","            {","                roundingUnit = this._getMinimumUnit(max, min, units);","                if(minGreaterThanZero && maxGreaterThanZero)","                {","                    if((alwaysShowZero || min < roundingUnit) && !setMin)","                    {","                        min = 0;","                        roundingUnit = this._getMinimumUnit(max, min, units);","                    }","                    else","                    {","                       min = this._roundDownToNearest(min, roundingUnit);","                    }","                    if(setMax)","                    {","                        if(!alwaysShowZero)","                        {","                            min = max - (roundingUnit * units);","                        }","                    }","                    else if(setMin)","                    {","                        max = min + (roundingUnit * units);","                    }","                    else","                    {","                        max = this._roundUpToNearest(max, roundingUnit);","                    }","                }","                else if(maxGreaterThanZero && !minGreaterThanZero)","                {","                    if(alwaysShowZero)","                    {","                        topTicks = Math.round(units/((-1 * min)/max + 1));","                        topTicks = Math.max(Math.min(topTicks, units - 1), 1);","                        botTicks = units - topTicks;","                        tempMax = Math.ceil( max/topTicks );","                        tempMin = Math.floor( min/botTicks ) * -1;","                        ","                        if(setMin)","                        {","                            while(tempMin < tempMax && botTicks >= 0)","                            {","                                botTicks--;","                                topTicks++;","                                tempMax = Math.ceil( max/topTicks );","                                tempMin = Math.floor( min/botTicks ) * -1;","                            }","                            //if there are any bottom ticks left calcualate the maximum by multiplying by the tempMin value","                            //if not, it's impossible to ensure that a zero is shown. skip it","                            if(botTicks > 0)","                            {","                                max = tempMin * topTicks;","                            }","                            else","                            {","                                max = min + (roundingUnit * units);","                            }","                        }","                        else if(setMax)","                        {","                            while(tempMax < tempMin && topTicks >= 0)","                            {","                                botTicks++;","                                topTicks--;","                                tempMin = Math.floor( min/botTicks ) * -1;","                                tempMax = Math.ceil( max/topTicks );","                            }","                            //if there are any top ticks left calcualate the minimum by multiplying by the tempMax value","                            //if not, it's impossible to ensure that a zero is shown. skip it","                            if(topTicks > 0)","                            {","                                min = tempMax * botTicks * -1;","                            }","                            else","                            {","                                min = max - (roundingUnit * units);","                            }","                        }","                        else","                        {","                            roundingUnit = Math.max(tempMax, tempMin);","                            roundingUnit = this._getNiceNumber(roundingUnit);  ","                            max = roundingUnit * topTicks;","                            min = roundingUnit * botTicks * -1;","                        }","                    }","                    else ","                    {","                        if(setMax)","                        {","                            min = max - (roundingUnit * units);","                        }","                        else if(setMin)","                        {","                            max = min + (roundingUnit * units);","                        }","                        else","                        {","                            min = this._roundDownToNearest(min, roundingUnit);","                            max = this._roundUpToNearest(max, roundingUnit);","                        }","                    }","                }","                else","                {","                    if(setMin)","                    {","                        if(alwaysShowZero)","                        {","                            max = 0;","                        }","                        else","                        {","                            max = min + (roundingUnit * units);","                        }","                    }","                    else if(!setMax)","                    {","                        if(alwaysShowZero || max === 0 || max + roundingUnit > 0)","                        {","                            max = 0;","                            roundingUnit = this._getMinimumUnit(max, min, units);","                            min = max - (roundingUnit * units);","                        }","                        else","                        {","                            min = this._roundDownToNearest(min, roundingUnit);","                            max = this._roundUpToNearest(max, roundingUnit);","                        }","                    }","                    else","                    {","                        min = max - (roundingUnit * units);","                    }","                }","            }","            else if(roundingMethod == \"auto\") ","            {","                if(minGreaterThanZero && maxGreaterThanZero)","                {","                    if((alwaysShowZero || min < (max-min)/units) && !setMin)","                    {","                        min = 0;","                    }","                ","                    roundingUnit = (max - min)/units;","                    if(useIntegers)","                    {","                        roundingUnit = Math.ceil(roundingUnit);","                    }","                    max = min + (roundingUnit * units);","                }","                else if(maxGreaterThanZero && !minGreaterThanZero)","                {","                    if(alwaysShowZero)","                    {","                        topTicks = Math.round( units / ( (-1 * min) /max + 1) );","                        topTicks = Math.max(Math.min(topTicks, units - 1), 1);","                        botTicks = units - topTicks;","","                        if(useIntegers)","                        {","                            tempMax = Math.ceil( max/topTicks );","                            tempMin = Math.floor( min/botTicks ) * -1;","                        }","                        else","                        {","                            tempMax = max/topTicks;","                            tempMin = min/botTicks * -1;","                        }","                        roundingUnit = Math.max(tempMax, tempMin);","                        max = roundingUnit * topTicks;","                        min = roundingUnit * botTicks * -1;","                    }","                    else","                    {","                        roundingUnit = (max - min)/units;","                        if(useIntegers)","                        {","                            roundingUnit = Math.ceil(roundingUnit);","                        }","                        min = this._roundDownToNearest(min, roundingUnit);","                        max = this._roundUpToNearest(max, roundingUnit);","                    }","                }","                else","                {","                    roundingUnit = (max - min)/units;","                    if(useIntegers)","                    {   ","                        roundingUnit = Math.ceil(roundingUnit);","                    }","                    if(alwaysShowZero || max === 0 || max + roundingUnit > 0)","                    {","                        max = 0;","                        roundingUnit = (max - min)/units;","                        if(useIntegers)","                        {","                            Math.ceil(roundingUnit);","                        }","                        min = max - (roundingUnit * units);","                    }","                    else","                    {","                        min = this._roundDownToNearest(min, roundingUnit);","                        max = this._roundUpToNearest(max, roundingUnit);","                    }","","                }","            }","            else if(!isNaN(roundingMethod) && isFinite(roundingMethod))","            {","                roundingUnit = roundingMethod;","                minimumRange = roundingUnit * units;","                dataRangeGreater = (max - min) > minimumRange;","                minRound = this._roundDownToNearest(min, roundingUnit);","                maxRound = this._roundUpToNearest(max, roundingUnit);","                if(setMax)","                {","                    min = max - minimumRange;","                }","                else if(setMin)","                {","                    max = min + minimumRange;","                }","                else if(minGreaterThanZero && maxGreaterThanZero)","                {","                    if(alwaysShowZero || minRound <= 0)","                    {","                        min = 0;","                    }","                    else","                    {","                        min = minRound;","                    }","                    max = min + minimumRange;","                }","                else if(maxGreaterThanZero && !minGreaterThanZero)","                {","                    min = minRound;","                    max = maxRound;","                }","                else","                {","                    if(alwaysShowZero || maxRound >= 0)","                    {","                        max = 0;","                    }","                    else","                    {","                        max = maxRound;","                    }","                    min = max - minimumRange;","                }","            }","        }","        this._dataMaximum = max;","        this._dataMinimum = min;","    },","","    /**","     * Calculates and returns a value based on the number of labels and the index of","     * the current label.","     *","     * @method getLabelByIndex","     * @param {Number} i Index of the label.","     * @param {Number} l Total number of labels.","     * @return String","     */","    getLabelByIndex: function(i, l)","    {","        var min = this.get(\"minimum\"),","            max = this.get(\"maximum\"),","            increm = (max - min)/(l-1),","            label,","            roundingMethod = this.get(\"roundingMethod\");","            l -= 1;","        //respect the min and max. calculate all other labels.","        if(i === 0)","        {","            label = min;","        }","        else if(i === l)","        {","            label = max;","        }","        else","        {","            label = (i * increm);","            if(roundingMethod == \"niceNumber\")","            {","                label = this._roundToNearest(label, increm);","            }","            label += min;","        }","        return parseFloat(label);","    },","","    /**","     * Rounds a Number to the nearest multiple of an input. For example, by rounding","     * 16 to the nearest 10, you will receive 20. Similar to the built-in function Math.round().","     *","     * @method _roundToNearest","     * @param {Number} number Number to round","     * @param {Number} nearest Multiple to round towards.","     * @return Number","     * @private","     */","    _roundToNearest: function(number, nearest)","    {","        nearest = nearest || 1;","        if(nearest === 0)","        {","            return number;","        }","        var roundedNumber = Math.round(this._roundToPrecision(number / nearest, 10)) * nearest;","        return this._roundToPrecision(roundedNumber, 10);","    },","	","    /**","     * Rounds a Number up to the nearest multiple of an input. For example, by rounding","     * 16 up to the nearest 10, you will receive 20. Similar to the built-in function Math.ceil().","     *","     * @method _roundUpToNearest","     * @param {Number} number Number to round","     * @param {Number} nearest Multiple to round towards.","     * @return Number","     * @private","     */","    _roundUpToNearest: function(number, nearest)","    {","        nearest = nearest || 1;","        if(nearest === 0)","        {","            return number;","        }","        return Math.ceil(this._roundToPrecision(number / nearest, 10)) * nearest;","    },","	","    /**","     * Rounds a Number down to the nearest multiple of an input. For example, by rounding","     * 16 down to the nearest 10, you will receive 10. Similar to the built-in function Math.floor().","     *","     * @method _roundDownToNearest","     * @param {Number} number Number to round","     * @param {Number} nearest Multiple to round towards.","     * @return Number","     * @private","     */","    _roundDownToNearest: function(number, nearest)","    {","        nearest = nearest || 1;","        if(nearest === 0)","        {","            return number;","        }","        return Math.floor(this._roundToPrecision(number / nearest, 10)) * nearest;","    },","","    /**","     * Rounds a number to a certain level of precision. Useful for limiting the number of","     * decimal places on a fractional number.","     *","     * @method _roundToPrecision","     * @param {Number} number Number to round","     * @param {Number} precision Multiple to round towards.","     * @return Number","     * @private","     */","    _roundToPrecision: function(number, precision)","    {","        precision = precision || 0;","        var decimalPlaces = Math.pow(10, precision);","        return Math.round(decimalPlaces * number) / decimalPlaces;","    },","    ","    /**","     * Checks to see if data extends beyond the range of the axis. If so,","     * that data will need to be hidden. This method is internal, temporary and subject","     * to removal in the future.","     *","     * @method _hasDataOverflow","     * @protected","     * @return Boolean","     */","    _hasDataOverflow: function()","    {","        var roundingMethod,","            min,","            max;","        if(this.get(\"setMin\") || this.get(\"setMax\"))","        {","            return true;","        }","        roundingMethod = this.get(\"roundingMethod\");","        min = this._actualMinimum;","        max = this._actualMaximum;","        if(Y_Lang.isNumber(roundingMethod) && ((Y_Lang.isNumber(max) && max > this._dataMaximum) || (Y_Lang.isNumber(min) && min < this._dataMinimum)))","        {","            return true;","        }","        return false;","    }","});","","Y.NumericAxis = NumericAxis;","		","/**"," * StackedAxis manages stacked numeric data on an axis."," *"," * @module charts"," * @submodule charts-base"," * @class StackedAxis"," * @constructor"," * @param {Object} config (optional) Configuration parameters for the Chart."," * @extends NumericAxis"," */","function StackedAxis(config)","{","	StackedAxis.superclass.constructor.apply(this, arguments);","}","","StackedAxis.NAME = \"stackedAxis\";","","","Y.extend(StackedAxis, Y.NumericAxis,","{","    /**","     * Calculates the maximum and minimum values for the `Axis`.","     *","     * @method _updateMinAndMax","     * @private ","     */","    _updateMinAndMax: function()","    {","        var max = 0,","            min = 0,","            pos = 0,","            neg = 0,","            len = 0,","            i = 0,","            key,","            num,","            keys = this.get(\"keys\"),","            setMin = this.get(\"setMin\"),","            setMax = this.get(\"setMax\");","","        for(key in keys)","        {","            if(keys.hasOwnProperty(key))","            {","                len = Math.max(len, keys[key].length);","            }","        }","        for(; i < len; ++i)","        {","            pos = 0;","            neg = 0;","            for(key in keys)","            {","                if(keys.hasOwnProperty(key))","                {","                    num = keys[key][i];","                    if(isNaN(num))","                    {","                        continue;","                    }","                    if(num >= 0)","                    {","                        pos += num;","                    }","                    else","                    {","                        neg += num;","                    }","                }","            }","            if(pos > 0)","            {","                max = Math.max(max, pos);","            }","            else ","            {","                max = Math.max(max, neg);","            }","            if(neg < 0)","            {","                min = Math.min(min, neg);","            }","            else","            {","                min = Math.min(min, pos);","            }","        }","        this._actualMaximum = max;","        this._actualMinimum = min;","        if(setMax)","        {","            max = this._setMaximum;","        }","        if(setMin)","        {","            min = this._setMinimum;","        }","        this._roundMinAndMax(min, max, setMin, setMax);","    }","});","","Y.StackedAxis = StackedAxis;","		","/**"," * TimeAxis manages time data on an axis."," *"," * @module charts"," * @submodule charts-base"," * @class TimeAxis"," * @constructor"," * @param {Object} config (optional) Configuration parameters for the Chart."," * @extends AxisType"," */","function TimeAxis(config)","{","	TimeAxis.superclass.constructor.apply(this, arguments);","}","","TimeAxis.NAME = \"timeAxis\";","","TimeAxis.ATTRS = ","{","    /**","     * Indicates whether the maximum is calculated or explicitly set. ","     *","     * @attribute setMax","     * @readOnly","     * @type Boolean","     * @private","     */","    setMax: {","        readOnly: true,","","        getter: function()","        {","            var max = this._getNumber(this._setMaximum);","            return (Y_Lang.isNumber(max));","        }","    },","","    /**","     * Indicates whether the minimum is calculated or explicitly set. ","     *","     * @attribute setMin","     * @readOnly","     * @type Boolean","     * @private","     */","    setMin: {","        readOnly: true,","","        getter: function()","        {","            var min = this._getNumber(this._setMinimum);","            return (Y_Lang.isNumber(min));","        }","    },","","    /**","     * The maximum value that will appear on an axis. Unless explicitly set, this value is calculated by the `Axis`.","     *","     * @attribute maximum","     * @type Number","     */","    maximum: {","        getter: function ()","        {","            var max = this._getNumber(this._setMaximum);","            if(!Y_Lang.isNumber(max))","            {","                max = this._getNumber(this.get(\"dataMaximum\"));","            }","            return parseFloat(max);","        },","        setter: function (value)","        {","            this._setMaximum = this._getNumber(value);","            return value;","        }","    },","","    /**","     * The minimum value that will appear on an axis. Unless explicitly set, this value is calculated by the `Axis`.","     *","     * @attribute minimum","     * @type Number","     */","    minimum: {","        getter: function ()","        {","            var min = this._getNumber(this._setMinimum);","            if(!Y_Lang.isNumber(min)) ","            {","                min = this._getNumber(this.get(\"dataMinimum\"));","            }","            return parseFloat(min);","        },","        setter: function (value)","        {","            this._setMinimum = this._getNumber(value);","            return value;","        }","    },","","    /**","     * Method used for formatting a label. This attribute allows for the default label formatting method to overridden. The method use would need","     * to implement the arguments below and return a `String` or an `HTMLElement`. The default implementation of the method returns a `String`. The output of this method","     * will be rendered to the DOM using `appendChild`. If you override the `labelFunction` method and return an html string, you will also need to override the Axis' ","     * `appendLabelFunction` to accept html as a `String`.","     * <dl>","     *      <dt>val</dt><dd>Label to be formatted. (`String`)</dd>","     *      <dt>format</dt><dd>STRFTime string used to format the label. (optional)</dd>","     * </dl>","     *","     * @attribute labelFunction","     * @type Function","     */","    labelFunction: {","        value: function(val, format)","        {","            val = Y.DataType.Date.parse(val);","            if(format)","            {","                return Y.DataType.Date.format(val, {format:format});","            }","            return val;","        }","    },","","    /**","     * Pattern used by the `labelFunction` to format a label.","     *","     * @attribute labelFormat","     * @type String","     */","    labelFormat: {","        value: \"%b %d, %y\"","    }","};","","Y.extend(TimeAxis, Y.AxisType, {","    /**","     * Formats a label based on the axis type and optionally specified format.","     *","     * @method formatLabel","     * @param {Object} value","     * @param {Object} format Pattern used to format the value.","     * @return String","     */","    formatLabel: function(val, format)","    {","        val = Y.DataType.Date.parse(val);","        if(format)","        {","            return Y.DataType.Date.format(val, {format:format});","        }","        return val;","    },","","    /**","     * Constant used to generate unique id.","     *","     * @property GUID","     * @type String","     * @private","     */","    GUID: \"yuitimeaxis\",","	","    /**","     * Type of data used in `Axis`.","     *","     * @property _dataType","     * @readOnly","     * @private","     */","    _dataType: \"time\",","	","    /**","     * Calculates and returns a value based on the number of labels and the index of","     * the current label.","     *","     * @method getLabelByIndex","     * @param {Number} i Index of the label.","     * @param {Number} l Total number of labels.","     * @return String","     */","    getLabelByIndex: function(i, l)","    {","        var min = this.get(\"minimum\"),","            max = this.get(\"maximum\"),","            position = this.get(\"position\"),","            increm,","            label;","            l -= 1;","        increm = ((max - min)/l) * i;","        if(position == \"bottom\" || position == \"top\")","        {","            label = min + increm;","        }","        else","        {","            label = max - increm;","        }","        return label;","    },","","    /**","     * Gets an array of values based on a key.","     *","     * @method _getKeyArray","     * @param {String} key Value key associated with the data array.","     * @param {Array} data Array in which the data resides.","     * @return Array","     * @private","     */","    _getKeyArray: function(key, data)","    {","        var obj,","            keyArray = [],","            i = 0,","            val,","            len = data.length;","        for(; i < len; ++i)","        {","            obj = data[i][key];","            if(Y_Lang.isDate(obj))","            {   ","                val = obj.valueOf();","            }","            else","            {","                val = new Date(obj);","                if(Y_Lang.isDate(val))","                {","                    val = val.valueOf();","                }","                else if(!Y_Lang.isNumber(obj))","                {","                    if(Y_Lang.isNumber(parseFloat(obj)))","                    {","                        val = parseFloat(obj);","                    }","                    else","                    {","                        if(typeof obj != \"string\")","                        {","                            obj = obj;","                        }","                        val = new Date(obj).valueOf();","                    }","                }","                else","                {","                    val = obj;","                }","            }","            keyArray[i] = val;","        }","        return keyArray;","    },","","    /**","     * Sets data by key","     *","     * @method _setDataByKey","     * @param {String} key Key value to use.","     * @param {Array} data Array to use.","     * @private ","     */","    _setDataByKey: function(key, data)","    {","        var obj, ","            arr = [], ","            dv = this._dataClone.concat(), ","            i, ","            val,","            len = dv.length;","        for(i = 0; i < len; ++i)","        {","            obj = dv[i][key];","            if(Y_Lang.isDate(obj))","            {   ","                val = obj.valueOf();","            }","            else","            {","                val = new Date(obj);","                if(Y_Lang.isDate(val))","                {","                    val = val.valueOf();","                }","                else if(!Y_Lang.isNumber(obj))","                {","                    if(Y_Lang.isNumber(parseFloat(obj)))","                    {","                        val = parseFloat(obj);","                    }","                    else","                    {","                        if(typeof obj != \"string\")","                        {","                            obj = obj.toString();","                        }","                        val = new Date(obj).valueOf();","                    }","                }","                else","                {","                    val = obj;","                }","            }","            arr[i] = val;","        }","        this.get(\"keys\")[key] = arr;","        this._updateTotalDataFlag = true;","    },","","    /**","     * Parses value into a number.","     *","     * @method _getNumber","     * @param val {Object} Value to parse into a number","     * @return Number","     * @private","     */","    _getNumber: function(val)","    {","        if(Y_Lang.isDate(val))","        {","            val = val.valueOf();","        }","        else if(!Y_Lang.isNumber(val) && val)","        {","            val = new Date(val).valueOf();","        }","","        return val;","    }","});","","Y.TimeAxis = TimeAxis;","		","/**"," * CategoryAxis manages category data on an axis."," *"," * @module charts"," * @submodule charts-base"," * @class CategoryAxis"," * @constructor"," * @param {Object} config (optional) Configuration parameters for the Chart."," * @extends AxisType"," */","function CategoryAxis(config)","{","	CategoryAxis.superclass.constructor.apply(this, arguments);","}","","CategoryAxis.NAME = \"categoryAxis\";","","Y.extend(CategoryAxis, Y.AxisType,","{","    /**","     * Formats a label based on the axis type and optionally specified format.","     *","     * @method formatLabel","     * @param {Object} value","     * @param {Object} format Pattern used to format the value.","     * @return String","     */","    formatLabel: function(val, format)","    {","        return val;","    },","","    /**","     * Object storing key data.","     *","     * @property _indices","     * @private","     */","    _indices: null,","","    /**","     * Constant used to generate unique id.","     *","     * @property GUID","     * @type String","     * @private","     */","    GUID: \"yuicategoryaxis\",","","    /**","     * Type of data used in `Axis`.","     *","     * @property _dataType","     * @readOnly","     * @private","     */","    _type: \"category\",","        ","    /**","     * Calculates the maximum and minimum values for the `Axis`.","     *","     * @method _updateMinAndMax","     * @private ","     */","    _updateMinAndMax: function()","    {","        this._dataMaximum = Math.max(this.get(\"data\").length - 1, 0);","        this._dataMinimum = 0;","    },","","    /**","     * Gets an array of values based on a key.","     *","     * @method _getKeyArray","     * @param {String} key Value key associated with the data array.","     * @param {Array} data Array in which the data resides.","     * @return Array","     * @private","     */","    _getKeyArray: function(key, data)","    {","        var i = 0,","            obj,","            keyArr = [],","            labels = [],","            len = data.length;","        if(!this._indices)","        {","            this._indices = {};","        }","        for(; i < len; ++i)","        {","            obj = data[i];","            keyArr[i] = i;","            labels[i] = obj[key];","        }","        this._indices[key] = keyArr;","        return labels;","    },","","    /**","     * Sets data by key","     *","     * @method _setDataByKey","     * @param {String} key Key value to use.","     * @param {Array} data Array to use.","     * @private ","     */","    _setDataByKey: function(key)","    {","        var i,","            obj, ","            arr = [], ","            labels = [], ","            dv = this._dataClone.concat(), ","            len = dv.length;","        if(!this._indices)","        {","            this._indices = {};","        }","        for(i = 0; i < len; ++i)","        {","            obj = dv[i];","            arr[i] = i;","            labels[i] = obj[key];","        }","        this._indices[key] = arr;","        this.get(\"keys\")[key] = labels.concat();","        this._updateTotalDataFlag = true;","    },","","    /**","     * Returns an array of values based on an identifier key.","     *","     * @method getDataByKey","     * @param {String} value value used to identify the array","     * @return Array","     */","    getDataByKey: function (value)","    {","        if(!this._indices)","        {","            this.get(\"keys\");","        }","        var keys = this._indices;","        if(keys[value])","        {","            return keys[value];","        }","        return null;","    },","","    /**","     * Returns the total number of majorUnits that will appear on an axis.","     *","     * @method getTotalMajorUnits","     * @param {Object} majorUnit Object containing properties related to the majorUnit.","     * @param {Number} len Length of the axis.","     * @return Number","     */","    getTotalMajorUnits: function(majorUnit, len)","    {","        return this.get(\"data\").length;","    },","    ","    /**","     * Returns the distance between major units on an axis.","     *","     * @method getMajorUnitDistance","     * @param {Number} len Number of ticks","     * @param {Number} uiLen Size of the axis.","     * @param {Object} majorUnit Hash of properties used to determine the majorUnit","     * @return Number","     */","    getMajorUnitDistance: function(len, uiLen, majorUnit)","    {","        var dist;","        if(majorUnit.determinant === \"count\")","        {","            dist = uiLen/len;","        }","        else if(majorUnit.determinant === \"distance\")","        {","            dist = majorUnit.distance;","        }","        return dist;","    },","   ","    /**","     * Gets the distance that the first and last ticks are offset from there respective","     * edges.","     *","     * @method getEdgeOffset","     * @param {Number} ct Number of ticks on the axis.","     * @param {Number} l Length (in pixels) of the axis.","     * @return Number","     */","    getEdgeOffset: function(ct, l)","    {","        return l/ct;","    },","","    /**","     * Returns a value based of a key value and an index.","     *","     * @method getKeyValueAt","     * @param {String} key value used to look up the correct array","     * @param {Number} index within the array","     * @return String ","     */","    getKeyValueAt: function(key, index)","    {","        var value = NaN,","            keys = this.get(\"keys\");","        if(keys[key] && keys[key][index]) ","        {","            value = keys[key][index];","        }","        return value;","    },","   ","    /**","     * Calculates and returns a value based on the number of labels and the index of","     * the current label.","     *","     * @method getLabelByIndex","     * @param {Number} i Index of the label.","     * @param {Number} l Total number of labels.","     * @return String","     */","    getLabelByIndex: function(i, l)","    {","        var label,","            data = this.get(\"data\"),","            position = this.get(\"position\");","        if(position == \"bottom\" || position == \"top\")","        {","            label = data[i];","        }","        else","        {","            label = data[l - (i + 1)];","        }   ","        return label;","    },","","    /**","     * Returns a string corresponding to the first label on an ","     * axis.","     *","     * @method getMinimumValue","     * @return String","     */","    getMinimumValue: function()","    {","        var data = this.get(\"data\"),","            label = data[0];","        return label;","    },","","    /**","     * Returns a string corresponding to the last label on an ","     * axis.","     *","     * @method getMaximumValue","     * @return String","     */","    getMaximumValue: function()","    {","        var data = this.get(\"data\"),","            len = data.length - 1,","            label = data[len];","        return label;","    }","});","","Y.CategoryAxis = CategoryAxis;","		","/**"," * Utility class used for calculating curve points."," *"," * @module charts"," * @submodule charts-base"," * @class CurveUtil"," * @constructor"," */","function CurveUtil()","{","}","","CurveUtil.prototype = {","    /**","     * Creates an array of start, end and control points for splines.","     *","     * @method getCurveControlPoints","     * @param {Array} xcoords Collection of x-coordinates used for calculate the curves","     * @param {Array} ycoords Collection of y-coordinates used for calculate the curves","     * @return Object","     * @protected","     */","    getCurveControlPoints: function(xcoords, ycoords) ","    {","		var outpoints = [],","            i = 1,","            l = xcoords.length - 1,","		    xvals = [],","		    yvals = [];","		","		","		// Too few points, need at least two","		if (l < 1) ","        {","			return null;","		} ","        ","        outpoints[0] = {","            startx: xcoords[0], ","            starty: ycoords[0],","            endx: xcoords[1],","            endy: ycoords[1]","        };","        ","		// Special case, the Bezier should be a straight line","        if (l === 1) ","        {","			outpoints[0].ctrlx1 = (2.0*xcoords[0] + xcoords[1])/3.0;  ","			outpoints[0].ctrly2 = (2.0*ycoords[0] + ycoords[1])/3.0;","			outpoints[0].ctrlx2 = 2.0*outpoints[0].ctrlx1 - xcoords[0];","            outpoints[0].ctrly2 = 2.0*outpoints[0].ctrly1 - ycoords[0];","            return outpoints;","		}","","		for (; i < l; ++i) ","        {","			outpoints.push({startx: Math.round(xcoords[i]), starty: Math.round(ycoords[i]), endx: Math.round(xcoords[i+1]), endy: Math.round(ycoords[i+1])});","			xvals[i] = 4.0 * xcoords[i] + 2*xcoords[i+1];","			yvals[i] = 4.0*ycoords[i] + 2*ycoords[i+1];","		}","		","		xvals[0] = xcoords[0] + (2.0 * xcoords[1]);","		xvals[l-1] = (8.0 * xcoords[l-1] + xcoords[l]) / 2.0;","		xvals = this.getControlPoints(xvals.concat());","        yvals[0] = ycoords[0] + (2.0 * ycoords[1]);","		yvals[l-1] = (8.0 * ycoords[l-1] + ycoords[l]) / 2.0;	","		yvals = this.getControlPoints(yvals.concat());","		","        for (i = 0; i < l; ++i) ","        {","			outpoints[i].ctrlx1 = Math.round(xvals[i]);","            outpoints[i].ctrly1 = Math.round(yvals[i]);","			","			if (i < l-1) ","            {","				outpoints[i].ctrlx2 = Math.round(2*xcoords[i+1] - xvals[i+1]);","                outpoints[i].ctrly2 = Math.round(2*ycoords[i+1] - yvals[i+1]);","			}","			else ","            {","				outpoints[i].ctrlx2 = Math.round((xcoords[l] + xvals[l-1])/2);","                outpoints[i].ctrly2 = Math.round((ycoords[l] + yvals[l-1])/2);","			}","		}","		","		return outpoints;	","	},","","    /**","     * Gets the control points for the curve.","     *","     * @method getControlPoints","     * @param {Array} vals Collection of values coords used to generate control points.","     * @return Array","     * @private","     */","	getControlPoints: function(vals) ","    {","		var l = vals.length,","            x = [],","            tmp = [],","            b = 2.0,","            i = 1;","		x[0] = vals[0] / b;","		for (; i < l; ++i) ","        {","			tmp[i] = 1/b;","			b = (i < l-1 ? 4.0 : 3.5) - tmp[i];","			x[i] = (vals[i] - x[i-1]) / b;","		}","		","		for (i = 1; i < l; ++i) ","        {","			x[l-i-1] -= tmp[l-i] * x[l-i];","		}","		","		return x;","	}","};","Y.CurveUtil = CurveUtil;","/**"," * Utility class used for creating stacked series."," *"," * @module charts"," * @submodule charts-base"," * @class StackingUtil"," * @constructor"," */","function StackingUtil(){}","","StackingUtil.prototype = {","    /**","     * Indicates whether the series is stacked.","     *","     * @property _stacked","     * @private","     */","    _stacked: true,","","    /**","     * @protected","     *","     * Adjusts coordinate values for stacked series.","     *","     * @method _stackCoordinates","     */","    _stackCoordinates: function() ","    {","        if(this.get(\"direction\") == \"vertical\")","        {","            this._stackXCoords();","        }","        else","        {","            this._stackYCoords();","        }","    },","","    /**","     * Stacks coordinates for a stacked vertical series.","     *","     * @method _stackXCoords","     * @protected","     */","    _stackXCoords: function()","    {","        var order = this.get(\"order\"),","            type = this.get(\"type\"),","            graph = this.get(\"graph\"),","            seriesCollection = graph.seriesTypes[type],","            i = 0,","            xcoords = this.get(\"xcoords\"),","            ycoords = this.get(\"ycoords\"),","            len,","            coord,","            prevCoord,","            prevOrder,","            stackedXCoords = xcoords.concat(),","            prevXCoords,","            prevYCoords,","            nullIndices = [],","            nullIndex;","        if(order > 0)","        {","            prevXCoords = seriesCollection[order - 1].get(\"stackedXCoords\");","            prevYCoords = seriesCollection[order - 1].get(\"stackedYCoords\");","            len = prevXCoords.length;","        }","        else","        {","            len = xcoords.length;","        }","        for(; i < len; i = i + 1)","        {","            if(Y_Lang.isNumber(xcoords[i]))","            {","                if(order > 0)","                {","                    prevCoord = prevXCoords[i];","                    if(!Y_Lang.isNumber(prevCoord))","                    {","                        prevOrder = order;","                        while(prevOrder >  - 1 && !Y_Lang.isNumber(prevCoord))","                        {","                            prevOrder = prevOrder - 1;","                            if(prevOrder > -1)","                            {","                                prevCoord = seriesCollection[prevOrder].get(\"stackedXCoords\")[i];","                            }","                            else","                            {","                                prevCoord = this._leftOrigin;","                            }","                        }","                    }","                    xcoords[i] = xcoords[i] + prevCoord;","                }","                stackedXCoords[i] = xcoords[i];","            }","            else","            {","                nullIndices.push(i);","            }","        }","        this._cleanXNaN(stackedXCoords, ycoords);","        len = nullIndices.length;","        if(len > 0)","        {","            for(i = 0; i < len; i = i + 1)","            {","                nullIndex = nullIndices[i];","                coord = order > 0 ? prevXCoords[nullIndex] : this._leftOrigin;","                stackedXCoords[nullIndex] =  Math.max(stackedXCoords[nullIndex], coord);","            }","        }","        this.set(\"stackedXCoords\", stackedXCoords);","        this.set(\"stackedYCoords\", ycoords);","    },","","    /**","     * Stacks coordinates for a stacked horizontal series.","     *","     * @method _stackYCoords","     * @protected","     */","    _stackYCoords: function()","    {","        var order = this.get(\"order\"),","            type = this.get(\"type\"),","            graph = this.get(\"graph\"),","            h = graph.get(\"height\"), ","            seriesCollection = graph.seriesTypes[type],","            i = 0,","            xcoords = this.get(\"xcoords\"),","            ycoords = this.get(\"ycoords\"),","            len,","            coord,","            prevCoord,","            prevOrder,","            stackedYCoords = ycoords.concat(),","            prevXCoords,","            prevYCoords,","            nullIndices = [],","            nullIndex;","        if(order > 0)","        {","            prevXCoords = seriesCollection[order - 1].get(\"stackedXCoords\");","            prevYCoords = seriesCollection[order - 1].get(\"stackedYCoords\");","            len = prevYCoords.length;","        }","        else","        {","            len = ycoords.length;","        }","        for(; i < len; i = i + 1)","        {","            if(Y_Lang.isNumber(ycoords[i]))","            {","                if(order > 0)","                {","                    prevCoord = prevYCoords[i];","                    if(!Y_Lang.isNumber(prevCoord))","                    {","                        prevOrder = order;","                        while(prevOrder >  - 1 && !Y_Lang.isNumber(prevCoord))","                        {","                            prevOrder = prevOrder - 1;","                            if(prevOrder > -1)","                            {","                                prevCoord = seriesCollection[prevOrder].get(\"stackedYCoords\")[i];","                            }","                            else","                            {","                                prevCoord = this._bottomOrigin;","                            }","                        }","                    }","                    ycoords[i] = prevCoord - (h - ycoords[i]);","                }","                stackedYCoords[i] = ycoords[i];","            }","            else","            {","                nullIndices.push(i);","            }","        }","        this._cleanYNaN(xcoords, stackedYCoords);","        len = nullIndices.length;","        if(len > 0)","        {","            for(i = 0; i < len; i = i + 1)","            {","                nullIndex = nullIndices[i];","                coord = order > 0 ? prevYCoords[nullIndex] : h;","                stackedYCoords[nullIndex] =  Math.min(stackedYCoords[nullIndex], coord);","            }","        }","        this.set(\"stackedXCoords\", xcoords);","        this.set(\"stackedYCoords\", stackedYCoords);","    },","","    /**","     * Cleans invalid x-coordinates by calculating their value based on the corresponding y-coordinate, the previous valid x-coordinate with its ","     * corresponding y-coordinate and the next valid x-coordinate with its corresponding y-coordinate. If there is no previous or next valid x-coordinate,","     * the value will not be altered.","     *","     * @method _cleanXNaN","     * @param {Array} xcoords An array of x-coordinate values","     * @param {Array} ycoords An arry of y-coordinate values","     * @private","     */","    _cleanXNaN: function(xcoords, ycoords)","    {","        var previousValidIndex,","            nextValidIndex,","            previousValidX,","            previousValidY,","            x,","            y,","            nextValidX,","            nextValidY,","            isNumber = Y_Lang.isNumber,","            m,","            i = 0,","            len = ycoords.length;","        for(; i < len; ++i)","        {","            x = xcoords[i];","            y = ycoords[i];","            //if x is invalid, calculate where it should be","            if(!isNumber(x) && i > 0 && i < len - 1)","            {","                previousValidY = ycoords[i - 1];","                //check to see if the previous value is valid","                previousValidX = this._getPreviousValidCoordValue(xcoords, i);","                nextValidY = ycoords[i + 1];","                nextValidX = this._getNextValidCoordValue(xcoords, i);","                //check to see if the next value is valid","                if(isNumber(previousValidX) && isNumber(nextValidX))","                {","                    //calculate slope and solve for x","                    m = (nextValidY - previousValidY) / (nextValidX - previousValidX);","                    xcoords[i] = (y + (m * previousValidX) - previousValidY)/m;","                }","                previousValidIndex = NaN;","                nextValidIndex = NaN;","            }","        }","    },","","    /**","     * Returns the previous valid (numeric) value in an array if available.","     *","     * @method _getPreviousValidCoordValue","     * @param {Array} coords Array of values","     * @param {Number} index The index in the array in which to begin searching.","     * @return Number","     * @private","     */","    _getPreviousValidCoordValue: function(coords, index)","    {","        var coord,","            isNumber = Y_Lang.isNumber,","            limit = -1;","        while(!isNumber(coord) && index > limit)","        {","            index = index - 1;","            coord = coords[index];","        }","        return coord;","    },","","    /**","     * Returns the next valid (numeric) value in an array if available.","     *","     * @method _getNextValidCoordValue","     * @param {Array} coords Array of values","     * @param {Number} index The index in the array in which to begin searching.","     * @return Number","     * @private","     */","    _getNextValidCoordValue: function(coords, index)","    {","        var coord,","            isNumber = Y_Lang.isNumber,","            limit = coords.length;","        while(!isNumber(coord) && index < limit)","        {","            index = index + 1;","            coord = coords[index];","        }","        return coord;","    },","","    /**","     * Cleans invalid y-coordinates by calculating their value based on the corresponding x-coordinate, the previous valid y-coordinate with its ","     * corresponding x-coordinate and the next valid y-coordinate with its corresponding x-coordinate. If there is no previous or next valid y-coordinate,","     * the value will not be altered.","     *","     * @method _cleanYNaN","     * @param {Array} xcoords An array of x-coordinate values","     * @param {Array} ycoords An arry of y-coordinate values","     * @private","     */","    _cleanYNaN: function(xcoords, ycoords)","    {","        var previousValidIndex,","            nextValidIndex,","            previousValidX,","            previousValidY,","            x,","            y,","            nextValidX,","            nextValidY,","            isNumber = Y_Lang.isNumber,","            m,","            i = 0,","            len = xcoords.length;","        for(; i < len; ++i)","        {","            x = xcoords[i];","            y = ycoords[i];","            //if y is invalid, calculate where it should be","            if(!isNumber(y) && i > 0 && i < len - 1)","            {","                //check to see if the previous value is valid","                previousValidX = xcoords[i - 1];","                previousValidY = this._getPreviousValidCoordValue(ycoords, i);","                //check to see if the next value is valid","                nextValidX = xcoords[i + 1];","                nextValidY = this._getNextValidCoordValue(ycoords, i);","                if(isNumber(previousValidY) && isNumber(nextValidY))","                {","                    //calculate slope and solve for y","                    m = (nextValidY - previousValidY) / (nextValidX - previousValidX);","                    ycoords[i] = previousValidY + ((m * x) - (m * previousValidX));","                }","                previousValidIndex = NaN;","                nextValidIndex = NaN;","            }","        }","    }","};","Y.StackingUtil = StackingUtil;","/**"," * Utility class used for drawing lines."," *"," * @module charts"," * @submodule charts-base"," * @class Lines"," * @constructor"," */","function Lines(){}","","Lines.prototype = {","    /**","     * @property _lineDefaults","     * @type Object","     * @private","     */","    _lineDefaults: null,","    ","    /**","     * Creates a graphic in which to draw a series.","     *","     * @method _getGraphic","     * @return Graphic","     * @private","     */","    _getGraphic: function()","    {","        var graphic = this.get(\"graphic\") || this.get(\"graph\").get(\"graphic\");","        if(!this._lineGraphic)","        {","            this._lineGraphic = graphic.addShape({type: \"path\"});","        }","        this._lineGraphic.clear();","        return this._lineGraphic;","    },","    ","    /**","     * Toggles visibility","     *","     * @method _toggleVisible","     * @param {Boolean} visible indicates visibilitye","     * @private","     */","    _toggleVisible: function(visible)","    {","        if(this._lineGraphic)","        {","            this._lineGraphic.set(\"visible\", visible);","        }","    },","","    /**","     * Draws lines for the series.","     *","     * @method drawLines","     * @protected","     */","    drawLines: function()","    {","        if(this.get(\"xcoords\").length < 1) ","        {","            return;","        }","        var isNumber = Y_Lang.isNumber,","            xcoords,","            ycoords,","            direction = this.get(\"direction\"),","            len,","            lastPointValid,","            pointValid,","            noPointsRendered = true,","            lastValidX,","            lastValidY,","            nextX,","            nextY,","            i,","            styles = this.get(\"styles\").line,","            lineType = styles.lineType,","            lc = styles.color || this._getDefaultColor(this.get(\"graphOrder\"), \"line\"),","            lineAlpha = styles.alpha,","            dashLength = styles.dashLength,","            gapSpace = styles.gapSpace,","            connectDiscontinuousPoints = styles.connectDiscontinuousPoints,","            discontinuousType = styles.discontinuousType,","            discontinuousDashLength = styles.discontinuousDashLength,","            discontinuousGapSpace = styles.discontinuousGapSpace,","            path = this._getGraphic();","        if(this._stacked)","        {","            xcoords = this.get(\"stackedXCoords\");","            ycoords = this.get(\"stackedYCoords\");","        }","        else","        {","            xcoords = this.get(\"xcoords\");","            ycoords = this.get(\"ycoords\");","        }","        len = direction === \"vertical\" ? ycoords.length : xcoords.length;","        path.set(\"stroke\", {","            weight: styles.weight, ","            color: lc, ","            opacity: lineAlpha","        });","        for(i = 0; i < len; i = ++i)","        {","            nextX = xcoords[i];","            nextY = ycoords[i];","            pointValid = isNumber(nextX) && isNumber(nextY); ","            if(!pointValid)","            {","                lastPointValid = pointValid;","                continue;","            }","            if(noPointsRendered)","            {","                noPointsRendered = false;","                path.moveTo(nextX, nextY);","            }","            else if(lastPointValid)","            {","                if(lineType != \"dashed\")","                {","                    path.lineTo(nextX, nextY);","                }","                else","                {","                    this.drawDashedLine(path, lastValidX, lastValidY, nextX, nextY, ","                                                dashLength, ","                                                gapSpace);","                }","            }","            else if(!connectDiscontinuousPoints)","            {","                path.moveTo(nextX, nextY);","            }","            else","            {","                if(discontinuousType != \"solid\")","                {","                    this.drawDashedLine(path, lastValidX, lastValidY, nextX, nextY, ","                                                discontinuousDashLength, ","                                                discontinuousGapSpace);","                }","                else","                {","                    path.lineTo(nextX, nextY);","                }","            }","            lastValidX = nextX;","            lastValidY = nextY;","            lastPointValid = true;","        }","        path.end();","    },","    ","    /**","     * Connects data points with a consistent curve for a series.","     * ","     * @method drawSpline","     * @protected","     */","    drawSpline: function()","    {","        if(this.get(\"xcoords\").length < 1) ","        {","            return;","        }","        var xcoords = this.get(\"xcoords\"),","            ycoords = this.get(\"ycoords\"),","            curvecoords = this.getCurveControlPoints(xcoords, ycoords),","            len = curvecoords.length,","            cx1,","            cx2,","            cy1,","            cy2,","            x,","            y,","            i = 0,","            styles = this.get(\"styles\").line,","            path = this._getGraphic(),","            lineAlpha = styles.alpha,","            color = styles.color || this._getDefaultColor(this.get(\"graphOrder\"), \"line\");","        path.set(\"stroke\", { ","            weight: styles.weight, ","            color: color, ","            opacity: lineAlpha","        });","        path.moveTo(xcoords[0], ycoords[0]);","        for(; i < len; i = ++i)","        {","            x = curvecoords[i].endx;","            y = curvecoords[i].endy;","            cx1 = curvecoords[i].ctrlx1;","            cx2 = curvecoords[i].ctrlx2;","            cy1 = curvecoords[i].ctrly1;","            cy2 = curvecoords[i].ctrly2;","            path.curveTo(cx1, cy1, cx2, cy2, x, y);","        }","        path.end();","    },","","    /**","     * Draws a dashed line between two points.","     * ","     * @method drawDashedLine","     * @param {Number} xStart	The x position of the start of the line","     * @param {Number} yStart	The y position of the start of the line","     * @param {Number} xEnd		The x position of the end of the line","     * @param {Number} yEnd		The y position of the end of the line","     * @param {Number} dashSize	the size of dashes, in pixels","     * @param {Number} gapSize	the size of gaps between dashes, in pixels","     * @private","     */","    drawDashedLine: function(path, xStart, yStart, xEnd, yEnd, dashSize, gapSize)","    {","        dashSize = dashSize || 10;","        gapSize = gapSize || 10;","        var segmentLength = dashSize + gapSize,","            xDelta = xEnd - xStart,","            yDelta = yEnd - yStart,","            delta = Math.sqrt(Math.pow(xDelta, 2) + Math.pow(yDelta, 2)),","            segmentCount = Math.floor(Math.abs(delta / segmentLength)),","            radians = Math.atan2(yDelta, xDelta),","            xCurrent = xStart,","            yCurrent = yStart,","            i;","        xDelta = Math.cos(radians) * segmentLength;","        yDelta = Math.sin(radians) * segmentLength;","        ","        for(i = 0; i < segmentCount; ++i)","        {","            path.moveTo(xCurrent, yCurrent);","            path.lineTo(xCurrent + Math.cos(radians) * dashSize, yCurrent + Math.sin(radians) * dashSize);","            xCurrent += xDelta;","            yCurrent += yDelta;","        }","        ","        path.moveTo(xCurrent, yCurrent);","        delta = Math.sqrt((xEnd - xCurrent) * (xEnd - xCurrent) + (yEnd - yCurrent) * (yEnd - yCurrent));","        ","        if(delta > dashSize)","        {","            path.lineTo(xCurrent + Math.cos(radians) * dashSize, yCurrent + Math.sin(radians) * dashSize);","        }","        else if(delta > 0)","        {","            path.lineTo(xCurrent + Math.cos(radians) * delta, yCurrent + Math.sin(radians) * delta);","        }","        ","        path.moveTo(xEnd, yEnd);","    },","","    /**","     * Default values for `styles` attribute.","     *","     * @method _getLineDefaults","     * @return Object","     * @protected","     */","    _getLineDefaults: function()","    {","        return {","            alpha: 1,","            weight: 6,","            lineType:\"solid\", ","            dashLength:10, ","            gapSpace:10, ","            connectDiscontinuousPoints:true, ","            discontinuousType:\"solid\", ","            discontinuousDashLength:10, ","            discontinuousGapSpace:10","        };","    }","};","Y.augment(Lines, Y.Attribute);","Y.Lines = Lines;","/**"," * Utility class used for drawing area fills."," *"," * @module charts"," * @class Fills"," * @constructor"," */","function Fills(cfg)","{","    var attrs = {","        area: {","            getter: function()","            {","                return this._defaults || this._getAreaDefaults();","            },","","            setter: function(val)","            {","                var defaults = this._defaults || this._getAreaDefaults();","                this._defaults = Y.merge(defaults, val);","            }","        }","    };","    this.addAttrs(attrs, cfg);","    this.get(\"styles\");","}","","Fills.prototype = {","    /**","     * Returns a path shape used for drawing fills.","     *","     * @method _getPath","     * @return Path","     * @private","     */","    _getPath: function()","    {","        var path = this._path;","        if(!path)","        {","            path = this.get(\"graph\").get(\"graphic\").addShape({type:\"path\"});","            this._path = path;","        }","        return path;","    },","    ","    /**","     * Toggles visibility","     *","     * @method _toggleVisible","     * @param {Boolean} visible indicates visibilitye","     * @private","     */","    _toggleVisible: function(visible)","    {   ","        if(this._path)","        {","            this._path.set(\"visible\", visible);","        }","    },","","    /**","     * Draws fill","     *","     * @method drawFill","     * @param {Array} xcoords The x-coordinates for the series.","     * @param {Array} ycoords The y-coordinates for the series.","     * @protected","     */","    drawFill: function(xcoords, ycoords)","    {","        if(xcoords.length < 1) ","        {","            return;","        }","        var isNumber = Y_Lang.isNumber,","            len = xcoords.length,","            firstX = xcoords[0],","            firstY = ycoords[0],","            lastValidX = firstX,","            lastValidY = firstY,","            nextX,","            nextY,","            pointValid,","            noPointsRendered = true,","            i = 0,","            styles = this.get(\"styles\").area,","            path = this._getPath(),","            color = styles.color || this._getDefaultColor(this.get(\"graphOrder\"), \"slice\");","        path.clear();","        path.set(\"fill\", {","            color: color, ","            opacity: styles.alpha","        });","        path.set(\"stroke\", {weight: 0});","        for(; i < len; i = ++i)","        {","            nextX = xcoords[i];","            nextY = ycoords[i];","            pointValid = isNumber(nextX) && isNumber(nextY); ","            if(!pointValid)","            {","                continue;","            }","            if(noPointsRendered)","            {","                this._firstValidX = nextX;","                this._firstValidY = nextY;","                noPointsRendered = false;","                path.moveTo(nextX, nextY);","            }","            else","            {","                path.lineTo(nextX, nextY);","            }","            lastValidX = nextX;","            lastValidY = nextY;","        }","        this._lastValidX = lastValidX;","        this._lastValidY = lastValidY;","        path.end();","    },","	","    /**","     * Draws a fill for a spline","     *","     * @method drawAreaSpline","     * @protected","     */","    drawAreaSpline: function()","    {","        if(this.get(\"xcoords\").length < 1) ","        {","            return;","        }","        var xcoords = this.get(\"xcoords\"),","            ycoords = this.get(\"ycoords\"),","            curvecoords = this.getCurveControlPoints(xcoords, ycoords),","            len = curvecoords.length,","            cx1,","            cx2,","            cy1,","            cy2,","            x,","            y,","            i = 0,","            firstX = xcoords[0],","            firstY = ycoords[0],","            styles = this.get(\"styles\").area,","            path = this._getPath(),","            color = styles.color || this._getDefaultColor(this.get(\"graphOrder\"), \"slice\");","        path.set(\"fill\", {","            color: color, ","            opacity: styles.alpha","        });","        path.set(\"stroke\", {weight: 0});","        path.moveTo(firstX, firstY);","        for(; i < len; i = ++i)","        {","            x = curvecoords[i].endx;","            y = curvecoords[i].endy;","            cx1 = curvecoords[i].ctrlx1;","            cx2 = curvecoords[i].ctrlx2;","            cy1 = curvecoords[i].ctrly1;","            cy2 = curvecoords[i].ctrly2;","            path.curveTo(cx1, cy1, cx2, cy2, x, y);","        }","        if(this.get(\"direction\") === \"vertical\")","        {","            path.lineTo(this._leftOrigin, y);","            path.lineTo(this._leftOrigin, firstY);","        }","        else","        {","            path.lineTo(x, this._bottomOrigin);","            path.lineTo(firstX, this._bottomOrigin);","        }","        path.lineTo(firstX, firstY);","        path.end();","    },","    ","    /**","     * Draws a a stacked area spline","     *","     * @method drawStackedAreaSpline","     * @protected","     */","    drawStackedAreaSpline: function()","    {","        if(this.get(\"xcoords\").length < 1) ","        {","            return;","        }","        var xcoords = this.get(\"xcoords\"),","            ycoords = this.get(\"ycoords\"),","            curvecoords,","            order = this.get(\"order\"),","            type = this.get(\"type\"),","            graph = this.get(\"graph\"),","            seriesCollection = graph.seriesTypes[type],","            prevXCoords,","            prevYCoords,","            len,","            cx1,","            cx2,","            cy1,","            cy2,","            x,","            y,","            i = 0,","            firstX,","            firstY,","            styles = this.get(\"styles\").area,","            path = this._getPath(),","            color = styles.color || this._getDefaultColor(this.get(\"graphOrder\"), \"slice\");","        firstX = xcoords[0];","        firstY = ycoords[0];","        curvecoords = this.getCurveControlPoints(xcoords, ycoords);","        len = curvecoords.length;","        path.set(\"fill\", {","            color: color, ","            opacity: styles.alpha","        });","        path.set(\"stroke\", {weight: 0});","        path.moveTo(firstX, firstY);","        for(; i < len; i = ++i)","        {","            x = curvecoords[i].endx;","            y = curvecoords[i].endy;","            cx1 = curvecoords[i].ctrlx1;","            cx2 = curvecoords[i].ctrlx2;","            cy1 = curvecoords[i].ctrly1;","            cy2 = curvecoords[i].ctrly2;","            path.curveTo(cx1, cy1, cx2, cy2, x, y);","        }","        if(order > 0)","        {","            prevXCoords = seriesCollection[order - 1].get(\"xcoords\").concat().reverse();","            prevYCoords = seriesCollection[order - 1].get(\"ycoords\").concat().reverse();","            curvecoords = this.getCurveControlPoints(prevXCoords, prevYCoords);","            i = 0;","            len = curvecoords.length;","            path.lineTo(prevXCoords[0], prevYCoords[0]);","            for(; i < len; i = ++i)","            {","                x = curvecoords[i].endx;","                y = curvecoords[i].endy;","                cx1 = curvecoords[i].ctrlx1;","                cx2 = curvecoords[i].ctrlx2;","                cy1 = curvecoords[i].ctrly1;","                cy2 = curvecoords[i].ctrly2;","                path.curveTo(cx1, cy1, cx2, cy2, x, y);","            }","        }","        else","        {","            if(this.get(\"direction\") === \"vertical\")","            {","                path.lineTo(this._leftOrigin, ycoords[ycoords.length-1]);","                path.lineTo(this._leftOrigin, firstY);","            }","            else","            {","                path.lineTo(xcoords[xcoords.length-1], this._bottomOrigin);","                path.lineTo(firstX, this._bottomOrigin);","            }","","        }","        path.lineTo(firstX, firstY);","        path.end();","    },","    ","    /**","     * Storage for default area styles.","     *","     * @property _defaults","     * @type Object","     * @private","     */","    _defaults: null,","","    /**","     * Concatenates coordinate array with correct coordinates for closing an area fill.","     *","     * @method _getClosingPoints","     * @return Array","     * @protected","     */","    _getClosingPoints: function()","    {","        var xcoords = this.get(\"xcoords\").concat(),","            ycoords = this.get(\"ycoords\").concat(),","            firstValidIndex,","            lastValidIndex;","        if(this.get(\"direction\") === \"vertical\")","        {","            lastValidIndex = this._getLastValidIndex(xcoords);","            firstValidIndex = this._getFirstValidIndex(xcoords);","            ycoords.push(ycoords[lastValidIndex]);","            ycoords.push(ycoords[firstValidIndex]);","            xcoords.push(this._leftOrigin);","            xcoords.push(this._leftOrigin);","        }","        else","        {","            lastValidIndex = this._getLastValidIndex(ycoords);","            firstValidIndex = this._getFirstValidIndex(ycoords);","            xcoords.push(xcoords[lastValidIndex]);","            xcoords.push(xcoords[firstValidIndex]);","            ycoords.push(this._bottomOrigin);","            ycoords.push(this._bottomOrigin);","        }","        xcoords.push(xcoords[0]);","        ycoords.push(ycoords[0]);","        return [xcoords, ycoords];","    },","","    /**","     * Returns the order of the series closest to the current series that has a valid value for the current index.","     *","     * @method _getHighestValidOrder","     * @param {Array} seriesCollection Array of series of a given type.","     * @param {Number} index Index of the series item.","     * @param {Number} order Index of the the series in the seriesCollection","     * @param {String} direction Indicates the direction of the series","     * @return Number","     * @private","     */","    _getHighestValidOrder: function(seriesCollection, index, order, direction)","    {","        var coords = direction == \"vertical\" ? \"stackedXCoords\" : \"stackedYCoords\",","            coord;","        while(isNaN(coord) && order > -1)","        {","          order = order - 1;","          if(order > -1)","          {","            coord = seriesCollection[order].get(coords)[index];","          }","        }","        return order;","    },","    ","    /**","     * Returns an array containing the x and y coordinates for a given series and index.","     *","     * @method _getCoordsByOrderAndIndex","     * @param {Array} seriesCollection Array of series of a given type.","     * @param {Number} index Index of the series item.","     * @param {Number} order Index of the the series in the seriesCollection","     * @param {String} direction Indicates the direction of the series","     * @return Array","     * @private","     */","    _getCoordsByOrderAndIndex: function(seriesCollection, index, order, direction)","    {","        var xcoord,","            ycoord;","        if(direction == \"vertical\")","        {","            xcoord = order < 0 ? this._leftOrigin : seriesCollection[order].get(\"stackedXCoords\")[index];","            ycoord = this.get(\"stackedYCoords\")[index];","        }","        else","        {","            xcoord = this.get(\"stackedXCoords\")[index];","            ycoord = order < 0 ? this._bottomOrigin : seriesCollection[order].get(\"stackedYCoords\")[index];","        }","        return [xcoord, ycoord];","    },","    ","    /**","     * Concatenates coordinate array with the correct coordinates for closing an area stack.","     *","     * @method _getStackedClosingPoints","     * @return Array","     * @protected","     */","    _getStackedClosingPoints: function()","    {","        var order = this.get(\"order\"),","            type = this.get(\"type\"),","            graph = this.get(\"graph\"),","            direction = this.get(\"direction\"),","            seriesCollection = graph.seriesTypes[type],","            firstValidIndex,","            lastValidIndex,","            xcoords = this.get(\"stackedXCoords\"),","            ycoords = this.get(\"stackedYCoords\"),","            limit,","            previousSeries,","            previousSeriesFirstValidIndex,","            previousSeriesLastValidIndex,","            previousXCoords,","            previousYCoords,","            coords,","            closingXCoords,","            closingYCoords,","            currentIndex,","            highestValidOrder,","            oldOrder;","        if(order < 1)","        {    ","          return this._getClosingPoints();","        }","        ","        previousSeries = seriesCollection[order - 1];","        previousXCoords = previousSeries.get(\"stackedXCoords\").concat();","        previousYCoords = previousSeries.get(\"stackedYCoords\").concat();","        if(direction == \"vertical\")","        {","            firstValidIndex = this._getFirstValidIndex(xcoords);","            lastValidIndex = this._getLastValidIndex(xcoords);","            previousSeriesFirstValidIndex = previousSeries._getFirstValidIndex(previousXCoords);","            previousSeriesLastValidIndex = previousSeries._getLastValidIndex(previousXCoords);","        }","        else","        {","            firstValidIndex = this._getFirstValidIndex(ycoords);","            lastValidIndex = this._getLastValidIndex(ycoords);","            previousSeriesFirstValidIndex = previousSeries._getFirstValidIndex(previousYCoords);","            previousSeriesLastValidIndex = previousSeries._getLastValidIndex(previousYCoords);","        }","        if(previousSeriesLastValidIndex >= firstValidIndex && previousSeriesFirstValidIndex <= lastValidIndex)","        {","            previousSeriesFirstValidIndex = Math.max(firstValidIndex, previousSeriesFirstValidIndex);","            previousSeriesLastValidIndex = Math.min(lastValidIndex, previousSeriesLastValidIndex);","            previousXCoords = previousXCoords.slice(previousSeriesFirstValidIndex, previousSeriesLastValidIndex + 1);","            previousYCoords = previousYCoords.slice(previousSeriesFirstValidIndex, previousSeriesLastValidIndex + 1);","            limit = previousSeriesFirstValidIndex;","        }","        else","        {","            limit = lastValidIndex;","        }","","        closingXCoords = [xcoords[firstValidIndex]];","        closingYCoords = [ycoords[firstValidIndex]];","        currentIndex = firstValidIndex;","        while((isNaN(highestValidOrder) || highestValidOrder < order - 1) && currentIndex <= limit)","        {","            oldOrder = highestValidOrder;","            highestValidOrder = this._getHighestValidOrder(seriesCollection, currentIndex, order, direction);","            if(!isNaN(oldOrder) && highestValidOrder > oldOrder)","            {","                coords = this._getCoordsByOrderAndIndex(seriesCollection, currentIndex, oldOrder, direction);","                closingXCoords.push(coords[0]);","                closingYCoords.push(coords[1]);","            }","            coords = this._getCoordsByOrderAndIndex(seriesCollection, currentIndex, highestValidOrder, direction);","            closingXCoords.push(coords[0]);","            closingYCoords.push(coords[1]);","            currentIndex = currentIndex + 1;","        }","        if(previousXCoords && previousXCoords.length > 0 && previousSeriesLastValidIndex > firstValidIndex && previousSeriesFirstValidIndex < lastValidIndex)","        {","            closingXCoords = closingXCoords.concat(previousXCoords);","            closingYCoords = closingYCoords.concat(previousYCoords);","            highestValidOrder = order -1; ","        }","        currentIndex = Math.max(firstValidIndex, previousSeriesLastValidIndex);","        order = order - 1;","        highestValidOrder = NaN;","        while(currentIndex <= lastValidIndex)","        {","            oldOrder = highestValidOrder;","            highestValidOrder = this._getHighestValidOrder(seriesCollection, currentIndex, order, direction);","            if(!isNaN(oldOrder))","            {","                if(highestValidOrder > oldOrder)","                {","                    coords = this._getCoordsByOrderAndIndex(seriesCollection, currentIndex, oldOrder, direction);","                    closingXCoords.push(coords[0]);","                    closingYCoords.push(coords[1]);","                }","                else if(highestValidOrder < oldOrder)","                {","                    coords = this._getCoordsByOrderAndIndex(seriesCollection, currentIndex - 1, highestValidOrder, direction);","                    closingXCoords.push(coords[0]);","                    closingYCoords.push(coords[1]);","                }","            }","            coords = this._getCoordsByOrderAndIndex(seriesCollection, currentIndex, highestValidOrder, direction);","            closingXCoords.push(coords[0]);","            closingYCoords.push(coords[1]);","            currentIndex = currentIndex + 1;","        }","","        closingXCoords.reverse();","        closingYCoords.reverse();","        return [xcoords.concat(closingXCoords), ycoords.concat(closingYCoords)];","    },","","    /**","     * Returns default values for area styles.","     *","     * @method _getAreaDefaults","     * @return Object","     * @private","     */","    _getAreaDefaults: function()","    {","        return {","        };","    }","};","Y.augment(Fills, Y.Attribute);","Y.Fills = Fills;","/**"," * Utility class used for drawing markers."," *"," * @module charts"," * @submodule charts-base"," * @class Plots"," * @constructor"," */","function Plots(cfg)","{","    var attrs = { ","        markers: {","            getter: function()","            {","                return this._markers;","            }","        }","    };","    this.addAttrs(attrs, cfg);","}","","Plots.prototype = {","    /**","     * Storage for default marker styles.","     *","     * @property _plotDefaults","     * @type Object","     * @private","     */","    _plotDefaults: null,","","    /**","     * Draws the markers","     *","     * @method drawPlots","     * @protected","     */","    drawPlots: function()","    {","        if(!this.get(\"xcoords\") || this.get(\"xcoords\").length < 1) ","		{","			return;","		}","        var isNumber = Y_Lang.isNumber,","            style = Y.clone(this.get(\"styles\").marker),","            w = style.width,","            h = style.height,","            xcoords = this.get(\"xcoords\"),","            ycoords = this.get(\"ycoords\"),","            i = 0,","            len = xcoords.length,","            top = ycoords[0],","            left,","            marker,","            offsetWidth = w/2,","            offsetHeight = h/2,","            xvalues,","            yvalues,","            fillColors = null,","            borderColors = null,","            graphOrder = this.get(\"graphOrder\"),","            groupMarkers = this.get(\"groupMarkers\");","        if(groupMarkers)","        {","            xvalues = [];","            yvalues = [];","            for(; i < len; ++i)","            {","                xvalues.push(parseFloat(xcoords[i] - offsetWidth));","                yvalues.push(parseFloat(ycoords[i] - offsetHeight));","            }","            this._createGroupMarker({","                xvalues: xvalues,","                yvalues: yvalues,","                fill: style.fill,","                border: style.border,","                dimensions: {","                    width: w,","                    height: h","                },","                graphOrder: graphOrder,","                shape: style.shape","            });","            return;","        }","        if(Y_Lang.isArray(style.fill.color))","        {","            fillColors = style.fill.color.concat(); ","        }","        if(Y_Lang.isArray(style.border.color))","        {","            borderColors = style.border.color.concat();","        }","        this._createMarkerCache();","        for(; i < len; ++i)","        {","            top = parseFloat(ycoords[i] - offsetHeight);","            left = parseFloat(xcoords[i] - offsetWidth);            ","            if(!isNumber(left) || !isNumber(top))","            {","                this._markers.push(null);","                continue;","            }","            if(fillColors)","            {","                style.fill.color = fillColors[i % fillColors.length];","            }","            if(borderColors)","            {","                style.border.color = borderColors[i % borderColors.length];","            }","","            style.x = left;","            style.y = top;","            marker = this.getMarker(style, graphOrder, i);","        }","        this._clearMarkerCache();","    },","","    /**","     * Pre-defined group shapes.","     *","     * @property _groupShapes","     * @private","     */","    _groupShapes: {","        circle: Y.CircleGroup,","        rect: Y.RectGroup,","        ellipse: Y.EllipseGroup,","        diamond: Y.DiamondGroup","    },","","    /**","     * Returns the correct group shape class.","     *","     * @method _getGroupShape","     * @param {Shape | String} shape Indicates which shape class. ","     * @return Function","     * @protected","     */","    _getGroupShape: function(shape)","    {","        if(Y_Lang.isString(shape))","        {","            shape = this._groupShapes[shape];","        }","        return shape;","    },","","    /**","     * Gets the default values for series that use the utility. This method is used by","     * the class' `styles` attribute's getter to get build default values.","     *","     * @method _getPlotDefaults","     * @return Object","     * @protected","     */","    _getPlotDefaults: function()","    {","        var defs = {","            fill:{","                type: \"solid\",","                alpha: 1,","                colors:null,","                alphas: null,","                ratios: null","            },","            border:{","                weight: 1,","                alpha: 1","            },","            width: 10,","            height: 10,","            shape: \"circle\"","        };","        defs.fill.color = this._getDefaultColor(this.get(\"graphOrder\"), \"fill\");","        defs.border.color = this._getDefaultColor(this.get(\"graphOrder\"), \"border\");","        return defs;","    },","","    /**","     * Collection of markers to be used in the series.","     *","     * @property _markers","     * @type Array","     * @private","     */","    _markers: null,","","    /**","     * Collection of markers to be re-used on a series redraw.","     *","     * @property _markerCache","     * @type Array","     * @private","     */","    _markerCache: null,","   ","    /**","     * Gets and styles a marker. If there is a marker in cache, it will use it. Otherwise","     * it will create one.","     *","     * @method getMarker","     * @param {Object} styles Hash of style properties.","     * @param {Number} order Order of the series.","     * @param {Number} index Index within the series associated with the marker.","     * @return Shape","     * @protected","     */","    getMarker: function(styles, order, index)","    {","        var marker,","            border = styles.border;","        styles.id = this.get(\"chart\").get(\"id\") + \"_\" + order + \"_\" + index;","        //fix name differences between graphic layer","        border.opacity = border.alpha;","        styles.stroke = border;","        styles.fill.opacity = styles.fill.alpha;","        if(this._markerCache.length > 0)","        {","            while(!marker)","            {","                if(this._markerCache.length < 1)","                {","                    marker = this._createMarker(styles, order, index);","                    break;","                }","                marker = this._markerCache.shift();","","            }","            marker.set(styles);","        }","        else","        {","            marker = this._createMarker(styles, order, index);","        }","        this._markers.push(marker);","        return marker;","    },","    ","    /**","     * Creates a shape to be used as a marker.","     *","     * @method _createMarker","     * @param {Object} styles Hash of style properties.","     * @param {Number} order Order of the series.","     * @param {Number} index Index within the series associated with the marker.","     * @return Shape","     * @private","     */","    _createMarker: function(styles, order, index)","    {","        var graphic = this.get(\"graphic\"),","            marker,","            cfg = Y.clone(styles);","        graphic.set(\"autoDraw\", false);","        cfg.type = cfg.shape;","        marker = graphic.addShape(cfg); ","        marker.addClass(SERIES_MARKER);","        return marker;","    },","    ","    /**","     * Creates a cache of markers for reuse.","     *","     * @method _createMarkerCache","     * @private","     */","    _createMarkerCache: function()","    {","        if(this._groupMarker)","        {","            this._groupMarker.destroy();","            this._groupMarker = null;","        }","        if(this._markers && this._markers.length > 0)","        {","            this._markerCache = this._markers.concat();","        }","        else","        {","            this._markerCache = [];","        }","        this._markers = [];","    },","  ","    /**","     * Draws a series of markers in a single shape instance.","     *","     * @method _createGroupMarkers","     * @param {Object} styles Set of configuration properties used to create the markers.","     * @protected","     */","    _createGroupMarker: function(styles)","    {","        var marker,","            markers = this.get(\"markers\"),","            border = styles.border,","            graphic,","            cfg,","            shape;","        if(markers && markers.length > 0)","        {","            while(markers.length > 0)","            {","                marker = markers.shift();","                marker.destroy();","            }","            this.set(\"markers\", []);","        }","        //fix name differences between graphic layer","        border.opacity = border.alpha;","        cfg = {","            id: this.get(\"chart\").get(\"id\") + \"_\" + styles.graphOrder,","            stroke: border,","            fill: styles.fill,","            dimensions: styles.dimensions,","            xvalues: styles.xvalues,","            yvalues: styles.yvalues","        };","        cfg.fill.opacity = styles.fill.alpha;","        shape = this._getGroupShape(styles.shape);","        if(shape)","        {","            cfg.type = shape;","        }","        if(styles.hasOwnProperty(\"radius\") && !isNaN(styles.radius))","        {","            cfg.dimensions.radius = styles.radius;","        }","        if(this._groupMarker)","        {","            this._groupMarker.destroy();","        }","        graphic = this.get(\"graphic\");","        graphic.set(\"autoDraw\", true);","        this._groupMarker = graphic.addShape(cfg);","    },","","    /**","     * Toggles visibility","     *","     * @method _toggleVisible","     * @param {Boolean} visible indicates visibilitye","     * @private","     */","    _toggleVisible: function(visible)","    {","        var marker,","            markers = this.get(\"markers\"),","            i = 0,","            len;","        if(markers)","        {","            len = markers.length;","            for(; i < len; ++i)","            {","                marker = markers[i];","                if(marker)","                {","                    marker.set(\"visible\", visible);","                }","            }","        }","    },","","    /**","     * Removes unused markers from the marker cache","     *","     * @method _clearMarkerCache","     * @private","     */","    _clearMarkerCache: function()","    {","        var marker;","        while(this._markerCache.length > 0)","        {","            marker = this._markerCache.shift();","            if(marker)","            {","                marker.destroy();","            }","        }","    },","","    /**","     * Resizes and positions markers based on a mouse interaction.","     *","     * @method updateMarkerState","     * @param {String} type state of the marker","     * @param {Number} i index of the marker","     * @protected","     */","    updateMarkerState: function(type, i)","    {","        if(this._markers && this._markers[i])","        {","            var w,","                h,","                styles = Y.clone(this.get(\"styles\").marker),","                state = this._getState(type),","                xcoords = this.get(\"xcoords\"),","                ycoords = this.get(\"ycoords\"),","                marker = this._markers[i],","                markerStyles = state == \"off\" || !styles[state] ? styles : styles[state]; ","                markerStyles.fill.color = this._getItemColor(markerStyles.fill.color, i);","                markerStyles.border.color = this._getItemColor(markerStyles.border.color, i);","                markerStyles.stroke = markerStyles.border;","                marker.set(markerStyles);","                w = markerStyles.width;","                h = markerStyles.height;","                marker.set(\"x\", (xcoords[i] - w/2));","                marker.set(\"y\",  (ycoords[i] - h/2));","                marker.set(\"visible\", this.get(\"visible\"));","        }","    },","","    /**","     * Parses a color from an array.","     *","     * @method _getItemColor","     * @param {Array} val collection of colors","     * @param {Number} i index of the item","     * @return String","     * @protected","     */","    _getItemColor: function(val, i)","    {","        if(Y_Lang.isArray(val))","        {","            return val[i % val.length];","        }","        return val;","    },","","    /**","     * Method used by `styles` setter. Overrides base implementation.","     *","     * @method _setStyles","     * @param {Object} newStyles Hash of properties to update.","     * @return Object","     * @protected","     */","    _setStyles: function(val)","    {","        val = this._parseMarkerStyles(val);","        return Y.Renderer.prototype._setStyles.apply(this, [val]);","    },","","    /**","     * Combines new styles with existing styles.","     *","     * @method _parseMarkerStyles","     * @param {Object} Object containing style properties for the marker.","     * @return Object","     * @private","     */","    _parseMarkerStyles: function(val)","    {","        if(val.marker)","        {","            var defs = this._getPlotDefaults();","            val.marker = this._mergeStyles(val.marker, defs);","            if(val.marker.over)","            {","                val.marker.over = this._mergeStyles(val.marker.over, val.marker);","            }","            if(val.marker.down)","            {","                val.marker.down = this._mergeStyles(val.marker.down, val.marker);","            }","        }","        return val;","    },","","    /**","     * Returns marker state based on event type","     *","     * @method _getState","     * @param {String} type event type","     * @return String","     * @protected","     */","    _getState: function(type)","    {","        var state;","        switch(type)","        {","            case \"mouseout\" :","                state = \"off\";","            break;","            case \"mouseover\" :","                state = \"over\";","            break;","            case \"mouseup\" :","                state = \"over\";","            break;","            case \"mousedown\" :","                state = \"down\";","            break;","        }","        return state;","    },","    ","    /**","     * @property _statSyles","     * @type Object","     * @private","     */","    _stateSyles: null","};","","Y.augment(Plots, Y.Attribute);","Y.Plots = Plots;","/**"," * Histogram is the base class for Column and Bar series."," *"," * @module charts"," * @submodule charts-base"," * @class Histogram"," * @constructor"," */","function Histogram(){}","","Histogram.prototype = {","    /**","     * Draws the series.","     *","     * @method drawSeries","     * @protected","     */","    drawSeries: function()","    {","        if(this.get(\"xcoords\").length < 1) ","        {","            return;","        }","        var style = Y.clone(this.get(\"styles\").marker),","            setSize,","            calculatedSize,","            xcoords = this.get(\"xcoords\"),","            ycoords = this.get(\"ycoords\"),","            i = 0,","            len = xcoords.length,","            top = ycoords[0],","            type = this.get(\"type\"),","            graph = this.get(\"graph\"),","            seriesCollection = graph.seriesTypes[type],","            seriesLen = seriesCollection.length,","            seriesSize = 0,","            totalSize = 0,","            offset = 0,","            ratio,","            renderer,","            order = this.get(\"order\"),","            graphOrder = this.get(\"graphOrder\"),","            left,","            marker,","            setSizeKey,","            calculatedSizeKey,","            config,","            fillColors = null,","            borderColors = null,","            xMarkerPlane = [],","            yMarkerPlane = [],","            xMarkerPlaneLeft,","            xMarkerPlaneRight,","            yMarkerPlaneTop,","            yMarkerPlaneBottom,","            dimensions = {","                width: [],","                height: []","            },","            xvalues = [],","            yvalues = [],","            groupMarkers = this.get(\"groupMarkers\");","        if(Y_Lang.isArray(style.fill.color))","        {","            fillColors = style.fill.color.concat(); ","        }","        if(Y_Lang.isArray(style.border.color))","        {","            borderColors = style.border.color.concat();","        }","        if(this.get(\"direction\") == \"vertical\")","        {","            setSizeKey = \"height\";","            calculatedSizeKey = \"width\";","        }","        else","        {","            setSizeKey = \"width\";","            calculatedSizeKey = \"height\";","        }","        setSize = style[setSizeKey];","        calculatedSize = style[calculatedSizeKey];","        this._createMarkerCache();","        for(; i < seriesLen; ++i)","        {","            renderer = seriesCollection[i];","            seriesSize += renderer.get(\"styles\").marker[setSizeKey];","            if(order > i) ","            {","                offset = seriesSize;","            }","        }","        totalSize = len * seriesSize;","        this._maxSize = graph.get(setSizeKey);","        if(totalSize > this._maxSize)","        {","            ratio = graph.get(setSizeKey)/totalSize;","            seriesSize *= ratio;","            offset *= ratio;","            setSize *= ratio;","            setSize = Math.max(setSize, 1);","            this._maxSize = setSize;","        }","        offset -= seriesSize/2;","        for(i = 0; i < len; ++i)","        {","            xMarkerPlaneLeft = xcoords[i] - seriesSize/2;","            xMarkerPlaneRight = xMarkerPlaneLeft + seriesSize;","            yMarkerPlaneTop = ycoords[i] - seriesSize/2;","            yMarkerPlaneBottom = yMarkerPlaneTop + seriesSize;","            xMarkerPlane.push({start: xMarkerPlaneLeft, end: xMarkerPlaneRight});","            yMarkerPlane.push({start: yMarkerPlaneTop, end: yMarkerPlaneBottom});","            if(isNaN(xcoords[i]) || isNaN(ycoords[i]))","            {","                this._markers.push(null);","                continue;","            }","            config = this._getMarkerDimensions(xcoords[i], ycoords[i], calculatedSize, offset);","            if(!isNaN(config.calculatedSize) && config.calculatedSize > 0)","            {","                top = config.top;","                left = config.left;","","                if(groupMarkers)","                {","                    dimensions[setSizeKey][i] = setSize;","                    dimensions[calculatedSizeKey][i] = config.calculatedSize;","                    xvalues.push(left);","                    yvalues.push(top);","                }","                else","                {","                    style[setSizeKey] = setSize;","                    style[calculatedSizeKey] = config.calculatedSize;","                    style.x = left;","                    style.y = top;","                    if(fillColors)","                    {","                        style.fill.color = fillColors[i % fillColors.length];","                    }","                    if(borderColors)","                    {","                        style.border.color = borderColors[i % borderColors.length];","                    }","                    marker = this.getMarker(style, graphOrder, i);","                }","","            }","            else if(!groupMarkers)","            {","                this._markers.push(null);","            }","        }","        this.set(\"xMarkerPlane\", xMarkerPlane);","        this.set(\"yMarkerPlane\", yMarkerPlane);","        if(groupMarkers)","        {","            this._createGroupMarker({","                fill: style.fill,","                border: style.border,","                dimensions: dimensions,","                xvalues: xvalues,","                yvalues: yvalues,","                shape: style.shape","            });","        }","        else","        {","            this._clearMarkerCache();","        }","    },","    ","    /**","     * Collection of default colors used for marker fills in a series when not specified by user.","     *","     * @property _defaultFillColors","     * @type Array","     * @protected","     */","    _defaultFillColors: [\"#66007f\", \"#a86f41\", \"#295454\", \"#996ab2\", \"#e8cdb7\", \"#90bdbd\",\"#000000\",\"#c3b8ca\", \"#968373\", \"#678585\"],","    ","    /**","     * Gets the default style values for the markers.","     *","     * @method _getPlotDefaults","     * @return Object","     * @private","     */","    _getPlotDefaults: function()","    {","        var defs = {","            fill:{","                type: \"solid\",","                alpha: 1,","                colors:null,","                alphas: null,","                ratios: null","            },","            border:{","                weight: 0,","                alpha: 1","            },","            width: 12,","            height: 12,","            shape: \"rect\",","","            padding:{","                top: 0,","                left: 0,","                right: 0,","                bottom: 0","            }","        };","        defs.fill.color = this._getDefaultColor(this.get(\"graphOrder\"), \"fill\");","        defs.border.color = this._getDefaultColor(this.get(\"graphOrder\"), \"border\");","        return defs;","    }","};","","Y.Histogram = Histogram;","/**"," * The CartesianSeries class creates a chart with horizontal and vertical axes."," *"," * @module charts"," * @submodule charts-base"," * @class CartesianSeries"," * @extends Base"," * @uses Renderer"," * @constructor"," */","Y.CartesianSeries = Y.Base.create(\"cartesianSeries\", Y.Base, [Y.Renderer], {","    /**","     * Storage for `xDisplayName` attribute.","     *","     * @property _xDisplayName","     * @type String","     * @private","     */","    _xDisplayName: null,","","    /**","     * Storage for `yDisplayName` attribute.","     *","     * @property _yDisplayName","     * @type String","     * @private","     */","    _yDisplayName: null,","    ","    /**","     * Th x-coordinate for the left edge of the series.","     *","     * @property _leftOrigin","     * @type String","     * @private","     */","    _leftOrigin: null,","","    /**","     * The y-coordinate for the bottom edge of the series.","     * ","     * @property _bottomOrigin","     * @type String","     * @private","     */","    _bottomOrigin: null,","","    /**","     * @method render","     * @private","     */","    render: function()","    {","        this._setCanvas();","        this.addListeners();","        this.set(\"rendered\", true);","        this.validate();","    },","","    /**","     * Adds event listeners.","     *","     * @method addListeners","     * @private","     */","    addListeners: function()","    {","        var xAxis = this.get(\"xAxis\"),","            yAxis = this.get(\"yAxis\");","        if(xAxis)","        {","            this._xDataReadyHandle = xAxis.after(\"dataReady\", Y.bind(this._xDataChangeHandler, this));","            this._xDataUpdateHandle = xAxis.after(\"dataUpdate\", Y.bind(this._xDataChangeHandler, this));","        }","        if(yAxis)","        {","            this._yDataReadyHandle = yAxis.after(\"dataReady\", Y.bind(this._yDataChangeHandler, this));","            this._yDataUpdateHandle = yAxis.after(\"dataUpdate\", Y.bind(this._yDataChangeHandler, this));","        }","        this._xAxisChangeHandle = this.after(\"xAxisChange\", this._xAxisChangeHandler);","        this._yAxisChangeHandle = this.after(\"yAxisChange\", this._yAxisChangeHandler);","        this._stylesChangeHandle = this.after(\"stylesChange\", function(e) {","            var axesReady = this._updateAxisData();","            if(axesReady)","            {","                this.draw();","            }","        });","        this._widthChangeHandle = this.after(\"widthChange\", function(e) {","            var axesReady = this._updateAxisData();","            if(axesReady)","            {","                this.draw();","            }","        });","        this._heightChangeHandle = this.after(\"heightChange\", function(e) {","            var axesReady = this._updateAxisData();","            if(axesReady)","            {","                this.draw();","            }","        });","        this._visibleChangeHandle = this.after(\"visibleChange\", this._handleVisibleChange);","    },","  ","    /**","     * Event handler for the xAxisChange event.","     *","     * @method _xAxisChangeHandler","     * @param {Object} e Event object.","     * @private","     */","    _xAxisChangeHandler: function(e)","    {","        var xAxis = this.get(\"xAxis\");","        xAxis.after(\"dataReady\", Y.bind(this._xDataChangeHandler, this));","        xAxis.after(\"dataUpdate\", Y.bind(this._xDataChangeHandler, this));","    },","    ","    /**","     * Event handler the yAxisChange event.","     *","     * @method _yAxisChangeHandler","     * @param {Object} e Event object.","     * @private","     */","    _yAxisChangeHandler: function(e)","    {","        var yAxis = this.get(\"yAxis\");","        yAxis.after(\"dataReady\", Y.bind(this._yDataChangeHandler, this));","        yAxis.after(\"dataUpdate\", Y.bind(this._yDataChangeHandler, this));","    },","","    /**","     * Constant used to generate unique id.","     *","     * @property GUID","     * @type String","     * @private","     */","    GUID: \"yuicartesianseries\",","","    /**","     * Event handler for xDataChange event.","     *","     * @method _xDataChangeHandler","     * @param {Object} event Event object.","     * @private ","     */","    _xDataChangeHandler: function(event)","    {","        var axesReady = this._updateAxisData();","        if(axesReady)","        {","            this.draw();","        }","    },","","    /**","     * Event handler for yDataChange event.","     *","     * @method _yDataChangeHandler","     * @param {Object} event Event object.","     * @private ","     */","    _yDataChangeHandler: function(event)","    {","        var axesReady = this._updateAxisData();","        if(axesReady)","        {","            this.draw();","        }","    },","","    /**","     * Checks to ensure that both xAxis and yAxis data are available. If so, set the `xData` and `yData` attributes and return `true`. Otherwise, return `false`.","     *","     * @method _updateAxisData","     * @return Boolean","     * @private ","     */","    _updateAxisData: function()","    {","        var xAxis = this.get(\"xAxis\"),","            yAxis = this.get(\"yAxis\"),","            xKey = this.get(\"xKey\"),","            yKey = this.get(\"yKey\"),","            yData,","            xData;","        if(!xAxis || !yAxis || !xKey || !yKey)","        {","            return false;","        }","        xData = xAxis.getDataByKey(xKey);","        yData = yAxis.getDataByKey(yKey);","        if(!xData || !yData)","        {","            return false;","        }","        this.set(\"xData\", xData.concat());","        this.set(\"yData\", yData.concat());","        return true;","    },","","    /**","     * Draws the series is the xAxis and yAxis data are both available.","     *","     * @method validate","     * @private","     */","    validate: function()","    {","        if((this.get(\"xData\") && this.get(\"yData\")) || this._updateAxisData())","        {","            this.draw();","        }","        else","        {","            this.fire(\"drawingComplete\");","        }","    },","","    /**","     * Creates a `Graphic` instance.","     *","     * @method _setCanvas","     * @protected","     */","    _setCanvas: function()","    {","        var graph = this.get(\"graph\"),","            graphic = graph.get(\"graphic\");","        this.set(\"graphic\", graphic);","    },","","    /**","     * Calculates the coordinates for the series.","     *","     * @method setAreaData","     * @protected","     */","    setAreaData: function()","    {","        var isNumber = Y_Lang.isNumber,","            nextX, nextY,","            graph = this.get(\"graph\"),","            w = graph.get(\"width\"),","            h = graph.get(\"height\"),","            xAxis = this.get(\"xAxis\"),","            yAxis = this.get(\"yAxis\"),","            xData = this.get(\"xData\").concat(),","            yData = this.get(\"yData\").concat(),","            xValue,","            yValue,","            xOffset = xAxis.getEdgeOffset(xData.length, w),","            yOffset = yAxis.getEdgeOffset(yData.length, h),","            padding = this.get(\"styles\").padding,","			leftPadding = padding.left,","			topPadding = padding.top,","			dataWidth = w - (leftPadding + padding.right + xOffset),","			dataHeight = h - (topPadding + padding.bottom + yOffset),","			xcoords = [],","			ycoords = [],","			xMax = xAxis.get(\"maximum\"),","			xMin = xAxis.get(\"minimum\"),","			yMax = yAxis.get(\"maximum\"),","			yMin = yAxis.get(\"minimum\"),","            xScaleFactor = dataWidth / (xMax - xMin),","			yScaleFactor = dataHeight / (yMax - yMin),","            dataLength,","            direction = this.get(\"direction\"),","            i = 0,","            xMarkerPlane = [],","            yMarkerPlane = [],","            xMarkerPlaneOffset = this.get(\"xMarkerPlaneOffset\"),","            yMarkerPlaneOffset = this.get(\"yMarkerPlaneOffset\"),","            graphic = this.get(\"graphic\");","        graphic.set(\"width\", w);","        graphic.set(\"height\", h);","        dataLength = xData.length;","        xOffset *= 0.5;","        yOffset *= 0.5;","        //Assuming a vertical graph has a range/category for its vertical axis.    ","        if(direction === \"vertical\")","        {","            yData = yData.reverse();","        }","        this._leftOrigin = Math.round(((0 - xMin) * xScaleFactor) + leftPadding + xOffset);","        this._bottomOrigin = Math.round((dataHeight + topPadding + yOffset)); ","        if(yMin < 0)","        {","            this._bottomOrigin = this._bottomOrigin - ((0 - yMin) * yScaleFactor);","        }","        for (; i < dataLength; ++i) ","		{","            xValue = parseFloat(xData[i]);","            yValue = parseFloat(yData[i]);","            if(isNumber(xValue))","            {","                nextX = (((xValue - xMin) * xScaleFactor) + leftPadding + xOffset);","            }","            else","            {","                nextX = NaN;","            }","            if(isNumber(yValue))","            {","			    nextY = ((dataHeight + topPadding + yOffset) - (yValue - yMin) * yScaleFactor);","            }","            else","            {","                nextY = NaN;","            }","            xcoords.push(nextX);","            ycoords.push(nextY);","            xMarkerPlane.push({start:nextX - xMarkerPlaneOffset, end: nextX + xMarkerPlaneOffset});","            yMarkerPlane.push({start:nextY - yMarkerPlaneOffset, end: nextY + yMarkerPlaneOffset});","        }","        this.set(\"xcoords\", xcoords);","		this.set(\"ycoords\", ycoords);","        this.set(\"xMarkerPlane\", xMarkerPlane);","        this.set(\"yMarkerPlane\", yMarkerPlane);","        this._dataLength = dataLength;","    },","","    /**","     * Finds the first valid index of an array coordinates.","     *","     * @method _getFirstValidIndex","     * @param {Array} coords An array of x or y coordinates.","     * @return Number","     * @private","     */","    _getFirstValidIndex: function(coords)","    {","        var coord,","            i = -1,","            limit = coords.length;","        while(!Y_Lang.isNumber(coord) && i < limit)","        {","            i += 1;","            coord = coords[i];","        }","        return i;","    },","","    /**","     * Finds the last valid index of an array coordinates.","     *","     * @method _getLastValidIndex","     * @param {Array} coords An array of x or y coordinates.","     * @return Number","     * @private","     */","    _getLastValidIndex: function(coords)","    {","        var coord,","            i = coords.length,","            limit = -1;","        while(!Y_Lang.isNumber(coord) && i > limit)","        {","            i -= 1;","            coord = coords[i];","        }","        return i;","    },","","    /**","     * Draws the series.","     *","     * @method draw","     * @protected","     */","    draw: function()","    {","        var graph = this.get(\"graph\"),","            w = graph.get(\"width\"),","            h = graph.get(\"height\");","        if(this.get(\"rendered\"))","        {","            if((isFinite(w) && isFinite(h) && w > 0 && h > 0) && ((this.get(\"xData\") && this.get(\"yData\")) || this._updateAxisData()))","            {","                if(this._drawing)","                {","                    this._callLater = true;","                    return;","                }","                this._drawing = true;","                this._callLater = false;","                this.setAreaData();","                if(this.get(\"xcoords\") && this.get(\"ycoords\"))","                {","                    this.drawSeries();","                }","                this._drawing = false;","                if(this._callLater)","                {","                    this.draw();","                }","                else","                {","                    this._toggleVisible(this.get(\"visible\"));","                    this.fire(\"drawingComplete\");","                }","            }","        }","    },","    ","    /**","     * Default value for plane offsets when the parent chart's `interactiveType` is `planar`. ","     *","     * @property _defaultPlaneOffset","     * @type Number","     * @private","     */","    _defaultPlaneOffset: 4,","    ","    /**","     * Gets the default value for the `styles` attribute. Overrides","     * base implementation.","     *","     * @method _getDefaultStyles","     * @return Object","     * @protected","     */","    _getDefaultStyles: function()","    {","        return {padding:{","                top: 0,","                left: 0,","                right: 0,","                bottom: 0","            }};","    },","","    /**","     * Collection of default colors used for lines in a series when not specified by user.","     *","     * @property _defaultLineColors","     * @type Array","     * @protected","     */","    _defaultLineColors:[\"#426ab3\", \"#d09b2c\", \"#000000\", \"#b82837\", \"#b384b5\", \"#ff7200\", \"#779de3\", \"#cbc8ba\", \"#7ed7a6\", \"#007a6c\"],","","    /**","     * Collection of default colors used for marker fills in a series when not specified by user.","     *","     * @property _defaultFillColors","     * @type Array","     * @protected","     */","    _defaultFillColors:[\"#6084d0\", \"#eeb647\", \"#6c6b5f\", \"#d6484f\", \"#ce9ed1\", \"#ff9f3b\", \"#93b7ff\", \"#e0ddd0\", \"#94ecba\", \"#309687\"],","    ","    /**","     * Collection of default colors used for marker borders in a series when not specified by user.","     *","     * @property _defaultBorderColors","     * @type Array","     * @protected","     */","    _defaultBorderColors:[\"#205096\", \"#b38206\", \"#000000\", \"#94001e\", \"#9d6fa0\", \"#e55b00\", \"#5e85c9\", \"#adab9e\", \"#6ac291\", \"#006457\"],","    ","    /**","     * Collection of default colors used for area fills, histogram fills and pie fills in a series when not specified by user.","     *","     * @property _defaultSliceColors","     * @type Array","     * @protected","     */","    _defaultSliceColors: [\"#66007f\", \"#a86f41\", \"#295454\", \"#996ab2\", \"#e8cdb7\", \"#90bdbd\",\"#000000\",\"#c3b8ca\", \"#968373\", \"#678585\"],","","    /**","     * Parses a color based on a series order and type.","     *","     * @method _getDefaultColor","     * @param {Number} index Index indicating the series order.","     * @param {String} type Indicates which type of object needs the color.","     * @return String","     * @protected","     */","    _getDefaultColor: function(index, type)","    {","        var colors = {","                line: this._defaultLineColors,","                fill: this._defaultFillColors,","                border: this._defaultBorderColors,","                slice: this._defaultSliceColors","            },","            col = colors[type],","            l = col.length;","        index = index || 0;","        if(index >= l)","        {","            index = index % l;","        }","        type = type || \"fill\";","        return colors[type][index];","    },","    ","    /**","     * Shows/hides contents of the series.","     *","     * @method _handleVisibleChange","     * @param {Object} e Event object.","     * @protected","     */","    _handleVisibleChange: function(e) ","    {","        this._toggleVisible(this.get(\"visible\"));","    },","","    /**","     * Returns the sum of all values for the series.","     *","     * @method getTotalValues","     * @return Number","     */","    getTotalValues: function()","    {","        var total = this.get(\"valueAxis\").getTotalByKey(this.get(\"valueKey\"));","        return total;","    },","","    /**","     * Destructor implementation for the CartesianSeries class. Calls destroy on all Graphic instances.","     *","     * @method destructor","     * @protected","     */","    destructor: function()","    {","        var marker,","            markers = this.get(\"markers\");","        if(this.get(\"rendered\"))","        {","            if(this._xDataReadyHandle)","            {","                this._xDataReadyHandle.detach();","            }","            if(this._xDataUpdateHandle)","            {","                this._xDataUpdateHandle.detach();","            }","            if(this._yDataReadyHandle)","            {","                this._yDataReadyHandle.detach();","            }","            if(this._yDataUpdateHandle)","            {","                this._yDataUpdateHandle.detach();","            }","            this._xAxisChangeHandle.detach();","            this._yAxisChangeHandle.detach();","            this._stylesChangeHandle.detach();","            this._widthChangeHandle.detach();","            this._heightChangeHandle.detach();","            this._visibleChangeHandle.detach();","        }","        while(markers && markers.length > 0)","        {","            marker = markers.shift();","            if(marker && marker instanceof Y.Shape)","            {","                marker.destroy();","            }","        }","        if(this._path)","        {","            this._path.destroy();","            this._path = null;","        }","        if(this._lineGraphic)","        {","            this._lineGraphic.destroy();","            this._lineGraphic = null;","        }","        if(this._groupMarker)","        {","            this._groupMarker.destroy();","            this._groupMarker = null;","        }","    }","        /**","         * Event handle for the x-axis' dataReady event.","         * ","         * @property _xDataReadyHandle","         * @type {EventHandle}","         * @private","         */","        ","        /**","         * Event handle for the x-axis dataUpdate event.","         *","         * @property _xDataUpdateHandle","         * @type {EventHandle}","         * @private","         */","        ","        /**","         * Event handle for the y-axis dataReady event.","         *","         * @property _yDataReadyHandle","         * @type {EventHandle}","         * @private","         */","","        /**","         * Event handle for the y-axis dataUpdate event.","         * @property _yDataUpdateHandle","         * @type {EventHandle}","         * @private","         */","","        /**","         * Event handle for the xAxisChange event.","         * @property _xAxisChangeHandle","         * @type {EventHandle}","         * @private","         */","","        /**","         * Event handle for the yAxisChange event.","         * @property _yAxisChangeHandle","         * @type {EventHandle}","         * @private","         */","","        /**","         * Event handle for the stylesChange event.","         * @property _stylesChangeHandle","         * @type {EventHandle}","         * @private","         */","","        /**","         * Event handle for the widthChange event.","         * @property _widthChangeHandle","         * @type {EventHandle}","         * @private","         */","","        /**","         * Event handle for the heightChange event.","         * @property _heightChangeHandle","         * @type {EventHandle}","         * @private","         */","","        /**","         * Event handle for the visibleChange event.","         * @property _visibleChangeHandle","         * @type {EventHandle}","         * @private","         */","}, {","    ATTRS: {","        /**","         * Name used for for displaying data related to the x-coordinate.","         *","         * @attribute xDisplayName","         * @type String","         */","        xDisplayName: {","            getter: function()","            {","                return this._xDisplayName || this.get(\"xKey\");","            },","","            setter: function(val)","            {","                this._xDisplayName = val.toString();","                return val;","            }","        },","","        /**","         * Name used for for displaying data related to the y-coordinate.","         *","         * @attribute yDisplayName","         * @type String","         */","        yDisplayName: {","            getter: function()","            {","                return this._yDisplayName || this.get(\"yKey\");","            },","","            setter: function(val)","            {","                this._yDisplayName = val.toString();","                return val;","            }","        },","        ","        /**","         * Name used for for displaying category data","         *","         * @attribute categoryDisplayName","         * @type String","         * @readOnly","         */","        categoryDisplayName: {","            lazyAdd: false,","","            getter: function()","            {","                return this.get(\"direction\") == \"vertical\" ? this.get(\"yDisplayName\") : this.get(\"xDisplayName\");","           },","","            setter: function(val)","            {","                if(this.get(\"direction\") == \"vertical\")","                {","                    this._yDisplayName = val;","                }","                else","                {","                    this._xDisplayName = val;","                }","                return val;","            }","        },","","        /**","         * Name used for for displaying value data","         *","         * @attribute valueDisplayName","         * @type String","         * @readOnly","         */","        valueDisplayName: {","            lazyAdd: false,","","            getter: function()","            {","                return this.get(\"direction\") == \"vertical\" ? this.get(\"xDisplayName\") : this.get(\"yDisplayName\");","            },","","            setter: function(val)","            {","                if(this.get(\"direction\") == \"vertical\")","                {","                    this._xDisplayName = val;","                }","                else","                {","                    this._yDisplayName = val;","                }","                return val;","            }","        },","        ","        /**","         * Read-only attribute indicating the type of series.","         *","         * @attribute type","         * @type String","         * @default cartesian","         */","        type: {		","            value: \"cartesian\"","        },","","        /**","         * Order of this instance of this `type`.","         *","         * @attribute order","         * @type Number","         */","        order: {},","","        /**","         * Order of the instance","         *","         * @attribute graphOrder","         * @type Number","         */","        graphOrder: {},","","        /**","         * x coordinates for the series.","         *","         * @attribute xcoords","         * @type Array","         */","        xcoords: {},","        ","        /**","         * y coordinates for the series","         *","         * @attribute ycoords","         * @type Array","         */","        ycoords: {},","","        /**","         * Reference to the `Chart` application.","         *","         * @attribute chart","         * @type ChartBase","         * @readOnly","         */","        chart: {","            readOnly: true,","","            getter: function()","            {","                return this.get(\"graph\").get(\"chart\");","            }","        },","        ","        /**","         * Reference to the `Graph` in which the series is drawn into.","         *","         * @attribute graph","         * @type Graph","         */","        graph: {},","","        /**","         * Reference to the `Axis` instance used for assigning ","         * x-values to the graph.","         *","         * @attribute xAxis","         * @type Axis","         */","        xAxis: {},","        ","        /**","         * Reference to the `Axis` instance used for assigning ","         * y-values to the graph.","         *","         * @attribute yAxis","         * @type Axis","         */","        yAxis: {},","        ","        /**","         * Indicates which array to from the hash of value arrays in ","         * the x-axis `Axis` instance.","         *","         * @attribute xKey","         * @type String","         */","        xKey: {","            setter: function(val)","            {","                return val.toString();","            }","        },","","        /**","         * Indicates which array to from the hash of value arrays in ","         * the y-axis `Axis` instance.","         *","         * @attribute yKey","         * @type String","         */","        yKey: {","            setter: function(val)","            {","                return val.toString();","            }","        },","","        /**","         * Array of x values for the series.","         *","         * @attribute xData","         * @type Array","         */","        xData: {},","","        /**","         * Array of y values for the series.","         *","         * @attribute yData","         * @type Array","         */","        yData: {},","       ","        /**","         * Indicates whether the Series has been through its initial set up.","         *","         * @attribute rendered","         * @type Boolean","         */","        rendered: {","            value: false","        },","","        /*","         * Returns the width of the parent graph","         *","         * @attribute width","         * @type Number","         */","        width: {","            readOnly: true,","            ","            getter: function()","            {","                this.get(\"graph\").get(\"width\");","            }","        },","","        /**","         * Returns the height of the parent graph","         *","         * @attribute height","         * @type Number","         */","        height: {","            readOnly: true,","            ","            getter: function()","            {","                this.get(\"graph\").get(\"height\");","            }","        },","","        /**","         * Indicates whether to show the series","         *","         * @attribute visible","         * @type Boolean","         * @default true","         */","        visible: {","            value: true","        },","","        /**","         * Collection of area maps along the xAxis. Used to determine mouseover for multiple","         * series.","         *","         * @attribute xMarkerPlane","         * @type Array","         */","        xMarkerPlane: {},","        ","        /**","         * Collection of area maps along the yAxis. Used to determine mouseover for multiple","         * series.","         *","         * @attribute yMarkerPlane","         * @type Array","         */","        yMarkerPlane: {},","","        /**","         * Distance from a data coordinate to the left/right for setting a hotspot.","         *","         * @attribute xMarkerPlaneOffset","         * @type Number","         */","        xMarkerPlaneOffset: {","            getter: function() {","                var marker = this.get(\"styles\").marker;","                if(marker && marker.width && isFinite(marker.width))","                {","                    return marker.width * 0.5;","                }","                return this._defaultPlaneOffset;","            }","        },","","        /**","         * Distance from a data coordinate to the top/bottom for setting a hotspot.","         *","         * @attribute yMarkerPlaneOffset","         * @type Number","         */","        yMarkerPlaneOffset: {","            getter: function() {","                var marker = this.get(\"styles\").marker;","                if(marker && marker.height && isFinite(marker.height))","                {","                    return marker.height * 0.5;","                }","                return this._defaultPlaneOffset;","            }","        },","","        /**","         * Direction of the series","         *","         * @attribute direction","         * @type String","         */","        direction: {","            value: \"horizontal\"","        },","","        /**","         * Indicates whether or not markers for a series will be grouped and rendered in a single complex shape instance.","         *","         * @attribute groupMarkers","         * @type Boolean","         */","        groupMarkers: {","            getter: function()","            {","                if(this._groupMarkers === undefined)","                {","                    return this.get(\"graph\").get(\"groupMarkers\");","                }","                else","                {","                    return this._groupMarkers;","                }","            },","","            setter: function(val)","            {","                this._groupMarkers = val;","                return val;","            }","        }","    }","});","/**"," * The MarkerSeries class renders quantitative data by plotting relevant data points "," * on a graph."," *"," * @module charts"," * @submodule charts-base"," * @class MarkerSeries"," * @extends CartesianSeries"," * @uses Plots"," * @constructor"," */","Y.MarkerSeries = Y.Base.create(\"markerSeries\", Y.CartesianSeries, [Y.Plots], {","    /**","     * @protected","     *","     * Draws the series.","     *","     * @method drawSeries","     */","    drawSeries: function()","    {","        this.drawPlots();","    },","    ","    /**","     * @protected","     *","     * Method used by `styles` setter. Overrides base implementation.","     *","     * @method _setStyles","     * @param {Object} newStyles Hash of properties to update.","     * @return Object","     */","    _setStyles: function(val)","    {","        if(!val.marker)","        {","            val = {marker:val};","        }","        val = this._parseMarkerStyles(val);","        return Y.MarkerSeries.superclass._mergeStyles.apply(this, [val, this._getDefaultStyles()]);","    },","    ","    /**","     * @protected","     *","     * Gets the default value for the `styles` attribute. Overrides","     * base implementation.","     *","     * @method _getDefaultStyles","     * @return Object","     */","    _getDefaultStyles: function()","    {","        var styles = this._mergeStyles({marker:this._getPlotDefaults()}, Y.MarkerSeries.superclass._getDefaultStyles());","        return styles;","    }","},{","    ATTRS : {","        /**","         * Read-only attribute indicating the type of series.","         *","         * @attribute type","         * @type String","         * @default marker","         */","        type: {","            value:\"marker\"","        }","        ","        /**","         * Style properties used for drawing markers. This attribute is inherited from `Renderer`. Below are the default values:","         *  <dl>","         *      <dt>fill</dt><dd>A hash containing the following values:","         *          <dl>","         *              <dt>color</dt><dd>Color of the fill. The default value is determined by the order of the series on the graph. The color","         *              will be retrieved from the below array:<br/>","         *              `[\"#6084d0\", \"#eeb647\", \"#6c6b5f\", \"#d6484f\", \"#ce9ed1\", \"#ff9f3b\", \"#93b7ff\", \"#e0ddd0\", \"#94ecba\", \"#309687\"]`","         *              </dd>","         *              <dt>alpha</dt><dd>Number from 0 to 1 indicating the opacity of the marker fill. The default value is 1.</dd>","         *          </dl>","         *      </dd>","         *      <dt>border</dt><dd>A hash containing the following values:","         *          <dl>","         *              <dt>color</dt><dd>Color of the border. The default value is determined by the order of the series on the graph. The color","         *              will be retrieved from the below array:<br/>","         *              `[\"#205096\", \"#b38206\", \"#000000\", \"#94001e\", \"#9d6fa0\", \"#e55b00\", \"#5e85c9\", \"#adab9e\", \"#6ac291\", \"#006457\"]`","         *              <dt>alpha</dt><dd>Number from 0 to 1 indicating the opacity of the marker border. The default value is 1.</dd>","         *              <dt>weight</dt><dd>Number indicating the width of the border. The default value is 1.</dd>","         *          </dl>","         *      </dd>","         *      <dt>width</dt><dd>indicates the width of the marker. The default value is 10.</dd>","         *      <dt>height</dt><dd>indicates the height of the marker The default value is 10.</dd>","         *      <dt>over</dt><dd>hash containing styles for markers when highlighted by a `mouseover` event. The default ","         *      values for each style is null. When an over style is not set, the non-over value will be used. For example,","         *      the default value for `marker.over.fill.color` is equivalent to `marker.fill.color`.</dd>","         *  </dl>","         *","         * @attribute styles","         * @type Object","         */","    }","});","","/**"," * The LineSeries class renders quantitative data on a graph by connecting relevant data points."," *"," * @module charts"," * @submodule charts-base"," * @class LineSeries"," * @extends CartesianSeries"," * @uses Lines"," * @constructor"," */","Y.LineSeries = Y.Base.create(\"lineSeries\", Y.CartesianSeries, [Y.Lines], {","    /**","     * @protected","     *","     * @method drawSeries","     */","    drawSeries: function()","    {","        this.drawLines();","    },","","    /**","     * @protected","     *","     * Method used by `styles` setter. Overrides base implementation.","     *","     * @method _setStyles","     * @param {Object} newStyles Hash of properties to update.","     * @return Object","     */","    _setStyles: function(val)","    {","        if(!val.line)","        {","            val = {line:val};","        }","        return Y.LineSeries.superclass._setStyles.apply(this, [val]);","    },","","    /**","     * @protected","     *","     * Gets the default value for the `styles` attribute. Overrides","     * base implementation.","     *","     * @method _getDefaultStyles","     * @return Object","     */","    _getDefaultStyles: function()","    {","        var styles = this._mergeStyles({line:this._getLineDefaults()}, Y.LineSeries.superclass._getDefaultStyles());","        return styles;","    }","},","{","    ATTRS: {","        /**","         * Read-only attribute indicating the type of series.","         *","         * @attribute type","         * @type String","         * @default line","         */","        type: {","            value:\"line\"","        }","","        /**","         * Style properties used for drawing lines. This attribute is inherited from `Renderer`. Below are the default values:","         *  <dl>","         *      <dt>color</dt><dd>The color of the line. The default value is determined by the order of the series on the graph. The color will be","         *      retrieved from the following array: ","         *      `[\"#426ab3\", \"#d09b2c\", \"#000000\", \"#b82837\", \"#b384b5\", \"#ff7200\", \"#779de3\", \"#cbc8ba\", \"#7ed7a6\", \"#007a6c\"]`","         *      <dt>weight</dt><dd>Number that indicates the width of the line. The default value is 6.</dd>","         *      <dt>alpha</dt><dd>Number between 0 and 1 that indicates the opacity of the line. The default value is 1.</dd>","         *      <dt>lineType</dt><dd>Indicates whether the line is solid or dashed. The default value is solid.</dd> ","         *      <dt>dashLength</dt><dd>When the `lineType` is dashed, indicates the length of the dash. The default value is 10.</dd>","         *      <dt>gapSpace</dt><dd>When the `lineType` is dashed, indicates the distance between dashes. The default value is 10.</dd>","         *      <dt>connectDiscontinuousPoints</dt><dd>Indicates whether or not to connect lines when there is a missing or null value between points. The default value is true.</dd> ","         *      <dt>discontinuousType</dt><dd>Indicates whether the line between discontinuous points is solid or dashed. The default value is solid.</dd>","         *      <dt>discontinuousDashLength</dt><dd>When the `discontinuousType` is dashed, indicates the length of the dash. The default value is 10.</dd>","         *      <dt>discontinuousGapSpace</dt><dd>When the `discontinuousType` is dashed, indicates the distance between dashes. The default value is 10.</dd>","         *  </dl>","         *","         * @attribute styles","         * @type Object","         */","    }","});","","","","		","","		","/**"," * SplineSeries renders a graph with data points connected by a curve."," *"," * @module charts"," * @submodule charts-base"," * @class SplineSeries"," * @constructor"," * @extends CartesianSeries"," * @uses CurveUtil"," * @uses Lines"," */","Y.SplineSeries = Y.Base.create(\"splineSeries\",  Y.LineSeries, [Y.CurveUtil, Y.Lines], {","    /**","     * @protected","     *","     * Draws the series.","     *","     * @method drawSeries","     */","    drawSeries: function()","    {","        this.drawSpline();","    }","}, {","	ATTRS : {","        /**","         * Read-only attribute indicating the type of series.","         *","         * @attribute type","         * @type String","         * @default spline","         */","        type : {","            value:\"spline\"","        }","","        /**","         * Style properties used for drawing lines. This attribute is inherited from `Renderer`. Below are the default values:","         *  <dl>","         *      <dt>color</dt><dd>The color of the line. The default value is determined by the order of the series on the graph. The color will be","         *      retrieved from the following array: ","         *      `[\"#426ab3\", \"#d09b2c\", \"#000000\", \"#b82837\", \"#b384b5\", \"#ff7200\", \"#779de3\", \"#cbc8ba\", \"#7ed7a6\", \"#007a6c\"]`","         *      <dt>weight</dt><dd>Number that indicates the width of the line. The default value is 6.</dd>","         *      <dt>alpha</dt><dd>Number between 0 and 1 that indicates the opacity of the line. The default value is 1.</dd>","         *      <dt>lineType</dt><dd>Indicates whether the line is solid or dashed. The default value is solid.</dd> ","         *      <dt>dashLength</dt><dd>When the `lineType` is dashed, indicates the length of the dash. The default value is 10.</dd>","         *      <dt>gapSpace</dt><dd>When the `lineType` is dashed, indicates the distance between dashes. The default value is 10.</dd>","         *      <dt>connectDiscontinuousPoints</dt><dd>Indicates whether or not to connect lines when there is a missing or null value between points. The default value is true.</dd> ","         *      <dt>discontinuousType</dt><dd>Indicates whether the line between discontinuous points is solid or dashed. The default value is solid.</dd>","         *      <dt>discontinuousDashLength</dt><dd>When the `discontinuousType` is dashed, indicates the length of the dash. The default value is 10.</dd>","         *      <dt>discontinuousGapSpace</dt><dd>When the `discontinuousType` is dashed, indicates the distance between dashes. The default value is 10.</dd>","         *  </dl>","         *","         * @attribute styles","         * @type Object","         */","    }","});","","","","		","","		","/**"," * StackedSplineSeries creates spline graphs in which the different series are stacked along a value axis"," * to indicate their contribution to a cumulative total."," *"," * @module charts"," * @submodule charts-base"," * @class StackedSplineSeries"," * @constructor"," * @extends SplineSeries"," * @extends StackingUtil"," */","Y.StackedSplineSeries = Y.Base.create(\"stackedSplineSeries\", Y.SplineSeries, [Y.StackingUtil], {","    /**","     * @protected","     *","     * Calculates the coordinates for the series. Overrides base implementation.","     *","     * @method setAreaData","     */","    setAreaData: function()","    {   ","        Y.StackedSplineSeries.superclass.setAreaData.apply(this);","        this._stackCoordinates.apply(this);","    }","}, {","    ATTRS: {","        /**","         * Read-only attribute indicating the type of series.","         *","         * @attribute type","         * @type String","         * @default stackedSpline","         */","        type: {","            value:\"stackedSpline\"","        }","    }","});","","/**"," * StackedMarkerSeries plots markers with different series stacked along the value axis to indicate each"," * series' contribution to a cumulative total."," *"," * @module charts"," * @submodule charts-base"," * @class StackedMarkerSeries"," * @constructor"," * @extends MarkerSeries"," * @extends StackingUtil"," */","Y.StackedMarkerSeries = Y.Base.create(\"stackedMarkerSeries\", Y.MarkerSeries, [Y.StackingUtil], {","    /**","     * @protected","     *","     * Calculates the coordinates for the series. Overrides base implementation.","     *","     * @method setAreaData","     */","    setAreaData: function()","    {   ","        Y.StackedMarkerSeries.superclass.setAreaData.apply(this);","        this._stackCoordinates.apply(this);","    }","}, {","    ATTRS: {","        /**","         * Read-only attribute indicating the type of series.","         *","         * @attribute type","         * @type String","         * @default stackedMarker","         */","        type: {","            value:\"stackedMarker\"","        }","    }","});","","/**"," * The ColumnSeries class renders columns positioned horizontally along a category or time axis. The columns'"," * lengths are proportional to the values they represent along a vertical axis."," * and the relevant data points."," *"," * @module charts"," * @submodule charts-base"," * @class ColumnSeries"," * @extends MarkerSeries"," * @uses Histogram"," * @constructor"," */","Y.ColumnSeries = Y.Base.create(\"columnSeries\", Y.MarkerSeries, [Y.Histogram], {","    /**","     * Helper method for calculating the size of markers. ","     *","     * @method _getMarkerDimensions","     * @param {Number} xcoord The x-coordinate representing the data point for the marker.","     * @param {Number} ycoord The y-coordinate representing the data point for the marker.","     * @param {Number} calculatedSize The calculated size for the marker. For a `BarSeries` is it the width. For a `ColumnSeries` it is the height.","     * @param {Number} offset Distance of position offset dictated by other marker series in the same graph.","     * @return Object","     * @private","     */","    _getMarkerDimensions: function(xcoord, ycoord, calculatedSize, offset)","    {","        var config = {","            left: xcoord + offset","        };","        if(this._bottomOrigin >= ycoord)","        {","            config.top = ycoord;","            config.calculatedSize = this._bottomOrigin - config.top;","        }","        else","        {","            config.top = this._bottomOrigin;","            config.calculatedSize = ycoord - this._bottomOrigin;","        }","        return config;","    },","","    /**","     * Resizes and positions markers based on a mouse interaction.","     *","     * @method updateMarkerState","     * @param {String} type state of the marker","     * @param {Number} i index of the marker","     * @protected","     */","    updateMarkerState: function(type, i)","    {","        if(this._markers && this._markers[i])","        {","            var styles = Y.clone(this.get(\"styles\").marker),","                markerStyles,","                state = this._getState(type),","                xcoords = this.get(\"xcoords\"),","                ycoords = this.get(\"ycoords\"),","                marker = this._markers[i],","                markers,","                graph = this.get(\"graph\"),","                seriesStyles,","                seriesCollection = graph.seriesTypes[this.get(\"type\")],","                seriesLen = seriesCollection.length,","                seriesSize = 0,","                offset = 0,","                renderer,","                n = 0,","                xs = [],","                order = this.get(\"order\"),","                config;","            markerStyles = state == \"off\" || !styles[state] ? Y.clone(styles) : Y.clone(styles[state]); ","            markerStyles.fill.color = this._getItemColor(markerStyles.fill.color, i);","            markerStyles.border.color = this._getItemColor(markerStyles.border.color, i);","            config = this._getMarkerDimensions(xcoords[i], ycoords[i], styles.width, offset);","            markerStyles.height = config.calculatedSize;","            markerStyles.width = Math.min(this._maxSize, markerStyles.width);","            marker.set(markerStyles);","            for(; n < seriesLen; ++n)","            {","                xs[n] = xcoords[i] + seriesSize;","                seriesStyles = seriesCollection[n].get(\"styles\").marker;","                seriesSize += Math.min(this._maxSize, seriesStyles.width);","                if(order > n)","                {","                    offset = seriesSize;","                }","                offset -= seriesSize/2;","            }","            for(n = 0; n < seriesLen; ++n)","            {","                markers = seriesCollection[n].get(\"markers\");","                if(markers)","                {","                    renderer = markers[i];","                    if(renderer && renderer !== undefined)","                    {","                        renderer.set(\"x\", (xs[n] - seriesSize/2));","                    }","                }","            }","        }","    }","}, {","    ATTRS: {","        /**","         * Read-only attribute indicating the type of series.","         *","         * @attribute type","         * @type String","         * @readOnly","         * @default column","         */","        type: {","            value: \"column\"","        }","        ","        /**","         * Style properties used for drawing markers. This attribute is inherited from `MarkerSeries`. Below are the default values:","         *  <dl>","         *      <dt>fill</dt><dd>A hash containing the following values:","         *          <dl>","         *              <dt>color</dt><dd>Color of the fill. The default value is determined by the order of the series on the graph. The color","         *              will be retrieved from the below array:<br/>","         *              `[\"#66007f\", \"#a86f41\", \"#295454\", \"#996ab2\", \"#e8cdb7\", \"#90bdbd\",\"#000000\",\"#c3b8ca\", \"#968373\", \"#678585\"]`","         *              </dd>","         *              <dt>alpha</dt><dd>Number from 0 to 1 indicating the opacity of the marker fill. The default value is 1.</dd>","         *          </dl>","         *      </dd>","         *      <dt>border</dt><dd>A hash containing the following values:","         *          <dl>","         *              <dt>color</dt><dd>Color of the border. The default value is determined by the order of the series on the graph. The color","         *              will be retrieved from the below array:<br/>","         *              `[\"#205096\", \"#b38206\", \"#000000\", \"#94001e\", \"#9d6fa0\", \"#e55b00\", \"#5e85c9\", \"#adab9e\", \"#6ac291\", \"#006457\"]`","         *              <dt>alpha</dt><dd>Number from 0 to 1 indicating the opacity of the marker border. The default value is 1.</dd>","         *              <dt>weight</dt><dd>Number indicating the width of the border. The default value is 1.</dd>","         *          </dl>","         *      </dd>","         *      <dt>width</dt><dd>indicates the width of the marker. The default value is 12.</dd>","         *      <dt>over</dt><dd>hash containing styles for markers when highlighted by a `mouseover` event. The default ","         *      values for each style is null. When an over style is not set, the non-over value will be used. For example,","         *      the default value for `marker.over.fill.color` is equivalent to `marker.fill.color`.</dd>","         *  </dl>","         *","         * @attribute styles","         * @type Object","         */","    }","});","/**"," * The BarSeries class renders bars positioned vertically along a category or time axis. The bars'"," * lengths are proportional to the values they represent along a horizontal axis."," * and the relevant data points."," *"," * @module charts"," * @submodule charts-base"," * @class BarSeries"," * @extends MarkerSeries"," * @uses Histogram"," * @constructor"," */","Y.BarSeries = Y.Base.create(\"barSeries\", Y.MarkerSeries, [Y.Histogram], {","    /**","     * Helper method for calculating the size of markers. ","     *","     * @method _getMarkerDimensions","     * @param {Number} xcoord The x-coordinate representing the data point for the marker.","     * @param {Number} ycoord The y-coordinate representing the data point for the marker.","     * @param {Number} calculatedSize The calculated size for the marker. For a `BarSeries` is it the width. For a `ColumnSeries` it is the height.","     * @param {Number} offset Distance of position offset dictated by other marker series in the same graph.","     * @return Object","     * @private","     */","    _getMarkerDimensions: function(xcoord, ycoord, calculatedSize, offset)","    {","        var config = {","            top: ycoord + offset","        };","        if(xcoord >= this._leftOrigin)","        {","            config.left = this._leftOrigin;","            config.calculatedSize = xcoord - config.left;","        }","        else","        {","            config.left = xcoord;","            config.calculatedSize = this._leftOrigin - xcoord;","        }","        return config;","    },","    ","    /**","     * Resizes and positions markers based on a mouse interaction.","     *","     * @method updateMarkerState","     * @param {String} type state of the marker","     * @param {Number} i index of the marker","     * @protected","     */","    updateMarkerState: function(type, i)","    {","        if(this._markers && this._markers[i])","        {","            var styles = Y.clone(this.get(\"styles\").marker),","                markerStyles,","                state = this._getState(type),","                xcoords = this.get(\"xcoords\"),","                ycoords = this.get(\"ycoords\"),","                marker = this._markers[i],","                markers,","                graph = this.get(\"graph\"),","                seriesCollection = graph.seriesTypes[this.get(\"type\")],","                seriesLen = seriesCollection.length,","                seriesStyles,","                seriesSize = 0,","                offset = 0,","                renderer,","                n = 0,","                ys = [],","                order = this.get(\"order\"),","                config;","            markerStyles = state == \"off\" || !styles[state] ? styles : styles[state]; ","            markerStyles.fill.color = this._getItemColor(markerStyles.fill.color, i);","            markerStyles.border.color = this._getItemColor(markerStyles.border.color, i);","            config = this._getMarkerDimensions(xcoords[i], ycoords[i], styles.height, offset);","            markerStyles.width = config.calculatedSize;","            markerStyles.height = Math.min(this._maxSize, markerStyles.height);","            marker.set(markerStyles);","            for(; n < seriesLen; ++n)","            {","                ys[n] = ycoords[i] + seriesSize;","                seriesStyles = seriesCollection[n].get(\"styles\").marker;","                seriesSize += Math.min(this._maxSize, seriesStyles.height); ","                if(order > n)","                {","                    offset = seriesSize;","                }","                offset -= seriesSize/2;","            }","            for(n = 0; n < seriesLen; ++n)","            {","                markers = seriesCollection[n].get(\"markers\");","                if(markers)","                {","                    renderer = markers[i];","                    if(renderer && renderer !== undefined)","                    {","                        renderer.set(\"y\", (ys[n] - seriesSize/2));","                    }","                }","            }","        }","    }","}, {","    ATTRS: {","        /**","         * Read-only attribute indicating the type of series.","         *","         * @attribute type","         * @type String","         * @default bar","         */","        type: {","            value: \"bar\"","        },","","        /**","         * Indicates the direction of the category axis that the bars are plotted against.","         *","         * @attribute direction","         * @type String","         */","        direction: {","            value: \"vertical\"","        }","        ","        /**","         * Style properties used for drawing markers. This attribute is inherited from `MarkerSeries`. Below are the default values:","         *  <dl>","         *      <dt>fill</dt><dd>A hash containing the following values:","         *          <dl>","         *              <dt>color</dt><dd>Color of the fill. The default value is determined by the order of the series on the graph. The color","         *              will be retrieved from the below array:<br/>","         *              `[\"#66007f\", \"#a86f41\", \"#295454\", \"#996ab2\", \"#e8cdb7\", \"#90bdbd\",\"#000000\",\"#c3b8ca\", \"#968373\", \"#678585\"]`","         *              </dd>","         *              <dt>alpha</dt><dd>Number from 0 to 1 indicating the opacity of the marker fill. The default value is 1.</dd>","         *          </dl>","         *      </dd>","         *      <dt>border</dt><dd>A hash containing the following values:","         *          <dl>","         *              <dt>color</dt><dd>Color of the border. The default value is determined by the order of the series on the graph. The color","         *              will be retrieved from the below array:<br/>","         *              `[\"#205096\", \"#b38206\", \"#000000\", \"#94001e\", \"#9d6fa0\", \"#e55b00\", \"#5e85c9\", \"#adab9e\", \"#6ac291\", \"#006457\"]`","         *              <dt>alpha</dt><dd>Number from 0 to 1 indicating the opacity of the marker border. The default value is 1.</dd>","         *              <dt>weight</dt><dd>Number indicating the width of the border. The default value is 1.</dd>","         *          </dl>","         *      </dd>","         *      <dt>height</dt><dd>indicates the width of the marker. The default value is 12.</dd>","         *      <dt>over</dt><dd>hash containing styles for markers when highlighted by a `mouseover` event. The default ","         *      values for each style is null. When an over style is not set, the non-over value will be used. For example,","         *      the default value for `marker.over.fill.color` is equivalent to `marker.fill.color`.</dd>","         *  </dl>","         *","         * @attribute styles","         * @type Object","         */","    }","});","/**"," * The AreaSeries class renders quantitative data on a graph by creating a fill between 0"," * and the relevant data points."," *"," * @module charts"," * @submodule charts-base"," * @class AreaSeries"," * @extends CartesianSeries"," * @uses Fills"," * @constructor"," */","Y.AreaSeries = Y.Base.create(\"areaSeries\", Y.CartesianSeries, [Y.Fills], {","    /**","     * @protected","     *","     * Renders the series. ","     *","     * @method drawSeries","     */","    drawSeries: function()","    {","        this.drawFill.apply(this, this._getClosingPoints());","    },","    ","    /**","     * @protected","     *","     * Method used by `styles` setter. Overrides base implementation.","     *","     * @method _setStyles","     * @param {Object} newStyles Hash of properties to update.","     * @return Object","     */","    _setStyles: function(val)","    {","        if(!val.area)","        {","            val = {area:val};","        }","        return Y.AreaSeries.superclass._setStyles.apply(this, [val]);","    },","","    /**","     * @protected","     *","     * Gets the default value for the `styles` attribute. Overrides","     * base implementation.","     *","     * @method _getDefaultStyles","     * @return Object","     */","    _getDefaultStyles: function()","    {","        var styles = this._mergeStyles({area:this._getAreaDefaults()}, Y.AreaSeries.superclass._getDefaultStyles());","        return styles;","    }","},","{","    ATTRS: {","        /**","         * Read-only attribute indicating the type of series.","         *","         * @attribute type","         * @type String","         * @default area","         */","        type: {","            value:\"area\"","        }","        ","        /**","         * Style properties used for drawing area fills. This attribute is inherited from `Renderer`. Below are the default values:","         *","         *  <dl>","         *      <dt>color</dt><dd>The color of the fill. The default value is determined by the order of the series on the graph. The color will be ","         *      retrieved from the following array:","         *      `[\"#66007f\", \"#a86f41\", \"#295454\", \"#996ab2\", \"#e8cdb7\", \"#90bdbd\",\"#000000\",\"#c3b8ca\", \"#968373\", \"#678585\"]`","         *      </dd>","         *      <dt>alpha</dt><dd>Number between 0 and 1 that indicates the opacity of the fill. The default value is 1</dd>","         *  </dl>","         *","         * @attribute styles","         * @type Object","         */","    }","});","","","","		","","		","/**"," * AreaSplineSeries renders an area graph with data points connected by a curve."," *"," * @module charts"," * @submodule charts-base"," * @class AreaSplineSeries"," * @constructor"," * @extends CartesianSeries"," * @uses Fills"," * @uses CurveUtil"," */","Y.AreaSplineSeries = Y.Base.create(\"areaSplineSeries\", Y.AreaSeries, [Y.CurveUtil], {","    /**","     * @protected","     *","     * Draws the series.","     *","     * @method drawSeries","     */","    drawSeries: function()","    {","        this.drawAreaSpline();","    }","}, {","	ATTRS : {","        /**","         * Read-only attribute indicating the type of series.","         *","         * @attribute type","         * @type String","         * @default areaSpline","         */","        type: {","            value:\"areaSpline\"","        }","        ","        /**","         * Style properties used for drawing area fills. This attribute is inherited from `Renderer`. Below are the default values:","         *","         *  <dl>","         *      <dt>color</dt><dd>The color of the fill. The default value is determined by the order of the series on the graph. The color will be ","         *      retrieved from the following array:","         *      `[\"#66007f\", \"#a86f41\", \"#295454\", \"#996ab2\", \"#e8cdb7\", \"#90bdbd\",\"#000000\",\"#c3b8ca\", \"#968373\", \"#678585\"]`","         *      </dd>","         *      <dt>alpha</dt><dd>Number between 0 and 1 that indicates the opacity of the fill. The default value is 1</dd>","         *  </dl>","         *","         * @attribute styles","         * @type Object","         */","    }","});","","/**"," * StackedAreaSplineSeries creates a stacked area chart with points data points connected by a curve."," *"," * @module charts"," * @submodule charts-base"," * @class StackedAreaSplineSeries"," * @constructor"," * @extends AreaSeries"," * @uses CurveUtil"," * @uses StackingUtil"," */","Y.StackedAreaSplineSeries = Y.Base.create(\"stackedAreaSplineSeries\", Y.AreaSeries, [Y.CurveUtil, Y.StackingUtil], {","    /**","     * @protected","     *","     * Draws the series.","     *","     * @method drawSeries","     */","    drawSeries: function()","    {","        this._stackCoordinates();","        this.drawStackedAreaSpline();","    }","}, {","    ATTRS : {","        /**","         * Read-only attribute indicating the type of series.","         *","         * @attribute type","         * @type String","         * @default stackedAreaSpline","         */","        type: {","            value:\"stackedAreaSpline\"","        }","    }","});","","/**"," * The ComboSeries class renders a combination of lines, plots and area fills in a single series. Each"," * series type has a corresponding boolean attribute indicating if it is rendered. By default, lines and plots "," * are rendered and area is not. "," *"," * @module charts"," * @submodule charts-base"," * @class ComboSeries"," * @extends CartesianSeries "," * @uses Fills"," * @uses Lines"," * @uses Plots"," * @constructor"," */","Y.ComboSeries = Y.Base.create(\"comboSeries\", Y.CartesianSeries, [Y.Fills, Y.Lines, Y.Plots], {","	/**","     * @protected","     * ","     * Draws the series.","     *","     * @method drawSeries","     */","    drawSeries: function()","    {","        if(this.get(\"showAreaFill\"))","        {","            this.drawFill.apply(this, this._getClosingPoints());","        }","        if(this.get(\"showLines\")) ","        {","            this.drawLines();","        }","        if(this.get(\"showMarkers\"))","        {","            this.drawPlots();","        }   ","    },","    ","    /**","     * Toggles visibility","     *","     * @method _toggleVisible","     * @param {Boolean} visible indicates visibilitye","     * @private","     */","    _toggleVisible: function(visible)","    {","        var markers,","            marker,","            len,","            i;","        if(this.get(\"showAreaFill\") && this._path)","        {","            this._path.set(\"visible\", visible);","        }","        if(this.get(\"showLines\") && this._lineGraphic)","        {","            this._lineGraphic.set(\"visible\", visible);","        }","        if(this.get(\"showMarkers\"))","        {","            markers = this.get(\"markers\");","            if(markers)","            {","                i = 0;","                len = markers.length;","                for(; i < len; ++i)","                {","                    marker = markers[i];","                    if(marker)","                    {","                        marker.set(\"visible\", visible);","                    }","                }","            }","        }","    },","","    /**","     * @protected","     *","     * Returns the default hash for the `styles` attribute.","     *","     * @method _getDefaultStyles","     * @return Object","     */","    _getDefaultStyles: function()","    {","        var styles = Y.ComboSeries.superclass._getDefaultStyles();","        styles.line = this._getLineDefaults();","        styles.marker = this._getPlotDefaults();","        styles.area = this._getAreaDefaults();","        return styles;","    }","},","{","    ATTRS: {","        /**","         * Read-only attribute indicating the type of series.","         *","         * @attribute type","         * @type String","         * @default combo","         */","        type: {","            value:\"combo\"","        },","","        /**","         * Indicates whether a fill is displayed.","         *","         * @attribute showAreaFill","         * @type Boolean","         * @default false","         */","        showAreaFill: {","            value: false","        },","","        /**","         * Indicates whether lines are displayed.","         *","         * @attribute showLines","         * @type Boolean","         * @default true","         */","        showLines: {","            value: true","        },","","        /**","         * Indicates whether markers are displayed.","         *","         * @attribute showMarkers","         * @type Boolean","         * @default true","         */","        showMarkers: {","            value: true","        },","","        /**","         * Reference to the styles of the markers. These styles can also","         * be accessed through the `styles` attribute. Below are default","         * values:","         *  <dl>","         *      <dt>fill</dt><dd>A hash containing the following values:","         *          <dl>","         *              <dt>color</dt><dd>Color of the fill. The default value is determined by the order of the series on the graph. The color","         *              will be retrieved from the below array:<br/>","         *              `[\"#6084d0\", \"#eeb647\", \"#6c6b5f\", \"#d6484f\", \"#ce9ed1\", \"#ff9f3b\", \"#93b7ff\", \"#e0ddd0\", \"#94ecba\", \"#309687\"]`","         *              </dd>","         *              <dt>alpha</dt><dd>Number from 0 to 1 indicating the opacity of the marker fill. The default value is 1.</dd>","         *          </dl>","         *      </dd>","         *      <dt>border</dt><dd>A hash containing the following values:","         *          <dl>","         *              <dt>color</dt><dd>Color of the border. The default value is determined by the order of the series on the graph. The color","         *              will be retrieved from the below array:<br/>","         *              `[\"#205096\", \"#b38206\", \"#000000\", \"#94001e\", \"#9d6fa0\", \"#e55b00\", \"#5e85c9\", \"#adab9e\", \"#6ac291\", \"#006457\"]`","         *              <dt>alpha</dt><dd>Number from 0 to 1 indicating the opacity of the marker border. The default value is 1.</dd>","         *              <dt>weight</dt><dd>Number indicating the width of the border. The default value is 1.</dd>","         *          </dl>","         *      </dd>","         *      <dt>width</dt><dd>indicates the width of the marker. The default value is 10.</dd>","         *      <dt>height</dt><dd>indicates the height of the marker The default value is 10.</dd>","         *      <dt>over</dt><dd>hash containing styles for markers when highlighted by a `mouseover` event. The default ","         *      values for each style is null. When an over style is not set, the non-over value will be used. For example,","         *      the default value for `marker.over.fill.color` is equivalent to `marker.fill.color`.</dd>","         *  </dl>","         *","         * @attribute marker","         * @type Object","         */","        marker: {","            lazyAdd: false,","            getter: function()","            {","                return this.get(\"styles\").marker;","            },","            setter: function(val)","            {","                this.set(\"styles\", {marker:val});","            }","        },","        ","        /**","         * Reference to the styles of the lines. These styles can also be accessed through the `styles` attribute.","         * Below are the default values:","         *  <dl>","         *      <dt>color</dt><dd>The color of the line. The default value is determined by the order of the series on the graph. The color will be","         *      retrieved from the following array: ","         *      `[\"#426ab3\", \"#d09b2c\", \"#000000\", \"#b82837\", \"#b384b5\", \"#ff7200\", \"#779de3\", \"#cbc8ba\", \"#7ed7a6\", \"#007a6c\"]`","         *      <dt>weight</dt><dd>Number that indicates the width of the line. The default value is 6.</dd>","         *      <dt>alpha</dt><dd>Number between 0 and 1 that indicates the opacity of the line. The default value is 1.</dd>","         *      <dt>lineType</dt><dd>Indicates whether the line is solid or dashed. The default value is solid.</dd> ","         *      <dt>dashLength</dt><dd>When the `lineType` is dashed, indicates the length of the dash. The default value is 10.</dd>","         *      <dt>gapSpace</dt><dd>When the `lineType` is dashed, indicates the distance between dashes. The default value is 10.</dd>","         *      <dt>connectDiscontinuousPoints</dt><dd>Indicates whether or not to connect lines when there is a missing or null value between points. The default value is true.</dd> ","         *      <dt>discontinuousType</dt><dd>Indicates whether the line between discontinuous points is solid or dashed. The default value is solid.</dd>","         *      <dt>discontinuousDashLength</dt><dd>When the `discontinuousType` is dashed, indicates the length of the dash. The default value is 10.</dd>","         *      <dt>discontinuousGapSpace</dt><dd>When the `discontinuousType` is dashed, indicates the distance between dashes. The default value is 10.</dd>","         *  </dl>","         *","         * @attribute line","         * @type Object","         */","        line: {","            lazyAdd: false,","            getter: function()","            {","                return this.get(\"styles\").line;","            },","            setter: function(val)","            {","                this.set(\"styles\", {line:val});","            }","        },","        ","        /**","         * Reference to the styles of the area fills. These styles can also be accessed through the `styles` attribute.","         * Below are the default values:","         *","         *  <dl>","         *      <dt>color</dt><dd>The color of the fill. The default value is determined by the order of the series on the graph. The color will be ","         *      retrieved from the following array:","         *      `[\"#66007f\", \"#a86f41\", \"#295454\", \"#996ab2\", \"#e8cdb7\", \"#90bdbd\",\"#000000\",\"#c3b8ca\", \"#968373\", \"#678585\"]`","         *      </dd>","         *      <dt>alpha</dt><dd>Number between 0 and 1 that indicates the opacity of the fill. The default value is 1</dd>","         *  </dl>","         *","         * @attribute area","         * @type Object","         */","        area: {","            lazyAdd: false,","            getter: function()","            {","                return this.get(\"styles\").area;","            },","            setter: function(val)","            {","                this.set(\"styles\", {area:val});","            }","        }","","        /**","         * Style properties for the series. Contains a key indexed hash of the following:","         *  <dl>","         *      <dt>marker</dt><dd>Style properties for the markers in the series. Specific style attributes are listed","         *      <a href=\"#attr_marker\">here</a>.</dd>","         *      <dt>line</dt><dd>Style properties for the lines in the series. Specific","         *      style attributes are listed <a href=\"#attr_line\">here</a>.</dd>","         *      <dt>area</dt><dd>Style properties for the area fills in the series. Specific style attributes are listed","         *      <a href=\"#attr_area\">here</a>.</dd>","         *  </dl>","         *","         * @attribute styles","         * @type Object","         */","    }","});","","","","		","","		","/**"," * The StackedComboSeries class renders a combination of lines, plots and area fills in a single series. Series"," * are stacked along the value axis to indicate each series contribution to a cumulative total. Each"," * series type has a corresponding boolean attribute indicating if it is rendered. By default, all three types are"," * rendered.  "," *"," * @module charts"," * @submodule charts-base"," * @class StackedComboSeries"," * @extends ComboSeries"," * @uses StackingUtil"," * @constructor"," */","Y.StackedComboSeries = Y.Base.create(\"stackedComboSeries\", Y.ComboSeries, [Y.StackingUtil], {","    /**","     * @protected","     *","     * Calculates the coordinates for the series. Overrides base implementation.","     *","     * @method setAreaData","     */","    setAreaData: function()","    {   ","        Y.StackedComboSeries.superclass.setAreaData.apply(this);","        this._stackCoordinates.apply(this);","    },","	","    /**","     * @protected","     *","     * Draws the series.","     *","     * @method drawSeries","     */","    drawSeries: function()","    {","        if(this.get(\"showAreaFill\"))","        {","            this.drawFill.apply(this, this._getStackedClosingPoints());","        }","        if(this.get(\"showLines\")) ","        {","            this.drawLines();","        }","        if(this.get(\"showMarkers\"))","        {","            this.drawPlots();","        }   ","    }","    ","}, {","    ATTRS : {","        /**","         * Read-only attribute indicating the type of series.","         *","         * @attribute type","         * @type String","         * @default stackedCombo","         */","        type: {","            value: \"stackedCombo\"","        },","","        /**","         * Indicates whether a fill is displayed.","         *","         * @attribute showAreaFill","         * @type Boolean","         * @default true","         */","        showAreaFill: {","            value: true","        }","    }","});","/**"," * The ComboSplineSeries class renders a combination of splines, plots and areaspline fills in a single series. Each"," * series type has a corresponding boolean attribute indicating if it is rendered. By default, splines and plots "," * are rendered and areaspline is not. "," *"," * @module charts"," * @submodule charts-base"," * @class ComboSplineSeries"," * @extends ComboSeries"," * @extends CurveUtil"," * @constructor"," */","Y.ComboSplineSeries = Y.Base.create(\"comboSplineSeries\", Y.ComboSeries, [Y.CurveUtil], {","    /**","     * @protected","     * ","     * Draws the series.","     *","     * @method drawSeries","     */","    drawSeries: function()","    {","        if(this.get(\"showAreaFill\"))","        {","            this.drawAreaSpline();","        }","        if(this.get(\"showLines\")) ","        {","            this.drawSpline();","        }","        if(this.get(\"showMarkers\"))","        {","            this.drawPlots();","        }   ","    }","}, {","    ATTRS: {","        /**","         * Read-only attribute indicating the type of series.","         *","         * @attribute type","         * @type String","         * @default comboSpline","         */","        type: {","            value : \"comboSpline\"","        }","    }","});","/**"," * The StackedComboSplineSeries class renders a combination of splines, plots and areaspline fills in a single series. Series"," * are stacked along the value axis to indicate each series contribution to a cumulative total. Each"," * series type has a corresponding boolean attribute indicating if it is rendered. By default, all three types are"," * rendered.  "," *"," * @module charts"," * @submodule charts-base"," * @class StackedComboSplineSeries"," * @extends StackedComboSeries"," * @uses CurveUtil"," * @constructor"," */","Y.StackedComboSplineSeries = Y.Base.create(\"stackedComboSplineSeries\", Y.StackedComboSeries, [Y.CurveUtil], {","    /**","	 * @protected","     *","     * Draws the series.","     *","     * @method drawSeries","	 */","	drawSeries: function()","    {","        if(this.get(\"showAreaFill\"))","        {","            this.drawStackedAreaSpline();","        }","        if(this.get(\"showLines\")) ","        {","            this.drawSpline();","        }","        if(this.get(\"showMarkers\"))","        {","            this.drawPlots();","        }   ","    }","}, {","    ATTRS: {","        /**","         * Read-only attribute indicating the type of series.","         *","         * @attribute type","         * @type String","         * @default stackedComboSpline","         */","        type : {","            value : \"stackedComboSpline\"","        },","","        /**","         * Indicates whether a fill is displayed.","         *","         * @attribute showAreaFill","         * @type Boolean","         * @default true","         */","        showAreaFill: {","            value: true","        }","    }","});","/**"," * StackedLineSeries creates line graphs in which the different series are stacked along a value axis"," * to indicate their contribution to a cumulative total."," *"," * @module charts"," * @submodule charts-base"," * @class StackedLineSeries"," * @constructor"," * @extends  LineSeries"," * @uses StackingUtil"," */","Y.StackedLineSeries = Y.Base.create(\"stackedLineSeries\", Y.LineSeries, [Y.StackingUtil], {","    /**","     * @protected","     *","     * Calculates the coordinates for the series. Overrides base implementation.","     *","     * @method setAreaData","     */","    setAreaData: function()","    {   ","        Y.StackedLineSeries.superclass.setAreaData.apply(this);","        this._stackCoordinates.apply(this);","    }","}, {","    ATTRS: {","        /**","         * Read-only attribute indicating the type of series.","         *","         * @attribute type","         * @type String","         * @default stackedLine","         */","        type: {","            value:\"stackedLine\"","        }","    }","});","/**"," * StackedAreaSeries area fills to display data showing its contribution to a whole."," *"," * @module charts"," * @submodule charts-base"," * @class StackedAreaSeries"," * @constructor"," * @param {Object} config (optional) Configuration parameters for the Chart."," * @extends AreaSeries"," * @uses StackingUtil"," */","Y.StackedAreaSeries = Y.Base.create(\"stackedAreaSeries\", Y.AreaSeries, [Y.StackingUtil], {","    /**","     * @protected","     *","     * Calculates the coordinates for the series. Overrides base implementation.","     *","     * @method setAreaData","     */","    setAreaData: function()","    {   ","        Y.StackedAreaSeries.superclass.setAreaData.apply(this);","        this._stackCoordinates.apply(this);","    },","","    /**","     * @protected","     *","     * Draws the series","     *","     * @method drawSeries","     */","	drawSeries: function()","    {","        this.drawFill.apply(this, this._getStackedClosingPoints());","    }","}, {","    ATTRS: {","        /**","         * Read-only attribute indicating the type of series.","         *","         * @attribute type","         * @type String","         * @default stackedArea","         */","        type: {","            value:\"stackedArea\"","        }","    }","});","/**"," * The StackedColumnSeries renders column chart in which series are stacked vertically to show"," * their contribution to the cumulative total."," *"," * @module charts"," * @submodule charts-base"," * @class StackedColumnSeries"," * @extends ColumnSeries"," * @uses StackingUtil"," * @constructor"," */","Y.StackedColumnSeries = Y.Base.create(\"stackedColumnSeries\", Y.ColumnSeries, [Y.StackingUtil], {","    /**","     * Draws the series.","     *","     * @method drawSeries","	 * @protected","	 */","	drawSeries: function()","	{","        if(this.get(\"xcoords\").length < 1) ","        {","            return;","        }","        var isNumber = Y_Lang.isNumber,","            style = Y.clone(this.get(\"styles\").marker), ","            w = style.width,","            h = style.height,","            xcoords = this.get(\"xcoords\"),","            ycoords = this.get(\"ycoords\"),","            i = 0,","            len = xcoords.length,","            top = ycoords[0],","            type = this.get(\"type\"),","            graph = this.get(\"graph\"),","            seriesCollection = graph.seriesTypes[type],","            ratio,","            order = this.get(\"order\"),","            graphOrder = this.get(\"graphOrder\"),","            left,","            marker,","            fillColors,","            borderColors,","            lastCollection,","            negativeBaseValues,","            positiveBaseValues,","            useOrigin = order === 0,","            totalWidth = len * w,","            dimensions = {","                width: [],","                height: []","            },","            xvalues = [],","            yvalues = [],","            groupMarkers = this.get(\"groupMarkers\");","        if(Y_Lang.isArray(style.fill.color))","        {","            fillColors = style.fill.color.concat(); ","        }","        if(Y_Lang.isArray(style.border.color))","        {","            borderColors = style.border.color.concat();","        }","        this._createMarkerCache();","        if(totalWidth > this.get(\"width\"))","        {","            ratio = this.width/totalWidth;","            w *= ratio;","            w = Math.max(w, 1);","        }","        if(!useOrigin)","        {","            lastCollection = seriesCollection[order - 1];","            negativeBaseValues = lastCollection.get(\"negativeBaseValues\");","            positiveBaseValues = lastCollection.get(\"positiveBaseValues\");","            if(!negativeBaseValues || !positiveBaseValues)","            {","                useOrigin = true;","                positiveBaseValues = [];","                negativeBaseValues = [];","            }","        }","        else","        {","            negativeBaseValues = [];","            positiveBaseValues = [];","        }","        this.set(\"negativeBaseValues\", negativeBaseValues);","        this.set(\"positiveBaseValues\", positiveBaseValues);","        for(i = 0; i < len; ++i)","        {","            left = xcoords[i];","            top = ycoords[i];","            ","            if(!isNumber(top) || !isNumber(left))","            {","                if(useOrigin)","                {","                    negativeBaseValues[i] = this._bottomOrigin;","                    positiveBaseValues[i] = this._bottomOrigin;","                }","                this._markers.push(null); ","                continue;","            }","            if(useOrigin)","            {","                h = Math.abs(this._bottomOrigin - top);","                if(top < this._bottomOrigin)","                {","                    positiveBaseValues[i] = top;","                    negativeBaseValues[i] = this._bottomOrigin;","                }","                else if(top > this._bottomOrigin)","                {","                    positiveBaseValues[i] = this._bottomOrigin;","                    negativeBaseValues[i] = top;","                    top -= h;","                }","                else","                {","                    positiveBaseValues[i] = top;","                    negativeBaseValues[i] = top;","                }","            }","            else ","            {","                if(top > this._bottomOrigin)","                {","                    top += (negativeBaseValues[i] - this._bottomOrigin);","                    h = top - negativeBaseValues[i];","                    negativeBaseValues[i] = top;","                    top -= h;","                }","                else if(top <= this._bottomOrigin)","                {","                    top = positiveBaseValues[i] - (this._bottomOrigin - top);","                    h = positiveBaseValues[i] - top;","                    positiveBaseValues[i] = top;","                }","            }","            if(!isNaN(h) && h > 0)","            {","                left -= w/2;","                if(groupMarkers)","                {","                    dimensions.width[i] = w;","                    dimensions.height[i] = h;","                    xvalues.push(left);","                    yvalues.push(top);","                }","                else","                {","                    style.width = w;","                    style.height = h;","                    style.x = left;","                    style.y = top;","                    if(fillColors)","                    {","                        style.fill.color = fillColors[i % fillColors.length];","                    }","                    if(borderColors)","                    {","                        style.border.color = borderColors[i % borderColors.length];","                    }","                    marker = this.getMarker(style, graphOrder, i);","                }","            }","            else if(!groupMarkers)","            {","               this._markers.push(null);","            }","        }","        if(groupMarkers)","        {","            this._createGroupMarker({","                fill: style.fill,","                border: style.border,","                dimensions: dimensions,","                xvalues: xvalues,","                yvalues: yvalues,","                shape: style.shape","            });","        }","        else","        {","            this._clearMarkerCache();","        }","    },","","    /**","     * Resizes and positions markers based on a mouse interaction.","     *","     * @method updateMarkerState","     * @param {String} type state of the marker","     * @param {Number} i index of the marker","     * @protected","     */","    updateMarkerState: function(type, i)","    {","        if(this._markers && this._markers[i])","        {","            var styles,","                markerStyles,","                state = this._getState(type),","                xcoords = this.get(\"xcoords\"),","                marker = this._markers[i],","                offset = 0,","                fillColor,","                borderColor;        ","            styles = this.get(\"styles\").marker;","            offset = styles.width * 0.5;","            markerStyles = state == \"off\" || !styles[state] ? Y.clone(styles) : Y.clone(styles[state]); ","            markerStyles.height = marker.get(\"height\");","            markerStyles.x = (xcoords[i] - offset);","            markerStyles.y = marker.get(\"y\");","            markerStyles.id = marker.get(\"id\");","            fillColor = markerStyles.fill.color; ","            borderColor = markerStyles.border.color;","            if(Y_Lang.isArray(fillColor))","            {","                markerStyles.fill.color = fillColor[i % fillColor.length];","            }","            else","            {","                markerStyles.fill.color = this._getItemColor(markerStyles.fill.color, i);","            }","            if(Y_Lang.isArray(borderColor))","            {","                markerStyles.border.color = borderColor[i % borderColor.length];","            }","            else","            {","                markerStyles.border.color = this._getItemColor(markerStyles.border.color, i);","            }","            marker.set(markerStyles);","        }","    },","	","    /**","     * Gets the default values for the markers. ","     *","     * @method _getPlotDefaults","     * @return Object","     * @protected","     */","    _getPlotDefaults: function()","    {","        var defs = {","            fill:{","                type: \"solid\",","                alpha: 1,","                colors:null,","                alphas: null,","                ratios: null","            },","            border:{","                weight: 0,","                alpha: 1","            },","            width: 24,","            height: 24,","            shape: \"rect\",","","            padding:{","                top: 0,","                left: 0,","                right: 0,","                bottom: 0","            }","        };","        defs.fill.color = this._getDefaultColor(this.get(\"graphOrder\"), \"fill\");","        defs.border.color = this._getDefaultColor(this.get(\"graphOrder\"), \"border\");","        return defs;","    }","}, {","    ATTRS: {","        /**","         * Read-only attribute indicating the type of series.","         *","         * @attribute type","         * @type String","         * @default stackedColumn","         */","        type: {","            value: \"stackedColumn\"","        },","","        /**","         * @attribute negativeBaseValues","         * @type Array","         * @default null","         * @private","         */","        negativeBaseValues: {","            value: null","        },","","        /**","         * @attribute positiveBaseValues","         * @type Array","         * @default null","         * @private","         */","        positiveBaseValues: {","            value: null","        }","        ","        /**","         * Style properties used for drawing markers. This attribute is inherited from `ColumnSeries`. Below are the default values:","         *  <dl>","         *      <dt>fill</dt><dd>A hash containing the following values:","         *          <dl>","         *              <dt>color</dt><dd>Color of the fill. The default value is determined by the order of the series on the graph. The color","         *              will be retrieved from the below array:<br/>","         *              `[\"#66007f\", \"#a86f41\", \"#295454\", \"#996ab2\", \"#e8cdb7\", \"#90bdbd\",\"#000000\",\"#c3b8ca\", \"#968373\", \"#678585\"]`","         *              </dd>","         *              <dt>alpha</dt><dd>Number from 0 to 1 indicating the opacity of the marker fill. The default value is 1.</dd>","         *          </dl>","         *      </dd>","         *      <dt>border</dt><dd>A hash containing the following values:","         *          <dl>","         *              <dt>color</dt><dd>Color of the border. The default value is determined by the order of the series on the graph. The color","         *              will be retrieved from the below array:<br/>","         *              `[\"#205096\", \"#b38206\", \"#000000\", \"#94001e\", \"#9d6fa0\", \"#e55b00\", \"#5e85c9\", \"#adab9e\", \"#6ac291\", \"#006457\"]`","         *              <dt>alpha</dt><dd>Number from 0 to 1 indicating the opacity of the marker border. The default value is 1.</dd>","         *              <dt>weight</dt><dd>Number indicating the width of the border. The default value is 1.</dd>","         *          </dl>","         *      </dd>","         *      <dt>width</dt><dd>indicates the width of the marker. The default value is 24.</dd>","         *      <dt>over</dt><dd>hash containing styles for markers when highlighted by a `mouseover` event. The default ","         *      values for each style is null. When an over style is not set, the non-over value will be used. For example,","         *      the default value for `marker.over.fill.color` is equivalent to `marker.fill.color`.</dd>","         *  </dl>","         *","         * @attribute styles","         * @type Object","         */","    }","});","","/**"," * The StackedBarSeries renders bar chart in which series are stacked horizontally to show"," * their contribution to the cumulative total."," *"," * @module charts"," * @submodule charts-base"," * @class StackedBarSeries"," * @extends BarSeries"," * @uses StackingUtil"," * @constructor"," */","Y.StackedBarSeries = Y.Base.create(\"stackedBarSeries\", Y.BarSeries, [Y.StackingUtil], {","    /**","     * @protected","     *","     * Draws the series.","     *","     * @method drawSeries","     */","    drawSeries: function()","	{","        if(this.get(\"xcoords\").length < 1) ","        {","            return;","        }","","        var isNumber = Y_Lang.isNumber,","            style = Y.clone(this.get(\"styles\").marker),","            w = style.width,","            h = style.height,","            xcoords = this.get(\"xcoords\"),","            ycoords = this.get(\"ycoords\"),","            i = 0,","            len = xcoords.length,","            top = ycoords[0],","            type = this.get(\"type\"),","            graph = this.get(\"graph\"),","            seriesCollection = graph.seriesTypes[type],","            ratio,","            order = this.get(\"order\"),","            graphOrder = this.get(\"graphOrder\"),","            left,","            marker,","            lastCollection,","            negativeBaseValues,","            positiveBaseValues,","            fillColors,","            borderColors,","            useOrigin = order === 0,","            totalHeight = len * h,","            dimensions = {","                width: [],","                height: []","            },","            xvalues = [],","            yvalues = [],","            groupMarkers = this.get(\"groupMarkers\");","        if(Y_Lang.isArray(style.fill.color))","        {","            fillColors = style.fill.color.concat(); ","        }","        if(Y_Lang.isArray(style.border.color))","        {","            borderColors = style.border.color.concat();","        }","        this._createMarkerCache();","        if(totalHeight > this.get(\"height\"))","        {","            ratio = this.height/totalHeight;","            h *= ratio;","            h = Math.max(h, 1);","        }","        if(!useOrigin)","        {","            lastCollection = seriesCollection[order - 1];","            negativeBaseValues = lastCollection.get(\"negativeBaseValues\");","            positiveBaseValues = lastCollection.get(\"positiveBaseValues\");","            if(!negativeBaseValues || !positiveBaseValues)","            {","                useOrigin = true;","                positiveBaseValues = [];","                negativeBaseValues = [];","            }","        }","        else","        {","            negativeBaseValues = [];","            positiveBaseValues = [];","        }","        this.set(\"negativeBaseValues\", negativeBaseValues);","        this.set(\"positiveBaseValues\", positiveBaseValues);","        for(i = 0; i < len; ++i)","        {","            top = ycoords[i];","            left = xcoords[i];","            if(!isNumber(top) || !isNumber(left))","            {","                if(useOrigin)","                {","                    positiveBaseValues[i] = this._leftOrigin;","                    negativeBaseValues[i] = this._leftOrigin;","                }","                this._markers.push(null);","                continue;","            }","            if(useOrigin)","            {","                w = Math.abs(left - this._leftOrigin);","                if(left > this._leftOrigin)","                {","                    positiveBaseValues[i] = left;","                    negativeBaseValues[i] = this._leftOrigin;","                    left -= w;","                }","                else if(left < this._leftOrigin)","                {   ","                    positiveBaseValues[i] = this._leftOrigin;","                    negativeBaseValues[i] = left;","                }","                else","                {","                    positiveBaseValues[i] = left;","                    negativeBaseValues[i] = this._leftOrigin;","                }","            }","            else","            {","                if(left < this._leftOrigin)","                {","                    left = negativeBaseValues[i] - (this._leftOrigin - xcoords[i]);","                    w = negativeBaseValues[i] - left;","                    negativeBaseValues[i] = left;","                }","                else if(left >= this._leftOrigin)","                {","                    left += (positiveBaseValues[i] - this._leftOrigin);","                    w = left - positiveBaseValues[i];","                    positiveBaseValues[i] = left;","                    left -= w;","                }","            }","            if(!isNaN(w) && w > 0)","            {","                top -= h/2;","                if(groupMarkers)","                {","                    dimensions.width[i] = w;","                    dimensions.height[i] = h;","                    xvalues.push(left);","                    yvalues.push(top);","                }","                else","                {","                    style.width = w;","                    style.height = h;","                    style.x = left;","                    style.y = top;","                    if(fillColors)","                    {","                        style.fill.color = fillColors[i % fillColors.length];","                    }","                    if(borderColors)","                    {","                        style.border.color = borderColors[i % borderColors.length];","                    }","                    marker = this.getMarker(style, graphOrder, i);","                }","            }","            else if(!groupMarkers)","            {","                this._markers.push(null);","            }","        }","        if(groupMarkers)","        {","            this._createGroupMarker({","                fill: style.fill,","                border: style.border,","                dimensions: dimensions,","                xvalues: xvalues,","                yvalues: yvalues,","                shape: style.shape","            });","        }","        else","        {","            this._clearMarkerCache();","        }","    },","","    /**","     * @protected","     *","     * Resizes and positions markers based on a mouse interaction.","     *","     * @method updateMarkerState","     * @param {String} type state of the marker","     * @param {Number} i index of the marker","     */","    updateMarkerState: function(type, i)","    {","        if(this._markers[i])","        {","            var state = this._getState(type),","                ycoords = this.get(\"ycoords\"),","                marker = this._markers[i],","                styles = this.get(\"styles\").marker,","                h = styles.height,","                markerStyles = state == \"off\" || !styles[state] ? Y.clone(styles) : Y.clone(styles[state]), ","                fillColor,","                borderColor;        ","            markerStyles.y = (ycoords[i] - h/2);","            markerStyles.x = marker.get(\"x\");","            markerStyles.width = marker.get(\"width\");","            markerStyles.id = marker.get(\"id\");","            fillColor = markerStyles.fill.color; ","            borderColor = markerStyles.border.color;","            if(Y_Lang.isArray(fillColor))","            {","                markerStyles.fill.color = fillColor[i % fillColor.length];","            }","            else","            {","                markerStyles.fill.color = this._getItemColor(markerStyles.fill.color, i);","            }","            if(Y_Lang.isArray(borderColor))","            {","                markerStyles.border.color = borderColor[i % borderColor.length];","            }","            else","            {","                markerStyles.border.color = this._getItemColor(markerStyles.border.color, i);","            }","            marker.set(markerStyles);","        }","    },","	","    /**","     * @protected","     *","     * Returns default values for the `styles` attribute.","     * ","     * @method _getPlotDefaults","     * @return Object","     */","    _getPlotDefaults: function()","    {","        var defs = {","            fill:{","                type: \"solid\",","                alpha: 1,","                colors:null,","                alphas: null,","                ratios: null","            },","            border:{","                weight: 0,","                alpha: 1","            },","            width: 24,","            height: 24,","            shape: \"rect\",","","            padding:{","                top: 0,","                left: 0,","                right: 0,","                bottom: 0","            }","        };","        defs.fill.color = this._getDefaultColor(this.get(\"graphOrder\"), \"fill\");","        defs.border.color = this._getDefaultColor(this.get(\"graphOrder\"), \"border\");","        return defs;","    }","}, {","    ATTRS: {","        /**","         * Read-only attribute indicating the type of series.","         *","         * @attribute type","         * @type String","         * @default stackedBar","         */","        type: {","            value: \"stackedBar\"","        },","","        /**","         * Direction of the series","         *","         * @attribute direction","         * @type String","         * @default vertical","         */","        direction: {","            value: \"vertical\"","        },","","        /**","         * @private","         *","         * @attribute negativeBaseValues","         * @type Array","         * @default null","         */","        negativeBaseValues: {","            value: null","        },","","        /**","         * @private","         *","         * @attribute positiveBaseValues","         * @type Array","         * @default null","         */","        positiveBaseValues: {","            value: null","        }","        ","        /**","         * Style properties used for drawing markers. This attribute is inherited from `BarSeries`. Below are the default values:","         *  <dl>","         *      <dt>fill</dt><dd>A hash containing the following values:","         *          <dl>","         *              <dt>color</dt><dd>Color of the fill. The default value is determined by the order of the series on the graph. The color","         *              will be retrieved from the below array:<br/>","         *              `[\"#66007f\", \"#a86f41\", \"#295454\", \"#996ab2\", \"#e8cdb7\", \"#90bdbd\",\"#000000\",\"#c3b8ca\", \"#968373\", \"#678585\"]`","         *              </dd>","         *              <dt>alpha</dt><dd>Number from 0 to 1 indicating the opacity of the marker fill. The default value is 1.</dd>","         *          </dl>","         *      </dd>","         *      <dt>border</dt><dd>A hash containing the following values:","         *          <dl>","         *              <dt>color</dt><dd>Color of the border. The default value is determined by the order of the series on the graph. The color","         *              will be retrieved from the below array:<br/>","         *              `[\"#205096\", \"#b38206\", \"#000000\", \"#94001e\", \"#9d6fa0\", \"#e55b00\", \"#5e85c9\", \"#adab9e\", \"#6ac291\", \"#006457\"]`","         *              <dt>alpha</dt><dd>Number from 0 to 1 indicating the opacity of the marker border. The default value is 1.</dd>","         *              <dt>weight</dt><dd>Number indicating the width of the border. The default value is 1.</dd>","         *          </dl>","         *      </dd>","         *      <dt>height</dt><dd>indicates the width of the marker. The default value is 24.</dd>","         *      <dt>over</dt><dd>hash containing styles for markers when highlighted by a `mouseover` event. The default ","         *      values for each style is null. When an over style is not set, the non-over value will be used. For example,","         *      the default value for `marker.over.fill.color` is equivalent to `marker.fill.color`.</dd>","         *  </dl>","         *","         * @attribute styles","         * @type Object","         */","    }","});","","/**"," * PieSeries visualizes data as a circular chart divided into wedges which represent data as a "," * percentage of a whole."," *"," * @module charts"," * @submodule charts-base"," * @class PieSeries"," * @constructor"," * @extends MarkerSeries"," */","Y.PieSeries = Y.Base.create(\"pieSeries\", Y.MarkerSeries, [], { ","    /**","     * Image map used for interactivity when rendered with canvas.","     *","     * @property _map","     * @type HTMLElement","     * @private","     */","    _map: null,","","    /**","     * Image used for image map when rendered with canvas.","     *","     * @property _image","     * @type HTMLElement","     * @private","     */","    _image: null,","","    /**","     * Creates or updates the image map when rendered with canvas.","     *","     * @method _setMap","     * @private","     */","    _setMap: function()","    {","        var id = \"pieHotSpotMapi_\" + Math.round(100000 * Math.random()),","            cb = this.get(\"graph\").get(\"contentBox\"),","            areaNode;","        if(this._image)","        {","            cb.removeChild(this._image);","            while(this._areaNodes && this._areaNodes.length > 0)","            {","                areaNode = this._areaNodes.shift();","                this._map.removeChild(areaNode);","            }","            cb.removeChild(this._map);","        }","        this._image = DOCUMENT.createElement(\"img\"); ","        this._image.src = \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAYAAAABCAYAAAD9yd/wAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAABJJREFUeNpiZGBgSGPAAgACDAAIkABoFyloZQAAAABJRU5ErkJggg==\";","        cb.appendChild(this._image);","        this._image.setAttribute(\"usemap\", \"#\" + id);","        this._image.style.zIndex = 3;","        this._image.style.opacity = 0;","        this._image.setAttribute(\"alt\", \"imagemap\");","        this._map = DOCUMENT.createElement(\"map\");","        this._map.style.zIndex = 5;","        cb.appendChild(this._map);","        this._map.setAttribute(\"name\", id);","        this._map.setAttribute(\"id\", id);","        this._areaNodes = [];","    },","","    /**","     * Storage for `categoryDisplayName` attribute.","     *","     * @property _categoryDisplayName","     * @private","     */","    _categoryDisplayName: null,","    ","    /**","     * Storage for `valueDisplayName` attribute.","     *","     * @property _valueDisplayName","     * @private","     */","    _valueDisplayName: null,","","    /**","     * Adds event listeners.","     *","     * @method addListeners","     * @private","     */","    addListeners: function()","    {","        var categoryAxis = this.get(\"categoryAxis\"),","            valueAxis = this.get(\"valueAxis\");","        if(categoryAxis)","        {","            categoryAxis.after(\"dataReady\", Y.bind(this._categoryDataChangeHandler, this));","            categoryAxis.after(\"dataUpdate\", Y.bind(this._categoryDataChangeHandler, this));","        }","        if(valueAxis)","        {","            valueAxis.after(\"dataReady\", Y.bind(this._valueDataChangeHandler, this));","            valueAxis.after(\"dataUpdate\", Y.bind(this._valueDataChangeHandler, this));","        }","        this.after(\"categoryAxisChange\", this.categoryAxisChangeHandler);","        this.after(\"valueAxisChange\", this.valueAxisChangeHandler);","        this.after(\"stylesChange\", this._updateHandler);","    },","    ","    /**","     * Draws the series.","     *","     * @method validate","     * @private","     */","    validate: function()","    {","        this.draw();","        this._renderered = true;","    },","","    /**","     * Event handler for the categoryAxisChange event.","     *","     * @method _categoryAxisChangeHandler","     * @param {Object} e Event object.","     * @private","     */","    _categoryAxisChangeHandler: function(e)","    {","        var categoryAxis = this.get(\"categoryAxis\");","        categoryAxis.after(\"dataReady\", Y.bind(this._categoryDataChangeHandler, this));","        categoryAxis.after(\"dataUpdate\", Y.bind(this._categoryDataChangeHandler, this));","    },","    ","    /**","     * Event handler for the valueAxisChange event.","     *","     * @method _valueAxisChangeHandler","     * @param {Object} e Event object.","     * @private","     */","    _valueAxisChangeHandler: function(e)","    {","        var valueAxis = this.get(\"valueAxis\");","        valueAxis.after(\"dataReady\", Y.bind(this._valueDataChangeHandler, this));","        valueAxis.after(\"dataUpdate\", Y.bind(this._valueDataChangeHandler, this));","    },","	","    /**","     * Constant used to generate unique id.","     *","     * @property GUID","     * @type String","     * @private","     */","    GUID: \"pieseries\",","	","    /**","     * Event handler for categoryDataChange event.","     *","     * @method _categoryDataChangeHandler","     * @param {Object} event Event object.","     * @private ","     */","    _categoryDataChangeHandler: function(event)","    {","       if(this._rendered && this.get(\"categoryKey\") && this.get(\"valueKey\"))","        {","            this.draw();","        }","    },","","    /**","     * Event handler for valueDataChange event.","     *","     * @method _valueDataChangeHandler","     * @param {Object} event Event object.","     * @private ","     */","    _valueDataChangeHandler: function(event)","    {","        if(this._rendered && this.get(\"categoryKey\") && this.get(\"valueKey\"))","        {","            this.draw();","        }","    },","   ","    /**","     * Draws the series. Overrides the base implementation.","     *","     * @method draw","     * @protected","     */","    draw: function()","    {","        var graph = this.get(\"graph\"),","            w = graph.get(\"width\"),","            h = graph.get(\"height\");","        if(isFinite(w) && isFinite(h) && w > 0 && h > 0)","        {   ","            this._rendered = true;","            if(this._drawing)","            {","                this._callLater = true;","                return;","            }","            this._drawing = true;","            this._callLater = false;","            this.drawSeries();","            this._drawing = false;","            if(this._callLater)","            {","                this.draw();","            }","            else","            {","                this.fire(\"drawingComplete\");","            }","        }","    },","","    /**","     * Draws the markers","     *","     * @method drawPlots","     * @protected","     */","    drawPlots: function()","    {","        var values = this.get(\"valueAxis\").getDataByKey(this.get(\"valueKey\")).concat(),","            catValues = this.get(\"categoryAxis\").getDataByKey(this.get(\"categoryKey\")).concat(),","            totalValue = 0,","            itemCount = values.length,","            styles = this.get(\"styles\").marker,","            fillColors = styles.fill.colors,","            fillAlphas = styles.fill.alphas || [\"1\"],","            borderColors = styles.border.colors,","            borderWeights = [styles.border.weight],","            borderAlphas = [styles.border.alpha],","            tbw = borderWeights.concat(),","            tbc = borderColors.concat(),","            tba = borderAlphas.concat(),","            tfc,","            tfa,","            padding = styles.padding,","            graph = this.get(\"graph\"),","            minDimension = Math.min(graph.get(\"width\"), graph.get(\"height\")),","            w = minDimension - (padding.left + padding.right),","            h = minDimension - (padding.top + padding.bottom),","            startAngle = -90,","            halfWidth = w / 2,","            halfHeight = h / 2,","            radius = Math.min(halfWidth, halfHeight),","            i = 0,","            value,","            angle = 0,","            lc,","            la,","            lw,","            wedgeStyle,","            marker,","            graphOrder = this.get(\"graphOrder\"),","            isCanvas = Y.Graphic.NAME == \"canvasGraphic\";","        for(; i < itemCount; ++i)","        {","            value = parseFloat(values[i]);","            ","            values.push(value);","            if(!isNaN(value))","            {","                totalValue += value;","            }","        }","        ","        tfc = fillColors ? fillColors.concat() : null;","        tfa = fillAlphas ? fillAlphas.concat() : null;","        this._createMarkerCache();","        if(isCanvas)","        {","            this._setMap();","            this._image.width = w;","            this._image.height = h;","        }","        for(i = 0; i < itemCount; i++)","        {","            value = values[i];","            if(totalValue === 0)","            {","                angle = 360 / values.length;","            }","            else","            {","                angle = 360 * (value / totalValue);","            }","            if(tfc && tfc.length < 1)","            {","                tfc = fillColors.concat();","            }","            if(tfa && tfa.length < 1)","            {","                tfa = fillAlphas.concat();","            }","            if(tbw && tbw.length < 1)","            {","                tbw = borderWeights.concat();","            }","            if(tbw && tbc.length < 1)","            {","                tbc = borderColors.concat();","            }","            if(tba && tba.length < 1)","            {","                tba = borderAlphas.concat();","            }","            lw = tbw ? tbw.shift() : null;","            lc = tbc ? tbc.shift() : null;","            la = tba ? tba.shift() : null;","            startAngle += angle;","            wedgeStyle = {","                border: {","                    color:lc,","                    weight:lw,","                    alpha:la","                },","                fill: {","                    color:tfc ? tfc.shift() : this._getDefaultColor(i, \"slice\"),","                    alpha:tfa ? tfa.shift() : null","                },","                type: \"pieslice\",","                arc: angle,","                radius: radius,","                startAngle: startAngle,","                cx: halfWidth,","                cy: halfHeight,","                width: w,","                height: h","            };","            marker = this.getMarker(wedgeStyle, graphOrder, i);","            if(isCanvas)","            {","                this._addHotspot(wedgeStyle, graphOrder, i);","            }","        }","        this._clearMarkerCache();","    },","","    /**","     *  Adds an interactive map when rendering in canvas.","     *","     *  @method _addHotspot","     *  @param {Object} cfg Object containing data used to draw the hotspot","     *  @param {Number} seriesIndex Index of series in the `seriesCollection`.","     *  @param {Number} index Index of the marker using the hotspot.","     *  @private","     */","    _addHotspot: function(cfg, seriesIndex, index)","    {","        var areaNode = DOCUMENT.createElement(\"area\"),","            i = 1,","            x = cfg.cx,","            y = cfg.cy, ","            arc = cfg.arc,","            startAngle = cfg.startAngle - arc, ","            endAngle = cfg.startAngle,","            radius = cfg.radius, ","            ax = x + Math.cos(startAngle / 180 * Math.PI) * radius,","            ay = y + Math.sin(startAngle / 180 * Math.PI) * radius,","            bx = x + Math.cos(endAngle / 180 * Math.PI) * radius,","            by = y + Math.sin(endAngle / 180 * Math.PI) * radius,","            numPoints = Math.floor(arc/10) - 1,","            divAngle = (arc/(Math.floor(arc/10)) / 180) * Math.PI,","            angleCoord = Math.atan((ay - y)/(ax - x)),","            pts = x + \", \" + y + \", \" + ax + \", \" + ay,","            cosAng,","            sinAng,","            multDivAng;","        for(i = 1; i <= numPoints; ++i)","        {","            multDivAng = divAngle * i;","            cosAng = Math.cos(angleCoord + multDivAng);","            sinAng = Math.sin(angleCoord + multDivAng);","            if(startAngle <= 90)","            {","                pts += \", \" + (x + (radius * Math.cos(angleCoord + (divAngle * i))));","                pts += \", \" + (y + (radius * Math.sin(angleCoord + (divAngle * i))));","            }","            else","            {","                pts += \", \" + (x - (radius * Math.cos(angleCoord + (divAngle * i))));","                pts += \", \" + (y - (radius * Math.sin(angleCoord + (divAngle * i))));","            }","        }","        pts += \", \" + bx + \", \" + by;","        pts += \", \" + x + \", \" + y;","        this._map.appendChild(areaNode);","        areaNode.setAttribute(\"class\", SERIES_MARKER);","        areaNode.setAttribute(\"id\", \"hotSpot_\" + seriesIndex + \"_\" + index);","        areaNode.setAttribute(\"shape\", \"polygon\");","        areaNode.setAttribute(\"coords\", pts);","        this._areaNodes.push(areaNode);","","    },","","    /**","     * Resizes and positions markers based on a mouse interaction.","     *","     * @method updateMarkerState","     * @param {String} type state of the marker","     * @param {Number} i index of the marker","     * @protected","     */","    updateMarkerState: function(type, i)","    {","        if(this._markers[i])","        {","            var state = this._getState(type),","                markerStyles,","                indexStyles,","                marker = this._markers[i],","                styles = this.get(\"styles\").marker; ","            markerStyles = state == \"off\" || !styles[state] ? styles : styles[state]; ","            indexStyles = this._mergeStyles(markerStyles, {});","            indexStyles.fill.color = indexStyles.fill.colors[i % indexStyles.fill.colors.length];","            indexStyles.fill.alpha = indexStyles.fill.alphas[i % indexStyles.fill.alphas.length];","            marker.set(indexStyles);","        }","    },","    ","    /**","     * Creates a shape to be used as a marker.","     *","     * @method _createMarker","     * @param {Object} styles Hash of style properties.","     * @param {Number} order Order of the series.","     * @param {Number} index Index within the series associated with the marker.","     * @return Shape","     * @private","     */","    _createMarker: function(styles, order, index)","    {","        var graphic = this.get(\"graphic\"),","            marker,","            cfg = Y.clone(styles);","        graphic.set(\"autoDraw\", false);","        marker = graphic.addShape(cfg); ","        marker.addClass(SERIES_MARKER);","        return marker;","    },","    ","    /**","     * Creates a cache of markers for reuse.","     *","     * @method _createMarkerCache","     * @private","     */","    _clearMarkerCache: function()","    {","        var len = this._markerCache.length,","            i = 0,","            marker;","        for(; i < len; ++i)","        {","            marker = this._markerCache[i];","            if(marker)","            {","                marker.destroy();","            }","        }","        this._markerCache = [];","    },","","    /**","     * Gets the default style values for the markers.","     *","     * @method _getPlotDefaults","     * @return Object","     * @private","     */","    _getPlotDefaults: function()","    {","         var defs = {","            padding:{","                top: 0,","                left: 0,","                right: 0,","                bottom: 0","            },","            fill:{","                alphas:[\"1\"]","            },","            border: {","                weight: 0,","                alpha: 1","            }","        };","        defs.fill.colors = this._defaultSliceColors;","        defs.border.colors = this._defaultBorderColors;","        return defs;","    },","","    /**","     * Collection of default colors used for lines in a series when not specified by user.","     *","     * @property _defaultLineColors","     * @type Array","     * @protected","     */","    _defaultLineColors:[\"#426ab3\", \"#d09b2c\", \"#000000\", \"#b82837\", \"#b384b5\", \"#ff7200\", \"#779de3\", \"#cbc8ba\", \"#7ed7a6\", \"#007a6c\"],","","    /**","     * Collection of default colors used for marker fills in a series when not specified by user.","     *","     * @property _defaultFillColors","     * @type Array","     * @protected","     */","    _defaultFillColors:[\"#6084d0\", \"#eeb647\", \"#6c6b5f\", \"#d6484f\", \"#ce9ed1\", \"#ff9f3b\", \"#93b7ff\", \"#e0ddd0\", \"#94ecba\", \"#309687\"],","    ","    /**","     * Collection of default colors used for marker borders in a series when not specified by user.","     *","     * @property _defaultBorderColors","     * @type Array","     * @protected","     */","    _defaultBorderColors:[\"#205096\", \"#b38206\", \"#000000\", \"#94001e\", \"#9d6fa0\", \"#e55b00\", \"#5e85c9\", \"#adab9e\", \"#6ac291\", \"#006457\"],","    ","    /**","     * Collection of default colors used for area fills, histogram fills and pie fills in a series when not specified by user.","     *","     * @property _defaultSliceColors","     * @type Array","     * @protected","     */","    _defaultSliceColors: [\"#66007f\", \"#a86f41\", \"#295454\", \"#996ab2\", \"#e8cdb7\", \"#90bdbd\",\"#000000\",\"#c3b8ca\", \"#968373\", \"#678585\"],","","    /**","     * Colors used if style colors are not specified","     *","     * @method _getDefaultColor","     * @param {Number} index Index indicating the series order.","     * @param {String} type Indicates which type of object needs the color.","     * @return String","     * @protected","     */","    _getDefaultColor: function(index, type)","    {","        var colors = {","                line: this._defaultLineColors,","                fill: this._defaultFillColors,","                border: this._defaultBorderColors,","                slice: this._defaultSliceColors","            },","            col = colors[type],","            l = col.length;","        index = index || 0;","        if(index >= l)","        {","            index = index % l;","        }","        type = type || \"fill\";","        return colors[type][index];","    }","}, {","    ATTRS: {","        /**","         * Read-only attribute indicating the type of series.","         *","         * @attribute type","         * @type String","         * @default pie","         */","        type: {		","            value: \"pie\"","        },","        ","        /**","         * Order of this instance of this `type`.","         *","         * @attribute order","         * @type Number","         */","        order: {},","","        /**","         * Reference to the `Graph` in which the series is drawn into.","         *","         * @attribute graph","         * @type Graph","         */","        graph: {},","        ","        /**","         * Reference to the `Axis` instance used for assigning ","         * category values to the graph.","         *","         * @attribute categoryAxis","         * @type Axis","         */","        categoryAxis: {","            value: null,","","            validator: function(value)","            {","                return value !== this.get(\"categoryAxis\");","            }","        },","        ","        /**","         * Reference to the `Axis` instance used for assigning ","         * series values to the graph.","         *","         * @attribute categoryAxis","         * @type Axis","         */","        valueAxis: {","            value: null,","","            validator: function(value)","            {","                return value !== this.get(\"valueAxis\");","            }","        },","","        /**","         * Indicates which array to from the hash of value arrays in ","         * the category `Axis` instance.","         *","         * @attribute categoryKey","         * @type String","         */","        categoryKey: {","            value: null,","","            validator: function(value)","            {","                return value !== this.get(\"categoryKey\");","            }","        },","        /**","         * Indicates which array to from the hash of value arrays in ","         * the value `Axis` instance.","         *","         * @attribute valueKey","         * @type String","         */","        valueKey: {","            value: null,","","            validator: function(value)","            {","                return value !== this.get(\"valueKey\");","            }","        },","","        /**","         * Name used for for displaying category data","         *","         * @attribute categoryDisplayName","         * @type String","         */","        categoryDisplayName: {","            setter: function(val)","            {","                this._categoryDisplayName = val;","                return val;","            },","","            getter: function()","            {","                return this._categoryDisplayName || this.get(\"categoryKey\");","            }","        },","","        /**","         * Name used for for displaying value data","         *","         * @attribute valueDisplayName","         * @type String","         */","        valueDisplayName: {","            setter: function(val)","            {","                this._valueDisplayName = val;","                return val;","            },","","            getter: function()","            {","                return this._valueDisplayName || this.get(\"valueKey\");","            }","        },","        ","        /**","         * @attribute slices","         * @type Array","         * @private","         */","        slices: null","        ","        /**","         * Style properties used for drawing markers. This attribute is inherited from `MarkerSeries`. Below are the default values:","         *  <dl>","         *      <dt>fill</dt><dd>A hash containing the following values:","         *          <dl>","         *              <dt>colors</dt><dd>An array of colors to be used for the marker fills. The color for each marker is retrieved from the ","         *              array below:<br/>","         *              `[\"#66007f\", \"#a86f41\", \"#295454\", \"#996ab2\", \"#e8cdb7\", \"#90bdbd\",\"#000000\",\"#c3b8ca\", \"#968373\", \"#678585\"]`","         *              </dd>","         *              <dt>alphas</dt><dd>An array of alpha references (Number from 0 to 1) indicating the opacity of each marker fill. The default value is [1].</dd>","         *          </dl>","         *      </dd>","         *      <dt>border</dt><dd>A hash containing the following values:","         *          <dl>","         *              <dt>color</dt><dd>An array of colors to be used for the marker borders. The color for each marker is retrieved from the","         *              array below:<br/>","         *              `[\"#205096\", \"#b38206\", \"#000000\", \"#94001e\", \"#9d6fa0\", \"#e55b00\", \"#5e85c9\", \"#adab9e\", \"#6ac291\", \"#006457\"]`","         *              <dt>alpha</dt><dd>Number from 0 to 1 indicating the opacity of the marker border. The default value is 1.</dd>","         *              <dt>weight</dt><dd>Number indicating the width of the border. The default value is 1.</dd>","         *          </dl>","         *      </dd>","         *      <dt>over</dt><dd>hash containing styles for markers when highlighted by a `mouseover` event. The default ","         *      values for each style is null. When an over style is not set, the non-over value will be used. For example,","         *      the default value for `marker.over.fill.color` is equivalent to `marker.fill.color`.</dd>","         *  </dl>","         *","         * @attribute styles","         * @type Object","         */","    }","});","/**"," * Gridlines draws gridlines on a Graph."," *"," * @module charts"," * @submodule charts-base"," * @class Gridlines"," * @constructor"," * @extends Base"," * @uses Renderer"," */","Y.Gridlines = Y.Base.create(\"gridlines\", Y.Base, [Y.Renderer], {","    /**","     * Reference to the `Path` element used for drawing Gridlines.","     *","     * @property _path","     * @type Path","     * @private","     */","    _path: null,","","    /**","     * Removes the Gridlines.","     *","     * @method remove","     * @private","     */","    remove: function()","    {","        var path = this._path;","        if(path)","        {","            path.destroy();","        }","    },","","    /**","     * Draws the gridlines","     *","     * @method draw","     * @protected","     */","    draw: function()","    {","        if(this.get(\"axis\") && this.get(\"graph\"))","        {","            this._drawGridlines();","        }","    },","","    /**","     * Algorithm for drawing gridlines","     *","     * @method _drawGridlines","     * @private","     */","    _drawGridlines: function()","    {","        var path,","            axis = this.get(\"axis\"),","            axisPosition = axis.get(\"position\"),","            points,","            i = 0,","            l,","            direction = this.get(\"direction\"),","            graph = this.get(\"graph\"),","            w = graph.get(\"width\"),","            h = graph.get(\"height\"),","            line = this.get(\"styles\").line,","            color = line.color,","            weight = line.weight,","            alpha = line.alpha,","            lineFunction = direction == \"vertical\" ? this._verticalLine : this._horizontalLine;","        if(isFinite(w) && isFinite(h) && w > 0 && h > 0)","        {","            if(axisPosition != \"none\" && axis && axis.get(\"tickPoints\"))","            {","                points = axis.get(\"tickPoints\");","                l = points.length;","            }","            else","            {","                points = [];","                l = axis.get(\"styles\").majorUnit.count;","                for(; i < l; ++i)","                {","                    points[i] = {","                        x: w * (i/(l-1)),","                        y: h * (i/(l-1))","                    };","                }","                i = 0;","            }","            path = graph.get(\"gridlines\");","            path.set(\"width\", w);","            path.set(\"height\", h);","            path.set(\"stroke\", {","                weight: weight,","                color: color,","                opacity: alpha","            });","            for(; i < l; ++i)","            {","                lineFunction(path, points[i], w, h);","            }","            path.end();","        }","    },","","    /**","     * Algorithm for horizontal lines.","     *","     * @method _horizontalLine","     * @param {Path} path Reference to path element","     * @param {Object} pt Coordinates corresponding to a major unit of an axis.","     * @param {Number} w Width of the Graph","     * @param {Number} h Height of the Graph","     * @private","     */","    _horizontalLine: function(path, pt, w, h)","    {","        path.moveTo(0, pt.y);","        path.lineTo(w, pt.y);","    },","","    /**","     * Algorithm for vertical lines.","     *","     * @method _verticalLine","     * @param {Path} path Reference to path element","     * @param {Object} pt Coordinates corresponding to a major unit of an axis.","     * @param {Number} w Width of the Graph","     * @param {Number} h Height of the Graph","     * @private","     */","    _verticalLine: function(path, pt, w, h)","    {","        path.moveTo(pt.x, 0);","        path.lineTo(pt.x, h);","    },","    ","    /**","     * Gets the default value for the `styles` attribute. Overrides","     * base implementation.","     *","     * @method _getDefaultStyles","     * @return Object","     * @protected","     */","    _getDefaultStyles: function()","    {","        var defs = {","            line: {","                color:\"#f0efe9\",","                weight: 1,","                alpha: 1","            }","        };","        return defs;","    }","","},","{","    ATTRS: {","        /**","         * Indicates the direction of the gridline.","         *","         * @attribute direction","         * @type String","         */","        direction: {},","        ","        /**","         * Indicate the `Axis` in which to bind","         * the gridlines.","         *","         * @attribute axis","         * @type Axis","         */","        axis: {},","        ","        /**","         * Indicates the `Graph` in which the gridlines ","         * are drawn.","         *","         * @attribute graph","         * @type Graph","         */","        graph: {}","    }","});","/**"," * Graph manages and contains series instances for a `CartesianChart`"," * instance."," *"," * @module charts"," * @submodule charts-base"," * @class Graph"," * @constructor"," * @extends Widget"," * @uses Renderer"," */","Y.Graph = Y.Base.create(\"graph\", Y.Widget, [Y.Renderer], {","    /**","     * @method bindUI","     * @private","     */","    bindUI: function()","    {","        var bb = this.get(\"boundingBox\");","        bb.setStyle(\"position\", \"absolute\");","        this.after(\"widthChange\", this._sizeChangeHandler);","        this.after(\"heightChange\", this._sizeChangeHandler);","        this.after(\"stylesChange\", this._updateStyles);","        this.after(\"groupMarkersChange\", this._drawSeries);","    },","","    /**","     * @method syncUI","     * @private","     */","    syncUI: function()","    {","        var background,","            cb,","            bg,","            sc = this.get(\"seriesCollection\"),","            series,","            i = 0,","            len = sc ? sc.length : 0,","            hgl = this.get(\"horizontalGridlines\"),","            vgl = this.get(\"verticalGridlines\");","        if(this.get(\"showBackground\"))","        {","            background = this.get(\"background\");","            cb = this.get(\"contentBox\");","            bg = this.get(\"styles\").background;","            bg.stroke = bg.border;","            bg.stroke.opacity = bg.stroke.alpha;","            bg.fill.opacity = bg.fill.alpha;","            bg.width = this.get(\"width\");","            bg.height = this.get(\"height\");","            bg.type = bg.shape;","            background.set(bg);","        }","        for(; i < len; ++i)","        {","            series = sc[i];","            if(series instanceof Y.CartesianSeries)","            {","                series.render();","            }","        }","        if(hgl && hgl instanceof Y.Gridlines)","        {","            hgl.draw();","        }","        if(vgl && vgl instanceof Y.Gridlines)","        {","            vgl.draw();","        }","    },","   ","    /**","     * Object of arrays containing series mapped to a series type.","     *","     * @property seriesTypes","     * @type Object","     * @private","     */","    seriesTypes: null,","","    /**","     * Returns a series instance based on an index.","     * ","     * @method getSeriesByIndex","     * @param {Number} val index of the series","     * @return CartesianSeries","     */","    getSeriesByIndex: function(val)","    {","        var col = this.get(\"seriesCollection\"),","            series;","        if(col && col.length > val)","        {","            series = col[val];","        }","        return series;","    },","","    /**","     * Returns a series instance based on a key value.","     * ","     * @method getSeriesByKey","     * @param {String} val key value of the series","     * @return CartesianSeries","     */","    getSeriesByKey: function(val)","    {","        var obj = this._seriesDictionary,","            series;","        if(obj && obj.hasOwnProperty(val))","        {","            series = obj[val];","        }","        return series;","    },","","    /**","     * Adds dispatcher to a `_dispatcher` used to","     * to ensure all series have redrawn before for firing event.","     *","     * @method addDispatcher","     * @param {CartesianSeries} val series instance to add","     * @protected","     */","    addDispatcher: function(val)","    {","        if(!this._dispatchers)","        {","            this._dispatchers = [];","        }","        this._dispatchers.push(val);","    },","","    /**","     * Collection of series to be displayed in the graph.","     *","     * @property _seriesCollection","     * @type Array","     * @private ","     */","    _seriesCollection: null,","    ","    /**","     * Object containing key value pairs of `CartesianSeries` instances.","     *","     * @property _seriesDictionary","     * @type Object","     * @private","     */","    _seriesDictionary: null,","","    /**","     * Parses series instances to be displayed in the graph.","     *","     * @method _parseSeriesCollection","     * @param {Array} Collection of `CartesianSeries` instances or objects container `CartesianSeries` attributes values.","     * @private","     */","    _parseSeriesCollection: function(val)","    {","        if(!val)","        {","            return;","        }	","        var len = val.length,","            i = 0,","            series,","            seriesKey;","        this._seriesCollection = [];","        this._seriesDictionary = {};","        this.seriesTypes = [];","        for(; i < len; ++i)","        {	","            series = val[i];","            if(!(series instanceof Y.CartesianSeries) && !(series instanceof Y.PieSeries))","            {","                this._createSeries(series);","                continue;","            }","            this._addSeries(series);","        }","        len = this._seriesCollection.length;","        for(i = 0; i < len; ++i)","        {","            series = this.get(\"seriesCollection\")[i];","            seriesKey = series.get(\"direction\") == \"horizontal\" ? \"yKey\" : \"xKey\";","            this._seriesDictionary[series.get(seriesKey)] = series;","        }","    },","","    /**","     * Adds a series to the graph.","     *","     * @method _addSeries","     * @param {CartesianSeries} series Series to add to the graph.","     * @private","     */","    _addSeries: function(series)","    {","        var type = series.get(\"type\"),","            seriesCollection = this.get(\"seriesCollection\"),","            graphSeriesLength = seriesCollection.length,","            seriesTypes = this.seriesTypes,","            typeSeriesCollection;	","        if(!series.get(\"graph\")) ","        {","            series.set(\"graph\", this);","        }","        seriesCollection.push(series);","        if(!seriesTypes.hasOwnProperty(type))","        {","            this.seriesTypes[type] = [];","        }","        typeSeriesCollection = this.seriesTypes[type];","        series.set(\"graphOrder\", graphSeriesLength);","        series.set(\"order\", typeSeriesCollection.length);","        typeSeriesCollection.push(series);","        this.addDispatcher(series);","        series.after(\"drawingComplete\", Y.bind(this._drawingCompleteHandler, this));","        this.fire(\"seriesAdded\", series);","    },","","    /**","     * Creates a `CartesianSeries` instance from an object containing attribute key value pairs. The key value pairs include attributes for the specific series and a type value which defines the type of","     * series to be used. ","     *","     * @method createSeries","     * @param {Object} seriesData Series attribute key value pairs.","     * @private","     */","    _createSeries: function(seriesData)","    {","        var type = seriesData.type,","            seriesCollection = this.get(\"seriesCollection\"),","            seriesTypes = this.seriesTypes,","            typeSeriesCollection,","            seriesType,","            series;","            seriesData.graph = this;","        if(!seriesTypes.hasOwnProperty(type))","        {","            seriesTypes[type] = [];","        }","        typeSeriesCollection = seriesTypes[type];","        seriesData.graph = this;","        seriesData.order = typeSeriesCollection.length;","        seriesData.graphOrder = seriesCollection.length;","        seriesType = this._getSeries(seriesData.type);","        series = new seriesType(seriesData);","        this.addDispatcher(series);","        series.after(\"drawingComplete\", Y.bind(this._drawingCompleteHandler, this));","        typeSeriesCollection.push(series);","        seriesCollection.push(series);","        if(this.get(\"rendered\"))","        {","            series.render();","        }","    },","    ","    /**","     * String reference for pre-defined `Series` classes.","     *","     * @property _seriesMap","     * @type Object","     * @private","     */","    _seriesMap: {","        line : Y.LineSeries,","        column : Y.ColumnSeries,","        bar : Y.BarSeries,","        area :  Y.AreaSeries,","        candlestick : Y.CandlestickSeries,","        ohlc : Y.OHLCSeries,","        stackedarea : Y.StackedAreaSeries,","        stackedline : Y.StackedLineSeries,","        stackedcolumn : Y.StackedColumnSeries,","        stackedbar : Y.StackedBarSeries,","        markerseries : Y.MarkerSeries,","        spline : Y.SplineSeries,","        areaspline : Y.AreaSplineSeries,","        stackedspline : Y.StackedSplineSeries,","        stackedareaspline : Y.StackedAreaSplineSeries,","        stackedmarkerseries : Y.StackedMarkerSeries,","        pie : Y.PieSeries,","        combo : Y.ComboSeries,","        stackedcombo : Y.StackedComboSeries,","        combospline : Y.ComboSplineSeries,","        stackedcombospline : Y.StackedComboSplineSeries","    },","","    /**","     * Returns a specific `CartesianSeries` class based on key value from a look up table of a direct reference to a class. When specifying a key value, the following options","     * are available:","     *","     *  <table>","     *      <tr><th>Key Value</th><th>Class</th></tr>","     *      <tr><td>line</td><td>Y.LineSeries</td></tr>    ","     *      <tr><td>column</td><td>Y.ColumnSeries</td></tr>    ","     *      <tr><td>bar</td><td>Y.BarSeries</td></tr>    ","     *      <tr><td>area</td><td>Y.AreaSeries</td></tr>    ","     *      <tr><td>stackedarea</td><td>Y.StackedAreaSeries</td></tr>    ","     *      <tr><td>stackedline</td><td>Y.StackedLineSeries</td></tr>    ","     *      <tr><td>stackedcolumn</td><td>Y.StackedColumnSeries</td></tr>    ","     *      <tr><td>stackedbar</td><td>Y.StackedBarSeries</td></tr>    ","     *      <tr><td>markerseries</td><td>Y.MarkerSeries</td></tr>    ","     *      <tr><td>spline</td><td>Y.SplineSeries</td></tr>    ","     *      <tr><td>areaspline</td><td>Y.AreaSplineSeries</td></tr>    ","     *      <tr><td>stackedspline</td><td>Y.StackedSplineSeries</td></tr>","     *      <tr><td>stackedareaspline</td><td>Y.StackedAreaSplineSeries</td></tr>","     *      <tr><td>stackedmarkerseries</td><td>Y.StackedMarkerSeries</td></tr>","     *      <tr><td>pie</td><td>Y.PieSeries</td></tr>","     *      <tr><td>combo</td><td>Y.ComboSeries</td></tr>","     *      <tr><td>stackedcombo</td><td>Y.StackedComboSeries</td></tr>","     *      <tr><td>combospline</td><td>Y.ComboSplineSeries</td></tr>","     *      <tr><td>stackedcombospline</td><td>Y.StackedComboSplineSeries</td></tr>","     *  </table>","     * ","     * When referencing a class directly, you can specify any of the above classes or any custom class that extends `CartesianSeries` or `PieSeries`.","     *","     * @method _getSeries","     * @param {String | Object} type Series type.","     * @return CartesianSeries","     * @private","     */","    _getSeries: function(type)","    {","        var seriesClass;","        if(Y_Lang.isString(type))","        {","            seriesClass = this._seriesMap[type];","        }","        else ","        {","            seriesClass = type;","        }","        return seriesClass;","    },","","    /**","     * Event handler for marker events.","     *","     * @method _markerEventHandler","     * @param {Object} e Event object.","     * @private","     */","    _markerEventHandler: function(e)","    {","        var type = e.type,","            markerNode = e.currentTarget,","            strArr = markerNode.getAttribute(\"id\").split(\"_\"),","            series = this.getSeriesByIndex(strArr[1]),","            index = strArr[2];","        series.updateMarkerState(type, index);","    },","","    /**","     * Collection of `CartesianSeries` instances to be redrawn.","     *","     * @property _dispatchers","     * @type Array","     * @private","     */","    _dispatchers: null,","","    /**","     * Updates the `Graph` styles.","     *","     * @method _updateStyles","     * @private","     */","    _updateStyles: function()","    {","        var styles = this.get(\"styles\").background,","            border = styles.border;","            border.opacity = border.alpha;","            styles.stroke = border;","            styles.fill.opacity = styles.fill.alpha;","        this.get(\"background\").set(styles);","        this._sizeChangeHandler();","    },","","    /**","     * Event handler for size changes.","     *","     * @method _sizeChangeHandler","     * @param {Object} e Event object.","     * @private","     */","    _sizeChangeHandler: function(e)","    {","        var hgl = this.get(\"horizontalGridlines\"),","            vgl = this.get(\"verticalGridlines\"),","            w = this.get(\"width\"),","            h = this.get(\"height\"),","            bg = this.get(\"styles\").background,","            weight,","            background;","        if(bg && bg.border)","        {","            weight = bg.border.weight || 0;","        }","        if(this.get(\"showBackground\"))","        {","            background = this.get(\"background\");","            if(w && h)","            {","                background.set(\"width\", w);","                background.set(\"height\", h);","            }","        }","        if(this._gridlines)","        {","            this._gridlines.clear();","        }","        if(hgl && hgl instanceof Y.Gridlines)","        {","            hgl.draw();","        }","        if(vgl && vgl instanceof Y.Gridlines)","        {","            vgl.draw();","        }","        this._drawSeries();","    },","","    /**","     * Draws each series.","     *","     * @method _drawSeries","     * @private","     */","    _drawSeries: function()","    {","        if(this._drawing)","        {","            this._callLater = true;","            return;","        }","        var sc,","            i,","            len,","            graphic = this.get(\"graphic\");","        graphic.set(\"autoDraw\", false);","        this._callLater = false;","        this._drawing = true;","        sc = this.get(\"seriesCollection\");","        i = 0;","        len = sc ? sc.length : 0;","        for(; i < len; ++i)","        {","            sc[i].draw();","            if((!sc[i].get(\"xcoords\") || !sc[i].get(\"ycoords\")) && !sc[i] instanceof Y.PieSeries)","            {","                this._callLater = true;","                break;","            }","        }","        this._drawing = false;","        if(this._callLater)","        {","            this._drawSeries();","        }","    },  ","","    /**","     * Event handler for series drawingComplete event.","     *","     * @method _drawingCompleteHandler","     * @param {Object} e Event object.","     * @private","     */","    _drawingCompleteHandler: function(e)","    {","        var series = e.currentTarget,","            graphic,","            index = Y.Array.indexOf(this._dispatchers, series);","        if(index > -1)","        {","            this._dispatchers.splice(index, 1);","        }","        if(this._dispatchers.length < 1)","        {","            graphic = this.get(\"graphic\");","            if(!graphic.get(\"autoDraw\"))","            {","                graphic._redraw();","            }","            this.fire(\"chartRendered\");","        }","    },","","    /**","     * Gets the default value for the `styles` attribute. Overrides","     * base implementation.","     *","     * @method _getDefaultStyles","     * @return Object","     * @protected","     */","    _getDefaultStyles: function()","    {","        var defs = {","            background: {","                shape: \"rect\",","                fill:{","                    color:\"#faf9f2\"","                },","                border: {","                    color:\"#dad8c9\",","                    weight: 1","                }","            }","        };","        return defs;","    },","","    /**","     * Destructor implementation Graph class. Removes all Graphic instances from the widget.","     *","     * @method destructor","     * @protected","     */","    destructor: function()","    {","        if(this._graphic)","        {","            this._graphic.destroy();","            this._graphic = null;","        }","        if(this._background)","        {","            this._background.get(\"graphic\").destroy();","            this._background = null;","        }","        if(this._gridlines)","        {","            this._gridlines.get(\"graphic\").destroy();","            this._gridlines = null;","        }","    }","}, {","    ATTRS: {","        /**","         * The x-coordinate for the graph.","         *","         * @attribute x","         * @type Number","         * @protected","         */","        x: {","            setter: function(val)","            {","                this.get(\"boundingBox\").setStyle(\"left\", val + \"px\");","                return val;","            }","        },","","        /**","         * The y-coordinate for the graph.","         *","         * @attribute y","         * @type Number","         * @protected","         */","        y: {","            setter: function(val)","            {","                this.get(\"boundingBox\").setStyle(\"top\", val + \"px\");","                return val;","            }","        },","","        /**","         * Reference to the chart instance using the graph.","         *","         * @attribute chart","         * @type ChartBase","         * @readOnly","         */","        chart: {},","","        /**","         * Collection of series. When setting the `seriesCollection` the array can contain a combination of either","         * `CartesianSeries` instances or object literals with properties that will define a series.","         *","         * @attribute seriesCollection","         * @type CartesianSeries","         */","        seriesCollection: {","            getter: function()","            {","                return this._seriesCollection;","            },","","            setter: function(val)","            {","                this._parseSeriesCollection(val);","                return this._seriesCollection;","            }","        },","       ","        /**","         * Indicates whether the `Graph` has a background.","         *","         * @attribute showBackground","         * @type Boolean","         * @default true","         */","        showBackground: {","            value: true","        },","","        /**","         * Read-only hash lookup for all series on in the `Graph`.","         *","         * @attribute seriesDictionary","         * @type Object","         * @readOnly","         */","        seriesDictionary: {","            readOnly: true,","","            getter: function()","            {","                return this._seriesDictionary;","            }","        },","","        /**","         * Reference to the horizontal `Gridlines` instance.","         *","         * @attribute horizontalGridlines","         * @type Gridlines","         * @default null","         */","        horizontalGridlines: {","            value: null,","","            setter: function(val)","            {","                var gl = this.get(\"horizontalGridlines\");","                if(gl && gl instanceof Y.Gridlines)","                {","                    gl.remove();","                }","                if(val instanceof Y.Gridlines)","                {","                    gl = val;","                    val.set(\"graph\", this);","                    return val;","                }","                else if(val && val.axis)","                {","                    gl = new Y.Gridlines({direction:\"horizontal\", axis:val.axis, graph:this, styles:val.styles});","                    return gl;","                }","            }","        },","        ","        /**","         * Reference to the vertical `Gridlines` instance.","         *","         * @attribute verticalGridlines","         * @type Gridlines","         * @default null","         */","        verticalGridlines: {","            value: null,","","            setter: function(val)","            {","                var gl = this.get(\"verticalGridlines\");","                if(gl && gl instanceof Y.Gridlines)","                {","                    gl.remove();","                }","                if(val instanceof Y.Gridlines)","                {","                    gl = val;","                    val.set(\"graph\", this);","                    return val;","                }","                else if(val && val.axis)","                {","                    gl = new Y.Gridlines({direction:\"vertical\", axis:val.axis, graph:this, styles:val.styles});","                    return gl;","                }","            }","        },","","        /**","         * Reference to graphic instance used for the background.","         *","         * @attribute background","         * @type Graphic","         * @readOnly","         */","        background: {","            getter: function()","            {","                if(!this._background)","                {","                    this._backgroundGraphic = new Y.Graphic({render:this.get(\"contentBox\")});","                    this._backgroundGraphic.get(\"node\").style.zIndex = 0; ","                    this._background = this._backgroundGraphic.addShape({type: \"rect\"});","                }","                return this._background;","            }","        },","","        /**","         * Reference to graphic instance used for gridlines.","         *","         * @attribute gridlines","         * @type Graphic","         * @readOnly","         */","        gridlines: {","            readOnly: true,","","            getter: function()","            {","                if(!this._gridlines)","                {","                    this._gridlinesGraphic = new Y.Graphic({render:this.get(\"contentBox\")});","                    this._gridlinesGraphic.get(\"node\").style.zIndex = 1; ","                    this._gridlines = this._gridlinesGraphic.addShape({type: \"path\"});","                }","                return this._gridlines;","            }","        },","        ","        /**","         * Reference to graphic instance used for series.","         *","         * @attribute graphic","         * @type Graphic","         * @readOnly","         */","        graphic: {","            readOnly: true,","","            getter: function() ","            {","                if(!this._graphic)","                {","                    this._graphic = new Y.Graphic({render:this.get(\"contentBox\")});","                    this._graphic.get(\"node\").style.zIndex = 2; ","                    this._graphic.set(\"autoDraw\", false);","                }","                return this._graphic;","            }","        },","","        /**","         * Indicates whether or not markers for a series will be grouped and rendered in a single complex shape instance.","         *","         * @attribute groupMarkers","         * @type Boolean","         */","        groupMarkers: {","            value: false","        }","","        /**","         * Style properties used for drawing a background. Below are the default values:","         *  <dl>","         *      <dt>background</dt><dd>An object containing the following values:","         *          <dl>","         *              <dt>fill</dt><dd>Defines the style properties for the fill. Contains the following values:","         *                  <dl>","         *                      <dt>color</dt><dd>Color of the fill. The default value is #faf9f2.</dd>","         *                      <dt>alpha</dt><dd>Number from 0 to 1 indicating the opacity of the background fill. The default value is 1.</dd>","         *                  </dl>","         *              </dd>","         *              <dt>border</dt><dd>Defines the style properties for the border. Contains the following values:","         *                  <dl>","         *                      <dt>color</dt><dd>Color of the border. The default value is #dad8c9.</dd>","         *                      <dt>alpha</dt><dd>Number from 0 to 1 indicating the opacity of the background border. The default value is 1.</dd>","         *                      <dt>weight</dt><dd>Number indicating the width of the border. The default value is 1.</dd>","         *                  </dl>","         *              </dd>","         *          </dl>","         *      </dd>","         *  </dl>","         *","         * @attribute styles","         * @type Object","         */","    }","});","/**"," * The ChartBase class is an abstract class used to create charts."," *"," * @module charts"," * @submodule charts-base"," * @class ChartBase"," * @constructor"," */","function ChartBase() {}","","ChartBase.ATTRS = {","    /**","     * Data used to generate the chart.","     * ","     * @attribute dataProvider","     * @type Array","     */","    dataProvider: {","        lazyAdd: false,","","        valueFn: function()","        {","            var defDataProvider = [];","            if(!this._seriesKeysExplicitlySet)","            {","                this._seriesKeys = this._buildSeriesKeys(defDataProvider);","            }","            return defDataProvider;","        },","","        setter: function(val)","        {","            var dataProvider = this._setDataValues(val);","            if(!this._seriesKeysExplicitlySet)","            {","                this._seriesKeys = this._buildSeriesKeys(dataProvider);","            }","            return dataProvider;","        }","    },","","    /**","     * A collection of keys that map to the series axes. If no keys are set,","     * they will be generated automatically depending on the data structure passed into ","     * the chart.","     *","     * @attribute seriesKeys","     * @type Array","     */","    seriesKeys: {","        getter: function()","        {","            return this._seriesKeys;","        },","","        setter: function(val)","        {","            this._seriesKeysExplicitlySet = true;","            this._seriesKeys = val;","            return val;","        }","    },","","    /**","     * Sets the `aria-label` for the chart.","     *","     * @attribute ariaLabel","     * @type String","     */","    ariaLabel: {","        value: \"Chart Application\",","","        setter: function(val)","        {","            var cb = this.get(\"contentBox\");","            if(cb)","            {","                cb.setAttribute(\"aria-label\", val);","            }","            return val;","        }","    },","    ","    /**","     * Sets the aria description for the chart.","     *","     * @attribute ariaDescription","     * @type String","     */","    ariaDescription: {","        value: \"Use the up and down keys to navigate between series. Use the left and right keys to navigate through items in a series.\",","","        setter: function(val)","        {","            if(this._description)","            {","                this._description.setContent(\"\");","                this._description.appendChild(DOCUMENT.createTextNode(val));","            }","            return val;","        }","    },","    ","    /**","     * Reference to the default tooltip available for the chart.","     * <p>Contains the following properties:</p>","     *  <dl>","     *      <dt>node</dt><dd>Reference to the actual dom node</dd>","     *      <dt>showEvent</dt><dd>Event that should trigger the tooltip</dd>","     *      <dt>hideEvent</dt><dd>Event that should trigger the removal of a tooltip (can be an event or an array of events)</dd>","     *      <dt>styles</dt><dd>A hash of style properties that will be applied to the tooltip node</dd>","     *      <dt>show</dt><dd>Indicates whether or not to show the tooltip</dd>","     *      <dt>markerEventHandler</dt><dd>Displays and hides tooltip based on marker events</dd>","     *      <dt>planarEventHandler</dt><dd>Displays and hides tooltip based on planar events</dd>","     *      <dt>markerLabelFunction</dt><dd>Reference to the function used to format a marker event triggered tooltip's text. The method contains ","     *      the following arguments:","     *  <dl>","     *      <dt>categoryItem</dt><dd>An object containing the following:","     *  <dl>","     *      <dt>axis</dt><dd>The axis to which the category is bound.</dd>","     *      <dt>displayName</dt><dd>The display name set to the category (defaults to key if not provided).</dd>","     *      <dt>key</dt><dd>The key of the category.</dd>","     *      <dt>value</dt><dd>The value of the category.</dd>","     *  </dl>","     *  </dd>","     *  <dt>valueItem</dt><dd>An object containing the following:","     *      <dl>","     *          <dt>axis</dt><dd>The axis to which the item's series is bound.</dd>","     *          <dt>displayName</dt><dd>The display name of the series. (defaults to key if not provided)</dd>","     *          <dt>key</dt><dd>The key for the series.</dd>","     *          <dt>value</dt><dd>The value for the series item.</dd> ","     *      </dl>","     *  </dd>","     *  <dt>itemIndex</dt><dd>The index of the item within the series.</dd>","     *  <dt>series</dt><dd> The `CartesianSeries` instance of the item.</dd>","     *  <dt>seriesIndex</dt><dd>The index of the series in the `seriesCollection`.</dd>","     *  </dl>","     *  The method returns an `HTMLElement` which is written into the DOM using `appendChild`. If you override this method and choose to return an html string, you","     *  will also need to override the tooltip's `setTextFunction` method to accept an html string.","     *  </dd>","     *  <dt>planarLabelFunction</dt><dd>Reference to the function used to format a planar event triggered tooltip's text","     *  <dl>","     *      <dt>categoryAxis</dt><dd> `CategoryAxis` Reference to the categoryAxis of the chart.","     *      <dt>valueItems</dt><dd>Array of objects for each series that has a data point in the coordinate plane of the event. Each object contains the following data:","     *  <dl>","     *      <dt>axis</dt><dd>The value axis of the series.</dd>","     *      <dt>key</dt><dd>The key for the series.</dd>","     *      <dt>value</dt><dd>The value for the series item.</dd>","     *      <dt>displayName</dt><dd>The display name of the series. (defaults to key if not provided)</dd>","     *  </dl> ","     *  </dd>","     *      <dt>index</dt><dd>The index of the item within its series.</dd>","     *      <dt>seriesArray</dt><dd>Array of series instances for each value item.</dd>","     *      <dt>seriesIndex</dt><dd>The index of the series in the `seriesCollection`.</dd>","     *  </dl>","     *  </dd>","     *  </dl>","     *  The method returns an `HTMLElement` which is written into the DOM using `appendChild`. If you override this method and choose to return an html string, you","     *  will also need to override the tooltip's `setTextFunction` method to accept an html string.","     *  </dd>","     *  <dt>setTextFunction</dt><dd>Method that writes content returned from `planarLabelFunction` or `markerLabelFunction` into the the tooltip node.","     *  has the following signature:","     *  <dl>","     *      <dt>label</dt><dd>The `HTMLElement` that the content is to be added.</dd>","     *      <dt>val</dt><dd>The content to be rendered into tooltip. This can be a `String` or `HTMLElement`. If an HTML string is used, it will be rendered as a","     *      string.</dd>","     *  </dl>","     *  </dd>","     *  </dl>","     * @attribute tooltip","     * @type Object","     */ ","    tooltip: {","        valueFn: \"_getTooltip\",","","        setter: function(val)","        {","            return this._updateTooltip(val);","        }","    },","","    /** ","     * The key value used for the chart's category axis. ","     *","     * @attribute categoryKey","     * @type String","     * @default category","     */","    categoryKey: {","        value: \"category\"","    },","        ","    /**","     * Indicates the type of axis to use for the category axis.","     *","     *  <dl>","     *      <dt>category</dt><dd>Specifies a `CategoryAxis`.</dd>","     *      <dt>time</dt><dd>Specifies a `TimeAxis</dd>","     *  </dl>","     *","     * @attribute categoryType","     * @type String","     * @default category","     */","    categoryType:{","        value:\"category\"","    },","","    /**","     * Indicates the the type of interactions that will fire events.","     *","     *  <dl>","     *      <dt>marker</dt><dd>Events will be broadcasted when the mouse interacts with individual markers.</dd>","     *      <dt>planar</dt><dd>Events will be broadcasted when the mouse intersects the plane of any markers on the chart.</dd>","     *      <dt>none</dt><dd>No events will be broadcasted.</dd>","     *  </dl>","     *","     * @attribute interactionType","     * @type String","     * @default marker","     */","    interactionType: {","        value: \"marker\"","    },","","    /**","     * Reference to all the axes in the chart.","     *","     * @attribute axesCollection","     * @type Array","     */","    axesCollection: {},","","    /**","     * Reference to graph instance.","     * ","     * @attribute graph","     * @type Graph ","     */","    graph: {","        valueFn: \"_getGraph\"","    },","","    /**","     * Indicates whether or not markers for a series will be grouped and rendered in a single complex shape instance.","     *","     * @attribute groupMarkers","     * @type Boolean","     */","    groupMarkers: {","        value: false","    }","};","","ChartBase.prototype = {","    /**","     * Handles groupMarkers change event.","     *","     * @method _groupMarkersChangeHandler","     * @param {Object} e Event object.","     * @private","     */","    _groupMarkersChangeHandler: function(e)","    {","        var graph = this.get(\"graph\"),","            useGroupMarkers = e.newVal;","        if(graph)","        {","            graph.set(\"groupMarkers\", useGroupMarkers);","        }","    },","","    /**","     * Handler for itemRendered event.","     *","     * @method _itemRendered","     * @param {Object} e Event object.","     * @private","     */","    _itemRendered: function(e)","    {","        this._itemRenderQueue = this._itemRenderQueue.splice(1 + Y.Array.indexOf(this._itemRenderQueue, e.currentTarget), 1);","        if(this._itemRenderQueue.length < 1)","        {","            this._redraw();","        }","    },","","    /**","     * Default value function for the `Graph` attribute.","     *","     * @method _getGraph","     * @return Graph","     * @private","     */","    _getGraph: function()","    {","        var graph = new Y.Graph({","            chart:this,","            groupMarkers: this.get(\"groupMarkers\")    ","        });","        graph.after(\"chartRendered\", Y.bind(function(e) {","            this.fire(\"chartRendered\");","        }, this));","        return graph; ","    },","","    /**","     * Returns a series instance by index or key value.","     *","     * @method getSeries","     * @param val","     * @return CartesianSeries","     */","    getSeries: function(val)","    {","        var series = null, ","            graph = this.get(\"graph\");","        if(graph)","        {","            if(Y_Lang.isNumber(val))","            {","                series = graph.getSeriesByIndex(val);","            }","            else","            {","                series = graph.getSeriesByKey(val);","            }","        }","        return series;","    },","","    /**","     * Returns an `Axis` instance by key reference. If the axis was explicitly set through the `axes` attribute,","     * the key will be the same as the key used in the `axes` object. For default axes, the key for","     * the category axis is the value of the `categoryKey` (`category`). For the value axis, the default ","     * key is `values`.","     *","     * @method getAxisByKey","     * @param {String} val Key reference used to look up the axis.","     * @return Axis","     */","    getAxisByKey: function(val)","    {","        var axis,","            axes = this.get(\"axes\");","        if(axes && axes.hasOwnProperty(val))","        {","            axis = axes[val];","        }","        return axis;","    },","","    /**","     * Returns the category axis for the chart.","     *","     * @method getCategoryAxis","     * @return Axis","     */","    getCategoryAxis: function()","    {","        var axis,","            key = this.get(\"categoryKey\"),","            axes = this.get(\"axes\");","        if(axes.hasOwnProperty(key))","        {","            axis = axes[key];","        }","        return axis;","    },","","    /**","     * Default direction of the chart.","     *","     * @property _direction","     * @type String","     * @default horizontal","     * @private","     */","    _direction: \"horizontal\",","    ","    /**","     * Storage for the `dataProvider` attribute.","     *","     * @property _dataProvider","     * @type Array","     * @private","     */","    _dataProvider: null,","","    /**","     * Setter method for `dataProvider` attribute.","     *","     * @method _setDataValues","     * @param {Array} val Array to be set as `dataProvider`.","     * @return Array","     * @private","     */","    _setDataValues: function(val)","    {","        if(Y_Lang.isArray(val[0]))","        {","            var hash, ","                dp = [], ","                cats = val[0], ","                i = 0, ","                l = cats.length, ","                n, ","                sl = val.length;","            for(; i < l; ++i)","            {","                hash = {category:cats[i]};","                for(n = 1; n < sl; ++n)","                {","                    hash[\"series\" + n] = val[n][i];","                }","                dp[i] = hash; ","            }","            return dp;","        }","        return val;","    },","","    /**","     * Storage for `seriesCollection` attribute.","     *","     * @property _seriesCollection","     * @type Array","     * @private ","     */","    _seriesCollection: null,","","    /**","     * Setter method for `seriesCollection` attribute.","     *","     * @property _setSeriesCollection","     * @param {Array} val Array of either `CartesianSeries` instances or objects containing series attribute key value pairs.","     * @private","     */","    _setSeriesCollection: function(val)","    {","        this._seriesCollection = val;","    },","    /**","     * Helper method that returns the axis class that a key references.","     *","     * @method _getAxisClass","     * @param {String} t The type of axis.","     * @return Axis","     * @private","     */","    _getAxisClass: function(t)","    {","        return this._axisClass[t];","    },","  ","    /**","     * Key value pairs of axis types. ","     *","     * @property _axisClass","     * @type Object","     * @private","     */","    _axisClass: {","        stacked: Y.StackedAxis,","        numeric: Y.NumericAxis,","        category: Y.CategoryAxis,","        time: Y.TimeAxis","    },","","    /**","     * Collection of axes.","     *","     * @property _axes","     * @type Array","     * @private","     */","    _axes: null,","","    /**","     * @method initializer","     * @private","     */","    initializer: function()","    {","        this._itemRenderQueue = [];","        this._seriesIndex = -1;","        this._itemIndex = -1;","        this.after(\"dataProviderChange\", this._dataProviderChangeHandler);","    },","","    /**","     * @method renderUI","     * @private","     */","    renderUI: function()","    {","        var tt = this.get(\"tooltip\"),","            bb = this.get(\"boundingBox\"),","            cb = this.get(\"contentBox\");","        //move the position = absolute logic to a class file","        bb.setStyle(\"position\", \"absolute\");","        cb.setStyle(\"position\", \"absolute\");","        this._addAxes();","        this._addSeries();","        if(tt && tt.show)","        {","            this._addTooltip();","        }","        this._setAriaElements(bb, cb);","    },","   ","    /**","     * Creates an aria `live-region`, `aria-label` and `aria-describedby` for the Chart.","     *","     * @method _setAriaElements","     * @param {Node} cb Reference to the Chart's `contentBox` attribute.","     * @private","     */","    _setAriaElements: function(bb, cb)","    {","        var description = this._getAriaOffscreenNode(),","            id = this.get(\"id\") + \"_description\",","            liveRegion = this._getAriaOffscreenNode();","        cb.set(\"tabIndex\", 0);","        cb.set(\"role\", \"img\");","        cb.setAttribute(\"aria-label\", this.get(\"ariaLabel\"));","        cb.setAttribute(\"aria-describedby\", id);","        description.set(\"id\", id);","        description.set(\"tabIndex\", -1);","        description.appendChild(DOCUMENT.createTextNode(this.get(\"ariaDescription\")));","        liveRegion.set(\"id\", \"live-region\");","        liveRegion.set(\"aria-live\", \"polite\");","        liveRegion.set(\"aria-atomic\", \"true\");","        liveRegion.set(\"role\", \"status\");","        bb.setAttribute(\"role\", \"application\");","        bb.appendChild(description);","        bb.appendChild(liveRegion);","        this._description = description;","        this._liveRegion = liveRegion;","    },","","    /**","     * Sets a node offscreen for use as aria-description or aria-live-regin.","     *","     * @method _setOffscreen","     * @return Node ","     * @private","     */","    _getAriaOffscreenNode: function()  ","    {","        var node = Y.Node.create(\"<div></div>\"),","            ie = Y.UA.ie,","            clipRect = (ie && ie < 8) ? \"rect(1px 1px 1px 1px)\" : \"rect(1px, 1px, 1px, 1px)\";","        node.setStyle(\"position\", \"absolute\");","        node.setStyle(\"height\", \"1px\"); ","        node.setStyle(\"width\", \"1px\"); ","        node.setStyle(\"overflow\", \"hidden\");","        node.setStyle(\"clip\", clipRect); ","        return node;","    },","  ","    /**","     * @method syncUI","     * @private","     */","    syncUI: function()","    {","        this._redraw();","    },","","    /**","     * @method bindUI","     * @private","     */","    bindUI: function()","    {","        this.after(\"tooltipChange\", Y.bind(this._tooltipChangeHandler, this));","        this.after(\"widthChange\", this._sizeChanged);","        this.after(\"heightChange\", this._sizeChanged);","        this.after(\"groupMarkersChange\", this._groupMarkersChangeHandler);","        var tt = this.get(\"tooltip\"),","            hideEvent = \"mouseout\",","            showEvent = \"mouseover\",","            cb = this.get(\"contentBox\"),","            interactionType = this.get(\"interactionType\"),","            i = 0,","            len,","            markerClassName = \".\" + SERIES_MARKER,","            isTouch = ((WINDOW && (\"ontouchstart\" in WINDOW)) && !(Y.UA.chrome && Y.UA.chrome < 6));","        Y.on(\"keydown\", Y.bind(function(e) {","            var key = e.keyCode,","                numKey = parseFloat(key),","                msg;","            if(numKey > 36 && numKey < 41)","            {","                e.halt();","                msg = this._getAriaMessage(numKey);","                this._liveRegion.setContent(\"\");","                this._liveRegion.appendChild(DOCUMENT.createTextNode(msg));","            }","        }, this), this.get(\"contentBox\"));","        if(interactionType == \"marker\")","        {","            //if touch capabilities, toggle tooltip on touchend. otherwise, the tooltip attribute's hideEvent/showEvent types.","            hideEvent = tt.hideEvent;","            showEvent = tt.showEvent;","            if(isTouch)","            {","                Y.delegate(\"touchend\", Y.bind(this._markerEventDispatcher, this), cb, markerClassName);","                //hide active tooltip if the chart is touched","                Y.on(\"touchend\", Y.bind(function(e) {","                    e.halt(true);","                    if(this._activeMarker)","                    {","                        this._activeMarker = null;","                        this.hideTooltip(e);","                    }","                }, this));","            }","            else","            {","                Y.delegate(\"mouseenter\", Y.bind(this._markerEventDispatcher, this), cb, markerClassName);","                Y.delegate(\"mousedown\", Y.bind(this._markerEventDispatcher, this), cb, markerClassName);","                Y.delegate(\"mouseup\", Y.bind(this._markerEventDispatcher, this), cb, markerClassName);","                Y.delegate(\"mouseleave\", Y.bind(this._markerEventDispatcher, this), cb, markerClassName);","                Y.delegate(\"click\", Y.bind(this._markerEventDispatcher, this), cb, markerClassName);","                Y.delegate(\"mousemove\", Y.bind(this._positionTooltip, this), cb, markerClassName);","            }","        }","        else if(interactionType == \"planar\")","        {","            if(isTouch)","            {","                this._overlay.on(\"touchend\", Y.bind(this._planarEventDispatcher, this));","            }","            else","            {","                this._overlay.on(\"mousemove\", Y.bind(this._planarEventDispatcher, this));","                this.on(\"mouseout\", this.hideTooltip);","            }","        }","        if(tt)","        {","            this.on(\"markerEvent:touchend\", Y.bind(function(e) {","                var marker = e.series.get(\"markers\")[e.index];","                if(this._activeMarker && marker === this._activeMarker)","                {","                    this._activeMarker = null;","                    this.hideTooltip(e);","                }","                else","                {","","                    this._activeMarker = marker;","                    tt.markerEventHandler.apply(this, [e]);","                }","            }, this));","            if(hideEvent && showEvent && hideEvent == showEvent)","            {","                this.on(interactionType + \"Event:\" + hideEvent, this.toggleTooltip);","            }","            else","            {","                if(showEvent)","                {","                    this.on(interactionType + \"Event:\" + showEvent, tt[interactionType + \"EventHandler\"]);","                }","                if(hideEvent)","                {","                    if(Y_Lang.isArray(hideEvent))","                    {","                        len = hideEvent.length;","                        for(; i < len; ++i)","                        {","                            this.on(interactionType + \"Event:\" + hideEvent[i], this.hideTooltip);","                        }","                    }","                    this.on(interactionType + \"Event:\" + hideEvent, this.hideTooltip);","                }","            }","        }","    },","    ","    /**","     * Event handler for marker events.","     *","     * @method _markerEventDispatcher","     * @param {Object} e Event object.","     * @private","     */","    _markerEventDispatcher: function(e)","    {","        var type = e.type,","            cb = this.get(\"contentBox\"),","            markerNode = e.currentTarget,","            strArr = markerNode.getAttribute(\"id\").split(\"_\"),","            index = strArr.pop(),","            seriesIndex = strArr.pop(),","            series = this.getSeries(parseInt(seriesIndex, 10)),","            items = this.getSeriesItems(series, index),","            isTouch = e && e.hasOwnProperty(\"changedTouches\"),","            pageX = isTouch ? e.changedTouches[0].pageX : e.pageX,","            pageY = isTouch ? e.changedTouches[0].pageY : e.pageY,","            x = pageX - cb.getX(),","            y = pageY - cb.getY();","        if(type == \"mouseenter\")","        {","            type = \"mouseover\";","        }","        else if(type == \"mouseleave\")","        {","            type = \"mouseout\";","        }","        series.updateMarkerState(type, index);","        e.halt();","        /**","         * Broadcasts when `interactionType` is set to `marker` and a series marker has received a mouseover event.","         * ","         *","         * @event markerEvent:mouseover","         * @preventable false","         * @param {EventFacade} e Event facade with the following additional","         *   properties:","         *  <dl>","         *      <dt>categoryItem</dt><dd>Hash containing information about the category `Axis`.</dd>","         *      <dt>valueItem</dt><dd>Hash containing information about the value `Axis`.</dd>","         *      <dt>node</dt><dd>The dom node of the marker.</dd>","         *      <dt>x</dt><dd>The x-coordinate of the mouse in relation to the Chart.</dd>","         *      <dt>y</dt><dd>The y-coordinate of the mouse in relation to the Chart.</dd>","         *      <dt>series</dt><dd>Reference to the series of the marker.</dd>","         *      <dt>index</dt><dd>Index of the marker in the series.</dd>","         *      <dt>seriesIndex</dt><dd>The `order` of the marker's series.</dd>","         *  </dl>","         */","        /**","         * Broadcasts when `interactionType` is set to `marker` and a series marker has received a mouseout event.","         *","         * @event markerEvent:mouseout","         * @preventable false","         * @param {EventFacade} e Event facade with the following additional","         *   properties:","         *  <dl>","         *      <dt>categoryItem</dt><dd>Hash containing information about the category `Axis`.</dd>","         *      <dt>valueItem</dt><dd>Hash containing information about the value `Axis`.</dd>","         *      <dt>node</dt><dd>The dom node of the marker.</dd>","         *      <dt>x</dt><dd>The x-coordinate of the mouse in relation to the Chart.</dd>","         *      <dt>y</dt><dd>The y-coordinate of the mouse in relation to the Chart.</dd>","         *      <dt>series</dt><dd>Reference to the series of the marker.</dd>","         *      <dt>index</dt><dd>Index of the marker in the series.</dd>","         *      <dt>seriesIndex</dt><dd>The `order` of the marker's series.</dd>","         *  </dl>","         */","        /**","         * Broadcasts when `interactionType` is set to `marker` and a series marker has received a mousedown event.","         *","         * @event markerEvent:mousedown","         * @preventable false","         * @param {EventFacade} e Event facade with the following additional","         *   properties:","         *  <dl>","         *      <dt>categoryItem</dt><dd>Hash containing information about the category `Axis`.</dd>","         *      <dt>valueItem</dt><dd>Hash containing information about the value `Axis`.</dd>","         *      <dt>node</dt><dd>The dom node of the marker.</dd>","         *      <dt>x</dt><dd>The x-coordinate of the mouse in relation to the Chart.</dd>","         *      <dt>y</dt><dd>The y-coordinate of the mouse in relation to the Chart.</dd>","         *      <dt>series</dt><dd>Reference to the series of the marker.</dd>","         *      <dt>index</dt><dd>Index of the marker in the series.</dd>","         *      <dt>seriesIndex</dt><dd>The `order` of the marker's series.</dd>","         *  </dl>","         */","        /**","         * Broadcasts when `interactionType` is set to `marker` and a series marker has received a mouseup event.","         *","         * @event markerEvent:mouseup","         * @preventable false","         * @param {EventFacade} e Event facade with the following additional","         *   properties:","         *  <dl>","         *      <dt>categoryItem</dt><dd>Hash containing information about the category `Axis`.</dd>","         *      <dt>valueItem</dt><dd>Hash containing information about the value `Axis`.</dd>","         *      <dt>node</dt><dd>The dom node of the marker.</dd>","         *      <dt>x</dt><dd>The x-coordinate of the mouse in relation to the Chart.</dd>","         *      <dt>y</dt><dd>The y-coordinate of the mouse in relation to the Chart.</dd>","         *      <dt>series</dt><dd>Reference to the series of the marker.</dd>","         *      <dt>index</dt><dd>Index of the marker in the series.</dd>","         *      <dt>seriesIndex</dt><dd>The `order` of the marker's series.</dd>","         *  </dl>","         */","        /**","         * Broadcasts when `interactionType` is set to `marker` and a series marker has received a click event.","         *","         * @event markerEvent:click","         * @preventable false","         * @param {EventFacade} e Event facade with the following additional","         *   properties:","         *  <dl>","         *      <dt>categoryItem</dt><dd>Hash containing information about the category `Axis`.</dd>","         *      <dt>valueItem</dt><dd>Hash containing information about the value `Axis`.</dd>","         *      <dt>node</dt><dd>The dom node of the marker.</dd>","         *      <dt>x</dt><dd>The x-coordinate of the mouse in relation to the Chart.</dd>","         *      <dt>y</dt><dd>The y-coordinate of the mouse in relation to the Chart.</dd>","         *      <dt>pageX</dt><dd>The x location of the event on the page (including scroll)</dd>","         *      <dt>pageY</dt><dd>The y location of the event on the page (including scroll)</dd>","         *      <dt>series</dt><dd>Reference to the series of the marker.</dd>","         *      <dt>index</dt><dd>Index of the marker in the series.</dd>","         *      <dt>seriesIndex</dt><dd>The `order` of the marker's series.</dd>","         *      <dt>originEvent</dt><dd>Underlying dom event.</dd>","         *  </dl>","         */","        this.fire(\"markerEvent:\" + type, {","            originEvent: e,","            pageX:pageX, ","            pageY:pageY, ","            categoryItem:items.category, ","            valueItem:items.value, ","            node:markerNode, ","            x:x, ","            y:y, ","            series:series, ","            index:index, ","            seriesIndex:seriesIndex","        });","    },","","    /**","     * Event handler for dataProviderChange.","     *","     * @method _dataProviderChangeHandler","     * @param {Object} e Event object.","     * @private","     */","    _dataProviderChangeHandler: function(e)","    {","        var dataProvider = e.newVal,","            axes,","            i,","            axis;","        this._seriesIndex = -1;","        this._itemIndex = -1;","        if(this instanceof Y.CartesianChart)","        {","            this.set(\"axes\", this.get(\"axes\"));","            this.set(\"seriesCollection\", this.get(\"seriesCollection\"));","        }","        axes = this.get(\"axes\");","        if(axes)","        {","            for(i in axes)","            {","                if(axes.hasOwnProperty(i))","                {","                    axis = axes[i];","                    if(axis instanceof Y.Axis)","                    {","                        if(axis.get(\"position\") != \"none\")","                        {","                            this._addToAxesRenderQueue(axis);","                        }","                        axis.set(\"dataProvider\", dataProvider);","                    }","                }","            }","        }","    },","    ","    /**","     * Event listener for toggling the tooltip. If a tooltip is visible, hide it. If not, it ","     * will create and show a tooltip based on the event object.","     * ","     * @method toggleTooltip","     * @param {Object} e Event object.","     */","    toggleTooltip: function(e)","    {","        var tt = this.get(\"tooltip\");","        if(tt.visible)","        {","            this.hideTooltip();","        }","        else","        {","            tt.markerEventHandler.apply(this, [e]);","        }","    },","","    /**","     * Shows a tooltip","     *","     * @method _showTooltip","     * @param {String} msg Message to dispaly in the tooltip.","     * @param {Number} x x-coordinate ","     * @param {Number} y y-coordinate","     * @private","     */","    _showTooltip: function(msg, x, y)","    {","        var tt = this.get(\"tooltip\"),","            node = tt.node;","        if(msg)","        {","            tt.visible = true;","            tt.setTextFunction(node, msg);","            node.setStyle(\"top\", y + \"px\");","            node.setStyle(\"left\", x + \"px\");","            node.setStyle(\"visibility\", \"visible\");","        }","    },","","    /**","     * Positions the tooltip","     *","     * @method _positionTooltip","     * @param {Object} e Event object.","     * @private","     */","    _positionTooltip: function(e)","    {","        var tt = this.get(\"tooltip\"),","            node = tt.node,","            cb = this.get(\"contentBox\"),","            x = (e.pageX + 10) - cb.getX(),","            y = (e.pageY + 10) - cb.getY();","        if(node)","        {","            node.setStyle(\"left\", x + \"px\");","            node.setStyle(\"top\", y + \"px\");","        }","    },","","    /**","     * Hides the default tooltip","     *","     * @method hideTooltip","     */","    hideTooltip: function()","    {","        var tt = this.get(\"tooltip\"),","            node = tt.node;","        tt.visible = false;","        node.set(\"innerHTML\", \"\");","        node.setStyle(\"left\", -10000);","        node.setStyle(\"top\", -10000);","        node.setStyle(\"visibility\", \"hidden\");","    },","","    /**","     * Adds a tooltip to the dom.","     *","     * @method _addTooltip","     * @private","     */","    _addTooltip: function()","    {","        var tt = this.get(\"tooltip\"),","            id = this.get(\"id\") + \"_tooltip\",","            cb = this.get(\"contentBox\"),","            oldNode = DOCUMENT.getElementById(id);","        if(oldNode)","        {","            cb.removeChild(oldNode);","        }","        tt.node.set(\"id\", id);","        tt.node.setStyle(\"visibility\", \"hidden\");","        cb.appendChild(tt.node);","    },","","    /**","     * Updates the tooltip attribute.","     *","     * @method _updateTooltip","     * @param {Object} val Object containing properties for the tooltip.","     * @return Object","     * @private","     */","    _updateTooltip: function(val)","    {","        var tt = this.get(\"tooltip\") || this._getTooltip(),","            i,","            styles,","            node,","            props = {","                markerLabelFunction:\"markerLabelFunction\",","                planarLabelFunction:\"planarLabelFunction\",","                setTextFunction:\"setTextFunction\",","                showEvent:\"showEvent\",","                hideEvent:\"hideEvent\",","                markerEventHandler:\"markerEventHandler\",","                planarEventHandler:\"planarEventHandler\",","                show:\"show\"","            };","        if(Y_Lang.isObject(val))","        {","            styles = val.styles;","            node = Y.one(val.node) || tt.node;","            if(styles)","            {","                for(i in styles)","                {","                    if(styles.hasOwnProperty(i))","                    {","                        node.setStyle(i, styles[i]);","                    }","                }","            }","            for(i in props)","            {","                if(val.hasOwnProperty(i))","                {","                    tt[i] = val[i];","                }","            }","            tt.node = node;","        }","        return tt;","    },","","    /**","     * Default getter for `tooltip` attribute.","     *","     * @method _getTooltip","     * @return Object","     * @private","     */","    _getTooltip: function()","    {","        var node = DOCUMENT.createElement(\"div\"),","            tooltipClass = _getClassName(\"chart-tooltip\"),","            tt = {","                setTextFunction: this._setText,","                markerLabelFunction: this._tooltipLabelFunction,","                planarLabelFunction: this._planarLabelFunction,","                show: true,","                hideEvent: \"mouseout\",","                showEvent: \"mouseover\",","                markerEventHandler: function(e)","                {","                    var tt = this.get(\"tooltip\"),","                    msg = tt.markerLabelFunction.apply(this, [e.categoryItem, e.valueItem, e.index, e.series, e.seriesIndex]);","                    this._showTooltip(msg, e.x + 10, e.y + 10);","                },","                planarEventHandler: function(e)","                {","                    var tt = this.get(\"tooltip\"),","                        msg ,","                        categoryAxis = this.get(\"categoryAxis\");","                    msg = tt.planarLabelFunction.apply(this, [categoryAxis, e.valueItem, e.index, e.items, e.seriesIndex]);","                    this._showTooltip(msg, e.x + 10, e.y + 10);","                }","            };","        node = Y.one(node);","        node.set(\"id\", this.get(\"id\") + \"_tooltip\");","        node.setStyle(\"fontSize\", \"85%\");","        node.setStyle(\"opacity\", \"0.83\");","        node.setStyle(\"position\", \"absolute\");","        node.setStyle(\"paddingTop\", \"2px\");","        node.setStyle(\"paddingRight\", \"5px\");","        node.setStyle(\"paddingBottom\", \"4px\");","        node.setStyle(\"paddingLeft\", \"2px\");","        node.setStyle(\"backgroundColor\", \"#fff\");","        node.setStyle(\"border\", \"1px solid #dbdccc\");","        node.setStyle(\"pointerEvents\", \"none\");","        node.setStyle(\"zIndex\", 3);","        node.setStyle(\"whiteSpace\", \"noWrap\");","        node.setStyle(\"visibility\", \"hidden\");","        node.addClass(tooltipClass);","        tt.node = Y.one(node);","        return tt;","    },","","    /**","     * Formats tooltip text when `interactionType` is `planar`.","     *","     * @method _planarLabelFunction","     * @param {Axis} categoryAxis Reference to the categoryAxis of the chart.","     * @param {Array} valueItems Array of objects for each series that has a data point in the coordinate plane of the event. Each object contains the following data:","     *  <dl>","     *      <dt>axis</dt><dd>The value axis of the series.</dd>","     *      <dt>key</dt><dd>The key for the series.</dd>","     *      <dt>value</dt><dd>The value for the series item.</dd>","     *      <dt>displayName</dt><dd>The display name of the series. (defaults to key if not provided)</dd>","     *  </dl> ","     *  @param {Number} index The index of the item within its series.","     *  @param {Array} seriesArray Array of series instances for each value item.","     *  @param {Number} seriesIndex The index of the series in the `seriesCollection`.","     *  @return {String | HTML} ","     * @private","     */","    _planarLabelFunction: function(categoryAxis, valueItems, index, seriesArray, seriesIndex)","    {","        var msg = DOCUMENT.createElement(\"div\"),","            valueItem,","            i = 0,","            len = seriesArray.length,","            axis,","            categoryValue,","            seriesValue,","            series;","        if(categoryAxis)","        {","            categoryValue = categoryAxis.get(\"labelFunction\").apply(this, [categoryAxis.getKeyValueAt(this.get(\"categoryKey\"), index), categoryAxis.get(\"labelFormat\")]);","            if(!Y_Lang.isObject(categoryValue))","            {","                categoryValue = DOCUMENT.createTextNode(categoryValue);","            }","            msg.appendChild(categoryValue);","        }","","        for(; i < len; ++i)","        {","            series = seriesArray[i];","            if(series.get(\"visible\"))","            {","                valueItem = valueItems[i];","                axis = valueItem.axis;","                seriesValue =  axis.get(\"labelFunction\").apply(this, [axis.getKeyValueAt(valueItem.key, index), axis.get(\"labelFormat\")]);","                msg.appendChild(DOCUMENT.createElement(\"br\"));","                msg.appendChild(DOCUMENT.createTextNode(valueItem.displayName));","                msg.appendChild(DOCUMENT.createTextNode(\": \"));","                if(!Y_Lang.isObject(seriesValue))","                {","                    seriesValue = DOCUMENT.createTextNode(seriesValue);","                }","                msg.appendChild(seriesValue);","            }","        }","        return msg;","    },","","    /**","     * Formats tooltip text when `interactionType` is `marker`.","     *","     * @method _tooltipLabelFunction","     * @param {Object} categoryItem An object containing the following:","     *  <dl>","     *      <dt>axis</dt><dd>The axis to which the category is bound.</dd>","     *      <dt>displayName</dt><dd>The display name set to the category (defaults to key if not provided)</dd>","     *      <dt>key</dt><dd>The key of the category.</dd>","     *      <dt>value</dt><dd>The value of the category</dd>","     *  </dl>","     * @param {Object} valueItem An object containing the following:","     *  <dl>","     *      <dt>axis</dt><dd>The axis to which the item's series is bound.</dd>","     *      <dt>displayName</dt><dd>The display name of the series. (defaults to key if not provided)</dd>","     *      <dt>key</dt><dd>The key for the series.</dd>","     *      <dt>value</dt><dd>The value for the series item.</dd> ","     *  </dl>","     * @param {Number} itemIndex The index of the item within the series.","     * @param {CartesianSeries} series The `CartesianSeries` instance of the item.","     * @param {Number} seriesIndex The index of the series in the `seriesCollection`.","     * @return {String | HTML}","     * @private","     */","    _tooltipLabelFunction: function(categoryItem, valueItem, itemIndex, series, seriesIndex)","    {","        var msg = DOCUMENT.createElement(\"div\"),","            categoryValue = categoryItem.axis.get(\"labelFunction\").apply(this, [categoryItem.value, categoryItem.axis.get(\"labelFormat\")]),","            seriesValue = valueItem.axis.get(\"labelFunction\").apply(this, [valueItem.value, valueItem.axis.get(\"labelFormat\")]);","        msg.appendChild(DOCUMENT.createTextNode(categoryItem.displayName)); ","        msg.appendChild(DOCUMENT.createTextNode(\": \")); ","        if(!Y_Lang.isObject(categoryValue))","        {","            categoryValue = DOCUMENT.createTextNode(categoryValue);","        }","        msg.appendChild(categoryValue);","        msg.appendChild(DOCUMENT.createElement(\"br\"));","        msg.appendChild(DOCUMENT.createTextNode(valueItem.displayName)); ","        msg.appendChild(DOCUMENT.createTextNode(\": \")); ","        if(!Y_Lang.isObject(seriesValue))","        {","            seriesValue = DOCUMENT.createTextNode(seriesValue);","        }","        msg.appendChild(seriesValue);","        return msg; ","    },","","    /**","     * Event handler for the tooltipChange.","     *","     * @method _tooltipChangeHandler","     * @param {Object} e Event object.","     * @private","     */","    _tooltipChangeHandler: function(e)","    {","        if(this.get(\"tooltip\"))","        {","            var tt = this.get(\"tooltip\"),","                node = tt.node,","                show = tt.show,","                cb = this.get(\"contentBox\");","            if(node && show)","            {","                if(!cb.contains(node))","                {","                    this._addTooltip();","                }","            }","        }","    },","    ","    /**","     * Updates the content of text field. This method writes a value into a text field using ","     * `appendChild`. If the value is a `String`, it is converted to a `TextNode` first. ","     *","     * @method _setText","     * @param label {HTMLElement} label to be updated","     * @param val {String} value with which to update the label","     * @private","     */","    _setText: function(textField, val)","    { ","        textField.setContent(\"\");","        if(Y_Lang.isNumber(val))","        {","            val = val + \"\";","        }","        else if(!val)","        {","            val = \"\";","        }","        if(IS_STRING(val))","        {","            val = DOCUMENT.createTextNode(val);","        }","        textField.appendChild(val);","    },","","    /**","     * Returns all the keys contained in a  `dataProvider`.","     *","     * @method _getAllKeys","     * @param {Array} dp Collection of objects to be parsed.","     * @return Object","     */","    _getAllKeys: function(dp)","    {","        var i = 0,","            len = dp.length,","            item,","            key,","            keys = {};","        for(; i < len; ++i)","        {","            item = dp[i];","            for(key in item)","            {","                if(item.hasOwnProperty(key))","                {","                    keys[key] = true;","                }","            }","        }","        return keys;","    },","    ","    /**","     * Constructs seriesKeys if not explicitly specified.","     *","     * @method _buildSeriesKeys","     * @param {Array} dataProvider The dataProvider for the chart.","     * @return Array","     * @private","     */","    _buildSeriesKeys: function(dataProvider)","    {","        var allKeys,","            catKey = this.get(\"categoryKey\"),","            keys = [],","            i;","        if(this._seriesKeysExplicitlySet)","        {","            return this._seriesKeys;","        }","        allKeys = this._getAllKeys(dataProvider);","        for(i in allKeys)","        {","            if(allKeys.hasOwnProperty(i) && i != catKey)","            {","                keys.push(i);","            }","        }","        return keys;","    }","};","Y.ChartBase = ChartBase;","/**"," * The CartesianChart class creates a chart with horizontal and vertical axes."," *"," * @module charts"," * @submodule charts-base"," * @class CartesianChart"," * @extends ChartBase"," * @constructor"," */","Y.CartesianChart = Y.Base.create(\"cartesianChart\", Y.Widget, [Y.ChartBase], {","    /**","     * @method renderUI","     * @private","     */","    renderUI: function()","    {","        var bb = this.get(\"boundingBox\"),","            cb = this.get(\"contentBox\"),","            tt = this.get(\"tooltip\"),","            overlay,","            overlayClass = _getClassName(\"overlay\");","        //move the position = absolute logic to a class file","        bb.setStyle(\"position\", \"absolute\");","        cb.setStyle(\"position\", \"absolute\");","        this._addAxes();","        this._addGridlines();","        this._addSeries();","        if(tt && tt.show)","        {","            this._addTooltip();","        }","        //If there is a style definition. Force them to set.","        this.get(\"styles\");","        if(this.get(\"interactionType\") == \"planar\")","        {","            overlay = DOCUMENT.createElement(\"div\");","            this.get(\"contentBox\").appendChild(overlay);","            this._overlay = Y.one(overlay); ","            this._overlay.set(\"id\", this.get(\"id\") + \"_overlay\");","            this._overlay.setStyle(\"position\", \"absolute\");","            this._overlay.setStyle(\"background\", \"#fff\");","            this._overlay.setStyle(\"opacity\", 0);","            this._overlay.addClass(overlayClass);","            this._overlay.setStyle(\"zIndex\", 4);","        }","        this._setAriaElements(bb, cb);","        this._redraw();","    },","","    /**","     * When `interactionType` is set to `planar`, listens for mouse move events and fires `planarEvent:mouseover` or `planarEvent:mouseout` depending on the position of the mouse in relation to ","     * data points on the `Chart`.","     *","     * @method _planarEventDispatcher","     * @param {Object} e Event object.","     * @private","     */","    _planarEventDispatcher: function(e)","    {","        var graph = this.get(\"graph\"),","            bb = this.get(\"boundingBox\"),","            cb = graph.get(\"contentBox\"),","            isTouch = e && e.hasOwnProperty(\"changedTouches\"),","            pageX = isTouch ? e.changedTouches[0].pageX : e.pageX,","            pageY = isTouch ? e.changedTouches[0].pageY : e.pageY,","            posX = pageX - bb.getX(),","            posY = pageY - bb.getY(),","            offset = {","                x: pageX - cb.getX(),","                y: pageY - cb.getY()","            },","            sc = graph.get(\"seriesCollection\"),","            series,","            i = 0,","            index,","            oldIndex = this._selectedIndex,","            item,","            items = [],","            categoryItems = [],","            valueItems = [],","            direction = this.get(\"direction\"),","            hasMarkers,","            catAxis,","            valAxis,","            coord,","            //data columns and area data could be created on a graph level","            markerPlane,","            len,","            coords;","        e.halt(true);","        if(direction == \"horizontal\")","        {","            catAxis = \"x\";","            valAxis = \"y\";","        }","        else","        {","            valAxis = \"x\";","            catAxis = \"y\";","        }","        coord = offset[catAxis];","        if(sc)","        {","            len = sc.length;","            while(i < len && !markerPlane)","            {","                if(sc[i])","                {","                    markerPlane = sc[i].get(catAxis + \"MarkerPlane\");","                }","                i++;","            }","        }","        if(markerPlane)","        {","            len = markerPlane.length;","            for(i = 0; i < len; ++i)","            {","                if(coord <= markerPlane[i].end && coord >= markerPlane[i].start)","                {","                    index = i;","                    break;","                }","            }","            len = sc.length;","            for(i = 0; i < len; ++i)","            {","                series = sc[i];","                coords = series.get(valAxis + \"coords\");","                hasMarkers = series.get(\"markers\");","                if(hasMarkers && !isNaN(oldIndex) && oldIndex > -1)","                {","                    series.updateMarkerState(\"mouseout\", oldIndex);","                }","                if(coords && coords[index] > -1)","                {","                    if(hasMarkers && !isNaN(index) && index > -1)","                    {","                        series.updateMarkerState(\"mouseover\", index);","                    }","                    item = this.getSeriesItems(series, index);","                    categoryItems.push(item.category);","                    valueItems.push(item.value);","                    items.push(series);","                }","                    ","            }","            this._selectedIndex = index;","","            /**","             * Broadcasts when `interactionType` is set to `planar` and a series' marker plane has received a mouseover event.","             * ","             *","             * @event planarEvent:mouseover","             * @preventable false","             * @param {EventFacade} e Event facade with the following additional","             *   properties:","             *  <dl>","             *      <dt>categoryItem</dt><dd>An array of hashes, each containing information about the category `Axis` of each marker whose plane has been intersected.</dd>","             *      <dt>valueItem</dt><dd>An array of hashes, each containing information about the value `Axis` of each marker whose plane has been intersected.</dd>","             *      <dt>x</dt><dd>The x-coordinate of the mouse in relation to the Chart.</dd>","             *      <dt>y</dt><dd>The y-coordinate of the mouse in relation to the Chart.</dd>","             *      <dt>pageX</dt><dd>The x location of the event on the page (including scroll)</dd>","             *      <dt>pageY</dt><dd>The y location of the event on the page (including scroll)</dd>","             *      <dt>items</dt><dd>An array including all the series which contain a marker whose plane has been intersected.</dd>","             *      <dt>index</dt><dd>Index of the markers in their respective series.</dd>","             *      <dt>originEvent</dt><dd>Underlying dom event.</dd>","             *  </dl>","             */","            /**","             * Broadcasts when `interactionType` is set to `planar` and a series' marker plane has received a mouseout event.","             *","             * @event planarEvent:mouseout","             * @preventable false","             * @param {EventFacade} e ","             */","            if(index > -1)","            {","                this.fire(\"planarEvent:mouseover\", {","                    categoryItem:categoryItems, ","                    valueItem:valueItems, ","                    x:posX, ","                    y:posY, ","                    pageX:pageX,","                    pageY:pageY,","                    items:items, ","                    index:index,","                    originEvent:e","                });","            }","            else","            {","                this.fire(\"planarEvent:mouseout\");","            }","        }","    },","","    /**","     * Indicates the default series type for the chart.","     *","     * @property _type","     * @type {String}","     * @private","     */","    _type: \"combo\",","","    /**","     * Queue of axes instances that will be updated. This method is used internally to determine when all axes have been updated.","     *","     * @property _itemRenderQueue","     * @type Array","     * @private","     */","    _itemRenderQueue: null,","","    /**","     * Adds an `Axis` instance to the `_itemRenderQueue`.","     *","     * @method _addToAxesRenderQueue","     * @param {Axis} axis An `Axis` instance.","     * @private ","     */","    _addToAxesRenderQueue: function(axis)","    {","        if(!this._itemRenderQueue)","        {","            this._itemRenderQueue = [];","        }","        if(Y.Array.indexOf(this._itemRenderQueue, axis) < 0)","        {","            this._itemRenderQueue.push(axis);","        }","    },","","    /**","     * Adds axis instance to the appropriate array based on position","     *","     * @method _addToAxesCollection","     * @param {String} position The position of the axis","     * @param {Axis} axis The `Axis` instance","     */","    _addToAxesCollection: function(position, axis)","    {","        var axesCollection = this.get(position + \"AxesCollection\");","        if(!axesCollection)","        {","            axesCollection = [];","            this.set(position + \"AxesCollection\", axesCollection);","        }","        axesCollection.push(axis);","    },","","    /**","     * Returns the default value for the `seriesCollection` attribute.","     *","     * @method _getDefaultSeriesCollection","     * @param {Array} val Array containing either `CartesianSeries` instances or objects containing data to construct series instances.","     * @return Array","     * @private","     */","    _getDefaultSeriesCollection: function()","    {","        var seriesCollection,","            dataProvider = this.get(\"dataProvider\");","        if(dataProvider)","        {","            seriesCollection = this._parseSeriesCollection();","        }","        return seriesCollection;","    },","","    /**","     * Parses and returns a series collection from an object and default properties.","     *","     * @method _parseSeriesCollection","     * @param {Object} val Object contain properties for series being set.","     * @return Object","     * @private","     */","    _parseSeriesCollection: function(val)","    {","        var dir = this.get(\"direction\"), ","            sc = [], ","            catAxis,","            valAxis,","            tempKeys = [],","            series,","            seriesKeys = this.get(\"seriesKeys\").concat(),","            i,","            index,","            l,","            type = this.get(\"type\"),","            key,","            catKey,","            seriesKey,","            graph,","            orphans = [],","            categoryKey = this.get(\"categoryKey\"),","            showMarkers = this.get(\"showMarkers\"),","            showAreaFill = this.get(\"showAreaFill\"),","            showLines = this.get(\"showLines\");","        val = val || []; ","        if(dir == \"vertical\")","        {","            catAxis = \"yAxis\";","            catKey = \"yKey\";","            valAxis = \"xAxis\";","            seriesKey = \"xKey\";","        }","        else","        {","            catAxis = \"xAxis\";","            catKey = \"xKey\";","            valAxis = \"yAxis\";","            seriesKey = \"yKey\";","        }","        l = val.length;","        while(val && val.length > 0)","        {","            series = val.shift();","            key = this._getBaseAttribute(series, seriesKey);","            if(key)","            {","                index = Y.Array.indexOf(seriesKeys, key);","                if(index > -1)","                {","                    seriesKeys.splice(index, 1);","                    tempKeys.push(key);","                    sc.push(series);","                }","                else","                {","                    orphans.push(series);","                }","            }","            else","            {","                orphans.push(series);","            }","        }","        while(orphans.length > 0)","        {","            series = orphans.shift();","            if(seriesKeys.length > 0)","            {","                key = seriesKeys.shift();","                this._setBaseAttribute(series, seriesKey, key);","                tempKeys.push(key);","                sc.push(series);","            }","            else if(series instanceof Y.CartesianSeries)","            {","                series.destroy(true);","            }","        }","        if(seriesKeys.length > 0)","        {","            tempKeys = tempKeys.concat(seriesKeys);","        }","        l = tempKeys.length;","        for(i = 0; i < l; ++i)","        {","            series = sc[i] || {type:type};","            if(series instanceof Y.CartesianSeries)","            {","                this._parseSeriesAxes(series);","                continue;","            }","","            series[catKey] = series[catKey] || categoryKey;","            series[seriesKey] = series[seriesKey] || seriesKeys.shift();","            series[catAxis] = this._getCategoryAxis();","            series[valAxis] = this._getSeriesAxis(series[seriesKey]);","                ","            series.type = series.type || type;","            series.direction = series.direction || dir;","            ","            if((series.type == \"combo\" || series.type == \"stackedcombo\" || series.type == \"combospline\" || series.type == \"stackedcombospline\"))","            {","                if(showAreaFill !== null)","                {","                    series.showAreaFill = (series.showAreaFill !== null && series.showAreaFill !== undefined) ? series.showAreaFill : showAreaFill;","                }","                if(showMarkers !== null)","                {","                    series.showMarkers = (series.showMarkers !== null && series.showMarkers !== undefined) ? series.showMarkers : showMarkers;","                }","                if(showLines !== null)","                {","                    series.showLines = (series.showLines !== null && series.showLines !== undefined) ? series.showLines : showLines;","                }","            }","            sc[i] = series;","        }","        if(sc)","        {","            graph = this.get(\"graph\");","            graph.set(\"seriesCollection\", sc);","            sc = graph.get(\"seriesCollection\");","        }","        return sc;","    },","","    /**","     * Parse and sets the axes for a series instance.","     *","     * @method _parseSeriesAxes","     * @param {CartesianSeries} series A `CartesianSeries` instance.","     * @private","     */","    _parseSeriesAxes: function(series)","    {","        var axes = this.get(\"axes\"),","            xAxis = series.get(\"xAxis\"),","            yAxis = series.get(\"yAxis\"),","            YAxis = Y.Axis,","            axis;","        if(xAxis && !(xAxis instanceof YAxis) && Y_Lang.isString(xAxis) && axes.hasOwnProperty(xAxis))","        {","            axis = axes[xAxis];","            if(axis instanceof YAxis)","            {","                series.set(\"xAxis\", axis);","            }","        }","        if(yAxis && !(yAxis instanceof YAxis) && Y_Lang.isString(yAxis) && axes.hasOwnProperty(yAxis))","        {   ","            axis = axes[yAxis];","            if(axis instanceof YAxis)","            {","                series.set(\"yAxis\", axis);","            }","        }","","    },","","    /**","     * Returns the category axis instance for the chart.","     *","     * @method _getCategoryAxis","     * @return Axis","     * @private","     */","    _getCategoryAxis: function()","    {","        var axis,","            axes = this.get(\"axes\"),","            categoryAxisName = this.get(\"categoryAxisName\") || this.get(\"categoryKey\");","        axis = axes[categoryAxisName];","        return axis;","    },","","    /**","     * Returns the value axis for a series.","     *","     * @method _getSeriesAxis","     * @param {String} key The key value used to determine the axis instance.","     * @return Axis","     * @private","     */","    _getSeriesAxis:function(key, axisName)","    {","        var axes = this.get(\"axes\"),","            i,","            keys,","            axis;","        if(axes)","        {","            if(axisName && axes.hasOwnProperty(axisName))","            {","                axis = axes[axisName];","            }","            else","            {","                for(i in axes)","                {","                    if(axes.hasOwnProperty(i))","                    {","                        keys = axes[i].get(\"keys\");","                        if(keys && keys.hasOwnProperty(key))","                        {","                            axis = axes[i];","                            break;","                        }","                    }","                }","            }","        }","        return axis;","    },","","    /**","     * Gets an attribute from an object, using a getter for Base objects and a property for object","     * literals. Used for determining attributes from series/axis references which can be an actual class instance","     * or a hash of properties that will be used to create a class instance.","     *","     * @method _getBaseAttribute","     * @param {Object} item Object or instance in which the attribute resides.","     * @param {String} key Attribute whose value will be returned.","     * @return Object","     * @private","     */","    _getBaseAttribute: function(item, key)","    {","        if(item instanceof Y.Base)","        {","            return item.get(key);","        }","        if(item.hasOwnProperty(key))","        {","            return item[key];","        }","        return null;","    },","","    /**","     * Sets an attribute on an object, using a setter of Base objects and a property for object","     * literals. Used for setting attributes on a Base class, either directly or to be stored in an object literal","     * for use at instantiation.","     *","     * @method _setBaseAttribute","     * @param {Object} item Object or instance in which the attribute resides.","     * @param {String} key Attribute whose value will be assigned.","     * @param {Object} value Value to be assigned to the attribute.","     * @private","     */","    _setBaseAttribute: function(item, key, value)","    {","        if(item instanceof Y.Base)","        {","            item.set(key, value);","        }","        else","        {","            item[key] = value;","        }","    },","","    /**","     * Creates `Axis` instances.","     *","     * @method _setAxes","     * @param {Object} val Object containing `Axis` instances or objects in which to construct `Axis` instances.","     * @return Object","     * @private","     */","    _setAxes: function(val)","    {","        var hash = this._parseAxes(val),","            axes = {},","            axesAttrs = {","                edgeOffset: \"edgeOffset\", ","                position: \"position\",","                overlapGraph:\"overlapGraph\",","                labelFunction:\"labelFunction\",","                labelFunctionScope:\"labelFunctionScope\",","                labelFormat:\"labelFormat\",","                appendLabelFunction: \"appendLabelFunction\",","                appendTitleFunction: \"appendTitleFunction\",","                maximum:\"maximum\",","                minimum:\"minimum\", ","                roundingMethod:\"roundingMethod\",","                alwaysShowZero:\"alwaysShowZero\",","                title:\"title\",","                width:\"width\",","                height:\"height\"","            },","            dp = this.get(\"dataProvider\"),","            ai,","            i, ","            pos, ","            axis,","            axisPosition,","            dh, ","            axisClass, ","            config,","            axesCollection;","        for(i in hash)","        {","            if(hash.hasOwnProperty(i))","            {","                dh = hash[i];","                if(dh instanceof Y.Axis)","                {","                    axis = dh;","                }","                else","                {","                    axis = null;","                    config = {};","                    config.dataProvider = dh.dataProvider || dp;","                    config.keys = dh.keys;","                    ","                    if(dh.hasOwnProperty(\"roundingUnit\"))","                    {","                        config.roundingUnit = dh.roundingUnit;","                    }","                    pos = dh.position;","                    if(dh.styles)","                    {","                        config.styles = dh.styles;","                    }","                    config.position = dh.position;","                    for(ai in axesAttrs)","                    {","                        if(axesAttrs.hasOwnProperty(ai) && dh.hasOwnProperty(ai))","                        {","                            config[ai] = dh[ai];","                        }","                    }","                   ","                    //only check for existing axis if we constructed the default axes already","                    if(val)","                    {","                        axis = this.getAxisByKey(i);","                    }","                    ","                    if(axis && axis instanceof Y.Axis)","                    {","                        axisPosition = axis.get(\"position\");","                        if(pos != axisPosition)","                        {","                            if(axisPosition != \"none\")","                            {","                                axesCollection = this.get(axisPosition + \"AxesCollection\");","                                axesCollection.splice(Y.Array.indexOf(axesCollection, axis), 1);","                            }","                            if(pos != \"none\")","                            {","                                this._addToAxesCollection(pos, axis);","                            }","                        }","                        axis.setAttrs(config);","                    }","                    else","                    {","                        axisClass = this._getAxisClass(dh.type);","                        axis = new axisClass(config);","                        axis.after(\"axisRendered\", Y.bind(this._itemRendered, this));","                    }","                }","","                if(axis)","                {","                    axesCollection = this.get(pos + \"AxesCollection\");","                    if(axesCollection && Y.Array.indexOf(axesCollection, axis) > 0)","                    {","                        axis.set(\"overlapGraph\", false);","                    }","                    axes[i] = axis;","                }","            }","        }","        return axes;","    },","    ","    /**","     * Adds axes to the chart.","     *","     * @method _addAxes","     * @private","     */","    _addAxes: function()","    {","        var axes = this.get(\"axes\"),","            i, ","            axis, ","            pos,","            w = this.get(\"width\"),","            h = this.get(\"height\"),","            node = Y.Node.one(this._parentNode);","        if(!this._axesCollection)","        {   ","            this._axesCollection = [];","        }","        for(i in axes)","        {","            if(axes.hasOwnProperty(i))","            {","                axis = axes[i];","                if(axis instanceof Y.Axis)","                {","                    if(!w)","                    {","                        this.set(\"width\", node.get(\"offsetWidth\"));","                        w = this.get(\"width\");","                    }","                    if(!h)","                    {","                        this.set(\"height\", node.get(\"offsetHeight\"));","                        h = this.get(\"height\");","                    }","                    this._addToAxesRenderQueue(axis);","                    pos = axis.get(\"position\");","                    if(!this.get(pos + \"AxesCollection\"))","                    {","                        this.set(pos + \"AxesCollection\", [axis]);","                    }","                    else","                    {","                        this.get(pos + \"AxesCollection\").push(axis);","                    }","                    this._axesCollection.push(axis);","                    if(axis.get(\"keys\").hasOwnProperty(this.get(\"categoryKey\")))","                    {","                        this.set(\"categoryAxis\", axis);","                    }","                    axis.render(this.get(\"contentBox\"));","                }","            }","        }","    },","","    /**","     * Renders the Graph.","     *","     * @method _addSeries","     * @private","     */","    _addSeries: function()","    {","        var graph = this.get(\"graph\"),","            sc = this.get(\"seriesCollection\");","        graph.render(this.get(\"contentBox\"));","","    },","","    /**","     * Adds gridlines to the chart.","     *","     * @method _addGridlines","     * @private","     */","    _addGridlines: function()","    {","        var graph = this.get(\"graph\"),","            hgl = this.get(\"horizontalGridlines\"),","            vgl = this.get(\"verticalGridlines\"),","            direction = this.get(\"direction\"),","            leftAxesCollection = this.get(\"leftAxesCollection\"),","            rightAxesCollection = this.get(\"rightAxesCollection\"),","            bottomAxesCollection = this.get(\"bottomAxesCollection\"),","            topAxesCollection = this.get(\"topAxesCollection\"),","            seriesAxesCollection,","            catAxis = this.get(\"categoryAxis\"),","            hAxis,","            vAxis;","        if(this._axesCollection)","        {","            seriesAxesCollection = this._axesCollection.concat();","            seriesAxesCollection.splice(Y.Array.indexOf(seriesAxesCollection, catAxis), 1);","        }","        if(hgl)","        {","            if(leftAxesCollection && leftAxesCollection[0])","            {","                hAxis = leftAxesCollection[0];","            }","            else if(rightAxesCollection && rightAxesCollection[0])","            {","                hAxis = rightAxesCollection[0];","            }","            else ","            {","                hAxis = direction == \"horizontal\" ? catAxis : seriesAxesCollection[0];","            }","            if(!this._getBaseAttribute(hgl, \"axis\") && hAxis)","            {","                this._setBaseAttribute(hgl, \"axis\", hAxis);","            }","            if(this._getBaseAttribute(hgl, \"axis\"))","            {","                graph.set(\"horizontalGridlines\", hgl);","            }","        }","        if(vgl)","        {","            if(bottomAxesCollection && bottomAxesCollection[0])","            {","                vAxis = bottomAxesCollection[0];","            }","            else if (topAxesCollection && topAxesCollection[0])","            {","                vAxis = topAxesCollection[0];","            }","            else ","            {","                vAxis = direction == \"vertical\" ? catAxis : seriesAxesCollection[0];","            }","            if(!this._getBaseAttribute(vgl, \"axis\") && vAxis)","            {","                this._setBaseAttribute(vgl, \"axis\", vAxis);","            }","            if(this._getBaseAttribute(vgl, \"axis\"))","            {","                graph.set(\"verticalGridlines\", vgl);","            }","        }","    },","    ","    /**","     * Default Function for the axes attribute.","     *","     * @method _getDefaultAxes","     * @return Object","     * @private","     */","    _getDefaultAxes: function()","    {","        var axes;","        if(this.get(\"dataProvider\"))","        {","            axes = this._parseAxes();","        }","        return axes;","    },","","    /**","     * Generates and returns a key-indexed object containing `Axis` instances or objects used to create `Axis` instances.","     *","     * @method _parseAxes","     * @param {Object} axes Object containing `Axis` instances or `Axis` attributes.","     * @return Object","     * @private","     */","    _parseAxes: function(axes)","    {","        var catKey = this.get(\"categoryKey\"),","            axis,","            attr,","            keys,","            newAxes = {},","            claimedKeys = [],","            categoryAxisName = this.get(\"categoryAxisName\") || this.get(\"categoryKey\"),","            valueAxisName = this.get(\"valueAxisName\"),","            seriesKeys = this.get(\"seriesKeys\").concat(),","            i, ","            l,","            ii,","            ll,","            cIndex,","            direction = this.get(\"direction\"),","            seriesPosition,","            categoryPosition,","            valueAxes = [],","            seriesAxis = this.get(\"stacked\") ? \"stacked\" : \"numeric\";","        if(direction == \"vertical\")","        {","            seriesPosition = \"bottom\";","            categoryPosition = \"left\";","        }","        else","        {","            seriesPosition = \"left\";","            categoryPosition = \"bottom\";","        }","        if(axes)","        {","            for(i in axes)","            {","                if(axes.hasOwnProperty(i))","                {","                    axis = axes[i];","                    keys = this._getBaseAttribute(axis, \"keys\");","                    attr = this._getBaseAttribute(axis, \"type\");","                    if(attr == \"time\" || attr == \"category\")","                    {","                        categoryAxisName = i;","                        this.set(\"categoryAxisName\", i);","                        if(Y_Lang.isArray(keys) && keys.length > 0)","                        {","                            catKey = keys[0];","                            this.set(\"categoryKey\", catKey);","                        }","                        newAxes[i] = axis;","                    }","                    else if(i == categoryAxisName)","                    {","                        newAxes[i] = axis;","                    }","                    else ","                    {","                        newAxes[i] = axis;","                        if(i != valueAxisName && keys && Y_Lang.isArray(keys))","                        {","                            ll = keys.length;","                            for(ii = 0; ii < ll; ++ii)","                            {","                                claimedKeys.push(keys[ii]);","                            }","                            valueAxes.push(newAxes[i]);","                        }","                        if(!(this._getBaseAttribute(newAxes[i], \"type\")))","                        {","                            this._setBaseAttribute(newAxes[i], \"type\", seriesAxis);","                        }","                        if(!(this._getBaseAttribute(newAxes[i], \"position\")))","                        {","                            this._setBaseAttribute(newAxes[i], \"position\", this._getDefaultAxisPosition(newAxes[i], valueAxes, seriesPosition));","                        }","                    }","                }","            }","        }","        cIndex = Y.Array.indexOf(seriesKeys, catKey);","        if(cIndex > -1)","        {","            seriesKeys.splice(cIndex, 1);","        }","        l = claimedKeys.length;","        for(i = 0; i < l; ++i)","        {","            cIndex = Y.Array.indexOf(seriesKeys, claimedKeys[i]); ","            if(cIndex > -1)","            {","                seriesKeys.splice(cIndex, 1);","            }","        }","        if(!newAxes.hasOwnProperty(categoryAxisName))","        {","            newAxes[categoryAxisName] = {};","        }","        if(!(this._getBaseAttribute(newAxes[categoryAxisName], \"keys\")))","        {","            this._setBaseAttribute(newAxes[categoryAxisName], \"keys\", [catKey]);","        }","        ","        if(!(this._getBaseAttribute(newAxes[categoryAxisName], \"position\")))","        {","            this._setBaseAttribute(newAxes[categoryAxisName], \"position\", categoryPosition);","        }","         ","        if(!(this._getBaseAttribute(newAxes[categoryAxisName], \"type\")))","        {","            this._setBaseAttribute(newAxes[categoryAxisName], \"type\", this.get(\"categoryType\"));","        }","        if(!newAxes.hasOwnProperty(valueAxisName) && seriesKeys && seriesKeys.length > 0)","        {","            newAxes[valueAxisName] = {keys:seriesKeys};","            valueAxes.push(newAxes[valueAxisName]);","        }","        if(claimedKeys.length > 0)","        {","            if(seriesKeys.length > 0)","            {","                seriesKeys = claimedKeys.concat(seriesKeys);","            }","            else","            {","                seriesKeys = claimedKeys;","            }","        }","        if(newAxes.hasOwnProperty(valueAxisName))","        {","            if(!(this._getBaseAttribute(newAxes[valueAxisName], \"position\")))","            {","                this._setBaseAttribute(newAxes[valueAxisName], \"position\", this._getDefaultAxisPosition(newAxes[valueAxisName], valueAxes, seriesPosition));","            }","            this._setBaseAttribute(newAxes[valueAxisName], \"type\", seriesAxis);","            this._setBaseAttribute(newAxes[valueAxisName], \"keys\", seriesKeys);","        } ","        if(!this._seriesKeysExplicitlySet)","        {","            this._seriesKeys = seriesKeys;","        }","        return newAxes;","    },","","    /**","     * Determines the position of an axis when one is not specified.","     *","     * @method _getDefaultAxisPosition","     * @param {Axis} axis `Axis` instance.","     * @param {Array} valueAxes Array of `Axis` instances.","     * @param {String} position Default position depending on the direction of the chart and type of axis.","     * @return String","     * @private","     */","    _getDefaultAxisPosition: function(axis, valueAxes, position)","    {","        var direction = this.get(\"direction\"),","            i = Y.Array.indexOf(valueAxes, axis);","        ","        if(valueAxes[i - 1] && valueAxes[i - 1].position)","        {","            if(direction == \"horizontal\")","            {","                if(valueAxes[i - 1].position == \"left\")","                {","                    position = \"right\";","                }","                else if(valueAxes[i - 1].position == \"right\")","                {","                    position = \"left\";","                }","            }","            else","            {","                if (valueAxes[i -1].position == \"bottom\")","                {","                    position = \"top\";","                }       ","                else","                {","                    position = \"bottom\";","                }","            }","        }","        return position;","    },","","   ","    /**","     * Returns an object literal containing a categoryItem and a valueItem for a given series index. Below is the structure of each:","     * ","     * @method getSeriesItems","     * @param {CartesianSeries} series Reference to a series.","     * @param {Number} index Index of the specified item within a series.","     * @return Object An object literal containing the following:","     *","     *  <dl>","     *      <dt>categoryItem</dt><dd>Object containing the following data related to the category axis of the series.","     *  <dl>","     *      <dt>axis</dt><dd>Reference to the category axis of the series.</dd>","     *      <dt>key</dt><dd>Category key for the series.</dd>","     *      <dt>value</dt><dd>Value on the axis corresponding to the series index.</dd>","     *  </dl>","     *      </dd>","     *      <dt>valueItem</dt><dd>Object containing the following data related to the category axis of the series.","     *  <dl>","     *      <dt>axis</dt><dd>Reference to the value axis of the series.</dd>","     *      <dt>key</dt><dd>Value key for the series.</dd>","     *      <dt>value</dt><dd>Value on the axis corresponding to the series index.</dd>","     *  </dl>","     *      </dd>","     *  </dl>","     */","    getSeriesItems: function(series, index)","    {","        var xAxis = series.get(\"xAxis\"),","            yAxis = series.get(\"yAxis\"),","            xKey = series.get(\"xKey\"),","            yKey = series.get(\"yKey\"),","            categoryItem,","            valueItem;","        if(this.get(\"direction\") == \"vertical\")","        {","            categoryItem = {","                axis:yAxis,","                key:yKey,","                value:yAxis.getKeyValueAt(yKey, index)","            };","            valueItem = {","                axis:xAxis,","                key:xKey,","                value: xAxis.getKeyValueAt(xKey, index)","            };","        }","        else","        {","            valueItem = {","                axis:yAxis,","                key:yKey,","                value:yAxis.getKeyValueAt(yKey, index)","            };","            categoryItem = {","                axis:xAxis,","                key:xKey,","                value: xAxis.getKeyValueAt(xKey, index)","            };","        }","        categoryItem.displayName = series.get(\"categoryDisplayName\");","        valueItem.displayName = series.get(\"valueDisplayName\");","        categoryItem.value = categoryItem.axis.getKeyValueAt(categoryItem.key, index);","        valueItem.value = valueItem.axis.getKeyValueAt(valueItem.key, index);","        return {category:categoryItem, value:valueItem};","    },","","    /**","     * Handler for sizeChanged event.","     *","     * @method _sizeChanged","     * @param {Object} e Event object.","     * @private","     */","    _sizeChanged: function(e)","    {","        if(this._axesCollection)","        {","            var ac = this._axesCollection,","                i = 0,","                l = ac.length;","            for(; i < l; ++i)","            {","                this._addToAxesRenderQueue(ac[i]);","            }","            this._redraw();","        }","    },","    ","    /**","     * Returns the maximum distance in pixels that the extends outside the top bounds of all vertical axes.","     *","     * @method _getTopOverflow","     * @param {Array} set1 Collection of axes to check.","     * @param {Array} set2 Seconf collection of axes to check.","     * @param {Number} width Width of the axes","     * @return Number","     * @private","     */","    _getTopOverflow: function(set1, set2, height)","    {","        var i = 0,","            len,","            overflow = 0,","            axis;","        if(set1)","        {","            len = set1.length;","            for(; i < len; ++i)","            {","                axis = set1[i];","                overflow = Math.max(overflow, Math.abs(axis.getMaxLabelBounds().top) - (axis.getEdgeOffset(axis.get(\"styles\").majorTicks.count, height) * 0.5));","            }","        }","        if(set2)","        {","            i = 0;","            len = set2.length;","            for(; i < len; ++i)","            {","                axis = set2[i];","                overflow = Math.max(overflow, Math.abs(axis.getMaxLabelBounds().top) - (axis.getEdgeOffset(axis.get(\"styles\").majorTicks.count, height) * 0.5));","            }","        }","        return overflow;","    },","    ","    /**","     * Returns the maximum distance in pixels that the extends outside the right bounds of all horizontal axes.","     *","     * @method _getRightOverflow","     * @param {Array} set1 Collection of axes to check.","     * @param {Array} set2 Seconf collection of axes to check.","     * @param {Number} width Width of the axes","     * @return Number","     * @private","     */","    _getRightOverflow: function(set1, set2, width)","    {","        var i = 0,","            len,","            overflow = 0,","            axis;","        if(set1)","        {","            len = set1.length;","            for(; i < len; ++i)","            {","                axis = set1[i];","                overflow = Math.max(overflow, axis.getMaxLabelBounds().right - (axis.getEdgeOffset(axis.get(\"styles\").majorTicks.count, width) * 0.5));","            }","        }","        if(set2)","        {","            i = 0;","            len = set2.length;","            for(; i < len; ++i)","            {","                axis = set2[i];","                overflow = Math.max(overflow, axis.getMaxLabelBounds().right - (axis.getEdgeOffset(axis.get(\"styles\").majorTicks.count, width) * 0.5));","            }","        }","        return overflow;","    },","    ","    /**","     * Returns the maximum distance in pixels that the extends outside the left bounds of all horizontal axes.","     *","     * @method _getLeftOverflow","     * @param {Array} set1 Collection of axes to check.","     * @param {Array} set2 Seconf collection of axes to check.","     * @param {Number} width Width of the axes","     * @return Number","     * @private","     */","    _getLeftOverflow: function(set1, set2, width)","    {","        var i = 0,","            len,","            overflow = 0,","            axis;","        if(set1)","        {","            len = set1.length;","            for(; i < len; ++i)","            {","                axis = set1[i];","                overflow = Math.max(overflow, Math.abs(axis.getMinLabelBounds().left) - (axis.getEdgeOffset(axis.get(\"styles\").majorTicks.count, width) * 0.5));","            }","        }","        if(set2)","        {","            i = 0;","            len = set2.length;","            for(; i < len; ++i)","            {","                axis = set2[i];","                overflow = Math.max(overflow, Math.abs(axis.getMinLabelBounds().left) - (axis.getEdgeOffset(axis.get(\"styles\").majorTicks.count, width) * 0.5));","            }","        }","        return overflow;","    },","    ","    /**","     * Returns the maximum distance in pixels that the extends outside the bottom bounds of all vertical axes.","     *","     * @method _getBottomOverflow","     * @param {Array} set1 Collection of axes to check.","     * @param {Array} set2 Seconf collection of axes to check.","     * @param {Number} height Height of the axes","     * @return Number","     * @private","     */","    _getBottomOverflow: function(set1, set2, height)","    {","        var i = 0,","            len,","            overflow = 0,","            axis;","        if(set1)","        {","            len = set1.length;","            for(; i < len; ++i)","            {","                axis = set1[i];","                overflow = Math.max(overflow, axis.getMinLabelBounds().bottom - (axis.getEdgeOffset(axis.get(\"styles\").majorTicks.count, height) * 0.5));","            }","        }","        if(set2)","        {","            i = 0;","            len = set2.length;","            for(; i < len; ++i)","            {","                axis = set2[i];","                overflow = Math.max(overflow, axis.getMinLabelBounds().bottom - (axis.getEdgeOffset(axis.get(\"styles\").majorTicks.count, height) * 0.5));","            }","        }","        return overflow;","    },","","    /**","     * Redraws and position all the components of the chart instance.","     *","     * @method _redraw","     * @private","     */","    _redraw: function()","    {","        if(this._drawing)","        {","            this._callLater = true;","            return;","        }","        this._drawing = true;","        this._callLater = false;","        var w = this.get(\"width\"),","            h = this.get(\"height\"),","            leftPaneWidth = 0,","            rightPaneWidth = 0,","            topPaneHeight = 0,","            bottomPaneHeight = 0,","            leftAxesCollection = this.get(\"leftAxesCollection\"),","            rightAxesCollection = this.get(\"rightAxesCollection\"),","            topAxesCollection = this.get(\"topAxesCollection\"),","            bottomAxesCollection = this.get(\"bottomAxesCollection\"),","            i = 0,","            l,","            axis,","            graphOverflow = \"visible\",","            graph = this.get(\"graph\"),","            topOverflow,","            bottomOverflow,","            leftOverflow,","            rightOverflow,","            graphWidth,","            graphHeight,","            graphX,","            graphY,","            allowContentOverflow = this.get(\"allowContentOverflow\"),","            diff,","            rightAxesXCoords,","            leftAxesXCoords,","            topAxesYCoords,","            bottomAxesYCoords,","            graphRect = {};","        if(leftAxesCollection)","        {","            leftAxesXCoords = [];","            l = leftAxesCollection.length;","            for(i = l - 1; i > -1; --i)","            {","                leftAxesXCoords.unshift(leftPaneWidth);","                leftPaneWidth += leftAxesCollection[i].get(\"width\");","            }","        }","        if(rightAxesCollection)","        {","            rightAxesXCoords = [];","            l = rightAxesCollection.length;","            i = 0;","            for(i = l - 1; i > -1; --i)","            {","                rightPaneWidth += rightAxesCollection[i].get(\"width\");","                rightAxesXCoords.unshift(w - rightPaneWidth);","            }","        }","        if(topAxesCollection)","        {","            topAxesYCoords = [];","            l = topAxesCollection.length;","            for(i = l - 1; i > -1; --i)","            {","                topAxesYCoords.unshift(topPaneHeight);","                topPaneHeight += topAxesCollection[i].get(\"height\");","            }","        }","        if(bottomAxesCollection)","        {","            bottomAxesYCoords = [];","            l = bottomAxesCollection.length;","            for(i = l - 1; i > -1; --i)","            {","                bottomPaneHeight += bottomAxesCollection[i].get(\"height\");","                bottomAxesYCoords.unshift(h - bottomPaneHeight);","            }","        }","        ","        graphWidth = w - (leftPaneWidth + rightPaneWidth);","        graphHeight = h - (bottomPaneHeight + topPaneHeight);","        graphRect.left = leftPaneWidth;","        graphRect.top = topPaneHeight;","        graphRect.bottom = h - bottomPaneHeight;","        graphRect.right = w - rightPaneWidth;","        if(!allowContentOverflow)","        {","            topOverflow = this._getTopOverflow(leftAxesCollection, rightAxesCollection);","            bottomOverflow = this._getBottomOverflow(leftAxesCollection, rightAxesCollection);","            leftOverflow = this._getLeftOverflow(bottomAxesCollection, topAxesCollection);","            rightOverflow = this._getRightOverflow(bottomAxesCollection, topAxesCollection);","            ","            diff = topOverflow - topPaneHeight;","            if(diff > 0)","            {","                graphRect.top = topOverflow;","                if(topAxesYCoords)","                {","                    i = 0;","                    l = topAxesYCoords.length;","                    for(; i < l; ++i)","                    {","                        topAxesYCoords[i] += diff;","                    }","                }","            }","","            diff = bottomOverflow - bottomPaneHeight;","            if(diff > 0)","            {","                graphRect.bottom = h - bottomOverflow;","                if(bottomAxesYCoords)","                {","                    i = 0;","                    l = bottomAxesYCoords.length;","                    for(; i < l; ++i)","                    {","                        bottomAxesYCoords[i] -= diff;","                    }","                }","            }","","            diff = leftOverflow - leftPaneWidth;","            if(diff > 0)","            {","                graphRect.left = leftOverflow;","                if(leftAxesXCoords)","                {","                    i = 0;","                    l = leftAxesXCoords.length;","                    for(; i < l; ++i)","                    {","                        leftAxesXCoords[i] += diff;","                    }","                }","            }","","            diff = rightOverflow - rightPaneWidth;","            if(diff > 0)","            {","                graphRect.right = w - rightOverflow;","                if(rightAxesXCoords)","                {","                    i = 0;","                    l = rightAxesXCoords.length;","                    for(; i < l; ++i)","                    {","                        rightAxesXCoords[i] -= diff;","                    }","                }","            }","        }","        graphWidth = graphRect.right - graphRect.left;","        graphHeight = graphRect.bottom - graphRect.top;","        graphX = graphRect.left;","        graphY = graphRect.top;","        if(topAxesCollection)","        {","            l = topAxesCollection.length;","            i = 0;","            for(; i < l; i++)","            {","                axis = topAxesCollection[i];","                if(axis.get(\"width\") !== graphWidth)","                {","                    axis.set(\"width\", graphWidth);","                }","                axis.get(\"boundingBox\").setStyle(\"left\", graphX + \"px\");","                axis.get(\"boundingBox\").setStyle(\"top\", topAxesYCoords[i] + \"px\");","            }","            if(axis._hasDataOverflow())","            {","                graphOverflow = \"hidden\";","            }","        }","        if(bottomAxesCollection)","        {","            l = bottomAxesCollection.length;","            i = 0;","            for(; i < l; i++)","            {","                axis = bottomAxesCollection[i];","                if(axis.get(\"width\") !== graphWidth)","                {","                    axis.set(\"width\", graphWidth);","                }","                axis.get(\"boundingBox\").setStyle(\"left\", graphX + \"px\");","                axis.get(\"boundingBox\").setStyle(\"top\", bottomAxesYCoords[i] + \"px\");","            }","            if(axis._hasDataOverflow())","            {","                graphOverflow = \"hidden\";","            }","        }","        if(leftAxesCollection)","        {","            l = leftAxesCollection.length;","            i = 0;","            for(; i < l; ++i)","            {","                axis = leftAxesCollection[i];","                axis.get(\"boundingBox\").setStyle(\"top\", graphY + \"px\");","                axis.get(\"boundingBox\").setStyle(\"left\", leftAxesXCoords[i] + \"px\");","                if(axis.get(\"height\") !== graphHeight)","                {","                    axis.set(\"height\", graphHeight);","                }","            }","            if(axis._hasDataOverflow())","            {","                graphOverflow = \"hidden\";","            }","        }","        if(rightAxesCollection)","        {","            l = rightAxesCollection.length;","            i = 0;","            for(; i < l; ++i)","            {","                axis = rightAxesCollection[i];","                axis.get(\"boundingBox\").setStyle(\"top\", graphY + \"px\");","                axis.get(\"boundingBox\").setStyle(\"left\", rightAxesXCoords[i] + \"px\");","                if(axis.get(\"height\") !== graphHeight)","                {","                    axis.set(\"height\", graphHeight);","                }","            }","            if(axis._hasDataOverflow())","            {","                graphOverflow = \"hidden\";","            }","        }","        this._drawing = false;","        if(this._callLater)","        {","            this._redraw();","            return;","        }","        if(graph)","        {","            graph.get(\"boundingBox\").setStyle(\"left\", graphX + \"px\");","            graph.get(\"boundingBox\").setStyle(\"top\", graphY + \"px\");","            graph.set(\"width\", graphWidth);","            graph.set(\"height\", graphHeight);","            graph.get(\"boundingBox\").setStyle(\"overflow\", graphOverflow);","        }","","        if(this._overlay)","        {","            this._overlay.setStyle(\"left\", graphX + \"px\");","            this._overlay.setStyle(\"top\", graphY + \"px\");","            this._overlay.setStyle(\"width\", graphWidth + \"px\");","            this._overlay.setStyle(\"height\", graphHeight + \"px\");","        }","    },","","    /**","     * Destructor implementation for the CartesianChart class. Calls destroy on all axes, series and the Graph instance.","     * Removes the tooltip and overlay HTML elements.","     *","     * @method destructor","     * @protected","     */","    destructor: function()","    {","        var graph = this.get(\"graph\"),","            i = 0,","            len,","            seriesCollection = this.get(\"seriesCollection\"),","            axesCollection = this._axesCollection,","            tooltip = this.get(\"tooltip\").node;","        if(this._description)","        {","            this._description.empty();","            this._description.remove(true);","        }","        if(this._liveRegion)","        {","            this._liveRegion.empty();","            this._liveRegion.remove(true);","        }","        len = seriesCollection ? seriesCollection.length : 0;","        for(; i < len; ++i)","        {","            if(seriesCollection[i] instanceof Y.CartesianSeries)","            {","                seriesCollection[i].destroy(true);","            }","        }","        len = axesCollection ? axesCollection.length : 0;","        for(i = 0; i < len; ++i)","        {","            if(axesCollection[i] instanceof Y.Axis)","            {","                axesCollection[i].destroy(true);","            }","        }","        if(graph)","        {","            graph.destroy(true);","        }","        if(tooltip)","        {","            tooltip.empty();","            tooltip.remove(true);","        }","        if(this._overlay)","        {","            this._overlay.empty();","            this._overlay.remove(true);","        }","    },","","    /**","     * Returns the appropriate message based on the key press.","     *","     * @method _getAriaMessage","     * @param {Number} key The keycode that was pressed.","     * @return String","     */","    _getAriaMessage: function(key)","    {","        var msg = \"\",","            series,","            items,","            categoryItem,","            valueItem,","            seriesIndex = this._seriesIndex,","            itemIndex = this._itemIndex,","            seriesCollection = this.get(\"seriesCollection\"),","            len = seriesCollection.length,","            dataLength;","        if(key % 2 === 0)","        {","            if(len > 1)","            {","                if(key === 38)","                {","                    seriesIndex = seriesIndex < 1 ? len - 1 : seriesIndex - 1;","                }","                else if(key === 40)","                {","                    seriesIndex = seriesIndex >= len - 1 ? 0 : seriesIndex + 1;","                }","                this._itemIndex = -1;","            }","            else","            {","                seriesIndex = 0;","            }","            this._seriesIndex = seriesIndex;","            series = this.getSeries(parseInt(seriesIndex, 10));","            msg = series.get(\"valueDisplayName\") + \" series.\";","        }","        else","        {","            if(seriesIndex > -1)","            {","                msg = \"\";","                series = this.getSeries(parseInt(seriesIndex, 10));","            }","            else","            {","                seriesIndex = 0;","                this._seriesIndex = seriesIndex;","                series = this.getSeries(parseInt(seriesIndex, 10));","                msg = series.get(\"valueDisplayName\") + \" series.\";","            }","            dataLength = series._dataLength ? series._dataLength : 0;","            if(key === 37)","            {","                itemIndex = itemIndex > 0 ? itemIndex - 1 : dataLength - 1;","            }","            else if(key === 39)","            {","                itemIndex = itemIndex >= dataLength - 1 ? 0 : itemIndex + 1;","            }","            this._itemIndex = itemIndex;","            items = this.getSeriesItems(series, itemIndex);","            categoryItem = items.category;","            valueItem = items.value;","            if(categoryItem && valueItem && categoryItem.value && valueItem.value)","            {","                msg += categoryItem.displayName + \": \" + categoryItem.axis.formatLabel.apply(this, [categoryItem.value, categoryItem.axis.get(\"labelFormat\")]) + \", \";","                msg += valueItem.displayName + \": \" + valueItem.axis.formatLabel.apply(this, [valueItem.value, valueItem.axis.get(\"labelFormat\")]) + \", \"; ","            }","           else","            {","                msg += \"No data available.\";","            }","            msg += (itemIndex + 1) + \" of \" + dataLength + \". \";","        }","        return msg;","    }","}, {","    ATTRS: {","        /**","         * Indicates whether axis labels are allowed to overflow beyond the bounds of the chart's content box.","         *","         * @attribute allowContentOverflow","         * @type Boolean","         */","        allowContentOverflow: {","            value: false","        },","","        /**","         * Style object for the axes.","         *","         * @attribute axesStyles","         * @type Object","         * @private","         */","        axesStyles: {","            getter: function()","            {","                var axes = this.get(\"axes\"),","                    i,","                    styles = this._axesStyles;","                if(axes)","                {","                    for(i in axes)","                    {","                        if(axes.hasOwnProperty(i) && axes[i] instanceof Y.Axis)","                        {","                            if(!styles)","                            {","                                styles = {};","                            }","                            styles[i] = axes[i].get(\"styles\");","                        }","                    }","                }","                return styles;","            },","            ","            setter: function(val)","            {","                var axes = this.get(\"axes\"),","                    i;","                for(i in val)","                {","                    if(val.hasOwnProperty(i) && axes.hasOwnProperty(i))","                    {","                        this._setBaseAttribute(axes[i], \"styles\", val[i]);","                    }","                }","            }","        },","","        /**","         * Style object for the series","         *","         * @attribute seriesStyles","         * @type Object","         * @private","         */","        seriesStyles: {","            getter: function()","            {","                var styles = this._seriesStyles,","                    graph = this.get(\"graph\"),","                    dict,","                    i;","                if(graph)","                {","                    dict = graph.get(\"seriesDictionary\");","                    if(dict)","                    {","                        styles = {};","                        for(i in dict)","                        {","                            if(dict.hasOwnProperty(i))","                            {","                                styles[i] = dict[i].get(\"styles\");","                            }","                        }","                    }","                }","                return styles;","            },","            ","            setter: function(val)","            {","                var i,","                    l,","                    s;","    ","                if(Y_Lang.isArray(val))","                {","                    s = this.get(\"seriesCollection\");","                    i = 0;","                    l = val.length;","","                    for(; i < l; ++i)","                    {","                        this._setBaseAttribute(s[i], \"styles\", val[i]);","                    }","                }","                else","                {","                    for(i in val)","                    {","                        if(val.hasOwnProperty(i))","                        {","                            s = this.getSeries(i);","                            this._setBaseAttribute(s, \"styles\", val[i]);","                        }","                    }","                }","            }","        },","","        /**","         * Styles for the graph.","         *","         * @attribute graphStyles","         * @type Object","         * @private","         */","        graphStyles: {","            getter: function()","            {","                var graph = this.get(\"graph\");","                if(graph)","                {","                    return(graph.get(\"styles\"));","                }","                return this._graphStyles;","            },","","            setter: function(val)","            {","                var graph = this.get(\"graph\");","                this._setBaseAttribute(graph, \"styles\", val);","            }","","        },","","        /**","         * Style properties for the chart. Contains a key indexed hash of the following:","         *  <dl>","         *      <dt>series</dt><dd>A key indexed hash containing references to the `styles` attribute for each series in the chart.","         *      Specific style attributes vary depending on the series:","         *      <ul>","         *          <li><a href=\"AreaSeries.html#attr_styles\">AreaSeries</a></li>","         *          <li><a href=\"BarSeries.html#attr_styles\">BarSeries</a></li>","         *          <li><a href=\"ColumnSeries.html#attr_styles\">ColumnSeries</a></li>","         *          <li><a href=\"ComboSeries.html#attr_styles\">ComboSeries</a></li>","         *          <li><a href=\"LineSeries.html#attr_styles\">LineSeries</a></li>","         *          <li><a href=\"MarkerSeries.html#attr_styles\">MarkerSeries</a></li>","         *          <li><a href=\"SplineSeries.html#attr_styles\">SplineSeries</a></li>","         *      </ul>","         *      </dd>","         *      <dt>axes</dt><dd>A key indexed hash containing references to the `styles` attribute for each axes in the chart. Specific","         *      style attributes can be found in the <a href=\"Axis.html#attr_styles\">Axis</a> class.</dd>","         *      <dt>graph</dt><dd>A reference to the `styles` attribute in the chart. Specific style attributes can be found in the","         *      <a href=\"Graph.html#attr_styles\">Graph</a> class.</dd>","         *  </dl>","         *","         * @attribute styles","         * @type Object","         */","        styles: {","            getter: function()","            {","                var styles = { ","                    axes: this.get(\"axesStyles\"),","                    series: this.get(\"seriesStyles\"),","                    graph: this.get(\"graphStyles\")","                };","                return styles;","            },","            setter: function(val)","            {","                if(val.hasOwnProperty(\"axes\"))","                {","                    if(this.get(\"axesStyles\"))","                    {","                        this.set(\"axesStyles\", val.axes);","                    }","                    else","                    {","                        this._axesStyles = val.axes;","                    }","                }","                if(val.hasOwnProperty(\"series\"))","                {","                    if(this.get(\"seriesStyles\"))","                    {","                        this.set(\"seriesStyles\", val.series);","                    }","                    else","                    {","                        this._seriesStyles = val.series;","                    }","                }","                if(val.hasOwnProperty(\"graph\"))","                {","                    this.set(\"graphStyles\", val.graph);","                }","            }","        },","","        /**","         * Axes to appear in the chart. This can be a key indexed hash of axis instances or object literals","         * used to construct the appropriate axes.","         *","         * @attribute axes","         * @type Object","         */","        axes: {","            valueFn: \"_getDefaultAxes\",","","            setter: function(val)","            {","                if(this.get(\"dataProvider\"))","                {","                    val = this._setAxes(val);","                }","                return val;","            }","        },","","        /**","         * Collection of series to appear on the chart. This can be an array of Series instances or object literals","         * used to construct the appropriate series.","         *","         * @attribute seriesCollection","         * @type Array","         */","        seriesCollection: {","            valueFn: \"_getDefaultSeriesCollection\",","            ","            setter: function(val)","            {","                if(this.get(\"dataProvider\"))","                {","                    val = this._parseSeriesCollection(val);","                }","                return val;","            }","        },","","        /**","         * Reference to the left-aligned axes for the chart.","         *","         * @attribute leftAxesCollection","         * @type Array","         * @private","         */","        leftAxesCollection: {},","","        /**","         * Reference to the bottom-aligned axes for the chart.","         *","         * @attribute bottomAxesCollection","         * @type Array","         * @private","         */","        bottomAxesCollection: {},","","        /**","         * Reference to the right-aligned axes for the chart.","         *","         * @attribute rightAxesCollection","         * @type Array","         * @private","         */","        rightAxesCollection: {},","","        /**","         * Reference to the top-aligned axes for the chart.","         *","         * @attribute topAxesCollection","         * @type Array","         * @private","         */","        topAxesCollection: {},","        ","        /**","         * Indicates whether or not the chart is stacked.","         *","         * @attribute stacked","         * @type Boolean","         */","        stacked: {","            value: false","        },","","        /**","         * Direction of chart's category axis when there is no series collection specified. Charts can","         * be horizontal or vertical. When the chart type is column, the chart is horizontal.","         * When the chart type is bar, the chart is vertical. ","         *","         * @attribute direction","         * @type String","         */","        direction: {","            getter: function()","            {","                var type = this.get(\"type\");","                if(type == \"bar\")","                {   ","                    return \"vertical\";","                }","                else if(type == \"column\")","                {","                    return \"horizontal\";","                }","                return this._direction;","            },","","            setter: function(val)","            {","                this._direction = val;","                return this._direction;","            }","        },","","        /**","         * Indicates whether or not an area is filled in a combo chart.","         * ","         * @attribute showAreaFill","         * @type Boolean","         */","        showAreaFill: {},","","        /**","         * Indicates whether to display markers in a combo chart.","         *","         * @attribute showMarkers","         * @type Boolean","         */","        showMarkers:{},","","        /**","         * Indicates whether to display lines in a combo chart.","         *","         * @attribute showLines","         * @type Boolean","         */","        showLines:{},","","        /**","         * Indicates the key value used to identify a category axis in the `axes` hash. If","         * not specified, the categoryKey attribute value will be used.","         * ","         * @attribute categoryAxisName","         * @type String","         */","        categoryAxisName: {","        },","","        /**","         * Indicates the key value used to identify a the series axis when an axis not generated.","         *","         * @attribute valueAxisName","         * @type String","         */","        valueAxisName: {","            value: \"values\"","        },","","        /**","         * Reference to the horizontalGridlines for the chart.","         *","         * @attribute horizontalGridlines","         * @type Gridlines","         */","        horizontalGridlines: {","            getter: function()","            {","                var graph = this.get(\"graph\");","                if(graph)","                {","                    return graph.get(\"horizontalGridlines\");","                }","                return this._horizontalGridlines;","            },","            setter: function(val)","            {","                var graph = this.get(\"graph\");","                if(val && !Y_Lang.isObject(val))","                {","                    val = {};","                }","                if(graph)","                {","                    graph.set(\"horizontalGridlines\", val);","                }","                else","                {","                    this._horizontalGridlines = val;","                }","            }","        },","","        /**","         * Reference to the verticalGridlines for the chart.","         *","         * @attribute verticalGridlines","         * @type Gridlines","         */","        verticalGridlines: {","            getter: function()","            {","                var graph = this.get(\"graph\");","                if(graph)","                {","                    return graph.get(\"verticalGridlines\");","                }","                return this._verticalGridlines;","            },","            setter: function(val)","            {","                var graph = this.get(\"graph\");","                if(val && !Y_Lang.isObject(val))","                {","                    val = {};","                }","                if(graph)","                {","                    graph.set(\"verticalGridlines\", val);","                }","                else","                {","                    this._verticalGridlines = val;","                }","            }","        },","        ","        /**","         * Type of chart when there is no series collection specified.","         *","         * @attribute type","         * @type String ","         */","        type: {","            getter: function()","            {","                if(this.get(\"stacked\"))","                {","                    return \"stacked\" + this._type;","                }","                return this._type;","            },","","            setter: function(val)","            {","                if(this._type == \"bar\")","                {","                    if(val != \"bar\")","                    {","                        this.set(\"direction\", \"horizontal\");","                    }","                }","                else","                {","                    if(val == \"bar\")","                    {","                        this.set(\"direction\", \"vertical\");","                    }","                }","                this._type = val;","                return this._type;","            }","        },","        ","        /**","         * Reference to the category axis used by the chart.","         *","         * @attribute categoryAxis","         * @type Axis","         */","        categoryAxis:{}","    }","});","/**"," * The PieChart class creates a pie chart"," *"," * @module charts"," * @submodule charts-base"," * @class PieChart"," * @extends ChartBase"," * @constructor"," */","Y.PieChart = Y.Base.create(\"pieChart\", Y.Widget, [Y.ChartBase], {","    /**","     * Calculates and returns a `seriesCollection`.","     *","     * @method _getSeriesCollection","     * @return Array","     * @private","     */","    _getSeriesCollection: function()","    {","        if(this._seriesCollection)","        {","            return this._seriesCollection;","        }","        var axes = this.get(\"axes\"),","            sc = [], ","            seriesKeys,","            i = 0,","            l,","            type = this.get(\"type\"),","            key,","            catAxis = \"categoryAxis\",","            catKey = \"categoryKey\",","            valAxis = \"valueAxis\",","            seriesKey = \"valueKey\";","        if(axes)","        {","            seriesKeys = axes.values.get(\"keyCollection\");","            key = axes.category.get(\"keyCollection\")[0];","            l = seriesKeys.length;","            for(; i < l; ++i)","            {","                sc[i] = {type:type};","                sc[i][catAxis] = \"category\";","                sc[i][valAxis] = \"values\";","                sc[i][catKey] = key;","                sc[i][seriesKey] = seriesKeys[i];","            }","        }","        this._seriesCollection = sc;","        return sc;","    },","","    /**","     * Creates `Axis` instances.","     *","     * @method _parseAxes","     * @param {Object} val Object containing `Axis` instances or objects in which to construct `Axis` instances.","     * @return Object","     * @private","     */","    _parseAxes: function(hash)","    {","        if(!this._axes)","        {","            this._axes = {};","        }","        var i, pos, axis, dh, config, axisClass,","            type = this.get(\"type\"),","            w = this.get(\"width\"),","            h = this.get(\"height\"),","            node = Y.Node.one(this._parentNode);","        if(!w)","        {","            this.set(\"width\", node.get(\"offsetWidth\"));","            w = this.get(\"width\");","        }","        if(!h)","        {","            this.set(\"height\", node.get(\"offsetHeight\"));","            h = this.get(\"height\");","        }","        for(i in hash)","        {","            if(hash.hasOwnProperty(i))","            {","                dh = hash[i];","                pos = type == \"pie\" ? \"none\" : dh.position;","                axisClass = this._getAxisClass(dh.type);","                config = {dataProvider:this.get(\"dataProvider\")};","                if(dh.hasOwnProperty(\"roundingUnit\"))","                {","                    config.roundingUnit = dh.roundingUnit;","                }","                config.keys = dh.keys;","                config.width = w;","                config.height = h;","                config.position = pos;","                config.styles = dh.styles;","                axis = new axisClass(config);","                axis.on(\"axisRendered\", Y.bind(this._itemRendered, this));","                this._axes[i] = axis;","            }","        }","    },","","    /**","     * Adds axes to the chart.","     *","     * @method _addAxes","     * @private","     */","    _addAxes: function()","    {","        var axes = this.get(\"axes\"),","            i, ","            axis, ","            p;","        if(!axes)","        {","            this.set(\"axes\", this._getDefaultAxes());","            axes = this.get(\"axes\");","        }","        if(!this._axesCollection)","        {   ","            this._axesCollection = [];","        }","        for(i in axes)","        {","            if(axes.hasOwnProperty(i))","            {","                axis = axes[i];","                p = axis.get(\"position\");","                if(!this.get(p + \"AxesCollection\"))","                {","                    this.set(p + \"AxesCollection\", [axis]);","                }","                else","                {","                    this.get(p + \"AxesCollection\").push(axis);","                }","                this._axesCollection.push(axis);","            }","        }","    },","","    /**","     * Renders the Graph.","     *","     * @method _addSeries","     * @private","     */","    _addSeries: function()","    {","        var graph = this.get(\"graph\"),","            seriesCollection = this.get(\"seriesCollection\");","        this._parseSeriesAxes(seriesCollection);","        graph.set(\"showBackground\", false);","        graph.set(\"width\", this.get(\"width\"));","        graph.set(\"height\", this.get(\"height\"));","        graph.set(\"seriesCollection\", seriesCollection);","        this._seriesCollection = graph.get(\"seriesCollection\");","        graph.render(this.get(\"contentBox\"));","    },","","    /**","     * Parse and sets the axes for the chart.","     *","     * @method _parseSeriesAxes","     * @param {Array} c A collection `PieSeries` instance.","     * @private","     */","    _parseSeriesAxes: function(c)","    {","        var i = 0, ","            len = c.length, ","            s,","            axes = this.get(\"axes\"),","            axis;","        for(; i < len; ++i)","        {","            s = c[i];","            if(s)","            {","                //If series is an actual series instance, ","                //replace axes attribute string ids with axes","                if(s instanceof Y.PieSeries)","                {","                    axis = s.get(\"categoryAxis\");","                    if(axis && !(axis instanceof Y.Axis))","                    {","                        s.set(\"categoryAxis\", axes[axis]);","                    }","                    axis = s.get(\"valueAxis\");","                    if(axis && !(axis instanceof Y.Axis))","                    {","                        s.set(\"valueAxis\", axes[axis]);","                    }","                    continue;","                }","                s.categoryAxis = axes.category;","                s.valueAxis = axes.values;","                if(!s.type)","                {","                    s.type = this.get(\"type\");","                }","            }","        }","    },","","    /**","     * Generates and returns a key-indexed object containing `Axis` instances or objects used to create `Axis` instances.","     *","     * @method _getDefaultAxes","     * @return Object","     * @private","     */","    _getDefaultAxes: function()","    {","        var catKey = this.get(\"categoryKey\"),","            seriesKeys = this.get(\"seriesKeys\").concat(), ","            seriesAxis = \"numeric\";","        return {","            values:{","                keys:seriesKeys,","                type:seriesAxis","            },","            category:{","                keys:[catKey],","                type:this.get(\"categoryType\")","            }","        };","    },","        ","    /**","     * Returns an object literal containing a categoryItem and a valueItem for a given series index.","     *","     * @method getSeriesItem","     * @param series Reference to a series.","     * @param index Index of the specified item within a series.","     * @return Object","     */","    getSeriesItems: function(series, index)","    {","        var categoryItem = {","                axis: series.get(\"categoryAxis\"),","                key: series.get(\"categoryKey\"),","                displayName: series.get(\"categoryDisplayName\")","            },","            valueItem = {","                axis: series.get(\"valueAxis\"),","                key: series.get(\"valueKey\"),","                displayName: series.get(\"valueDisplayName\")","            };","        categoryItem.value = categoryItem.axis.getKeyValueAt(categoryItem.key, index);","        valueItem.value = valueItem.axis.getKeyValueAt(valueItem.key, index);","        return {category:categoryItem, value:valueItem};","    },","","    /**","     * Handler for sizeChanged event.","     *","     * @method _sizeChanged","     * @param {Object} e Event object.","     * @private","     */","    _sizeChanged: function(e)","    {","        this._redraw();","    },","","    /**","     * Redraws the chart instance.","     *","     * @method _redraw","     * @private","     */","    _redraw: function()","    {","        var graph = this.get(\"graph\"),","            w = this.get(\"width\"),","            h = this.get(\"height\"),","            dimension;","        if(graph)","        {","            dimension = Math.min(w, h);","            graph.set(\"width\", dimension);","            graph.set(\"height\", dimension);","        }","    },","    ","    /**","     * Formats tooltip text for a pie chart.","     *","     * @method _tooltipLabelFunction","     * @param {Object} categoryItem An object containing the following:","     *  <dl>","     *      <dt>axis</dt><dd>The axis to which the category is bound.</dd>","     *      <dt>displayName</dt><dd>The display name set to the category (defaults to key if not provided)</dd>","     *      <dt>key</dt><dd>The key of the category.</dd>","     *      <dt>value</dt><dd>The value of the category</dd>","     *  </dl>","     * @param {Object} valueItem An object containing the following:","     *  <dl>","     *      <dt>axis</dt><dd>The axis to which the item's series is bound.</dd>","     *      <dt>displayName</dt><dd>The display name of the series. (defaults to key if not provided)</dd>","     *      <dt>key</dt><dd>The key for the series.</dd>","     *      <dt>value</dt><dd>The value for the series item.</dd> ","     *  </dl>","     * @param {Number} itemIndex The index of the item within the series.","     * @param {CartesianSeries} series The `PieSeries` instance of the item.","     * @param {Number} seriesIndex The index of the series in the `seriesCollection`.","     * @return {HTML}","     * @private","     */","    _tooltipLabelFunction: function(categoryItem, valueItem, itemIndex, series, seriesIndex)","    {","        var msg = DOCUMENT.createElement(\"div\"),","            total = series.getTotalValues(),","            pct = Math.round((valueItem.value / total) * 10000)/100;","        msg.appendChild(DOCUMENT.createTextNode(categoryItem.displayName +","        \": \" + categoryItem.axis.get(\"labelFunction\").apply(this, [categoryItem.value, categoryItem.axis.get(\"labelFormat\")]))); ","        msg.appendChild(DOCUMENT.createElement(\"br\"));","        msg.appendChild(DOCUMENT.createTextNode(valueItem.displayName + ","        \": \" + valueItem.axis.get(\"labelFunction\").apply(this, [valueItem.value, valueItem.axis.get(\"labelFormat\")])));","        msg.appendChild(DOCUMENT.createElement(\"br\"));","        msg.appendChild(DOCUMENT.createTextNode(pct + \"%\")); ","        return msg; ","    },","","    /**","     * Returns the appropriate message based on the key press.","     *","     * @method _getAriaMessage","     * @param {Number} key The keycode that was pressed.","     * @return String","     */","    _getAriaMessage: function(key)","    {","        var msg = \"\",","            categoryItem,","            items,","            series,","            valueItem,","            seriesIndex = 0,","            itemIndex = this._itemIndex,","            seriesCollection = this.get(\"seriesCollection\"),","            len,","            total,","            pct,","            markers;","        series = this.getSeries(parseInt(seriesIndex, 10));","        markers = series.get(\"markers\");","        len = markers && markers.length ? markers.length : 0;","        if(key === 37)","        {","            itemIndex = itemIndex > 0 ? itemIndex - 1 : len - 1;","        }","        else if(key === 39)","        {","            itemIndex = itemIndex >= len - 1 ? 0 : itemIndex + 1;","        }","        this._itemIndex = itemIndex;","        items = this.getSeriesItems(series, itemIndex);","        categoryItem = items.category;","        valueItem = items.value;","        total = series.getTotalValues();","        pct = Math.round((valueItem.value / total) * 10000)/100;","        if(categoryItem && valueItem)","        {","            msg += categoryItem.displayName + \": \" + categoryItem.axis.formatLabel.apply(this, [categoryItem.value, categoryItem.axis.get(\"labelFormat\")]) + \", \";","            msg += valueItem.displayName + \": \" + valueItem.axis.formatLabel.apply(this, [valueItem.value, valueItem.axis.get(\"labelFormat\")]) + \", \"; ","            msg += \"Percent of total \" + valueItem.displayName + \": \" + pct + \"%,\"; ","        }","        else","        {","            msg += \"No data available,\";","        }","        msg += (itemIndex + 1) + \" of \" + len + \". \";","        return msg;","    }","}, {","    ATTRS: {","        /**","         * Sets the aria description for the chart.","         *","         * @attribute ariaDescription","         * @type String","         */","        ariaDescription: {","            value: \"Use the left and right keys to navigate through items.\",","","            setter: function(val)","            {","                if(this._description)","                {","                    this._description.setContent(\"\");","                    this._description.appendChild(DOCUMENT.createTextNode(val));","                }","                return val;","            }","        },","        ","        /**","         * Axes to appear in the chart. ","         *","         * @attribute axes","         * @type Object","         */","        axes: {","            getter: function()","            {","                return this._axes;","            },","","            setter: function(val)","            {","                this._parseAxes(val);","            }","        },","","        /**","         * Collection of series to appear on the chart. This can be an array of Series instances or object literals","         * used to describe a Series instance.","         *","         * @attribute seriesCollection","         * @type Array","         */","        seriesCollection: {","            getter: function()","            {","                return this._getSeriesCollection();","            },","            ","            setter: function(val)","            {","                return this._setSeriesCollection(val);","            }","        },","        ","        /**","         * Type of chart when there is no series collection specified.","         *","         * @attribute type","         * @type String ","         */","        type: {","            value: \"pie\"","        }","    }","});","","","}, '@VERSION@' ,{requires:['dom', 'datatype-number', 'datatype-date', 'event-custom', 'event-mouseenter', 'event-touch', 'widget', 'widget-position', 'widget-stack', 'graphics']});"];
_yuitest_coverage["/build/charts-base/charts-base.js"].lines = {"1":0,"17":0,"40":0,"42":0,"45":0,"47":0,"56":0,"76":0,"78":0,"80":0,"81":0,"83":0,"84":0,"85":0,"86":0,"87":0,"89":0,"97":0,"98":0,"106":0,"120":0,"123":0,"125":0,"127":0,"131":0,"135":0,"140":0,"142":0,"146":0,"147":0,"148":0,"149":0,"150":0,"161":0,"162":0,"168":0,"172":0,"178":0,"182":0,"186":0,"195":0,"197":0,"200":0,"202":0,"211":0,"215":0,"219":0,"224":0,"226":0,"230":0,"231":0,"232":0,"233":0,"234":0,"245":0,"246":0,"255":0,"257":0,"260":0,"262":0,"271":0,"275":0,"276":0,"285":0,"287":0,"290":0,"292":0,"301":0,"305":0,"306":0,"315":0,"317":0,"320":0,"322":0,"331":0,"335":0,"336":0,"346":0,"348":0,"359":0,"360":0,"365":0,"377":0,"379":0,"399":0,"400":0,"415":0,"417":0,"419":0,"420":0,"422":0,"424":0,"428":0,"431":0,"443":0,"452":0,"453":0,"463":0,"465":0,"475":0,"491":0,"496":0,"497":0,"499":0,"502":0,"503":0,"504":0,"506":0,"507":0,"508":0,"510":0,"511":0,"512":0,"514":0,"515":0,"516":0,"531":0,"537":0,"549":0,"555":0,"557":0,"559":0,"561":0,"563":0,"576":0,"588":0,"595":0,"597":0,"599":0,"601":0,"605":0,"607":0,"619":0,"621":0,"626":0,"627":0,"629":0,"641":0,"650":0,"651":0,"652":0,"654":0,"656":0,"657":0,"658":0,"659":0,"673":0,"684":0,"686":0,"687":0,"689":0,"691":0,"693":0,"695":0,"696":0,"700":0,"701":0,"703":0,"704":0,"705":0,"706":0,"707":0,"719":0,"725":0,"727":0,"728":0,"730":0,"732":0,"733":0,"735":0,"737":0,"738":0,"742":0,"743":0,"745":0,"746":0,"760":0,"761":0,"763":0,"765":0,"767":0,"769":0,"771":0,"775":0,"777":0,"799":0,"807":0,"809":0,"811":0,"812":0,"816":0,"825":0,"827":0,"837":0,"853":0,"858":0,"859":0,"861":0,"864":0,"865":0,"866":0,"868":0,"869":0,"870":0,"872":0,"873":0,"874":0,"876":0,"877":0,"878":0,"893":0,"899":0,"911":0,"918":0,"920":0,"922":0,"924":0,"926":0,"939":0,"951":0,"958":0,"960":0,"962":0,"964":0,"968":0,"970":0,"982":0,"984":0,"989":0,"990":0,"992":0,"1004":0,"1013":0,"1014":0,"1015":0,"1017":0,"1019":0,"1020":0,"1021":0,"1022":0,"1036":0,"1047":0,"1049":0,"1051":0,"1053":0,"1055":0,"1057":0,"1058":0,"1060":0,"1062":0,"1066":0,"1067":0,"1069":0,"1070":0,"1071":0,"1072":0,"1073":0,"1074":0,"1075":0,"1087":0,"1093":0,"1095":0,"1097":0,"1099":0,"1100":0,"1102":0,"1104":0,"1108":0,"1109":0,"1111":0,"1112":0,"1126":0,"1127":0,"1129":0,"1131":0,"1133":0,"1135":0,"1137":0,"1141":0,"1143":0,"1155":0,"1158":0,"1169":0,"1174":0,"1176":0,"1178":0,"1179":0,"1183":0,"1192":0,"1194":0,"1204":0,"1220":0,"1225":0,"1226":0,"1228":0,"1231":0,"1232":0,"1233":0,"1235":0,"1236":0,"1237":0,"1239":0,"1240":0,"1241":0,"1243":0,"1244":0,"1245":0,"1257":0,"1263":0,"1265":0,"1267":0,"1269":0,"1271":0,"1285":0,"1291":0,"1304":0,"1316":0,"1323":0,"1325":0,"1327":0,"1329":0,"1333":0,"1335":0,"1347":0,"1349":0,"1354":0,"1355":0,"1357":0,"1369":0,"1378":0,"1379":0,"1380":0,"1382":0,"1384":0,"1385":0,"1386":0,"1387":0,"1401":0,"1412":0,"1414":0,"1416":0,"1418":0,"1420":0,"1422":0,"1423":0,"1427":0,"1429":0,"1430":0,"1431":0,"1432":0,"1433":0,"1434":0,"1435":0,"1447":0,"1454":0,"1456":0,"1457":0,"1459":0,"1461":0,"1462":0,"1466":0,"1467":0,"1469":0,"1470":0,"1484":0,"1485":0,"1487":0,"1489":0,"1491":0,"1495":0,"1497":0,"1509":0,"1510":0,"1521":0,"1526":0,"1528":0,"1530":0,"1533":0,"1542":0,"1544":0,"1554":0,"1570":0,"1575":0,"1576":0,"1577":0,"1580":0,"1581":0,"1582":0,"1584":0,"1585":0,"1586":0,"1588":0,"1589":0,"1590":0,"1592":0,"1593":0,"1594":0,"1606":0,"1613":0,"1615":0,"1617":0,"1619":0,"1621":0,"1635":0,"1641":0,"1654":0,"1666":0,"1673":0,"1675":0,"1677":0,"1679":0,"1683":0,"1685":0,"1697":0,"1699":0,"1704":0,"1705":0,"1707":0,"1719":0,"1728":0,"1729":0,"1730":0,"1732":0,"1734":0,"1735":0,"1736":0,"1737":0,"1751":0,"1761":0,"1763":0,"1764":0,"1768":0,"1770":0,"1771":0,"1773":0,"1775":0,"1777":0,"1779":0,"1780":0,"1784":0,"1787":0,"1788":0,"1789":0,"1790":0,"1791":0,"1803":0,"1809":0,"1811":0,"1812":0,"1816":0,"1818":0,"1819":0,"1821":0,"1823":0,"1825":0,"1827":0,"1828":0,"1832":0,"1835":0,"1836":0,"1850":0,"1851":0,"1853":0,"1857":0,"1859":0,"1861":0,"1863":0,"1865":0,"1867":0,"1871":0,"1874":0,"1896":0,"1904":0,"1906":0,"1908":0,"1909":0,"1912":0,"1925":0,"1953":0,"1955":0,"1968":0,"1969":0,"1981":0,"1982":0,"1984":0,"1986":0,"1991":0,"1993":0,"2007":0,"2009":0,"2019":0,"2028":0,"2034":0,"2036":0,"2037":0,"2038":0,"2039":0,"2041":0,"2043":0,"2045":0,"2046":0,"2050":0,"2061":0,"2067":0,"2068":0,"2069":0,"2070":0,"2071":0,"2073":0,"2077":0,"2079":0,"2080":0,"2081":0,"2082":0,"2083":0,"2096":0,"2151":0,"2163":0,"2168":0,"2169":0,"2170":0,"2172":0,"2202":0,"2203":0,"2216":0,"2218":0,"2221":0,"2222":0,"2224":0,"2225":0,"2227":0,"2228":0,"2231":0,"2236":0,"2254":0,"2256":0,"2257":0,"2259":0,"2260":0,"2261":0,"2263":0,"2287":0,"2288":0,"2289":0,"2290":0,"2291":0,"2296":0,"2297":0,"2298":0,"2299":0,"2300":0,"2301":0,"2302":0,"2303":0,"2304":0,"2306":0,"2310":0,"2311":0,"2312":0,"2314":0,"2315":0,"2316":0,"2321":0,"2323":0,"2324":0,"2325":0,"2326":0,"2327":0,"2328":0,"2329":0,"2330":0,"2332":0,"2334":0,"2336":0,"2337":0,"2338":0,"2339":0,"2340":0,"2341":0,"2342":0,"2343":0,"2345":0,"2347":0,"2348":0,"2349":0,"2351":0,"2352":0,"2354":0,"2356":0,"2357":0,"2359":0,"2361":0,"2363":0,"2367":0,"2368":0,"2370":0,"2374":0,"2375":0,"2388":0,"2397":0,"2398":0,"2399":0,"2401":0,"2402":0,"2404":0,"2409":0,"2410":0,"2412":0,"2415":0,"2416":0,"2427":0,"2431":0,"2433":0,"2434":0,"2436":0,"2438":0,"2439":0,"2441":0,"2443":0,"2455":0,"2461":0,"2463":0,"2468":0,"2469":0,"2471":0,"2472":0,"2473":0,"2474":0,"2475":0,"2477":0,"2479":0,"2481":0,"2484":0,"2485":0,"2487":0,"2489":0,"2492":0,"2493":0,"2494":0,"2495":0,"2497":0,"2499":0,"2500":0,"2502":0,"2504":0,"2505":0,"2520":0,"2528":0,"2530":0,"2534":0,"2535":0,"2536":0,"2538":0,"2540":0,"2542":0,"2545":0,"2546":0,"2547":0,"2548":0,"2550":0,"2552":0,"2555":0,"2566":0,"2568":0,"2570":0,"2575":0,"2577":0,"2588":0,"2590":0,"2593":0,"2595":0,"2596":0,"2597":0,"2598":0,"2601":0,"2613":0,"2616":0,"2618":0,"2622":0,"2635":0,"2641":0,"2643":0,"2647":0,"2649":0,"2662":0,"2666":0,"2668":0,"2672":0,"2674":0,"2688":0,"2689":0,"2691":0,"2695":0,"2697":0,"2709":0,"2713":0,"2715":0,"2719":0,"2732":0,"2738":0,"2742":0,"2744":0,"2748":0,"2753":0,"2755":0,"2768":0,"2776":0,"2778":0,"2779":0,"2780":0,"2781":0,"2782":0,"2783":0,"2784":0,"2785":0,"2786":0,"2787":0,"2791":0,"2792":0,"2794":0,"2796":0,"2800":0,"2801":0,"2802":0,"2803":0,"2804":0,"2805":0,"2806":0,"2808":0,"2812":0,"2814":0,"2815":0,"2816":0,"2820":0,"2821":0,"2823":0,"2825":0,"2844":0,"2846":0,"2847":0,"2848":0,"2849":0,"2850":0,"2861":0,"2872":0,"2885":0,"2890":0,"2891":0,"2892":0,"2893":0,"2894":0,"2895":0,"2896":0,"2897":0,"2898":0,"2899":0,"2900":0,"2901":0,"2902":0,"2903":0,"2915":0,"2917":0,"2918":0,"2920":0,"2921":0,"2922":0,"2935":0,"2940":0,"2942":0,"2944":0,"2945":0,"2946":0,"2947":0,"2950":0,"2952":0,"2976":0,"2977":0,"2979":0,"2981":0,"2983":0,"2985":0,"2987":0,"2989":0,"3008":0,"3010":0,"3012":0,"3017":0,"3018":0,"3036":0,"3038":0,"3040":0,"3045":0,"3046":0,"3060":0,"3065":0,"3066":0,"3080":0,"3085":0,"3086":0,"3121":0,"3123":0,"3124":0,"3126":0,"3129":0,"3144":0,"3146":0,"3147":0,"3149":0,"3152":0,"3173":0,"3174":0,"3176":0,"3178":0,"3236":0,"3251":0,"3253":0,"3255":0,"3271":0,"3293":0,"3298":0,"3299":0,"3333":0,"3354":0,"3375":0,"3440":0,"3447":0,"3448":0,"3449":0,"3450":0,"3451":0,"3452":0,"3453":0,"3454":0,"3463":0,"3464":0,"3465":0,"3466":0,"3467":0,"3468":0,"3469":0,"3481":0,"3484":0,"3486":0,"3488":0,"3490":0,"3494":0,"3496":0,"3583":0,"3597":0,"3601":0,"3603":0,"3604":0,"3606":0,"3619":0,"3624":0,"3626":0,"3627":0,"3629":0,"3630":0,"3641":0,"3643":0,"3644":0,"3646":0,"3648":0,"3651":0,"3663":0,"3664":0,"3666":0,"3667":0,"3681":0,"3683":0,"3685":0,"3687":0,"3699":0,"3700":0,"3702":0,"3704":0,"3715":0,"3721":0,"3723":0,"3724":0,"3725":0,"3727":0,"3729":0,"3730":0,"3732":0,"3734":0,"3735":0,"3739":0,"3740":0,"3751":0,"3754":0,"3756":0,"3758":0,"3760":0,"3762":0,"3776":0,"3777":0,"3779":0,"3781":0,"3783":0,"3785":0,"3799":0,"3813":0,"3817":0,"3818":0,"3819":0,"3831":0,"3832":0,"3846":0,"3848":0,"3850":0,"3862":0,"3874":0,"3889":0,"3893":0,"3895":0,"3896":0,"3898":0,"3902":0,"3904":0,"3905":0,"3909":0,"3911":0,"3913":0,"3917":0,"3918":0,"3957":0,"3971":0,"3985":0,"3987":0,"3989":0,"4004":0,"4008":0,"4010":0,"4012":0,"4014":0,"4016":0,"4020":0,"4021":0,"4035":0,"4037":0,"4039":0,"4054":0,"4055":0,"4057":0,"4059":0,"4063":0,"4064":0,"4080":0,"4096":0,"4109":0,"4111":0,"4113":0,"4126":0,"4129":0,"4131":0,"4133":0,"4136":0,"4152":0,"4154":0,"4157":0,"4159":0,"4186":0,"4188":0,"4190":0,"4212":0,"4224":0,"4226":0,"4228":0,"4240":0,"4245":0,"4247":0,"4248":0,"4250":0,"4253":0,"4277":0,"4290":0,"4295":0,"4297":0,"4298":0,"4302":0,"4304":0,"4306":0,"4308":0,"4320":0,"4329":0,"4331":0,"4333":0,"4334":0,"4336":0,"4337":0,"4339":0,"4341":0,"4343":0,"4345":0,"4347":0,"4348":0,"4352":0,"4353":0,"4354":0,"4357":0,"4359":0,"4361":0,"4363":0,"4367":0,"4369":0,"4371":0,"4373":0,"4375":0,"4379":0,"4382":0,"4383":0,"4386":0,"4400":0,"4415":0,"4417":0,"4419":0,"4420":0,"4422":0,"4424":0,"4425":0,"4429":0,"4431":0,"4433":0,"4435":0,"4438":0,"4440":0,"4444":0,"4447":0,"4449":0,"4451":0,"4452":0,"4453":0,"4454":0,"4455":0,"4457":0,"4459":0,"4461":0,"4462":0,"4463":0,"4464":0,"4468":0,"4470":0,"4474":0,"4477":0,"4479":0,"4481":0,"4482":0,"4483":0,"4484":0,"4488":0,"4490":0,"4494":0,"4499":0,"4500":0,"4501":0,"4502":0,"4507":0,"4509":0,"4511":0,"4513":0,"4517":0,"4518":0,"4524":0,"4526":0,"4528":0,"4532":0,"4535":0,"4537":0,"4539":0,"4540":0,"4541":0,"4545":0,"4546":0,"4551":0,"4555":0,"4557":0,"4559":0,"4561":0,"4564":0,"4565":0,"4567":0,"4569":0,"4571":0,"4573":0,"4575":0,"4576":0,"4577":0,"4579":0,"4581":0,"4582":0,"4586":0,"4587":0,"4589":0,"4590":0,"4591":0,"4595":0,"4596":0,"4598":0,"4600":0,"4601":0,"4606":0,"4607":0,"4609":0,"4611":0,"4613":0,"4614":0,"4615":0,"4617":0,"4619":0,"4623":0,"4624":0,"4629":0,"4631":0,"4632":0,"4633":0,"4634":0,"4635":0,"4636":0,"4638":0,"4640":0,"4642":0,"4644":0,"4646":0,"4648":0,"4652":0,"4654":0,"4656":0,"4658":0,"4659":0,"4663":0,"4665":0,"4669":0,"4671":0,"4675":0,"4676":0,"4690":0,"4695":0,"4697":0,"4699":0,"4701":0,"4703":0,"4707":0,"4708":0,"4710":0,"4712":0,"4714":0,"4729":0,"4730":0,"4732":0,"4734":0,"4735":0,"4750":0,"4751":0,"4753":0,"4755":0,"4770":0,"4771":0,"4773":0,"4775":0,"4790":0,"4791":0,"4792":0,"4806":0,"4809":0,"4811":0,"4813":0,"4814":0,"4815":0,"4816":0,"4818":0,"4820":0,"4824":0,"4836":0,"4838":0,"4841":0,"4844":0,"4854":0,"4866":0,"4868":0,"4870":0,"4873":0,"4875":0,"4876":0,"4877":0,"4879":0,"4881":0,"4882":0,"4884":0,"4886":0,"4888":0,"4892":0,"4896":0,"4898":0,"4902":0,"4904":0,"4906":0,"4910":0,"4913":0,"4914":0,"4915":0,"4917":0,"4919":0,"4921":0,"4923":0,"4927":0,"4939":0,"4941":0,"4944":0,"4946":0,"4961":0,"4962":0,"4979":0,"4980":0,"4993":0,"4994":0,"4996":0,"4998":0,"5002":0,"5003":0,"5016":0,"5017":0,"5019":0,"5021":0,"5025":0,"5026":0,"5046":0,"5047":0,"5049":0,"5051":0,"5066":0,"5077":0,"5078":0,"5080":0,"5082":0,"5114":0,"5119":0,"5120":0,"5121":0,"5123":0,"5127":0,"5129":0,"5143":0,"5148":0,"5150":0,"5151":0,"5153":0,"5157":0,"5158":0,"5160":0,"5162":0,"5164":0,"5166":0,"5170":0,"5172":0,"5174":0,"5179":0,"5182":0,"5184":0,"5197":0,"5203":0,"5205":0,"5206":0,"5208":0,"5212":0,"5213":0,"5215":0,"5217":0,"5219":0,"5221":0,"5225":0,"5227":0,"5229":0,"5234":0,"5237":0,"5239":0,"5240":0,"5253":0,"5255":0,"5257":0,"5259":0,"5262":0,"5266":0,"5278":0,"5280":0,"5283":0,"5285":0,"5297":0,"5334":0,"5335":0,"5349":0,"5354":0,"5356":0,"5358":0,"5360":0,"5361":0,"5362":0,"5364":0,"5365":0,"5378":0,"5384":0,"5386":0,"5388":0,"5390":0,"5391":0,"5392":0,"5394":0,"5395":0,"5396":0,"5408":0,"5410":0,"5412":0,"5413":0,"5415":0,"5417":0,"5430":0,"5444":0,"5445":0,"5447":0,"5449":0,"5451":0,"5453":0,"5467":0,"5480":0,"5482":0,"5484":0,"5486":0,"5500":0,"5503":0,"5505":0,"5509":0,"5511":0,"5523":0,"5525":0,"5537":0,"5540":0,"5544":0,"5554":0,"5558":0,"5570":0,"5578":0,"5580":0,"5583":0,"5591":0,"5593":0,"5594":0,"5595":0,"5596":0,"5597":0,"5600":0,"5602":0,"5603":0,"5604":0,"5607":0,"5608":0,"5609":0,"5610":0,"5611":0,"5612":0,"5614":0,"5616":0,"5617":0,"5619":0,"5621":0,"5622":0,"5626":0,"5627":0,"5631":0,"5644":0,"5649":0,"5650":0,"5652":0,"5653":0,"5654":0,"5657":0,"5659":0,"5662":0,"5665":0,"5674":0,"5676":0,"5694":0,"5696":0,"5700":0,"5712":0,"5728":0,"5730":0,"5731":0,"5732":0,"5736":0,"5738":0,"5740":0,"5742":0,"5744":0,"5745":0,"5747":0,"5748":0,"5750":0,"5751":0,"5753":0,"5757":0,"5761":0,"5763":0,"5767":0,"5770":0,"5771":0,"5772":0,"5774":0,"5776":0,"5777":0,"5778":0,"5781":0,"5782":0,"5793":0,"5810":0,"5812":0,"5813":0,"5814":0,"5818":0,"5820":0,"5822":0,"5824":0,"5826":0,"5827":0,"5829":0,"5830":0,"5832":0,"5833":0,"5835":0,"5839":0,"5843":0,"5845":0,"5849":0,"5852":0,"5853":0,"5854":0,"5856":0,"5858":0,"5859":0,"5860":0,"5863":0,"5864":0,"5879":0,"5891":0,"5893":0,"5894":0,"5896":0,"5898":0,"5900":0,"5901":0,"5902":0,"5904":0,"5907":0,"5908":0,"5910":0,"5911":0,"5927":0,"5930":0,"5932":0,"5933":0,"5935":0,"5949":0,"5952":0,"5954":0,"5955":0,"5957":0,"5972":0,"5984":0,"5986":0,"5987":0,"5989":0,"5992":0,"5993":0,"5995":0,"5996":0,"5997":0,"6000":0,"6001":0,"6003":0,"6004":0,"6009":0,"6018":0,"6020":0,"6037":0,"6038":0,"6040":0,"6042":0,"6043":0,"6055":0,"6057":0,"6069":0,"6071":0,"6073":0,"6097":0,"6099":0,"6100":0,"6104":0,"6105":0,"6107":0,"6108":0,"6113":0,"6115":0,"6116":0,"6117":0,"6118":0,"6120":0,"6121":0,"6123":0,"6125":0,"6126":0,"6128":0,"6130":0,"6132":0,"6136":0,"6141":0,"6143":0,"6147":0,"6149":0,"6155":0,"6158":0,"6159":0,"6160":0,"6162":0,"6173":0,"6175":0,"6177":0,"6192":0,"6197":0,"6198":0,"6200":0,"6201":0,"6202":0,"6203":0,"6204":0,"6205":0,"6206":0,"6208":0,"6225":0,"6226":0,"6227":0,"6236":0,"6237":0,"6239":0,"6241":0,"6242":0,"6243":0,"6244":0,"6247":0,"6248":0,"6250":0,"6252":0,"6254":0,"6256":0,"6259":0,"6271":0,"6284":0,"6285":0,"6293":0,"6295":0,"6299":0,"6304":0,"6305":0,"6309":0,"6310":0,"6313":0,"6323":0,"6324":0,"6326":0,"6327":0,"6329":0,"6341":0,"6343":0,"6357":0,"6359":0,"6361":0,"6375":0,"6376":0,"6380":0,"6381":0,"6383":0,"6384":0,"6385":0,"6386":0,"6388":0,"6390":0,"6392":0,"6393":0,"6394":0,"6395":0,"6399":0,"6401":0,"6402":0,"6404":0,"6405":0,"6406":0,"6417":0,"6419":0,"6421":0,"6437":0,"6441":0,"6442":0,"6443":0,"6445":0,"6446":0,"6447":0,"6448":0,"6449":0,"6450":0,"6451":0,"6453":0,"6455":0,"6456":0,"6460":0,"6461":0,"6463":0,"6464":0,"6475":0,"6477":0,"6479":0,"6501":0,"6502":0,"6503":0,"6504":0,"6505":0,"6509":0,"6510":0,"6511":0,"6513":0,"6514":0,"6515":0,"6516":0,"6517":0,"6518":0,"6519":0,"6521":0,"6523":0,"6524":0,"6525":0,"6526":0,"6527":0,"6528":0,"6529":0,"6531":0,"6532":0,"6533":0,"6534":0,"6535":0,"6536":0,"6537":0,"6542":0,"6544":0,"6545":0,"6549":0,"6550":0,"6554":0,"6555":0,"6576":0,"6580":0,"6582":0,"6583":0,"6584":0,"6585":0,"6586":0,"6587":0,"6591":0,"6592":0,"6593":0,"6594":0,"6595":0,"6596":0,"6598":0,"6599":0,"6600":0,"6616":0,"6618":0,"6620":0,"6621":0,"6623":0,"6626":0,"6642":0,"6644":0,"6646":0,"6647":0,"6651":0,"6652":0,"6654":0,"6666":0,"6687":0,"6689":0,"6692":0,"6693":0,"6694":0,"6695":0,"6697":0,"6698":0,"6699":0,"6700":0,"6704":0,"6705":0,"6706":0,"6707":0,"6709":0,"6711":0,"6712":0,"6713":0,"6714":0,"6715":0,"6719":0,"6722":0,"6723":0,"6724":0,"6725":0,"6727":0,"6728":0,"6729":0,"6731":0,"6732":0,"6733":0,"6735":0,"6736":0,"6737":0,"6738":0,"6740":0,"6742":0,"6743":0,"6744":0,"6746":0,"6747":0,"6748":0,"6749":0,"6751":0,"6752":0,"6753":0,"6755":0,"6757":0,"6758":0,"6759":0,"6761":0,"6763":0,"6764":0,"6765":0,"6768":0,"6769":0,"6770":0,"6771":0,"6774":0,"6775":0,"6776":0,"6788":0,"6792":0,"6793":0,"6802":0,"6804":0,"6808":0,"6812":0,"6815":0,"6833":0,"6835":0,"6837":0,"6856":0,"6858":0,"6859":0,"6860":0,"6862":0,"6863":0,"6865":0,"6877":0,"6879":0,"6881":0,"6883":0,"6885":0,"6887":0,"6888":0,"6890":0,"6891":0,"6892":0,"6894":0,"6895":0,"6897":0,"6899":0,"6901":0,"6903":0,"6906":0,"6907":0,"6908":0,"6910":0,"6936":0,"6938":0,"6940":0,"6953":0,"6969":0,"6970":0,"6971":0,"7005":0,"7007":0,"7009":0,"7010":0,"7011":0,"7012":0,"7014":0,"7016":0,"7018":0,"7019":0,"7021":0,"7024":0,"7028":0,"7030":0,"7031":0,"7046":0,"7049":0,"7050":0,"7051":0,"7052":0,"7053":0,"7064":0,"7066":0,"7067":0,"7069":0,"7071":0,"7075":0,"7077":0,"7089":0,"7095":0,"7097":0,"7099":0,"7100":0,"7102":0,"7105":0,"7106":0,"7114":0,"7115":0,"7116":0,"7118":0,"7120":0,"7122":0,"7124":0,"7126":0,"7128":0,"7129":0,"7130":0,"7142":0,"7146":0,"7148":0,"7149":0,"7151":0,"7152":0,"7154":0,"7168":0,"7169":0,"7171":0,"7172":0,"7174":0,"7189":0,"7191":0,"7199":0,"7200":0,"7201":0,"7202":0,"7203":0,"7204":0,"7205":0,"7206":0,"7207":0,"7222":0,"7224":0,"7226":0,"7239":0,"7240":0,"7253":0,"7255":0,"7256":0,"7257":0,"7259":0,"7261":0,"7263":0,"7266":0,"7279":0,"7280":0,"7283":0,"7284":0,"7286":0,"7287":0,"7289":0,"7290":0,"7292":0,"7293":0,"7295":0,"7306":0,"7307":0,"7316":0,"7318":0,"7327":0,"7329":0,"7331":0,"7370":0,"7372":0,"7374":0,"7376":0,"7378":0,"7380":0,"7381":0,"7385":0,"7386":0,"7388":0,"7389":0,"7390":0,"7391":0,"7393":0,"7394":0,"7395":0,"7397":0,"7400":0,"7401":0,"7402":0,"7404":0,"7405":0,"7406":0,"7407":0,"7408":0,"7409":0,"7411":0,"7412":0,"7414":0,"7415":0,"7416":0,"7417":0,"7418":0,"7419":0,"7420":0,"7422":0,"7423":0,"7425":0,"7426":0,"7428":0,"7429":0,"7431":0,"7433":0,"7434":0,"7435":0,"7436":0,"7440":0,"7441":0,"7442":0,"7443":0,"7444":0,"7446":0,"7448":0,"7450":0,"7452":0,"7456":0,"7458":0,"7461":0,"7462":0,"7463":0,"7465":0,"7476":0,"7498":0,"7521":0,"7522":0,"7523":0,"7527":0,"7538":0,"7581":0,"7582":0,"7583":0,"7584":0,"7595":0,"7597":0,"7599":0,"7600":0,"7602":0,"7604":0,"7605":0,"7607":0,"7608":0,"7609":0,"7610":0,"7611":0,"7613":0,"7616":0,"7617":0,"7618":0,"7620":0,"7623":0,"7624":0,"7625":0,"7627":0,"7630":0,"7642":0,"7643":0,"7644":0,"7656":0,"7657":0,"7658":0,"7679":0,"7680":0,"7682":0,"7695":0,"7696":0,"7698":0,"7711":0,"7717":0,"7719":0,"7721":0,"7722":0,"7723":0,"7725":0,"7727":0,"7728":0,"7729":0,"7740":0,"7742":0,"7746":0,"7758":0,"7760":0,"7771":0,"7805":0,"7806":0,"7807":0,"7808":0,"7809":0,"7811":0,"7813":0,"7815":0,"7816":0,"7817":0,"7819":0,"7821":0,"7823":0,"7824":0,"7825":0,"7827":0,"7831":0,"7833":0,"7835":0,"7839":0,"7841":0,"7842":0,"7843":0,"7844":0,"7846":0,"7847":0,"7848":0,"7849":0,"7850":0,"7863":0,"7866":0,"7868":0,"7869":0,"7871":0,"7884":0,"7887":0,"7889":0,"7890":0,"7892":0,"7903":0,"7906":0,"7908":0,"7910":0,"7912":0,"7913":0,"7915":0,"7916":0,"7917":0,"7918":0,"7920":0,"7922":0,"7923":0,"7925":0,"7929":0,"7930":0,"7955":0,"8010":0,"8018":0,"8019":0,"8021":0,"8023":0,"8024":0,"8036":0,"8047":0,"8048":0,"8059":0,"8061":0,"8063":0,"8065":0,"8067":0,"8069":0,"8071":0,"8073":0,"8075":0,"8077":0,"8079":0,"8080":0,"8081":0,"8082":0,"8083":0,"8084":0,"8086":0,"8088":0,"8089":0,"8091":0,"8094":0,"8096":0,"8097":0,"8099":0,"8101":0,"8102":0,"8104":0,"8106":0,"8107":0,"8193":0,"8198":0,"8199":0,"8212":0,"8217":0,"8218":0,"8234":0,"8239":0,"8241":0,"8245":0,"8247":0,"8263":0,"8268":0,"8270":0,"8274":0,"8276":0,"8335":0,"8375":0,"8389":0,"8430":0,"8445":0,"8486":0,"8487":0,"8489":0,"8491":0,"8503":0,"8504":0,"8506":0,"8508":0,"8531":0,"8533":0,"8537":0,"8543":0,"8544":0,"8560":0,"8570":0,"8584":0,"8586":0,"8588":0,"8589":0,"8603":0,"8604":0,"8663":0,"8671":0,"8685":0,"8687":0,"8689":0,"8703":0,"8704":0,"8759":0,"8769":0,"8823":0,"8833":0,"8834":0,"8862":0,"8872":0,"8873":0,"8902":0,"8916":0,"8919":0,"8921":0,"8922":0,"8926":0,"8927":0,"8929":0,"8942":0,"8944":0,"8962":0,"8963":0,"8964":0,"8965":0,"8966":0,"8967":0,"8968":0,"8969":0,"8971":0,"8972":0,"8973":0,"8974":0,"8976":0,"8978":0,"8980":0,"8982":0,"8983":0,"8985":0,"8986":0,"8988":0,"9052":0,"9066":0,"9069":0,"9071":0,"9072":0,"9076":0,"9077":0,"9079":0,"9092":0,"9094":0,"9112":0,"9113":0,"9114":0,"9115":0,"9116":0,"9117":0,"9118":0,"9119":0,"9121":0,"9122":0,"9123":0,"9124":0,"9126":0,"9128":0,"9130":0,"9132":0,"9133":0,"9135":0,"9136":0,"9138":0,"9210":0,"9220":0,"9234":0,"9236":0,"9238":0,"9252":0,"9253":0,"9302":0,"9312":0,"9355":0,"9365":0,"9366":0,"9397":0,"9407":0,"9409":0,"9411":0,"9413":0,"9415":0,"9417":0,"9430":0,"9434":0,"9436":0,"9438":0,"9440":0,"9442":0,"9444":0,"9445":0,"9447":0,"9448":0,"9449":0,"9451":0,"9452":0,"9454":0,"9471":0,"9472":0,"9473":0,"9474":0,"9475":0,"9561":0,"9565":0,"9594":0,"9598":0,"9621":0,"9625":0,"9664":0,"9674":0,"9675":0,"9687":0,"9689":0,"9691":0,"9693":0,"9695":0,"9697":0,"9738":0,"9748":0,"9750":0,"9752":0,"9754":0,"9756":0,"9758":0,"9788":0,"9798":0,"9800":0,"9802":0,"9804":0,"9806":0,"9808":0,"9847":0,"9857":0,"9858":0,"9885":0,"9895":0,"9896":0,"9908":0,"9935":0,"9944":0,"9946":0,"9948":0,"9979":0,"9981":0,"9983":0,"9985":0,"9987":0,"9988":0,"9990":0,"9991":0,"9992":0,"9994":0,"9996":0,"9997":0,"9998":0,"9999":0,"10001":0,"10002":0,"10003":0,"10008":0,"10009":0,"10011":0,"10012":0,"10013":0,"10015":0,"10016":0,"10018":0,"10020":0,"10022":0,"10023":0,"10025":0,"10026":0,"10028":0,"10030":0,"10031":0,"10033":0,"10034":0,"10036":0,"10038":0,"10039":0,"10040":0,"10044":0,"10045":0,"10050":0,"10052":0,"10053":0,"10054":0,"10055":0,"10057":0,"10059":0,"10060":0,"10061":0,"10064":0,"10066":0,"10067":0,"10069":0,"10070":0,"10071":0,"10072":0,"10076":0,"10077":0,"10078":0,"10079":0,"10080":0,"10082":0,"10084":0,"10086":0,"10088":0,"10091":0,"10093":0,"10096":0,"10098":0,"10109":0,"10123":0,"10125":0,"10133":0,"10134":0,"10135":0,"10136":0,"10137":0,"10138":0,"10139":0,"10140":0,"10141":0,"10142":0,"10144":0,"10148":0,"10150":0,"10152":0,"10156":0,"10158":0,"10171":0,"10194":0,"10195":0,"10196":0,"10275":0,"10285":0,"10287":0,"10290":0,"10321":0,"10323":0,"10325":0,"10327":0,"10329":0,"10330":0,"10332":0,"10333":0,"10334":0,"10336":0,"10338":0,"10339":0,"10340":0,"10341":0,"10343":0,"10344":0,"10345":0,"10350":0,"10351":0,"10353":0,"10354":0,"10355":0,"10357":0,"10358":0,"10359":0,"10361":0,"10363":0,"10364":0,"10366":0,"10367":0,"10369":0,"10371":0,"10372":0,"10374":0,"10375":0,"10376":0,"10378":0,"10380":0,"10381":0,"10385":0,"10386":0,"10391":0,"10393":0,"10394":0,"10395":0,"10397":0,"10399":0,"10400":0,"10401":0,"10402":0,"10405":0,"10407":0,"10408":0,"10410":0,"10411":0,"10412":0,"10413":0,"10417":0,"10418":0,"10419":0,"10420":0,"10421":0,"10423":0,"10425":0,"10427":0,"10429":0,"10432":0,"10434":0,"10437":0,"10439":0,"10450":0,"10465":0,"10467":0,"10475":0,"10476":0,"10477":0,"10478":0,"10479":0,"10480":0,"10481":0,"10483":0,"10487":0,"10489":0,"10491":0,"10495":0,"10497":0,"10511":0,"10534":0,"10535":0,"10536":0,"10627":0,"10654":0,"10657":0,"10659":0,"10660":0,"10662":0,"10663":0,"10665":0,"10667":0,"10668":0,"10669":0,"10670":0,"10671":0,"10672":0,"10673":0,"10674":0,"10675":0,"10676":0,"10677":0,"10678":0,"10679":0,"10706":0,"10708":0,"10710":0,"10711":0,"10713":0,"10715":0,"10716":0,"10718":0,"10719":0,"10720":0,"10731":0,"10732":0,"10744":0,"10745":0,"10746":0,"10758":0,"10759":0,"10760":0,"10781":0,"10783":0,"10796":0,"10798":0,"10810":0,"10813":0,"10815":0,"10816":0,"10818":0,"10819":0,"10821":0,"10822":0,"10823":0,"10824":0,"10825":0,"10827":0,"10831":0,"10844":0,"10878":0,"10880":0,"10882":0,"10883":0,"10885":0,"10889":0,"10890":0,"10891":0,"10892":0,"10894":0,"10895":0,"10896":0,"10898":0,"10900":0,"10901":0,"10903":0,"10907":0,"10909":0,"10911":0,"10913":0,"10915":0,"10917":0,"10919":0,"10921":0,"10923":0,"10925":0,"10927":0,"10929":0,"10930":0,"10931":0,"10932":0,"10933":0,"10952":0,"10953":0,"10955":0,"10958":0,"10972":0,"10991":0,"10993":0,"10994":0,"10995":0,"10996":0,"10998":0,"10999":0,"11003":0,"11004":0,"11007":0,"11008":0,"11009":0,"11010":0,"11011":0,"11012":0,"11013":0,"11014":0,"11028":0,"11030":0,"11035":0,"11036":0,"11037":0,"11038":0,"11039":0,"11055":0,"11058":0,"11059":0,"11060":0,"11061":0,"11072":0,"11075":0,"11077":0,"11078":0,"11080":0,"11083":0,"11095":0,"11110":0,"11111":0,"11112":0,"11162":0,"11170":0,"11171":0,"11173":0,"11175":0,"11176":0,"11219":0,"11235":0,"11251":0,"11266":0,"11279":0,"11280":0,"11285":0,"11298":0,"11299":0,"11304":0,"11356":0,"11374":0,"11375":0,"11377":0,"11389":0,"11391":0,"11403":0,"11418":0,"11420":0,"11422":0,"11423":0,"11427":0,"11428":0,"11429":0,"11431":0,"11436":0,"11438":0,"11439":0,"11440":0,"11441":0,"11446":0,"11448":0,"11450":0,"11466":0,"11467":0,"11482":0,"11483":0,"11496":0,"11503":0,"11547":0,"11554":0,"11555":0,"11556":0,"11557":0,"11558":0,"11559":0,"11568":0,"11577":0,"11579":0,"11580":0,"11581":0,"11582":0,"11583":0,"11584":0,"11585":0,"11586":0,"11587":0,"11588":0,"11590":0,"11592":0,"11593":0,"11595":0,"11598":0,"11600":0,"11602":0,"11604":0,"11626":0,"11628":0,"11630":0,"11632":0,"11644":0,"11646":0,"11648":0,"11650":0,"11663":0,"11665":0,"11667":0,"11697":0,"11699":0,"11701":0,"11705":0,"11706":0,"11707":0,"11708":0,"11710":0,"11711":0,"11713":0,"11714":0,"11716":0,"11718":0,"11719":0,"11721":0,"11722":0,"11723":0,"11736":0,"11741":0,"11743":0,"11745":0,"11746":0,"11748":0,"11750":0,"11751":0,"11752":0,"11753":0,"11754":0,"11755":0,"11756":0,"11769":0,"11775":0,"11776":0,"11778":0,"11780":0,"11781":0,"11782":0,"11783":0,"11784":0,"11785":0,"11786":0,"11787":0,"11788":0,"11789":0,"11790":0,"11792":0,"11863":0,"11864":0,"11866":0,"11870":0,"11872":0,"11884":0,"11889":0,"11909":0,"11911":0,"11912":0,"11913":0,"11914":0,"11915":0,"11927":0,"11934":0,"11936":0,"11938":0,"11940":0,"11941":0,"11943":0,"11944":0,"11947":0,"11949":0,"11951":0,"11953":0,"11955":0,"11957":0,"11959":0,"11970":0,"11972":0,"11973":0,"11975":0,"11979":0,"11980":0,"11981":0,"11982":0,"11983":0,"11984":0,"11985":0,"11987":0,"11988":0,"11990":0,"11991":0,"11994":0,"11995":0,"11997":0,"12010":0,"12013":0,"12015":0,"12017":0,"12019":0,"12020":0,"12022":0,"12024":0,"12038":0,"12050":0,"12061":0,"12063":0,"12064":0,"12066":0,"12068":0,"12069":0,"12071":0,"12073":0,"12074":0,"12089":0,"12090":0,"12104":0,"12105":0,"12128":0,"12133":0,"12134":0,"12161":0,"12177":0,"12178":0,"12180":0,"12182":0,"12184":0,"12185":0,"12186":0,"12188":0,"12190":0,"12191":0,"12208":0,"12209":0,"12211":0,"12213":0,"12215":0,"12216":0,"12217":0,"12219":0,"12221":0,"12222":0,"12237":0,"12239":0,"12240":0,"12241":0,"12243":0,"12259":0,"12261":0,"12262":0,"12263":0,"12265":0,"12281":0,"12283":0,"12284":0,"12285":0,"12287":0,"12336":0,"12338":0,"12350":0,"12351":0,"12353":0,"12355":0,"12360":0,"12361":0,"12363":0,"12365":0,"12380":0,"12385":0,"12386":0,"12387":0,"12402":0,"12403":0,"12405":0,"12407":0,"12422":0,"12424":0,"12425":0,"12427":0,"12505":0,"12582":0,"12592":0,"12594":0,"12596":0,"12609":0,"12610":0,"12612":0,"12625":0,"12629":0,"12630":0,"12632":0,"12644":0,"12646":0,"12648":0,"12650":0,"12654":0,"12657":0,"12672":0,"12674":0,"12676":0,"12678":0,"12689":0,"12692":0,"12694":0,"12696":0,"12728":0,"12730":0,"12737":0,"12739":0,"12740":0,"12742":0,"12744":0,"12746":0,"12748":0,"12769":0,"12781":0,"12813":0,"12814":0,"12815":0,"12816":0,"12825":0,"12829":0,"12830":0,"12831":0,"12832":0,"12833":0,"12835":0,"12837":0,"12849":0,"12852":0,"12853":0,"12854":0,"12855":0,"12856":0,"12857":0,"12858":0,"12859":0,"12860":0,"12861":0,"12862":0,"12863":0,"12864":0,"12865":0,"12866":0,"12867":0,"12879":0,"12882":0,"12883":0,"12884":0,"12885":0,"12886":0,"12887":0,"12896":0,"12905":0,"12906":0,"12907":0,"12908":0,"12909":0,"12918":0,"12919":0,"12922":0,"12924":0,"12925":0,"12926":0,"12927":0,"12930":0,"12933":0,"12934":0,"12935":0,"12937":0,"12939":0,"12940":0,"12941":0,"12943":0,"12944":0,"12950":0,"12951":0,"12952":0,"12953":0,"12954":0,"12955":0,"12958":0,"12960":0,"12962":0,"12966":0,"12967":0,"12970":0,"12972":0,"12973":0,"12974":0,"12976":0,"12977":0,"12982":0,"12983":0,"12986":0,"12988":0,"12992":0,"12994":0,"12996":0,"12998":0,"13000":0,"13001":0,"13003":0,"13006":0,"13021":0,"13034":0,"13036":0,"13038":0,"13040":0,"13042":0,"13043":0,"13138":0,"13162":0,"13166":0,"13167":0,"13168":0,"13170":0,"13171":0,"13173":0,"13174":0,"13176":0,"13178":0,"13180":0,"13181":0,"13183":0,"13185":0,"13187":0,"13203":0,"13204":0,"13206":0,"13210":0,"13225":0,"13227":0,"13229":0,"13230":0,"13231":0,"13232":0,"13233":0,"13246":0,"13251":0,"13253":0,"13254":0,"13265":0,"13267":0,"13268":0,"13269":0,"13270":0,"13271":0,"13282":0,"13286":0,"13288":0,"13290":0,"13291":0,"13292":0,"13305":0,"13319":0,"13321":0,"13322":0,"13323":0,"13325":0,"13327":0,"13329":0,"13333":0,"13335":0,"13337":0,"13340":0,"13342":0,"13354":0,"13365":0,"13367":0,"13371":0,"13374":0,"13375":0,"13378":0,"13379":0,"13380":0,"13381":0,"13382":0,"13383":0,"13384":0,"13385":0,"13386":0,"13387":0,"13388":0,"13389":0,"13390":0,"13391":0,"13392":0,"13393":0,"13394":0,"13395":0,"13418":0,"13426":0,"13428":0,"13429":0,"13431":0,"13433":0,"13436":0,"13438":0,"13439":0,"13441":0,"13442":0,"13443":0,"13444":0,"13445":0,"13446":0,"13447":0,"13449":0,"13451":0,"13454":0,"13483":0,"13486":0,"13487":0,"13488":0,"13490":0,"13492":0,"13493":0,"13494":0,"13495":0,"13496":0,"13498":0,"13500":0,"13501":0,"13513":0,"13515":0,"13519":0,"13521":0,"13523":0,"13540":0,"13541":0,"13543":0,"13545":0,"13547":0,"13549":0,"13551":0,"13553":0,"13565":0,"13570":0,"13572":0,"13573":0,"13575":0,"13577":0,"13581":0,"13594":0,"13598":0,"13600":0,"13602":0,"13603":0,"13605":0,"13607":0,"13610":0,"13613":0,"13623":0,"13630":0,"13636":0,"13637":0,"13638":0,"13639":0,"13640":0,"13641":0,"13643":0,"13646":0,"13647":0,"13649":0,"13650":0,"13651":0,"13652":0,"13653":0,"13654":0,"13655":0,"13656":0,"13657":0,"13659":0,"13660":0,"13673":0,"13703":0,"13704":0,"13706":0,"13707":0,"13711":0,"13712":0,"13714":0,"13715":0,"13717":0,"13718":0,"13720":0,"13722":0,"13724":0,"13727":0,"13729":0,"13730":0,"13732":0,"13734":0,"13735":0,"13738":0,"13739":0,"13741":0,"13742":0,"13743":0,"13744":0,"13746":0,"13748":0,"13750":0,"13752":0,"13754":0,"13755":0,"13756":0,"13757":0,"13761":0,"13790":0,"13792":0,"13806":0,"13838":0,"13840":0,"13842":0,"13844":0,"13857":0,"13858":0,"13860":0,"13861":0,"13863":0,"13876":0,"13878":0,"13880":0,"13882":0,"13895":0,"13915":0,"13916":0,"13918":0,"13919":0,"13920":0,"13921":0,"13925":0,"13926":0,"13927":0,"13928":0,"13930":0,"13931":0,"13933":0,"13934":0,"13935":0,"13937":0,"13938":0,"13940":0,"13941":0,"13942":0,"13946":0,"13951":0,"13954":0,"13956":0,"13957":0,"13959":0,"13960":0,"13961":0,"13962":0,"13964":0,"13966":0,"13969":0,"13971":0,"13973":0,"13974":0,"13976":0,"13977":0,"13979":0,"13980":0,"13983":0,"13984":0,"13985":0,"13986":0,"13988":0,"13989":0,"13991":0,"13993":0,"13995":0,"13997":0,"13999":0,"14001":0,"14003":0,"14006":0,"14008":0,"14010":0,"14011":0,"14012":0,"14014":0,"14026":0,"14031":0,"14033":0,"14034":0,"14036":0,"14039":0,"14041":0,"14042":0,"14044":0,"14059":0,"14062":0,"14063":0,"14076":0,"14080":0,"14082":0,"14084":0,"14088":0,"14090":0,"14092":0,"14093":0,"14095":0,"14096":0,"14102":0,"14118":0,"14120":0,"14122":0,"14124":0,"14126":0,"14142":0,"14144":0,"14148":0,"14162":0,"14191":0,"14193":0,"14195":0,"14196":0,"14198":0,"14202":0,"14203":0,"14204":0,"14205":0,"14207":0,"14209":0,"14211":0,"14212":0,"14214":0,"14216":0,"14217":0,"14219":0,"14221":0,"14226":0,"14228":0,"14231":0,"14233":0,"14234":0,"14236":0,"14238":0,"14239":0,"14241":0,"14243":0,"14246":0,"14250":0,"14251":0,"14252":0,"14256":0,"14258":0,"14259":0,"14261":0,"14263":0,"14267":0,"14278":0,"14285":0,"14287":0,"14289":0,"14291":0,"14293":0,"14294":0,"14296":0,"14298":0,"14299":0,"14301":0,"14303":0,"14304":0,"14306":0,"14307":0,"14308":0,"14310":0,"14314":0,"14316":0,"14317":0,"14319":0,"14321":0,"14335":0,"14337":0,"14349":0,"14361":0,"14363":0,"14364":0,"14366":0,"14368":0,"14370":0,"14372":0,"14374":0,"14378":0,"14380":0,"14382":0,"14384":0,"14386":0,"14389":0,"14391":0,"14393":0,"14395":0,"14397":0,"14401":0,"14403":0,"14405":0,"14407":0,"14409":0,"14423":0,"14424":0,"14426":0,"14428":0,"14441":0,"14460":0,"14462":0,"14463":0,"14467":0,"14468":0,"14470":0,"14472":0,"14474":0,"14476":0,"14477":0,"14478":0,"14479":0,"14481":0,"14482":0,"14483":0,"14485":0,"14486":0,"14488":0,"14490":0,"14492":0,"14496":0,"14497":0,"14499":0,"14500":0,"14502":0,"14504":0,"14506":0,"14508":0,"14510":0,"14512":0,"14518":0,"14519":0,"14521":0,"14523":0,"14524":0,"14526":0,"14527":0,"14529":0,"14532":0,"14534":0,"14536":0,"14538":0,"14541":0,"14543":0,"14546":0,"14548":0,"14550":0,"14552":0,"14553":0,"14555":0,"14557":0,"14559":0,"14563":0,"14566":0,"14568":0,"14570":0,"14572":0,"14573":0,"14575":0,"14577":0,"14579":0,"14594":0,"14597":0,"14599":0,"14601":0,"14603":0,"14605":0,"14607":0,"14612":0,"14614":0,"14618":0,"14622":0,"14653":0,"14659":0,"14661":0,"14666":0,"14674":0,"14679":0,"14685":0,"14686":0,"14687":0,"14688":0,"14689":0,"14701":0,"14703":0,"14706":0,"14708":0,"14710":0,"14726":0,"14730":0,"14732":0,"14733":0,"14735":0,"14736":0,"14739":0,"14741":0,"14742":0,"14743":0,"14745":0,"14746":0,"14749":0,"14764":0,"14768":0,"14770":0,"14771":0,"14773":0,"14774":0,"14777":0,"14779":0,"14780":0,"14781":0,"14783":0,"14784":0,"14787":0,"14802":0,"14806":0,"14808":0,"14809":0,"14811":0,"14812":0,"14815":0,"14817":0,"14818":0,"14819":0,"14821":0,"14822":0,"14825":0,"14840":0,"14844":0,"14846":0,"14847":0,"14849":0,"14850":0,"14853":0,"14855":0,"14856":0,"14857":0,"14859":0,"14860":0,"14863":0,"14874":0,"14876":0,"14877":0,"14879":0,"14880":0,"14881":0,"14911":0,"14913":0,"14914":0,"14915":0,"14917":0,"14918":0,"14921":0,"14923":0,"14924":0,"14925":0,"14926":0,"14928":0,"14929":0,"14932":0,"14934":0,"14935":0,"14936":0,"14938":0,"14939":0,"14942":0,"14944":0,"14945":0,"14946":0,"14948":0,"14949":0,"14953":0,"14954":0,"14955":0,"14956":0,"14957":0,"14958":0,"14959":0,"14961":0,"14962":0,"14963":0,"14964":0,"14966":0,"14967":0,"14969":0,"14970":0,"14972":0,"14973":0,"14974":0,"14976":0,"14981":0,"14982":0,"14984":0,"14985":0,"14987":0,"14988":0,"14989":0,"14991":0,"14996":0,"14997":0,"14999":0,"15000":0,"15002":0,"15003":0,"15004":0,"15006":0,"15011":0,"15012":0,"15014":0,"15015":0,"15017":0,"15018":0,"15019":0,"15021":0,"15026":0,"15027":0,"15028":0,"15029":0,"15030":0,"15032":0,"15033":0,"15034":0,"15036":0,"15037":0,"15039":0,"15041":0,"15042":0,"15044":0,"15046":0,"15049":0,"15051":0,"15052":0,"15053":0,"15055":0,"15056":0,"15058":0,"15060":0,"15061":0,"15063":0,"15065":0,"15068":0,"15070":0,"15071":0,"15072":0,"15074":0,"15075":0,"15076":0,"15077":0,"15079":0,"15082":0,"15084":0,"15087":0,"15089":0,"15090":0,"15091":0,"15093":0,"15094":0,"15095":0,"15096":0,"15098":0,"15101":0,"15103":0,"15106":0,"15107":0,"15109":0,"15110":0,"15112":0,"15114":0,"15115":0,"15116":0,"15117":0,"15118":0,"15121":0,"15123":0,"15124":0,"15125":0,"15126":0,"15139":0,"15145":0,"15147":0,"15148":0,"15150":0,"15152":0,"15153":0,"15155":0,"15156":0,"15158":0,"15160":0,"15163":0,"15164":0,"15166":0,"15168":0,"15171":0,"15173":0,"15175":0,"15177":0,"15178":0,"15180":0,"15182":0,"15183":0,"15196":0,"15206":0,"15208":0,"15210":0,"15212":0,"15214":0,"15216":0,"15218":0,"15222":0,"15224":0,"15225":0,"15226":0,"15230":0,"15232":0,"15233":0,"15237":0,"15238":0,"15239":0,"15240":0,"15242":0,"15243":0,"15245":0,"15247":0,"15249":0,"15251":0,"15252":0,"15253":0,"15254":0,"15255":0,"15257":0,"15258":0,"15262":0,"15264":0,"15266":0,"15290":0,"15293":0,"15295":0,"15297":0,"15299":0,"15301":0,"15303":0,"15307":0,"15312":0,"15314":0,"15316":0,"15318":0,"15334":0,"15338":0,"15340":0,"15341":0,"15343":0,"15344":0,"15346":0,"15348":0,"15353":0,"15358":0,"15362":0,"15364":0,"15365":0,"15366":0,"15368":0,"15370":0,"15375":0,"15377":0,"15379":0,"15380":0,"15397":0,"15398":0,"15400":0,"15402":0,"15407":0,"15408":0,"15440":0,"15445":0,"15449":0,"15451":0,"15453":0,"15457":0,"15460":0,"15462":0,"15464":0,"15468":0,"15471":0,"15473":0,"15490":0,"15492":0,"15494":0,"15510":0,"15512":0,"15514":0,"15575":0,"15576":0,"15578":0,"15580":0,"15582":0,"15584":0,"15589":0,"15590":0,"15647":0,"15648":0,"15650":0,"15652":0,"15656":0,"15657":0,"15659":0,"15661":0,"15663":0,"15667":0,"15681":0,"15682":0,"15684":0,"15686":0,"15690":0,"15691":0,"15693":0,"15695":0,"15697":0,"15701":0,"15715":0,"15717":0,"15719":0,"15724":0,"15726":0,"15728":0,"15733":0,"15735":0,"15738":0,"15739":0,"15761":0,"15771":0,"15773":0,"15775":0,"15786":0,"15788":0,"15789":0,"15790":0,"15791":0,"15793":0,"15794":0,"15795":0,"15796":0,"15797":0,"15800":0,"15801":0,"15814":0,"15816":0,"15818":0,"15823":0,"15825":0,"15826":0,"15828":0,"15830":0,"15831":0,"15833":0,"15835":0,"15837":0,"15838":0,"15839":0,"15840":0,"15841":0,"15843":0,"15845":0,"15846":0,"15847":0,"15848":0,"15849":0,"15850":0,"15851":0,"15852":0,"15865":0,"15869":0,"15871":0,"15872":0,"15874":0,"15876":0,"15878":0,"15880":0,"15882":0,"15883":0,"15884":0,"15886":0,"15890":0,"15892":0,"15905":0,"15907":0,"15908":0,"15909":0,"15910":0,"15911":0,"15912":0,"15913":0,"15925":0,"15930":0,"15932":0,"15933":0,"15937":0,"15939":0,"15940":0,"15942":0,"15944":0,"15945":0,"15947":0,"15949":0,"15951":0,"15952":0,"15953":0,"15955":0,"15970":0,"15973":0,"15995":0,"16005":0,"16006":0,"16007":0,"16019":0,"16030":0,"16034":0,"16036":0,"16037":0,"16038":0,"16068":0,"16071":0,"16073":0,"16074":0,"16076":0,"16077":0,"16078":0,"16090":0,"16102":0,"16103":0,"16104":0,"16105":0,"16107":0,"16109":0,"16111":0,"16113":0,"16114":0,"16115":0,"16116":0,"16117":0,"16118":0,"16119":0,"16121":0,"16122":0,"16123":0,"16127":0,"16129":0,"16130":0,"16145":0,"16147":0,"16148":0,"16150":0,"16163":0,"16168":0,"16182":0,"16187":0};
_yuitest_coverage["/build/charts-base/charts-base.js"].functions = {"ShapeGroup:40":0,"_draw:54":0,"_getRadiusCollection:118":0,"getter:133":0,"setter:159":0,"getter:166":0,"setter:170":0,"getter:176":0,"setter:180":0,"CircleGroup:195":0,"drawShape:209":0,"getter:217":0,"RectGroup:255":0,"drawShape:269":0,"DiamondGroup:285":0,"drawShape:299":0,"EllipseGroup:315":0,"drawShape:329":0,"Renderer:346":0,"getter:357":0,"setter:363":0,"_setStyles:397":0,"(anonymous 2):420":0,"_mergeStyles:413":0,"_getDefaultStyles:441":0,"_getDefaultMargins:473":0,"setTickOffsets:489":0,"drawTick:529":0,"getLineStart:547":0,"getLabelPoint:574":0,"updateMaxLabelSize:586":0,"getExplicitlySized:617":0,"positionTitle:639":0,"positionLabel:671":0,"_setRotationCoords:717":0,"_getTransformOrigin:758":0,"setCalculatedSize:797":0,"_getDefaultMargins:835":0,"setTickOffsets:851":0,"drawTick:891":0,"getLineStart:909":0,"getLabelPoint:937":0,"updateMaxLabelSize:949":0,"getExplicitlySized:980":0,"positionTitle:1002":0,"positionLabel:1034":0,"_setRotationCoords:1085":0,"_getTransformOrigin:1124":0,"offsetNodeForTick:1153":0,"setCalculatedSize:1167":0,"_getDefaultMargins:1202":0,"setTickOffsets:1218":0,"getLineStart:1255":0,"drawTick:1283":0,"getLabelPoint:1302":0,"updateMaxLabelSize:1314":0,"getExplicitlySized:1345":0,"positionTitle:1367":0,"positionLabel:1399":0,"_setRotationCoords:1445":0,"_getTransformOrigin:1482":0,"offsetNodeForTick:1507":0,"setCalculatedSize:1519":0,"_getDefaultMargins:1552":0,"setTickOffsets:1568":0,"getLineStart:1604":0,"drawTick:1633":0,"getLabelPoint:1652":0,"updateMaxLabelSize:1664":0,"getExplicitlySized:1695":0,"positionTitle:1717":0,"positionLabel:1749":0,"_setRotationCoords:1801":0,"_getTransformOrigin:1848":0,"setCalculatedSize:1894":0,"_dataChangeHandler:1951":0,"_positionChangeHandler:1966":0,"_updateGraphic:1979":0,"_updateHandler:2005":0,"renderUI:2017":0,"syncUI:2026":0,"_setCanvas:2059":0,"_getDefaultStyles:2094":0,"_handleSizeChange:2161":0,"drawLine:2200":0,"_getTextRotationProps:2214":0,"_drawAxis:2252":0,"_setTotalTitleSize:2386":0,"_updatePathElement:2425":0,"_setTitle:2453":0,"getLabel:2518":0,"_createLabelCache:2564":0,"_clearLabelCache:2586":0,"getLineEnd:2611":0,"getLength:2633":0,"getFirstPoint:2660":0,"getNextPoint:2686":0,"getLastPoint:2707":0,"getPosition:2730":0,"_rotate:2766":0,"_simulateRotateWithTransformOrigin:2842":0,"getMaxLabelBounds:2859":0,"getMinLabelBounds:2870":0,"_getLabelBounds:2883":0,"_removeChildren:2913":0,"destructor:2933":0,"_setText:2974":0,"getter:3006":0,"setter:3015":0,"getter:3034":0,"setter:3043":0,"getter:3058":0,"setter:3063":0,"getter:3078":0,"setter:3083":0,"getter:3119":0,"getter:3142":0,"setter:3171":0,"getter:3234":0,"getter:3249":0,"validator:3269":0,"getter:3291":0,"setter:3296":0,"value:3331":0,"valueFn:3352":0,"valueFn:3373":0,"initializer:3445":0,"bindUI:3461":0,"_dataProviderChangeHandler:3479":0,"addKey:3581":0,"_getKeyArray:3595":0,"_setDataByKey:3617":0,"_updateTotalData:3639":0,"removeKey:3661":0,"getKeyValueAt:3679":0,"getDataByKey:3697":0,"_updateMinAndMax:3713":0,"getTotalMajorUnits:3749":0,"getMajorUnitDistance:3774":0,"getEdgeOffset:3797":0,"getLabelByIndex:3811":0,"_keyChangeHandler:3829":0,"_hasDataOverflow:3844":0,"getMinimumValue:3860":0,"getMaximumValue:3872":0,"setter:3887":0,"getter:3955":0,"setter:3969":0,"getter:3983":0,"getter:4002":0,"setter:4018":0,"getter:4033":0,"getter:4052":0,"setter:4061":0,"getter:4078":0,"getter:4094":0,"getter:4107":0,"getter:4124":0,"NumericAxis:4152":0,"value:4184":0,"formatLabel:4222":0,"getTotalByKey:4238":0,"_getMinimumUnit:4275":0,"_getNiceNumber:4288":0,"_updateMinAndMax:4318":0,"_roundMinAndMax:4398":0,"getLabelByIndex:4688":0,"_roundToNearest:4727":0,"_roundUpToNearest:4748":0,"_roundDownToNearest:4768":0,"_roundToPrecision:4788":0,"_hasDataOverflow:4804":0,"StackedAxis:4836":0,"_updateMinAndMax:4852":0,"TimeAxis:4939":0,"getter:4959":0,"getter:4977":0,"getter:4991":0,"setter:5000":0,"getter:5014":0,"setter:5023":0,"value:5044":0,"formatLabel:5075":0,"getLabelByIndex:5112":0,"_getKeyArray:5141":0,"_setDataByKey:5195":0,"_getNumber:5251":0,"CategoryAxis:5278":0,"formatLabel:5295":0,"_updateMinAndMax:5332":0,"_getKeyArray:5347":0,"_setDataByKey:5376":0,"getDataByKey:5406":0,"getTotalMajorUnits:5428":0,"getMajorUnitDistance:5442":0,"getEdgeOffset:5465":0,"getKeyValueAt:5478":0,"getLabelByIndex:5498":0,"getMinimumValue:5521":0,"getMaximumValue:5535":0,"CurveUtil:5554":0,"getCurveControlPoints:5568":0,"getControlPoints:5642":0,"StackingUtil:5674":0,"_stackCoordinates:5692":0,"_stackXCoords:5710":0,"_stackYCoords:5791":0,"_cleanXNaN:5877":0,"_getPreviousValidCoordValue:5925":0,"_getNextValidCoordValue:5947":0,"_cleanYNaN:5970":0,"Lines:6018":0,"_getGraphic:6035":0,"_toggleVisible:6053":0,"drawLines:6067":0,"drawSpline:6171":0,"drawDashedLine:6223":0,"_getLineDefaults:6269":0,"getter:6297":0,"setter:6302":0,"Fills:6293":0,"_getPath:6321":0,"_toggleVisible:6339":0,"drawFill:6355":0,"drawAreaSpline:6415":0,"drawStackedAreaSpline:6473":0,"_getClosingPoints:6574":0,"_getHighestValidOrder:6614":0,"_getCoordsByOrderAndIndex:6640":0,"_getStackedClosingPoints:6664":0,"_getAreaDefaults:6786":0,"getter:6806":0,"Plots:6802":0,"drawPlots:6831":0,"_getGroupShape:6934":0,"_getPlotDefaults:6951":0,"getMarker:7003":0,"_createMarker:7044":0,"_createMarkerCache:7062":0,"_createGroupMarker:7087":0,"_toggleVisible:7140":0,"_clearMarkerCache:7166":0,"updateMarkerState:7187":0,"_getItemColor:7220":0,"_setStyles:7237":0,"_parseMarkerStyles:7251":0,"_getState:7277":0,"Histogram:7316":0,"drawSeries:7325":0,"_getPlotDefaults:7496":0,"render:7579":0,"(anonymous 3):7609":0,"(anonymous 4):7616":0,"(anonymous 5):7623":0,"addListeners:7593":0,"_xAxisChangeHandler:7640":0,"_yAxisChangeHandler:7654":0,"_xDataChangeHandler:7677":0,"_yDataChangeHandler:7693":0,"_updateAxisData:7709":0,"validate:7738":0,"_setCanvas:7756":0,"setAreaData:7769":0,"_getFirstValidIndex:7861":0,"_getLastValidIndex:7882":0,"draw:7901":0,"_getDefaultStyles:7953":0,"_getDefaultColor:8008":0,"_handleVisibleChange:8034":0,"getTotalValues:8045":0,"destructor:8057":0,"getter:8191":0,"setter:8196":0,"getter:8210":0,"setter:8215":0,"getter:8232":0,"setter:8237":0,"getter:8261":0,"setter:8266":0,"getter:8333":0,"setter:8373":0,"setter:8387":0,"getter:8428":0,"getter:8443":0,"getter:8485":0,"getter:8502":0,"getter:8529":0,"setter:8541":0,"drawSeries:8568":0,"_setStyles:8582":0,"_getDefaultStyles:8601":0,"drawSeries:8669":0,"_setStyles:8683":0,"_getDefaultStyles:8701":0,"drawSeries:8767":0,"setAreaData:8831":0,"setAreaData:8870":0,"_getMarkerDimensions:8914":0,"updateMarkerState:8940":0,"_getMarkerDimensions:9064":0,"updateMarkerState:9090":0,"drawSeries:9218":0,"_setStyles:9232":0,"_getDefaultStyles:9250":0,"drawSeries:9310":0,"drawSeries:9363":0,"drawSeries:9405":0,"_toggleVisible:9428":0,"_getDefaultStyles:9469":0,"getter:9559":0,"setter:9563":0,"getter:9592":0,"setter:9596":0,"getter:9619":0,"setter:9623":0,"setAreaData:9672":0,"drawSeries:9685":0,"drawSeries:9746":0,"drawSeries:9796":0,"setAreaData:9855":0,"setAreaData:9893":0,"drawSeries:9906":0,"drawSeries:9942":0,"updateMarkerState:10121":0,"_getPlotDefaults:10169":0,"drawSeries:10283":0,"updateMarkerState:10463":0,"_getPlotDefaults:10509":0,"_setMap:10652":0,"addListeners:10704":0,"validate:10729":0,"_categoryAxisChangeHandler:10742":0,"_valueAxisChangeHandler:10756":0,"_categoryDataChangeHandler:10779":0,"_valueDataChangeHandler:10794":0,"draw:10808":0,"drawPlots:10842":0,"_addHotspot:10970":0,"updateMarkerState:11026":0,"_createMarker:11053":0,"_clearMarkerCache:11070":0,"_getPlotDefaults:11093":0,"_getDefaultColor:11160":0,"validator:11217":0,"validator:11233":0,"validator:11249":0,"validator:11264":0,"setter:11277":0,"getter:11283":0,"setter:11296":0,"getter:11302":0,"remove:11372":0,"draw:11387":0,"_drawGridlines:11401":0,"_horizontalLine:11464":0,"_verticalLine:11480":0,"_getDefaultStyles:11494":0,"bindUI:11552":0,"syncUI:11566":0,"getSeriesByIndex:11624":0,"getSeriesByKey:11642":0,"addDispatcher:11661":0,"_parseSeriesCollection:11695":0,"_addSeries:11734":0,"_createSeries:11767":0,"_getSeries:11861":0,"_markerEventHandler:11882":0,"_updateStyles:11907":0,"_sizeChangeHandler:11925":0,"_drawSeries:11968":0,"_drawingCompleteHandler:12008":0,"_getDefaultStyles:12036":0,"destructor:12059":0,"setter:12087":0,"setter:12102":0,"getter:12126":0,"setter:12131":0,"getter:12159":0,"setter:12175":0,"setter:12206":0,"getter:12235":0,"getter:12257":0,"getter:12279":0,"ChartBase:12336":0,"valueFn:12348":0,"setter:12358":0,"getter:12378":0,"setter:12383":0,"setter:12400":0,"setter:12420":0,"setter:12503":0,"_groupMarkersChangeHandler:12590":0,"_itemRendered:12607":0,"(anonymous 6):12629":0,"_getGraph:12623":0,"getSeries:12642":0,"getAxisByKey:12670":0,"getCategoryAxis:12687":0,"_setDataValues:12726":0,"_setSeriesCollection:12767":0,"_getAxisClass:12779":0,"initializer:12811":0,"renderUI:12823":0,"_setAriaElements:12847":0,"_getAriaOffscreenNode:12877":0,"syncUI:12894":0,"(anonymous 7):12918":0,"(anonymous 8):12939":0,"(anonymous 9):12972":0,"bindUI:12903":0,"_markerEventDispatcher:13019":0,"_dataProviderChangeHandler:13160":0,"toggleTooltip:13201":0,"_showTooltip:13223":0,"_positionTooltip:13244":0,"hideTooltip:13263":0,"_addTooltip:13280":0,"_updateTooltip:13303":0,"markerEventHandler:13363":0,"planarEventHandler:13369":0,"_getTooltip:13352":0,"_planarLabelFunction:13416":0,"_tooltipLabelFunction:13481":0,"_tooltipChangeHandler:13511":0,"_setText:13538":0,"_getAllKeys:13563":0,"_buildSeriesKeys:13592":0,"renderUI:13628":0,"_planarEventDispatcher:13671":0,"_addToAxesRenderQueue:13836":0,"_addToAxesCollection:13855":0,"_getDefaultSeriesCollection:13874":0,"_parseSeriesCollection:13893":0,"_parseSeriesAxes:14024":0,"_getCategoryAxis:14057":0,"_getSeriesAxis:14074":0,"_getBaseAttribute:14116":0,"_setBaseAttribute:14140":0,"_setAxes:14160":0,"_addAxes:14276":0,"_addSeries:14333":0,"_addGridlines:14347":0,"_getDefaultAxes:14421":0,"_parseAxes:14439":0,"_getDefaultAxisPosition:14592":0,"getSeriesItems:14651":0,"_sizeChanged:14699":0,"_getTopOverflow:14724":0,"_getRightOverflow:14762":0,"_getLeftOverflow:14800":0,"_getBottomOverflow:14838":0,"_redraw:14872":0,"destructor:15137":0,"_getAriaMessage:15194":0,"getter:15288":0,"setter:15310":0,"getter:15332":0,"setter:15356":0,"getter:15395":0,"setter:15405":0,"getter:15438":0,"setter:15447":0,"setter:15488":0,"setter:15508":0,"getter:15573":0,"setter:15587":0,"getter:15645":0,"setter:15654":0,"getter:15679":0,"setter:15688":0,"getter:15713":0,"setter:15722":0,"_getSeriesCollection:15769":0,"_parseAxes:15812":0,"_addAxes:15863":0,"_addSeries:15903":0,"_parseSeriesAxes:15923":0,"_getDefaultAxes:15968":0,"getSeriesItems:15993":0,"_sizeChanged:16017":0,"_redraw:16028":0,"_tooltipLabelFunction:16066":0,"_getAriaMessage:16088":0,"setter:16143":0,"getter:16161":0,"setter:16166":0,"getter:16180":0,"setter:16185":0,"(anonymous 1):1":0};
_yuitest_coverage["/build/charts-base/charts-base.js"].coveredLines = 3967;
_yuitest_coverage["/build/charts-base/charts-base.js"].coveredFunctions = 489;
_yuitest_coverline("/build/charts-base/charts-base.js", 1);
YUI.add('charts-base', function(Y) {

/**
 * The Charts widget provides an api for displaying data
 * graphically.
 *
 * @module charts
 * @main charts
 */

/**
 * The charts-base submodule contains the core functionality for the charts module.
 *
 * @module charts
 * @submodule charts-base
 */
_yuitest_coverfunc("/build/charts-base/charts-base.js", "(anonymous 1)", 1);
_yuitest_coverline("/build/charts-base/charts-base.js", 17);
var CONFIG = Y.config,
    WINDOW = CONFIG.win,
    DOCUMENT = CONFIG.doc,
    Y_Lang = Y.Lang,
    IS_STRING = Y_Lang.isString,
    LeftAxisLayout,
    RightAxisLayout,
    BottomAxisLayout,
    TopAxisLayout,
    _getClassName = Y.ClassNameManager.getClassName,
    SERIES_MARKER = _getClassName("seriesmarker"),
    ShapeGroup,
    CircleGroup,
    RectGroup,
    EllipseGroup,
    DiamondGroup;

/**
 * Abstract class for creating groups of shapes with the same styles and dimensions.
 *
 * @class ShapeGroup
 * @constructor
 */
 _yuitest_coverline("/build/charts-base/charts-base.js", 40);
ShapeGroup = function(cfg)
 {
    _yuitest_coverfunc("/build/charts-base/charts-base.js", "ShapeGroup", 40);
_yuitest_coverline("/build/charts-base/charts-base.js", 42);
ShapeGroup.superclass.constructor.apply(this, arguments);
 };
    
 _yuitest_coverline("/build/charts-base/charts-base.js", 45);
ShapeGroup.NAME = "shapeGroup";

 _yuitest_coverline("/build/charts-base/charts-base.js", 47);
Y.extend(ShapeGroup, Y.Path, {    
    /**
     * Updates the shape.
     *
     * @method _draw
     * @private
     */
    _draw: function()
    {
        _yuitest_coverfunc("/build/charts-base/charts-base.js", "_draw", 54);
_yuitest_coverline("/build/charts-base/charts-base.js", 56);
var xvalues = this.get("xvalues"),
            yvalues = this.get("yvalues"),
            x,
            y,
            xRad,
            yRad,
            i = 0,
            len,
            attrs = [],
            dimensions = this.get("dimensions"),
            width = dimensions.width,
            height = dimensions.height,
            radius = dimensions.radius,
            yRadius = dimensions.yRadius,
            id = this.get("id"),
            className = this.node.className,
            widthIsArray = Y_Lang.isArray(width),
            heightIsArray = Y_Lang.isArray(height),
            radiusIsArray = Y_Lang.isArray(radius),
            yRadiusIsArray = Y_Lang.isArray(yRadius);
        _yuitest_coverline("/build/charts-base/charts-base.js", 76);
if(xvalues && yvalues && xvalues.length > 0)
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 78);
this.clear();

            _yuitest_coverline("/build/charts-base/charts-base.js", 80);
len = xvalues.length;
            _yuitest_coverline("/build/charts-base/charts-base.js", 81);
for(; i < len; ++i)
            {
                _yuitest_coverline("/build/charts-base/charts-base.js", 83);
x = xvalues[i];
                _yuitest_coverline("/build/charts-base/charts-base.js", 84);
y = yvalues[i];
                _yuitest_coverline("/build/charts-base/charts-base.js", 85);
xRad = radiusIsArray ? radius[i] : radius;
                _yuitest_coverline("/build/charts-base/charts-base.js", 86);
yRad = yRadiusIsArray ? yRadius[i] : yRadius;
                _yuitest_coverline("/build/charts-base/charts-base.js", 87);
if(!isNaN(x) && !isNaN(y) && !isNaN(xRad))
                {
                    _yuitest_coverline("/build/charts-base/charts-base.js", 89);
this.drawShape({
                        x: x,
                        y: y,
                        width: widthIsArray ? width[i] : width,
                        height: heightIsArray ? height[i] : height,
                        radius: xRad,
                        yRadius: yRad 
                    });
                    _yuitest_coverline("/build/charts-base/charts-base.js", 97);
this.closePath();
                    _yuitest_coverline("/build/charts-base/charts-base.js", 98);
attrs[i] = {
                        id: id + "_" + i,
                        className: className,
                        coords: (x - this._left) + ", " + (y - this._top)  + ", " + radius,
                        shape: "circle"
                    };
                }
            }
            _yuitest_coverline("/build/charts-base/charts-base.js", 106);
this._closePath();
        }
    },

    /**
     * Parses and array of lengths into radii
     *
     * @method _getRadiusCollection
     * @param {Array} val Array of lengths
     * @return Array
     * @private
     */
    _getRadiusCollection: function(val)
    {
        _yuitest_coverfunc("/build/charts-base/charts-base.js", "_getRadiusCollection", 118);
_yuitest_coverline("/build/charts-base/charts-base.js", 120);
var i = 0,
            len = val.length,
            radii = [];
        _yuitest_coverline("/build/charts-base/charts-base.js", 123);
for(; i < len; ++i)
        {   
            _yuitest_coverline("/build/charts-base/charts-base.js", 125);
radii[i] = val[i] * 0.5;
        }
        _yuitest_coverline("/build/charts-base/charts-base.js", 127);
return radii;
    }
 });
    
_yuitest_coverline("/build/charts-base/charts-base.js", 131);
ShapeGroup.ATTRS = Y.merge(Y.Path.ATTRS, {
    dimensions: {
        getter: function()
        {
            _yuitest_coverfunc("/build/charts-base/charts-base.js", "getter", 133);
_yuitest_coverline("/build/charts-base/charts-base.js", 135);
var dimensions = this._dimensions,
                radius,
                yRadius,
                width,
                height;
            _yuitest_coverline("/build/charts-base/charts-base.js", 140);
if(dimensions.hasOwnProperty("radius"))
            {
                _yuitest_coverline("/build/charts-base/charts-base.js", 142);
return dimensions;
            }
            else
            {
                _yuitest_coverline("/build/charts-base/charts-base.js", 146);
width = dimensions.width;
                _yuitest_coverline("/build/charts-base/charts-base.js", 147);
height = dimensions.height;
                _yuitest_coverline("/build/charts-base/charts-base.js", 148);
radius = Y_Lang.isArray(width) ? this._getRadiusCollection(width) : (width * 0.5);
                _yuitest_coverline("/build/charts-base/charts-base.js", 149);
yRadius = Y_Lang.isArray(height) ? this._getRadiusCollection(height) : (height * 0.5);
                _yuitest_coverline("/build/charts-base/charts-base.js", 150);
return {
                    width: width,
                    height: height,
                    radius: radius,
                    yRadius: yRadius
                };
            }
        },

        setter: function(val)
        {
            _yuitest_coverfunc("/build/charts-base/charts-base.js", "setter", 159);
_yuitest_coverline("/build/charts-base/charts-base.js", 161);
this._dimensions = val;
            _yuitest_coverline("/build/charts-base/charts-base.js", 162);
return val;
        }
    },
    xvalues: {
        getter: function()
        {
            _yuitest_coverfunc("/build/charts-base/charts-base.js", "getter", 166);
_yuitest_coverline("/build/charts-base/charts-base.js", 168);
return this._xvalues;
        },
        setter: function(val)
        {
            _yuitest_coverfunc("/build/charts-base/charts-base.js", "setter", 170);
_yuitest_coverline("/build/charts-base/charts-base.js", 172);
this._xvalues = val;
        }
    },
    yvalues: {
        getter: function()
        {
            _yuitest_coverfunc("/build/charts-base/charts-base.js", "getter", 176);
_yuitest_coverline("/build/charts-base/charts-base.js", 178);
return this._yvalues;
        },
        setter: function(val)
        {
            _yuitest_coverfunc("/build/charts-base/charts-base.js", "setter", 180);
_yuitest_coverline("/build/charts-base/charts-base.js", 182);
this._yvalues = val;
        }
    }
});
_yuitest_coverline("/build/charts-base/charts-base.js", 186);
Y.ShapeGroup = ShapeGroup;
/**
 * Abstract class for creating groups of circles with the same styles and dimensions.
 *
 * @module charts
 * @submodule charts-base
 * @class CircleGroup
 * @constructor
 */
 _yuitest_coverline("/build/charts-base/charts-base.js", 195);
CircleGroup = function(cfg)
 {
    _yuitest_coverfunc("/build/charts-base/charts-base.js", "CircleGroup", 195);
_yuitest_coverline("/build/charts-base/charts-base.js", 197);
CircleGroup.superclass.constructor.apply(this, arguments);
 };
    
 _yuitest_coverline("/build/charts-base/charts-base.js", 200);
CircleGroup.NAME = "circleGroup";

 _yuitest_coverline("/build/charts-base/charts-base.js", 202);
Y.extend(CircleGroup, Y.ShapeGroup, {    
    /**
     * Algorithm for drawing shape.
     *
     * @method drawShape
     * @param {Object} cfg Parameters used to draw the shape.
     */
    drawShape: function(cfg)
    {
        _yuitest_coverfunc("/build/charts-base/charts-base.js", "drawShape", 209);
_yuitest_coverline("/build/charts-base/charts-base.js", 211);
this.drawCircle(cfg.x, cfg.y, cfg.radius);
    }
 });

_yuitest_coverline("/build/charts-base/charts-base.js", 215);
CircleGroup.ATTRS = Y.merge(Y.ShapeGroup.ATTRS, {
    dimensions: {
        getter: function()
        {
            _yuitest_coverfunc("/build/charts-base/charts-base.js", "getter", 217);
_yuitest_coverline("/build/charts-base/charts-base.js", 219);
var dimensions = this._dimensions,
                radius,
                yRadius,
                width,
                height;
            _yuitest_coverline("/build/charts-base/charts-base.js", 224);
if(dimensions.hasOwnProperty("radius"))
            {
                _yuitest_coverline("/build/charts-base/charts-base.js", 226);
return dimensions;
            }
            else
            {
                _yuitest_coverline("/build/charts-base/charts-base.js", 230);
width = dimensions.width;
                _yuitest_coverline("/build/charts-base/charts-base.js", 231);
height = dimensions.height;
                _yuitest_coverline("/build/charts-base/charts-base.js", 232);
radius = Y_Lang.isArray(width) ? this._getRadiusCollection(width) : (width * 0.5);
                _yuitest_coverline("/build/charts-base/charts-base.js", 233);
yRadius = radius;
                _yuitest_coverline("/build/charts-base/charts-base.js", 234);
return {
                    width: width,
                    height: height,
                    radius: radius,
                    yRadius: yRadius
                };
            }
        }
    }
});
    
_yuitest_coverline("/build/charts-base/charts-base.js", 245);
CircleGroup.ATTRS = Y.ShapeGroup.ATTRS;
_yuitest_coverline("/build/charts-base/charts-base.js", 246);
Y.CircleGroup = CircleGroup;
/**
 * Abstract class for creating groups of rects with the same styles and dimensions.
 *
 * @module charts
 * @submodule charts-base
 * @class GroupRect
 * @constructor
 */
 _yuitest_coverline("/build/charts-base/charts-base.js", 255);
RectGroup = function(cfg)
 {
    _yuitest_coverfunc("/build/charts-base/charts-base.js", "RectGroup", 255);
_yuitest_coverline("/build/charts-base/charts-base.js", 257);
RectGroup.superclass.constructor.apply(this, arguments);
 };
    
 _yuitest_coverline("/build/charts-base/charts-base.js", 260);
RectGroup.NAME = "rectGroup";

 _yuitest_coverline("/build/charts-base/charts-base.js", 262);
Y.extend(RectGroup, Y.ShapeGroup, {    
    /**
     * Updates the rect.
     *
     * @method _draw
     * @private
     */
    drawShape: function(cfg)
    {
        _yuitest_coverfunc("/build/charts-base/charts-base.js", "drawShape", 269);
_yuitest_coverline("/build/charts-base/charts-base.js", 271);
this.drawRect(cfg.x, cfg.y, cfg.width, cfg.height);
    }
 });
    
_yuitest_coverline("/build/charts-base/charts-base.js", 275);
RectGroup.ATTRS = Y.ShapeGroup.ATTRS;
_yuitest_coverline("/build/charts-base/charts-base.js", 276);
Y.RectGroup = RectGroup;
/**
 * Abstract class for creating groups of diamonds with the same styles and dimensions.
 *
 * @module charts
 * @submodule charts-base
 * @class GroupDiamond
 * @constructor
 */
 _yuitest_coverline("/build/charts-base/charts-base.js", 285);
DiamondGroup = function(cfg)
 {
    _yuitest_coverfunc("/build/charts-base/charts-base.js", "DiamondGroup", 285);
_yuitest_coverline("/build/charts-base/charts-base.js", 287);
DiamondGroup.superclass.constructor.apply(this, arguments);
 };
    
 _yuitest_coverline("/build/charts-base/charts-base.js", 290);
DiamondGroup.NAME = "diamondGroup";

 _yuitest_coverline("/build/charts-base/charts-base.js", 292);
Y.extend(DiamondGroup, Y.ShapeGroup, {    
    /**
     * Updates the diamond.
     *
     * @method _draw
     * @private
     */
    drawShape: function(cfg)
    {
        _yuitest_coverfunc("/build/charts-base/charts-base.js", "drawShape", 299);
_yuitest_coverline("/build/charts-base/charts-base.js", 301);
this.drawDiamond(cfg.x, cfg.y, cfg.width, cfg.height);
    }
 });
    
_yuitest_coverline("/build/charts-base/charts-base.js", 305);
DiamondGroup.ATTRS = Y.ShapeGroup.ATTRS;
_yuitest_coverline("/build/charts-base/charts-base.js", 306);
Y.DiamondGroup = DiamondGroup;
/**
 * Abstract class for creating groups of diamonds with the same styles and dimensions.
 *
 * @module charts
 * @submodule charts-base
 * @class EllipseGroup
 * @constructor
 */
 _yuitest_coverline("/build/charts-base/charts-base.js", 315);
EllipseGroup = function(cfg)
 {
    _yuitest_coverfunc("/build/charts-base/charts-base.js", "EllipseGroup", 315);
_yuitest_coverline("/build/charts-base/charts-base.js", 317);
EllipseGroup.superclass.constructor.apply(this, arguments);
 };
    
 _yuitest_coverline("/build/charts-base/charts-base.js", 320);
EllipseGroup.NAME = "diamondGroup";

 _yuitest_coverline("/build/charts-base/charts-base.js", 322);
Y.extend(EllipseGroup, Y.ShapeGroup, {    
    /**
     * Updates the diamond.
     *
     * @method _draw
     * @private
     */
    drawShape: function(cfg)
    {
        _yuitest_coverfunc("/build/charts-base/charts-base.js", "drawShape", 329);
_yuitest_coverline("/build/charts-base/charts-base.js", 331);
this.drawEllipse(cfg.x, cfg.y, cfg.width, cfg.height);
    }
 });
    
_yuitest_coverline("/build/charts-base/charts-base.js", 335);
EllipseGroup.ATTRS = Y.ShapeGroup.ATTRS;
_yuitest_coverline("/build/charts-base/charts-base.js", 336);
Y.EllipseGroup = EllipseGroup;
/**
 * The Renderer class is a base class for chart components that use the `styles`
 * attribute.
 *
 * @module charts
 * @submodule charts-base
 * @class Renderer
 * @constructor
 */
_yuitest_coverline("/build/charts-base/charts-base.js", 346);
function Renderer(){}

_yuitest_coverline("/build/charts-base/charts-base.js", 348);
Renderer.ATTRS = {
        /**
         * Style properties for class
         * 
         * @attribute styles
         * @type Object
         */
        styles:
        {
            getter: function()
            {
                _yuitest_coverfunc("/build/charts-base/charts-base.js", "getter", 357);
_yuitest_coverline("/build/charts-base/charts-base.js", 359);
this._styles = this._styles || this._getDefaultStyles();
                _yuitest_coverline("/build/charts-base/charts-base.js", 360);
return this._styles;
            },

            setter: function(val)
            {
                _yuitest_coverfunc("/build/charts-base/charts-base.js", "setter", 363);
_yuitest_coverline("/build/charts-base/charts-base.js", 365);
this._styles = this._setStyles(val);
            }
        },
        
        /**
         * The graphic in which drawings will be rendered.
         *
         * @attribute graphic
         * @type Graphic
         */
        graphic: {}
};
_yuitest_coverline("/build/charts-base/charts-base.js", 377);
Renderer.NAME = "renderer";

_yuitest_coverline("/build/charts-base/charts-base.js", 379);
Renderer.prototype = {
    /**
     * Storage for `styles` attribute.
     *
     * @property _styles
     * @type Object
     * @private
     */
	_styles: null,
	
    /**
     * Method used by `styles` setter.
     *
     * @method _setStyles
     * @param {Object} newStyles Hash of properties to update.
     * @return Object
     * @protected
     */
	_setStyles: function(newstyles)
	{
		_yuitest_coverfunc("/build/charts-base/charts-base.js", "_setStyles", 397);
_yuitest_coverline("/build/charts-base/charts-base.js", 399);
var styles = this.get("styles");
        _yuitest_coverline("/build/charts-base/charts-base.js", 400);
return this._mergeStyles(newstyles, styles);
	},
    
    /**
     * Merges to object literals so that only specified properties are 
     * overwritten.
     *
     * @method _mergeStyles
     * @param {Object} a Hash of new styles
     * @param {Object} b Hash of original styles
     * @return Object
     * @protected
     */
    _mergeStyles: function(a, b)
    {
        _yuitest_coverfunc("/build/charts-base/charts-base.js", "_mergeStyles", 413);
_yuitest_coverline("/build/charts-base/charts-base.js", 415);
if(!b)
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 417);
b = {};
        }
        _yuitest_coverline("/build/charts-base/charts-base.js", 419);
var newstyles = Y.merge(b, {});
        _yuitest_coverline("/build/charts-base/charts-base.js", 420);
Y.Object.each(a, function(value, key, a)
        {
            _yuitest_coverfunc("/build/charts-base/charts-base.js", "(anonymous 2)", 420);
_yuitest_coverline("/build/charts-base/charts-base.js", 422);
if(b.hasOwnProperty(key) && Y_Lang.isObject(value) && !Y_Lang.isFunction(value) && !Y_Lang.isArray(value))
            {
                _yuitest_coverline("/build/charts-base/charts-base.js", 424);
newstyles[key] = this._mergeStyles(value, b[key]);
            }
            else
            {
                _yuitest_coverline("/build/charts-base/charts-base.js", 428);
newstyles[key] = value;
            }
        }, this);
        _yuitest_coverline("/build/charts-base/charts-base.js", 431);
return newstyles;
    },

    /**
     * Gets the default value for the `styles` attribute. 
     *
     * @method _getDefaultStyles
     * @return Object
     * @protected
     */
    _getDefaultStyles: function()
    {
        _yuitest_coverfunc("/build/charts-base/charts-base.js", "_getDefaultStyles", 441);
_yuitest_coverline("/build/charts-base/charts-base.js", 443);
return {padding:{
            top:0,
            right: 0,
            bottom: 0,
            left: 0
        }};
    }
};

_yuitest_coverline("/build/charts-base/charts-base.js", 452);
Y.augment(Renderer, Y.Attribute);
_yuitest_coverline("/build/charts-base/charts-base.js", 453);
Y.Renderer = Renderer;

/**
 * Algorithmic strategy for rendering a left axis.
 *
 * @module charts
 * @submodule charts-base
 * @class LeftAxisLayout
 * @constructor
 */
_yuitest_coverline("/build/charts-base/charts-base.js", 463);
LeftAxisLayout = function() {};

_yuitest_coverline("/build/charts-base/charts-base.js", 465);
LeftAxisLayout.prototype = {
    /**
     *  Default margins for text fields.
     *
     *  @private
     *  @method _getDefaultMargins
     *  @return Object
     */
    _getDefaultMargins: function() 
    {
        _yuitest_coverfunc("/build/charts-base/charts-base.js", "_getDefaultMargins", 473);
_yuitest_coverline("/build/charts-base/charts-base.js", 475);
return {
            top: 0,
            left: 0,
            right: 4,
            bottom: 0
        };
    },

    /**
     * Sets the length of the tick on either side of the axis line.
     *
     * @method setTickOffset
     * @protected
     */
    setTickOffsets: function()
    {
        _yuitest_coverfunc("/build/charts-base/charts-base.js", "setTickOffsets", 489);
_yuitest_coverline("/build/charts-base/charts-base.js", 491);
var host = this,
            majorTicks = host.get("styles").majorTicks,
            tickLength = majorTicks.length,
            halfTick = tickLength * 0.5,
            display = majorTicks.display;
        _yuitest_coverline("/build/charts-base/charts-base.js", 496);
host.set("topTickOffset",  0);
        _yuitest_coverline("/build/charts-base/charts-base.js", 497);
host.set("bottomTickOffset",  0);
        
        _yuitest_coverline("/build/charts-base/charts-base.js", 499);
switch(display)
        {
            case "inside" :
                _yuitest_coverline("/build/charts-base/charts-base.js", 502);
host.set("rightTickOffset",  tickLength);
                _yuitest_coverline("/build/charts-base/charts-base.js", 503);
host.set("leftTickOffset", 0);
            _yuitest_coverline("/build/charts-base/charts-base.js", 504);
break;
            case "outside" : 
                _yuitest_coverline("/build/charts-base/charts-base.js", 506);
host.set("rightTickOffset", 0);
                _yuitest_coverline("/build/charts-base/charts-base.js", 507);
host.set("leftTickOffset",  tickLength);
            _yuitest_coverline("/build/charts-base/charts-base.js", 508);
break;
            case "cross":
                _yuitest_coverline("/build/charts-base/charts-base.js", 510);
host.set("rightTickOffset", halfTick); 
                _yuitest_coverline("/build/charts-base/charts-base.js", 511);
host.set("leftTickOffset",  halfTick);
            _yuitest_coverline("/build/charts-base/charts-base.js", 512);
break;
            default:
                _yuitest_coverline("/build/charts-base/charts-base.js", 514);
host.set("rightTickOffset", 0);
                _yuitest_coverline("/build/charts-base/charts-base.js", 515);
host.set("leftTickOffset", 0);
            _yuitest_coverline("/build/charts-base/charts-base.js", 516);
break;
        }
    },
    
    /**
     * Draws a tick
     *
     * @method drawTick
     * @param {Path} path reference to the path `Path` element in which to draw the tick.
     * @param {Object} pt Point on the axis in which the tick will intersect.
     * @param {Object} tickStyle Hash of properties to apply to the tick.
     * @protected
     */
    drawTick: function(path, pt, tickStyles)
    {
        _yuitest_coverfunc("/build/charts-base/charts-base.js", "drawTick", 529);
_yuitest_coverline("/build/charts-base/charts-base.js", 531);
var host = this,
            style = host.get("styles"),
            padding = style.padding,
            tickLength = tickStyles.length,
            start = {x:padding.left, y:pt.y},
            end = {x:tickLength + padding.left, y:pt.y};
        _yuitest_coverline("/build/charts-base/charts-base.js", 537);
host.drawLine(path, start, end);
    },

    /**
     * Calculates the coordinates for the first point on an axis.
     *
     * @method getLineStart
     * @return {Object}
     * @protected
     */
    getLineStart: function()
    {
        _yuitest_coverfunc("/build/charts-base/charts-base.js", "getLineStart", 547);
_yuitest_coverline("/build/charts-base/charts-base.js", 549);
var style = this.get("styles"),
            padding = style.padding,
            majorTicks = style.majorTicks,
            tickLength = majorTicks.length,
            display = majorTicks.display,
            pt = {x:padding.left, y:0};
        _yuitest_coverline("/build/charts-base/charts-base.js", 555);
if(display === "outside")
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 557);
pt.x += tickLength;
        }
        else {_yuitest_coverline("/build/charts-base/charts-base.js", 559);
if(display === "cross")
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 561);
pt.x += tickLength/2;
        }}
        _yuitest_coverline("/build/charts-base/charts-base.js", 563);
return pt; 
    },
    
    /**
     * Calculates the point for a label.
     *
     * @method getLabelPoint
     * @param {Object} point Point on the axis in which the tick will intersect.
     * @return {Object} 
     * @protected
     */
    getLabelPoint: function(point)
    {
        _yuitest_coverfunc("/build/charts-base/charts-base.js", "getLabelPoint", 574);
_yuitest_coverline("/build/charts-base/charts-base.js", 576);
return {x:point.x - this.get("leftTickOffset"), y:point.y};
    },
    
    /**
     * Updates the value for the `maxLabelSize` for use in calculating total size.
     *
     * @method updateMaxLabelSize
     * @param {HTMLElement} label to measure
     * @protected
     */
    updateMaxLabelSize: function(labelWidth, labelHeight)
    {
        _yuitest_coverfunc("/build/charts-base/charts-base.js", "updateMaxLabelSize", 586);
_yuitest_coverline("/build/charts-base/charts-base.js", 588);
var host = this,
            props = this._labelRotationProps,
            rot = props.rot,
            absRot = props.absRot,
            sinRadians = props.sinRadians,
            cosRadians = props.cosRadians,
            max;
        _yuitest_coverline("/build/charts-base/charts-base.js", 595);
if(rot === 0)
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 597);
max = labelWidth;
        }
        else {_yuitest_coverline("/build/charts-base/charts-base.js", 599);
if(absRot === 90)
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 601);
max = labelHeight;
        }
        else
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 605);
max = (cosRadians * labelWidth) + (sinRadians * labelHeight);
        }}
        _yuitest_coverline("/build/charts-base/charts-base.js", 607);
host._maxLabelSize = Math.max(host._maxLabelSize, max);
    },
    
    /**
     * Determines the available label width when the axis width has been explicitly set.
     *
     * @method getExplicitlySized
     * @return Boolean
     * @protected
     */
    getExplicitlySized: function(styles)
    {
        _yuitest_coverfunc("/build/charts-base/charts-base.js", "getExplicitlySized", 617);
_yuitest_coverline("/build/charts-base/charts-base.js", 619);
if(this._explicitWidth)
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 621);
var host = this,
                w = host._explicitWidth,
                totalTitleSize = host._totalTitleSize,
                leftTickOffset = host.get("leftTickOffset"),
                margin = styles.label.margin.right;
            _yuitest_coverline("/build/charts-base/charts-base.js", 626);
host._maxLabelSize =  w - (leftTickOffset + margin + totalTitleSize);
            _yuitest_coverline("/build/charts-base/charts-base.js", 627);
return true;
        }
        _yuitest_coverline("/build/charts-base/charts-base.js", 629);
return false;
    },

    /**
     * Rotate and position title.
     *
     * @method positionTitle
     * @param {HTMLElement} label to rotate position
     * @protected
     */
    positionTitle: function(label)
    {
        _yuitest_coverfunc("/build/charts-base/charts-base.js", "positionTitle", 639);
_yuitest_coverline("/build/charts-base/charts-base.js", 641);
var host = this,
            bounds = host._titleBounds,
            margin = host.get("styles").title.margin,
            props = host._titleRotationProps,
            w = bounds.right - bounds.left,
            labelWidth = label.offsetWidth,
            labelHeight = label.offsetHeight,
            x = (labelWidth * -0.5) + (w * 0.5),
            y = (host.get("height") * 0.5) - (labelHeight * 0.5);
        _yuitest_coverline("/build/charts-base/charts-base.js", 650);
props.labelWidth = labelWidth;
        _yuitest_coverline("/build/charts-base/charts-base.js", 651);
props.labelHeight = labelHeight;
        _yuitest_coverline("/build/charts-base/charts-base.js", 652);
if(margin && margin.left)
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 654);
x += margin.left;
        }
        _yuitest_coverline("/build/charts-base/charts-base.js", 656);
props.x = x;
        _yuitest_coverline("/build/charts-base/charts-base.js", 657);
props.y = y;
        _yuitest_coverline("/build/charts-base/charts-base.js", 658);
props.transformOrigin = [0.5, 0.5];
        _yuitest_coverline("/build/charts-base/charts-base.js", 659);
host._rotate(label, props);
    },

    /**
     * Rotate and position labels.
     *
     * @method positionLabel
     * @param {HTMLElement} label to rotate position
     * @param {Object} pt hash containing the x and y coordinates in which the label will be positioned
     * against.
     * @protected
     */
    positionLabel: function(label, pt, styles, i)
    {
        _yuitest_coverfunc("/build/charts-base/charts-base.js", "positionLabel", 671);
_yuitest_coverline("/build/charts-base/charts-base.js", 673);
var host = this,
            tickOffset = host.get("leftTickOffset"),
            totalTitleSize = this._totalTitleSize,
            leftOffset = pt.x + totalTitleSize - tickOffset,
            topOffset = pt.y,
            props = this._labelRotationProps,
            rot = props.rot,
            absRot = props.absRot,
            maxLabelSize = host._maxLabelSize,
            labelWidth = this._labelWidths[i],
            labelHeight = this._labelHeights[i];
        _yuitest_coverline("/build/charts-base/charts-base.js", 684);
if(rot === 0)
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 686);
leftOffset -= labelWidth;
            _yuitest_coverline("/build/charts-base/charts-base.js", 687);
topOffset -= labelHeight * 0.5;
        }
        else {_yuitest_coverline("/build/charts-base/charts-base.js", 689);
if(rot === 90)
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 691);
leftOffset -= labelWidth * 0.5;
        }
        else {_yuitest_coverline("/build/charts-base/charts-base.js", 693);
if(rot === -90)
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 695);
leftOffset -= labelWidth * 0.5;
            _yuitest_coverline("/build/charts-base/charts-base.js", 696);
topOffset -= labelHeight;
        }
        else
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 700);
leftOffset -= labelWidth + (labelHeight * absRot/360);
            _yuitest_coverline("/build/charts-base/charts-base.js", 701);
topOffset -= labelHeight * 0.5;
        }}}
        _yuitest_coverline("/build/charts-base/charts-base.js", 703);
props.labelWidth = labelWidth;
        _yuitest_coverline("/build/charts-base/charts-base.js", 704);
props.labelHeight = labelHeight;
        _yuitest_coverline("/build/charts-base/charts-base.js", 705);
props.x = Math.round(maxLabelSize + leftOffset);
        _yuitest_coverline("/build/charts-base/charts-base.js", 706);
props.y = Math.round(topOffset);
        _yuitest_coverline("/build/charts-base/charts-base.js", 707);
this._rotate(label, props);
    },

    /**
     * Adjusts the coordinates of an axis label based on the rotation.
     *
     * @method _setRotationCoords
     * @param {Object} props Coordinates, dimension and rotation properties of the label.
     * @protected
     */
    _setRotationCoords: function(props)
    {
        _yuitest_coverfunc("/build/charts-base/charts-base.js", "_setRotationCoords", 717);
_yuitest_coverline("/build/charts-base/charts-base.js", 719);
var rot = props.rot,
            absRot = props.absRot,
            leftOffset,
            topOffset,
            labelWidth = props.labelWidth,
            labelHeight = props.labelHeight;
        _yuitest_coverline("/build/charts-base/charts-base.js", 725);
if(rot === 0)
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 727);
leftOffset = labelWidth;
            _yuitest_coverline("/build/charts-base/charts-base.js", 728);
topOffset = labelHeight * 0.5;
        }
        else {_yuitest_coverline("/build/charts-base/charts-base.js", 730);
if(rot === 90)
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 732);
topOffset = 0;
            _yuitest_coverline("/build/charts-base/charts-base.js", 733);
leftOffset = labelWidth * 0.5;
        }
        else {_yuitest_coverline("/build/charts-base/charts-base.js", 735);
if(rot === -90)
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 737);
leftOffset = labelWidth * 0.5;
            _yuitest_coverline("/build/charts-base/charts-base.js", 738);
topOffset = labelHeight;
        }
        else
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 742);
leftOffset = labelWidth + (labelHeight * absRot/360);
            _yuitest_coverline("/build/charts-base/charts-base.js", 743);
topOffset = labelHeight * 0.5;
        }}}
        _yuitest_coverline("/build/charts-base/charts-base.js", 745);
props.x -= leftOffset;
        _yuitest_coverline("/build/charts-base/charts-base.js", 746);
props.y -= topOffset;
    },

    /**
     * Returns the transformOrigin to use for an axis label based on the position of the axis 
     * and the rotation of the label.
     *
     * @method _getTransformOrigin
     * @param {Number} rot The rotation (in degrees) of the label.
     * @return Array
     * @protected
     */
    _getTransformOrigin: function(rot)
    {
        _yuitest_coverfunc("/build/charts-base/charts-base.js", "_getTransformOrigin", 758);
_yuitest_coverline("/build/charts-base/charts-base.js", 760);
var transformOrigin;
        _yuitest_coverline("/build/charts-base/charts-base.js", 761);
if(rot === 0)
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 763);
transformOrigin = [0, 0];
        }
        else {_yuitest_coverline("/build/charts-base/charts-base.js", 765);
if(rot === 90)
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 767);
transformOrigin = [0.5, 0];
        }
        else {_yuitest_coverline("/build/charts-base/charts-base.js", 769);
if(rot === -90)
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 771);
transformOrigin = [0.5, 1];
        }
        else
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 775);
transformOrigin = [1, 0.5];
        }}}
        _yuitest_coverline("/build/charts-base/charts-base.js", 777);
return transformOrigin;
    },

    /**
     * Adjust the position of the Axis widget's content box for internal axes.
     *
     * @method offsetNodeForTick
     * @param {Node} cb Content box of the Axis.
     * @protected
     */
    offsetNodeForTick: function(cb)
    {
    },

    /**
     * Sets the width of the axis based on its contents.
     *
     * @method setCalculatedSize
     * @protected
     */
    setCalculatedSize: function()
    {
        _yuitest_coverfunc("/build/charts-base/charts-base.js", "setCalculatedSize", 797);
_yuitest_coverline("/build/charts-base/charts-base.js", 799);
var host = this,
            graphic = this.get("graphic"),
            style = host.get("styles"),
            label = style.label,
            tickOffset = host.get("leftTickOffset"),
            max = host._maxLabelSize,
            totalTitleSize = this._totalTitleSize,
            ttl = Math.round(totalTitleSize + tickOffset + max + label.margin.right);
        _yuitest_coverline("/build/charts-base/charts-base.js", 807);
if(this._explicitWidth)
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 809);
ttl = this._explicitWidth;
        }
        _yuitest_coverline("/build/charts-base/charts-base.js", 811);
this.set("calculatedWidth", ttl);
        _yuitest_coverline("/build/charts-base/charts-base.js", 812);
graphic.set("x", ttl - tickOffset);
    }
};

_yuitest_coverline("/build/charts-base/charts-base.js", 816);
Y.LeftAxisLayout = LeftAxisLayout;
/**
 * RightAxisLayout contains algorithms for rendering a right axis.
 *
 * @module charts
 * @submodule charts-base
 * @class RightAxisLayout
 * @constructor
 */
_yuitest_coverline("/build/charts-base/charts-base.js", 825);
RightAxisLayout = function(){};

_yuitest_coverline("/build/charts-base/charts-base.js", 827);
RightAxisLayout.prototype = {
    /**
     *  Default margins for text fields.
     *
     *  @private
     *  @method _getDefaultMargins
     *  @return Object
     */
    _getDefaultMargins: function() 
    {
        _yuitest_coverfunc("/build/charts-base/charts-base.js", "_getDefaultMargins", 835);
_yuitest_coverline("/build/charts-base/charts-base.js", 837);
return {
            top: 0,
            left: 4,
            right: 0,
            bottom: 0
        };
    },

    /**
     * Sets the length of the tick on either side of the axis line.
     *
     * @method setTickOffset
     * @protected
     */
    setTickOffsets: function()
    {
        _yuitest_coverfunc("/build/charts-base/charts-base.js", "setTickOffsets", 851);
_yuitest_coverline("/build/charts-base/charts-base.js", 853);
var host = this,
            majorTicks = host.get("styles").majorTicks,
            tickLength = majorTicks.length,
            halfTick = tickLength * 0.5,
            display = majorTicks.display;
        _yuitest_coverline("/build/charts-base/charts-base.js", 858);
host.set("topTickOffset",  0);
        _yuitest_coverline("/build/charts-base/charts-base.js", 859);
host.set("bottomTickOffset",  0);
        
        _yuitest_coverline("/build/charts-base/charts-base.js", 861);
switch(display)
        {
            case "inside" :
                _yuitest_coverline("/build/charts-base/charts-base.js", 864);
host.set("leftTickOffset", tickLength);
                _yuitest_coverline("/build/charts-base/charts-base.js", 865);
host.set("rightTickOffset", 0);
            _yuitest_coverline("/build/charts-base/charts-base.js", 866);
break;
            case "outside" : 
                _yuitest_coverline("/build/charts-base/charts-base.js", 868);
host.set("leftTickOffset", 0);
                _yuitest_coverline("/build/charts-base/charts-base.js", 869);
host.set("rightTickOffset", tickLength);
            _yuitest_coverline("/build/charts-base/charts-base.js", 870);
break;
            case "cross" :
                _yuitest_coverline("/build/charts-base/charts-base.js", 872);
host.set("rightTickOffset", halfTick);
                _yuitest_coverline("/build/charts-base/charts-base.js", 873);
host.set("leftTickOffset", halfTick);
            _yuitest_coverline("/build/charts-base/charts-base.js", 874);
break;
            default:
                _yuitest_coverline("/build/charts-base/charts-base.js", 876);
host.set("leftTickOffset", 0);
                _yuitest_coverline("/build/charts-base/charts-base.js", 877);
host.set("rightTickOffset", 0);
            _yuitest_coverline("/build/charts-base/charts-base.js", 878);
break;
        }
    },

    /**
     * Draws a tick
     *
     * @method drawTick
     * @param {Path} path reference to the path `Path` element in which to draw the tick.
     * @param {Object} pt Point on the axis in which the tick will intersect.
     * @param {Object) tickStyle Hash of properties to apply to the tick.
     * @protected
     */
    drawTick: function(path, pt, tickStyles)
    {
        _yuitest_coverfunc("/build/charts-base/charts-base.js", "drawTick", 891);
_yuitest_coverline("/build/charts-base/charts-base.js", 893);
var host = this,
            style = host.get("styles"),
            padding = style.padding,
            tickLength = tickStyles.length,
            start = {x:padding.left, y:pt.y},
            end = {x:padding.left + tickLength, y:pt.y};
        _yuitest_coverline("/build/charts-base/charts-base.js", 899);
host.drawLine(path, start, end);
    },
    
    /**
     * Calculates the coordinates for the first point on an axis.
     *
     * @method getLineStart
     * @return {Object}
     * @protected
     */
    getLineStart: function()
    {
        _yuitest_coverfunc("/build/charts-base/charts-base.js", "getLineStart", 909);
_yuitest_coverline("/build/charts-base/charts-base.js", 911);
var host = this,
            style = host.get("styles"),
            padding = style.padding,
            majorTicks = style.majorTicks,
            tickLength = majorTicks.length,
            display = majorTicks.display,
            pt = {x:padding.left, y:padding.top};
        _yuitest_coverline("/build/charts-base/charts-base.js", 918);
if(display === "inside")
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 920);
pt.x += tickLength;
        }
        else {_yuitest_coverline("/build/charts-base/charts-base.js", 922);
if(display === "cross")
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 924);
pt.x += tickLength/2;
        }}
        _yuitest_coverline("/build/charts-base/charts-base.js", 926);
return pt;
    },
    
    /**
     * Calculates the point for a label.
     *
     * @method getLabelPoint
     * @param {Object} point Point on the axis in which the tick will intersect.
     * @return {Object} 
     * @protected
     */
    getLabelPoint: function(point)
    {
        _yuitest_coverfunc("/build/charts-base/charts-base.js", "getLabelPoint", 937);
_yuitest_coverline("/build/charts-base/charts-base.js", 939);
return {x:point.x + this.get("rightTickOffset"), y:point.y};
    },
    
    /**
     * Updates the value for the `maxLabelSize` for use in calculating total size.
     *
     * @method updateMaxLabelSize
     * @param {HTMLElement} label to measure
     * @protected
     */
    updateMaxLabelSize: function(labelWidth, labelHeight)
    {
        _yuitest_coverfunc("/build/charts-base/charts-base.js", "updateMaxLabelSize", 949);
_yuitest_coverline("/build/charts-base/charts-base.js", 951);
var host = this,
            props = this._labelRotationProps,
            rot = props.rot,
            absRot = props.absRot,
            sinRadians = props.sinRadians,
            cosRadians = props.cosRadians,
            max;
        _yuitest_coverline("/build/charts-base/charts-base.js", 958);
if(rot === 0)
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 960);
max = labelWidth;
        }
        else {_yuitest_coverline("/build/charts-base/charts-base.js", 962);
if(absRot === 90)
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 964);
max = labelHeight;
        }
        else
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 968);
max = (cosRadians * labelWidth) + (sinRadians * labelHeight);
        }}
        _yuitest_coverline("/build/charts-base/charts-base.js", 970);
host._maxLabelSize = Math.max(host._maxLabelSize, max);
    },
    
    /**
     * Determines the available label width when the axis width has been explicitly set.
     *
     * @method getExplicitlySized
     * @return Boolean
     * @protected
     */
    getExplicitlySized: function(styles)
    {
        _yuitest_coverfunc("/build/charts-base/charts-base.js", "getExplicitlySized", 980);
_yuitest_coverline("/build/charts-base/charts-base.js", 982);
if(this._explicitWidth)
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 984);
var host = this,
                w = host._explicitWidth,
                totalTitleSize = this._totalTitleSize,
                rightTickOffset = host.get("rightTickOffset"),
                margin = styles.label.margin.right;
            _yuitest_coverline("/build/charts-base/charts-base.js", 989);
host._maxLabelSize =  w - (rightTickOffset + margin + totalTitleSize);
            _yuitest_coverline("/build/charts-base/charts-base.js", 990);
return true;
        }
        _yuitest_coverline("/build/charts-base/charts-base.js", 992);
return false;
    },

    /**
     * Rotate and position title.
     *
     * @method positionTitle
     * @param {HTMLElement} label to rotate position
     * @protected
     */
    positionTitle: function(label)
    {
        _yuitest_coverfunc("/build/charts-base/charts-base.js", "positionTitle", 1002);
_yuitest_coverline("/build/charts-base/charts-base.js", 1004);
var host = this,
            bounds = host._titleBounds,
            margin = host.get("styles").title.margin,
            props = host._titleRotationProps,
            labelWidth = label.offsetWidth,
            labelHeight = label.offsetHeight,
            w = bounds.right - bounds.left,
            x = this.get("width") - (labelWidth * 0.5) - (w * 0.5),
            y = (host.get("height") * 0.5) - (labelHeight * 0.5);
        _yuitest_coverline("/build/charts-base/charts-base.js", 1013);
props.labelWidth = labelWidth;
        _yuitest_coverline("/build/charts-base/charts-base.js", 1014);
props.labelHeight = labelHeight;
        _yuitest_coverline("/build/charts-base/charts-base.js", 1015);
if(margin && margin.right)
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 1017);
x -= margin.left;
        }
        _yuitest_coverline("/build/charts-base/charts-base.js", 1019);
props.x = x;
        _yuitest_coverline("/build/charts-base/charts-base.js", 1020);
props.y = y;
        _yuitest_coverline("/build/charts-base/charts-base.js", 1021);
props.transformOrigin = [0.5, 0.5];
        _yuitest_coverline("/build/charts-base/charts-base.js", 1022);
host._rotate(label, props);
    },

    /**
     * Rotate and position labels.
     *
     * @method positionLabel
     * @param {HTMLElement} label to rotate position
     * @param {Object} pt hash containing the x and y coordinates in which the label will be positioned
     * against.
     * @protected
     */
    positionLabel: function(label, pt, styles, i)
    {
        _yuitest_coverfunc("/build/charts-base/charts-base.js", "positionLabel", 1034);
_yuitest_coverline("/build/charts-base/charts-base.js", 1036);
var host = this,
            tickOffset = host.get("rightTickOffset"),
            labelStyles = styles.label,
            margin = 0,
            leftOffset = pt.x,
            topOffset = pt.y,
            props = this._labelRotationProps,
            rot = props.rot,
            absRot = props.absRot,
            labelWidth = this._labelWidths[i],
            labelHeight = this._labelHeights[i];
        _yuitest_coverline("/build/charts-base/charts-base.js", 1047);
if(labelStyles.margin && labelStyles.margin.left)
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 1049);
margin = labelStyles.margin.left;
        }
        _yuitest_coverline("/build/charts-base/charts-base.js", 1051);
if(rot === 0)
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 1053);
topOffset -= labelHeight * 0.5;
        }
        else {_yuitest_coverline("/build/charts-base/charts-base.js", 1055);
if(rot === 90)
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 1057);
leftOffset -= labelWidth * 0.5;
            _yuitest_coverline("/build/charts-base/charts-base.js", 1058);
topOffset -= labelHeight;
        }
        else {_yuitest_coverline("/build/charts-base/charts-base.js", 1060);
if(rot === -90)
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 1062);
leftOffset -= labelWidth * 0.5;
        }
        else
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 1066);
topOffset -= labelHeight * 0.5;
            _yuitest_coverline("/build/charts-base/charts-base.js", 1067);
leftOffset += labelHeight/2 * absRot/90;
        }}}
        _yuitest_coverline("/build/charts-base/charts-base.js", 1069);
leftOffset += margin;
        _yuitest_coverline("/build/charts-base/charts-base.js", 1070);
leftOffset += tickOffset;
        _yuitest_coverline("/build/charts-base/charts-base.js", 1071);
props.labelWidth = labelWidth;
        _yuitest_coverline("/build/charts-base/charts-base.js", 1072);
props.labelHeight = labelHeight;
        _yuitest_coverline("/build/charts-base/charts-base.js", 1073);
props.x = Math.round(leftOffset);
        _yuitest_coverline("/build/charts-base/charts-base.js", 1074);
props.y = Math.round(topOffset);
        _yuitest_coverline("/build/charts-base/charts-base.js", 1075);
this._rotate(label, props);
    },
 
    /**
     * Adjusts the coordinates of an axis label based on the rotation.
     *
     * @method _setRotationCoords
     * @param {Object} props Coordinates, dimension and rotation properties of the label.
     * @protected
     */
    _setRotationCoords: function(props)
    {
        _yuitest_coverfunc("/build/charts-base/charts-base.js", "_setRotationCoords", 1085);
_yuitest_coverline("/build/charts-base/charts-base.js", 1087);
var rot = props.rot,
            absRot = props.absRot,
            leftOffset = 0,
            topOffset = 0,
            labelWidth = props.labelWidth,
            labelHeight = props.labelHeight;
        _yuitest_coverline("/build/charts-base/charts-base.js", 1093);
if(rot === 0)
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 1095);
topOffset = labelHeight * 0.5;
        }
        else {_yuitest_coverline("/build/charts-base/charts-base.js", 1097);
if(rot === 90)
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 1099);
leftOffset = labelWidth * 0.5;
            _yuitest_coverline("/build/charts-base/charts-base.js", 1100);
topOffset = labelHeight;
        }
        else {_yuitest_coverline("/build/charts-base/charts-base.js", 1102);
if(rot === -90)
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 1104);
leftOffset = labelWidth * 0.5;
        }
        else
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 1108);
topOffset = labelHeight * 0.5;
            _yuitest_coverline("/build/charts-base/charts-base.js", 1109);
leftOffset = labelHeight/2 * absRot/90;
        }}}
        _yuitest_coverline("/build/charts-base/charts-base.js", 1111);
props.x -= leftOffset;
        _yuitest_coverline("/build/charts-base/charts-base.js", 1112);
props.y -= topOffset;
    },
   
    /**
     * Returns the transformOrigin to use for an axis label based on the position of the axis 
     * and the rotation of the label.
     *
     * @method _getTransformOrigin
     * @param {Number} rot The rotation (in degrees) of the label.
     * @return Array
     * @protected
     */
    _getTransformOrigin: function(rot)
    {
        _yuitest_coverfunc("/build/charts-base/charts-base.js", "_getTransformOrigin", 1124);
_yuitest_coverline("/build/charts-base/charts-base.js", 1126);
var transformOrigin;
        _yuitest_coverline("/build/charts-base/charts-base.js", 1127);
if(rot === 0)
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 1129);
transformOrigin = [0, 0];
        }
        else {_yuitest_coverline("/build/charts-base/charts-base.js", 1131);
if(rot === 90)
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 1133);
transformOrigin = [0.5, 1];
        }
        else {_yuitest_coverline("/build/charts-base/charts-base.js", 1135);
if(rot === -90)
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 1137);
transformOrigin = [0.5, 0];
        }
        else
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 1141);
transformOrigin = [0, 0.5];
        }}}
        _yuitest_coverline("/build/charts-base/charts-base.js", 1143);
return transformOrigin;
    },

    /**
     * Adjusts position for inner ticks.
     *
     * @method offsetNodeForTick
     * @param {Node} cb contentBox of the axis
     * @protected
     */
    offsetNodeForTick: function(cb)
    {
        _yuitest_coverfunc("/build/charts-base/charts-base.js", "offsetNodeForTick", 1153);
_yuitest_coverline("/build/charts-base/charts-base.js", 1155);
var host = this,
            tickOffset = host.get("leftTickOffset"),
            offset = 0 - tickOffset;
        _yuitest_coverline("/build/charts-base/charts-base.js", 1158);
cb.setStyle("left", offset);
    },

    /**
     * Assigns a height based on the size of the contents.
     *
     * @method setCalculatedSize
     * @protected
     */
    setCalculatedSize: function()
    {
        _yuitest_coverfunc("/build/charts-base/charts-base.js", "setCalculatedSize", 1167);
_yuitest_coverline("/build/charts-base/charts-base.js", 1169);
var host = this,
            styles = host.get("styles"),
            labelStyle = styles.label,
            totalTitleSize = this._totalTitleSize,
            ttl = Math.round(host.get("rightTickOffset") + host._maxLabelSize + totalTitleSize + labelStyle.margin.left);
        _yuitest_coverline("/build/charts-base/charts-base.js", 1174);
if(this._explicitWidth)
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 1176);
ttl = this._explicitWidth;
        }
        _yuitest_coverline("/build/charts-base/charts-base.js", 1178);
host.set("calculatedWidth", ttl);
        _yuitest_coverline("/build/charts-base/charts-base.js", 1179);
host.get("contentBox").setStyle("width", ttl);
    }
};

_yuitest_coverline("/build/charts-base/charts-base.js", 1183);
Y.RightAxisLayout = RightAxisLayout;
/**
 * Contains algorithms for rendering a bottom axis.
 *
 * @module charts
 * @submodule charts-base
 * @class BottomAxisLayout
 * @Constructor
 */
_yuitest_coverline("/build/charts-base/charts-base.js", 1192);
BottomAxisLayout = function(){};

_yuitest_coverline("/build/charts-base/charts-base.js", 1194);
BottomAxisLayout.prototype = {
    /**
     *  Default margins for text fields.
     *
     *  @private
     *  @method _getDefaultMargins
     *  @return Object
     */
    _getDefaultMargins: function() 
    {
        _yuitest_coverfunc("/build/charts-base/charts-base.js", "_getDefaultMargins", 1202);
_yuitest_coverline("/build/charts-base/charts-base.js", 1204);
return {
            top: 4,
            left: 0,
            right: 0,
            bottom: 0
        };
    },

    /**
     * Sets the length of the tick on either side of the axis line.
     *
     * @method setTickOffsets
     * @protected
     */
    setTickOffsets: function()
    {
        _yuitest_coverfunc("/build/charts-base/charts-base.js", "setTickOffsets", 1218);
_yuitest_coverline("/build/charts-base/charts-base.js", 1220);
var host = this,
            majorTicks = host.get("styles").majorTicks,
            tickLength = majorTicks.length,
            halfTick = tickLength * 0.5,
            display = majorTicks.display;
        _yuitest_coverline("/build/charts-base/charts-base.js", 1225);
host.set("leftTickOffset",  0);
        _yuitest_coverline("/build/charts-base/charts-base.js", 1226);
host.set("rightTickOffset",  0);

        _yuitest_coverline("/build/charts-base/charts-base.js", 1228);
switch(display)
        {
            case "inside" :
                _yuitest_coverline("/build/charts-base/charts-base.js", 1231);
host.set("topTickOffset", tickLength);
                _yuitest_coverline("/build/charts-base/charts-base.js", 1232);
host.set("bottomTickOffset", 0);
            _yuitest_coverline("/build/charts-base/charts-base.js", 1233);
break;
            case "outside" : 
                _yuitest_coverline("/build/charts-base/charts-base.js", 1235);
host.set("topTickOffset", 0);
                _yuitest_coverline("/build/charts-base/charts-base.js", 1236);
host.set("bottomTickOffset", tickLength);
            _yuitest_coverline("/build/charts-base/charts-base.js", 1237);
break;
            case "cross":
                _yuitest_coverline("/build/charts-base/charts-base.js", 1239);
host.set("topTickOffset",  halfTick);
                _yuitest_coverline("/build/charts-base/charts-base.js", 1240);
host.set("bottomTickOffset",  halfTick);
            _yuitest_coverline("/build/charts-base/charts-base.js", 1241);
break;
            default:
                _yuitest_coverline("/build/charts-base/charts-base.js", 1243);
host.set("topTickOffset", 0);
                _yuitest_coverline("/build/charts-base/charts-base.js", 1244);
host.set("bottomTickOffset", 0);
            _yuitest_coverline("/build/charts-base/charts-base.js", 1245);
break;
        }
    },

    /**
     * Calculates the coordinates for the first point on an axis.
     *
     * @method getLineStart
     * @protected
     */
    getLineStart: function()
    {
        _yuitest_coverfunc("/build/charts-base/charts-base.js", "getLineStart", 1255);
_yuitest_coverline("/build/charts-base/charts-base.js", 1257);
var style = this.get("styles"),
            padding = style.padding,
            majorTicks = style.majorTicks,
            tickLength = majorTicks.length,
            display = majorTicks.display,
            pt = {x:0, y:padding.top};
        _yuitest_coverline("/build/charts-base/charts-base.js", 1263);
if(display === "inside")
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 1265);
pt.y += tickLength;
        }
        else {_yuitest_coverline("/build/charts-base/charts-base.js", 1267);
if(display === "cross")
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 1269);
pt.y += tickLength/2;
        }}
        _yuitest_coverline("/build/charts-base/charts-base.js", 1271);
return pt; 
    },
    
    /**
     * Draws a tick
     *
     * @method drawTick
     * @param {Path} path reference to the path `Path` element in which to draw the tick.
     * @param {Object} pt hash containing x and y coordinates
     * @param {Object} tickStyles hash of properties used to draw the tick
     * @protected
     */
    drawTick: function(path, pt, tickStyles)
    {
        _yuitest_coverfunc("/build/charts-base/charts-base.js", "drawTick", 1283);
_yuitest_coverline("/build/charts-base/charts-base.js", 1285);
var host = this,
            style = host.get("styles"),
            padding = style.padding,
            tickLength = tickStyles.length,
            start = {x:pt.x, y:padding.top},
            end = {x:pt.x, y:tickLength + padding.top};
        _yuitest_coverline("/build/charts-base/charts-base.js", 1291);
host.drawLine(path, start, end);
    },

    /**
     * Calculates the point for a label.
     *
     * @method getLabelPoint
     * @param {Object} pt Object containing x and y coordinates
     * @return Object
     * @protected
     */
    getLabelPoint: function(point)
    {
        _yuitest_coverfunc("/build/charts-base/charts-base.js", "getLabelPoint", 1302);
_yuitest_coverline("/build/charts-base/charts-base.js", 1304);
return {x:point.x, y:point.y + this.get("bottomTickOffset")};
    },
    
    /**
     * Updates the value for the `maxLabelSize` for use in calculating total size.
     *
     * @method updateMaxLabelSize
     * @param {HTMLElement} label to measure
     * @protected
     */
    updateMaxLabelSize: function(labelWidth, labelHeight)
    {
        _yuitest_coverfunc("/build/charts-base/charts-base.js", "updateMaxLabelSize", 1314);
_yuitest_coverline("/build/charts-base/charts-base.js", 1316);
var host = this,
            props = this._labelRotationProps,
            rot = props.rot,
            absRot = props.absRot,
            sinRadians = props.sinRadians,
            cosRadians = props.cosRadians,
            max;
        _yuitest_coverline("/build/charts-base/charts-base.js", 1323);
if(rot === 0)
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 1325);
max = labelHeight;
        }
        else {_yuitest_coverline("/build/charts-base/charts-base.js", 1327);
if(absRot === 90)
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 1329);
max = labelWidth;
        }
        else
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 1333);
max = (sinRadians * labelWidth) + (cosRadians * labelHeight); 
        }}
        _yuitest_coverline("/build/charts-base/charts-base.js", 1335);
host._maxLabelSize = Math.max(host._maxLabelSize, max);
    },
    
    /**
     * Determines the available label height when the axis width has been explicitly set.
     *
     * @method getExplicitlySized
     * @return Boolean
     * @protected
     */
    getExplicitlySized: function(styles)
    {
        _yuitest_coverfunc("/build/charts-base/charts-base.js", "getExplicitlySized", 1345);
_yuitest_coverline("/build/charts-base/charts-base.js", 1347);
if(this._explicitHeight)
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 1349);
var host = this,
                h = host._explicitHeight,
                totalTitleSize = host._totalTitleSize,
                bottomTickOffset = host.get("bottomTickOffset"),
                margin = styles.label.margin.right;
            _yuitest_coverline("/build/charts-base/charts-base.js", 1354);
host._maxLabelSize =  h - (bottomTickOffset + margin + totalTitleSize);
            _yuitest_coverline("/build/charts-base/charts-base.js", 1355);
return true;
        }
        _yuitest_coverline("/build/charts-base/charts-base.js", 1357);
return false;
    },

    /**
     * Rotate and position title.
     *
     * @method positionTitle
     * @param {HTMLElement} label to rotate position
     * @protected
     */
    positionTitle: function(label)
    {
        _yuitest_coverfunc("/build/charts-base/charts-base.js", "positionTitle", 1367);
_yuitest_coverline("/build/charts-base/charts-base.js", 1369);
var host = this,
            bounds = host._titleBounds,
            margin = host.get("styles").title.margin,
            props = host._titleRotationProps,
            h = bounds.bottom - bounds.top,
            labelWidth = label.offsetWidth,
            labelHeight = label.offsetHeight,
            x = (host.get("width") * 0.5) - (labelWidth * 0.5),
            y = host.get("height") - labelHeight/2 - h/2;
        _yuitest_coverline("/build/charts-base/charts-base.js", 1378);
props.labelWidth = labelWidth;
        _yuitest_coverline("/build/charts-base/charts-base.js", 1379);
props.labelHeight = labelHeight;
        _yuitest_coverline("/build/charts-base/charts-base.js", 1380);
if(margin && margin.bottom)
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 1382);
y -= margin.bottom;
        }
        _yuitest_coverline("/build/charts-base/charts-base.js", 1384);
props.x = x;
        _yuitest_coverline("/build/charts-base/charts-base.js", 1385);
props.y = y;
        _yuitest_coverline("/build/charts-base/charts-base.js", 1386);
props.transformOrigin = [0.5, 0.5];
        _yuitest_coverline("/build/charts-base/charts-base.js", 1387);
host._rotate(label, props);
    },
    
    /**
     * Rotate and position labels.
     *
     * @method positionLabel
     * @param {HTMLElement} label to rotate position
     * @param {Object} pt hash containing the x and y coordinates in which the label will be positioned
     * against.
     * @protected
     */
    positionLabel: function(label, pt, styles, i)
    {
        _yuitest_coverfunc("/build/charts-base/charts-base.js", "positionLabel", 1399);
_yuitest_coverline("/build/charts-base/charts-base.js", 1401);
var host = this,
            tickOffset = host.get("bottomTickOffset"),
            labelStyles = styles.label,
            margin = 0,
            props = host._labelRotationProps,
            rot = props.rot,
            absRot = props.absRot,
            leftOffset = Math.round(pt.x),
            topOffset = Math.round(pt.y),
            labelWidth = host._labelWidths[i],
            labelHeight = host._labelHeights[i];
        _yuitest_coverline("/build/charts-base/charts-base.js", 1412);
if(labelStyles.margin && labelStyles.margin.top)
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 1414);
margin = labelStyles.margin.top;
        }
        _yuitest_coverline("/build/charts-base/charts-base.js", 1416);
if(rot > 0)
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 1418);
topOffset -= labelHeight/2 * rot/90;
        }
        else {_yuitest_coverline("/build/charts-base/charts-base.js", 1420);
if(rot < 0)
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 1422);
leftOffset -= labelWidth;
            _yuitest_coverline("/build/charts-base/charts-base.js", 1423);
topOffset -= labelHeight/2 * absRot/90;
        }
        else
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 1427);
leftOffset -= labelWidth * 0.5;
        }}
        _yuitest_coverline("/build/charts-base/charts-base.js", 1429);
topOffset += margin;
        _yuitest_coverline("/build/charts-base/charts-base.js", 1430);
topOffset += tickOffset;
        _yuitest_coverline("/build/charts-base/charts-base.js", 1431);
props.labelWidth = labelWidth;
        _yuitest_coverline("/build/charts-base/charts-base.js", 1432);
props.labelHeight = labelHeight;
        _yuitest_coverline("/build/charts-base/charts-base.js", 1433);
props.x = leftOffset;
        _yuitest_coverline("/build/charts-base/charts-base.js", 1434);
props.y = topOffset;
        _yuitest_coverline("/build/charts-base/charts-base.js", 1435);
host._rotate(label, props);
    },
    
    /**
     * Adjusts the coordinates of an axis label based on the rotation.
     *
     * @method _setRotationCoords
     * @param {Object} props Coordinates, dimension and rotation properties of the label.
     * @protected
     */
    _setRotationCoords: function(props)
    {
        _yuitest_coverfunc("/build/charts-base/charts-base.js", "_setRotationCoords", 1445);
_yuitest_coverline("/build/charts-base/charts-base.js", 1447);
var rot = props.rot,
            absRot = props.absRot,
            labelWidth = props.labelWidth,
            labelHeight = props.labelHeight,
            leftOffset,
            topOffset;

        _yuitest_coverline("/build/charts-base/charts-base.js", 1454);
if(rot > 0)
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 1456);
leftOffset = 0;
            _yuitest_coverline("/build/charts-base/charts-base.js", 1457);
topOffset = labelHeight/2 * rot/90;
        }
        else {_yuitest_coverline("/build/charts-base/charts-base.js", 1459);
if(rot < 0)
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 1461);
leftOffset = labelWidth;
            _yuitest_coverline("/build/charts-base/charts-base.js", 1462);
topOffset = labelHeight/2 * absRot/90;
        }
        else
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 1466);
leftOffset = labelWidth * 0.5;
            _yuitest_coverline("/build/charts-base/charts-base.js", 1467);
topOffset = 0;
        }}
        _yuitest_coverline("/build/charts-base/charts-base.js", 1469);
props.x -= leftOffset;
        _yuitest_coverline("/build/charts-base/charts-base.js", 1470);
props.y -= topOffset;
    },

    /**
     * Returns the transformOrigin to use for an axis label based on the position of the axis 
     * and the rotation of the label.
     *
     * @method _getTransformOrigin
     * @param {Number} rot The rotation (in degrees) of the label.
     * @return Array
     * @protected
     */
    _getTransformOrigin: function(rot)
    {
        _yuitest_coverfunc("/build/charts-base/charts-base.js", "_getTransformOrigin", 1482);
_yuitest_coverline("/build/charts-base/charts-base.js", 1484);
var transformOrigin;
        _yuitest_coverline("/build/charts-base/charts-base.js", 1485);
if(rot > 0)
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 1487);
transformOrigin = [0, 0.5];
        }
        else {_yuitest_coverline("/build/charts-base/charts-base.js", 1489);
if(rot < 0)
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 1491);
transformOrigin = [1, 0.5];
        }
        else
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 1495);
transformOrigin = [0, 0];
        }}
        _yuitest_coverline("/build/charts-base/charts-base.js", 1497);
return transformOrigin;
    },

    /**
     * Adjusts position for inner ticks.
     *
     * @method offsetNodeForTick
     * @param {Node} cb contentBox of the axis
     * @protected
     */
    offsetNodeForTick: function(cb)
    {
        _yuitest_coverfunc("/build/charts-base/charts-base.js", "offsetNodeForTick", 1507);
_yuitest_coverline("/build/charts-base/charts-base.js", 1509);
var host = this;
        _yuitest_coverline("/build/charts-base/charts-base.js", 1510);
host.get("contentBox").setStyle("top", 0 - host.get("topTickOffset"));
    },

    /**
     * Assigns a height based on the size of the contents.
     *
     * @method setCalculatedSize
     * @protected
     */
    setCalculatedSize: function()
    {
        _yuitest_coverfunc("/build/charts-base/charts-base.js", "setCalculatedSize", 1519);
_yuitest_coverline("/build/charts-base/charts-base.js", 1521);
var host = this,
            styles = host.get("styles"),
            labelStyle = styles.label,
            totalTitleSize = host._totalTitleSize,
            ttl = Math.round(host.get("bottomTickOffset") + host._maxLabelSize + labelStyle.margin.top + totalTitleSize);
        _yuitest_coverline("/build/charts-base/charts-base.js", 1526);
if(host._explicitHeight)
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 1528);
ttl = host._explicitHeight;
        }
        _yuitest_coverline("/build/charts-base/charts-base.js", 1530);
host.set("calculatedHeight", ttl);
    }
};
_yuitest_coverline("/build/charts-base/charts-base.js", 1533);
Y.BottomAxisLayout = BottomAxisLayout;
/**
 * Contains algorithms for rendering a top axis.
 *
 * @module charts
 * @submodule charts-base
 * @class TopAxisLayout
 * @constructor
 */
_yuitest_coverline("/build/charts-base/charts-base.js", 1542);
TopAxisLayout = function(){};

_yuitest_coverline("/build/charts-base/charts-base.js", 1544);
TopAxisLayout.prototype = {
    /**
     *  Default margins for text fields.
     *
     *  @private
     *  @method _getDefaultMargins
     *  @return Object
     */
    _getDefaultMargins: function() 
    {
        _yuitest_coverfunc("/build/charts-base/charts-base.js", "_getDefaultMargins", 1552);
_yuitest_coverline("/build/charts-base/charts-base.js", 1554);
return {
            top: 0,
            left: 0,
            right: 0,
            bottom: 4
        };
    },
    
    /**
     * Sets the length of the tick on either side of the axis line.
     *
     * @method setTickOffsets
     * @protected
     */
    setTickOffsets: function()
    {
        _yuitest_coverfunc("/build/charts-base/charts-base.js", "setTickOffsets", 1568);
_yuitest_coverline("/build/charts-base/charts-base.js", 1570);
var host = this,
            majorTicks = host.get("styles").majorTicks,
            tickLength = majorTicks.length,
            halfTick = tickLength * 0.5,
            display = majorTicks.display;
        _yuitest_coverline("/build/charts-base/charts-base.js", 1575);
host.set("leftTickOffset",  0);
        _yuitest_coverline("/build/charts-base/charts-base.js", 1576);
host.set("rightTickOffset",  0);
        _yuitest_coverline("/build/charts-base/charts-base.js", 1577);
switch(display)
        {
            case "inside" :
                _yuitest_coverline("/build/charts-base/charts-base.js", 1580);
host.set("bottomTickOffset", tickLength);
                _yuitest_coverline("/build/charts-base/charts-base.js", 1581);
host.set("topTickOffset", 0);
            _yuitest_coverline("/build/charts-base/charts-base.js", 1582);
break;
            case "outside" : 
                _yuitest_coverline("/build/charts-base/charts-base.js", 1584);
host.set("bottomTickOffset", 0);
                _yuitest_coverline("/build/charts-base/charts-base.js", 1585);
host.set("topTickOffset",  tickLength);
            _yuitest_coverline("/build/charts-base/charts-base.js", 1586);
break;
            case "cross" :
                _yuitest_coverline("/build/charts-base/charts-base.js", 1588);
host.set("topTickOffset", halfTick);
                _yuitest_coverline("/build/charts-base/charts-base.js", 1589);
host.set("bottomTickOffset", halfTick);
            _yuitest_coverline("/build/charts-base/charts-base.js", 1590);
break;
            default:
                _yuitest_coverline("/build/charts-base/charts-base.js", 1592);
host.set("topTickOffset", 0);
                _yuitest_coverline("/build/charts-base/charts-base.js", 1593);
host.set("bottomTickOffset", 0);
            _yuitest_coverline("/build/charts-base/charts-base.js", 1594);
break;
        }
    },

    /**
     * Calculates the coordinates for the first point on an axis.
     *
     * @method getLineStart
     * @protected
     */
    getLineStart: function()
    {
        _yuitest_coverfunc("/build/charts-base/charts-base.js", "getLineStart", 1604);
_yuitest_coverline("/build/charts-base/charts-base.js", 1606);
var host = this,
            style = host.get("styles"),
            padding = style.padding,
            majorTicks = style.majorTicks,
            tickLength = majorTicks.length,
            display = majorTicks.display,
            pt = {x:0, y:padding.top};
        _yuitest_coverline("/build/charts-base/charts-base.js", 1613);
if(display === "outside")
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 1615);
pt.y += tickLength;
        }
        else {_yuitest_coverline("/build/charts-base/charts-base.js", 1617);
if(display === "cross")
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 1619);
pt.y += tickLength/2;
        }}
        _yuitest_coverline("/build/charts-base/charts-base.js", 1621);
return pt; 
    },
    
    /**
     * Draws a tick
     *
     * @method drawTick
     * @param {Path} path reference to the path `Path` element in which to draw the tick.
     * @param {Object} pt hash containing x and y coordinates
     * @param {Object} tickStyles hash of properties used to draw the tick
     * @protected
     */
    drawTick: function(path, pt, tickStyles)
    {
        _yuitest_coverfunc("/build/charts-base/charts-base.js", "drawTick", 1633);
_yuitest_coverline("/build/charts-base/charts-base.js", 1635);
var host = this,
            style = host.get("styles"),
            padding = style.padding,
            tickLength = tickStyles.length,
            start = {x:pt.x, y:padding.top},
            end = {x:pt.x, y:tickLength + padding.top};
        _yuitest_coverline("/build/charts-base/charts-base.js", 1641);
host.drawLine(path, start, end);
    },
    
    /**
     * Calculates the point for a label.
     *
     * @method getLabelPoint
     * @param {Object} pt hash containing x and y coordinates
     * @return Object
     * @protected
     */
    getLabelPoint: function(pt)
    {
        _yuitest_coverfunc("/build/charts-base/charts-base.js", "getLabelPoint", 1652);
_yuitest_coverline("/build/charts-base/charts-base.js", 1654);
return {x:pt.x, y:pt.y - this.get("topTickOffset")};
    },
    
    /**
     * Updates the value for the `maxLabelSize` for use in calculating total size.
     *
     * @method updateMaxLabelSize
     * @param {HTMLElement} label to measure
     * @protected
     */
    updateMaxLabelSize: function(labelWidth, labelHeight)
    {
        _yuitest_coverfunc("/build/charts-base/charts-base.js", "updateMaxLabelSize", 1664);
_yuitest_coverline("/build/charts-base/charts-base.js", 1666);
var host = this,
            props = this._labelRotationProps,
            rot = props.rot,
            absRot = props.absRot,
            sinRadians = props.sinRadians,
            cosRadians = props.cosRadians,
            max;
        _yuitest_coverline("/build/charts-base/charts-base.js", 1673);
if(rot === 0)
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 1675);
max = labelHeight;
        }
        else {_yuitest_coverline("/build/charts-base/charts-base.js", 1677);
if(absRot === 90)
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 1679);
max = labelWidth;
        }
        else
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 1683);
max = (sinRadians * labelWidth) + (cosRadians * labelHeight); 
        }}
        _yuitest_coverline("/build/charts-base/charts-base.js", 1685);
host._maxLabelSize = Math.max(host._maxLabelSize, max);
    },

    /**
     * Determines the available label height when the axis width has been explicitly set.
     *
     * @method getExplicitlySized
     * @return Boolean
     * @protected
     */
    getExplicitlySized: function(styles)
    {
        _yuitest_coverfunc("/build/charts-base/charts-base.js", "getExplicitlySized", 1695);
_yuitest_coverline("/build/charts-base/charts-base.js", 1697);
if(this._explicitHeight)
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 1699);
var host = this,
                h = host._explicitHeight,
                totalTitleSize = host._totalTitleSize,
                topTickOffset = host.get("topTickOffset"),
                margin = styles.label.margin.right;
            _yuitest_coverline("/build/charts-base/charts-base.js", 1704);
host._maxLabelSize =  h - (topTickOffset + margin + totalTitleSize);
            _yuitest_coverline("/build/charts-base/charts-base.js", 1705);
return true;
        }
        _yuitest_coverline("/build/charts-base/charts-base.js", 1707);
return false;
    },

    /**
     * Rotate and position title.
     *
     * @method positionTitle
     * @param {HTMLElement} label to rotate position
     * @protected
     */
    positionTitle: function(label)
    {
        _yuitest_coverfunc("/build/charts-base/charts-base.js", "positionTitle", 1717);
_yuitest_coverline("/build/charts-base/charts-base.js", 1719);
var host = this,
            bounds = host._titleBounds,
            margin = host.get("styles").title.margin,
            props = host._titleRotationProps,
            labelWidth = label.offsetWidth,
            labelHeight = label.offsetHeight,
            h = bounds.bottom - bounds.top,
            x = (host.get("width") * 0.5) - (labelWidth * 0.5),
            y = h/2 - labelHeight/2;
        _yuitest_coverline("/build/charts-base/charts-base.js", 1728);
props.labelWidth = labelWidth;
        _yuitest_coverline("/build/charts-base/charts-base.js", 1729);
props.labelHeight = labelHeight;
        _yuitest_coverline("/build/charts-base/charts-base.js", 1730);
if(margin && margin.top)
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 1732);
y += margin.top;
        }
        _yuitest_coverline("/build/charts-base/charts-base.js", 1734);
props.x = x;
        _yuitest_coverline("/build/charts-base/charts-base.js", 1735);
props.y = y;
        _yuitest_coverline("/build/charts-base/charts-base.js", 1736);
props.transformOrigin = [0.5, 0.5];
        _yuitest_coverline("/build/charts-base/charts-base.js", 1737);
host._rotate(label, props);
    },

    /**
     * Rotate and position labels.
     *
     * @method positionLabel
     * @param {HTMLElement} label to rotate position
     * @param {Object} pt hash containing the x and y coordinates in which the label will be positioned
     * against.
     * @protected
     */
    positionLabel: function(label, pt, styles, i)
    {
        _yuitest_coverfunc("/build/charts-base/charts-base.js", "positionLabel", 1749);
_yuitest_coverline("/build/charts-base/charts-base.js", 1751);
var host = this,
            totalTitleSize = this._totalTitleSize,
            maxLabelSize = host._maxLabelSize,
            leftOffset = pt.x,
            topOffset = pt.y + totalTitleSize + maxLabelSize,
            props = this._labelRotationProps,
            rot = props.rot,
            absRot = props.absRot,
            labelWidth = this._labelWidths[i],
            labelHeight = this._labelHeights[i];
        _yuitest_coverline("/build/charts-base/charts-base.js", 1761);
if(rot === 0)
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 1763);
leftOffset -= labelWidth * 0.5;
            _yuitest_coverline("/build/charts-base/charts-base.js", 1764);
topOffset -= labelHeight;
        }
        else
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 1768);
if(rot === 90)
            {
                _yuitest_coverline("/build/charts-base/charts-base.js", 1770);
leftOffset -= labelWidth;
                _yuitest_coverline("/build/charts-base/charts-base.js", 1771);
topOffset -= (labelHeight * 0.5);
            }
            else {_yuitest_coverline("/build/charts-base/charts-base.js", 1773);
if (rot === -90)
            {
                _yuitest_coverline("/build/charts-base/charts-base.js", 1775);
topOffset -= (labelHeight * 0.5);
            }    
            else {_yuitest_coverline("/build/charts-base/charts-base.js", 1777);
if(rot > 0)
            {
                _yuitest_coverline("/build/charts-base/charts-base.js", 1779);
leftOffset -= labelWidth;
                _yuitest_coverline("/build/charts-base/charts-base.js", 1780);
topOffset -= labelHeight - (labelHeight * rot/180);
            }
            else
            {
                _yuitest_coverline("/build/charts-base/charts-base.js", 1784);
topOffset -= labelHeight - (labelHeight * absRot/180);
            }}}
        }
        _yuitest_coverline("/build/charts-base/charts-base.js", 1787);
props.x = Math.round(leftOffset);
        _yuitest_coverline("/build/charts-base/charts-base.js", 1788);
props.y = Math.round(topOffset);
        _yuitest_coverline("/build/charts-base/charts-base.js", 1789);
props.labelWidth = labelWidth;
        _yuitest_coverline("/build/charts-base/charts-base.js", 1790);
props.labelHeight = labelHeight;
        _yuitest_coverline("/build/charts-base/charts-base.js", 1791);
this._rotate(label, props);
    },

    /**
     * Adjusts the coordinates of an axis label based on the rotation.
     *
     * @method _setRotationCoords
     * @param {Object} props Coordinates, dimension and rotation properties of the label.
     * @protected
     */
    _setRotationCoords: function(props)
    {
        _yuitest_coverfunc("/build/charts-base/charts-base.js", "_setRotationCoords", 1801);
_yuitest_coverline("/build/charts-base/charts-base.js", 1803);
var rot = props.rot,
            absRot = props.absRot,
            labelWidth = props.labelWidth,
            labelHeight = props.labelHeight,
            leftOffset,
            topOffset;
        _yuitest_coverline("/build/charts-base/charts-base.js", 1809);
if(rot === 0)
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 1811);
leftOffset = labelWidth * 0.5;
            _yuitest_coverline("/build/charts-base/charts-base.js", 1812);
topOffset = labelHeight;
        }
        else
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 1816);
if(rot === 90)
            {
                _yuitest_coverline("/build/charts-base/charts-base.js", 1818);
leftOffset = labelWidth;
                _yuitest_coverline("/build/charts-base/charts-base.js", 1819);
topOffset = (labelHeight * 0.5);
            }
            else {_yuitest_coverline("/build/charts-base/charts-base.js", 1821);
if (rot === -90)
            {
                _yuitest_coverline("/build/charts-base/charts-base.js", 1823);
topOffset = (labelHeight * 0.5);
            }    
            else {_yuitest_coverline("/build/charts-base/charts-base.js", 1825);
if(rot > 0)
            {
                _yuitest_coverline("/build/charts-base/charts-base.js", 1827);
leftOffset = labelWidth;
                _yuitest_coverline("/build/charts-base/charts-base.js", 1828);
topOffset = labelHeight - (labelHeight * rot/180);
            }
            else
            {
                _yuitest_coverline("/build/charts-base/charts-base.js", 1832);
topOffset = labelHeight - (labelHeight * absRot/180);
            }}}
        }
        _yuitest_coverline("/build/charts-base/charts-base.js", 1835);
props.x -= leftOffset;
        _yuitest_coverline("/build/charts-base/charts-base.js", 1836);
props.y -= topOffset;
    },

    /**
     * Returns the transformOrigin to use for an axis label based on the position of the axis 
     * and the rotation of the label.
     *
     * @method _getTransformOrigin
     * @param {Number} rot The rotation (in degrees) of the label.
     * @return Array
     * @protected
     */
    _getTransformOrigin: function(rot)
    {
        _yuitest_coverfunc("/build/charts-base/charts-base.js", "_getTransformOrigin", 1848);
_yuitest_coverline("/build/charts-base/charts-base.js", 1850);
var transformOrigin;
        _yuitest_coverline("/build/charts-base/charts-base.js", 1851);
if(rot === 0)
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 1853);
transformOrigin = [0, 0];
        }
        else
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 1857);
if(rot === 90)
            {
                _yuitest_coverline("/build/charts-base/charts-base.js", 1859);
transformOrigin = [1, 0.5];
            }
            else {_yuitest_coverline("/build/charts-base/charts-base.js", 1861);
if (rot === -90)
            {
                _yuitest_coverline("/build/charts-base/charts-base.js", 1863);
transformOrigin = [0, 0.5];
            }    
            else {_yuitest_coverline("/build/charts-base/charts-base.js", 1865);
if(rot > 0)
            {
                _yuitest_coverline("/build/charts-base/charts-base.js", 1867);
transformOrigin = [1, 0.5];
            }
            else
            {
                _yuitest_coverline("/build/charts-base/charts-base.js", 1871);
transformOrigin = [0, 0.5];
            }}}
        }
        _yuitest_coverline("/build/charts-base/charts-base.js", 1874);
return transformOrigin;
    },

    /**
     * Adjusts position for inner ticks.
     *
     * @method offsetNodeForTick
     * @param {Node} cb contentBox of the axis
     * @protected
     */
    offsetNodeForTick: function(cb)
    {
    },

    /**
     * Assigns a height based on the size of the contents.
     *
     * @method setCalculatedSize
     * @protected
     */
    setCalculatedSize: function()
    {
        _yuitest_coverfunc("/build/charts-base/charts-base.js", "setCalculatedSize", 1894);
_yuitest_coverline("/build/charts-base/charts-base.js", 1896);
var host = this,
            graphic = host.get("graphic"),
            styles = host.get("styles"),
            labelMargin = styles.label.margin,
            totalLabelSize = labelMargin.bottom + host._maxLabelSize,
            totalTitleSize = host._totalTitleSize,
            topTickOffset = this.get("topTickOffset"),
            ttl = Math.round(topTickOffset + totalLabelSize + totalTitleSize);
        _yuitest_coverline("/build/charts-base/charts-base.js", 1904);
if(this._explicitHeight)
        {
           _yuitest_coverline("/build/charts-base/charts-base.js", 1906);
ttl = this._explicitWidth; 
        }
        _yuitest_coverline("/build/charts-base/charts-base.js", 1908);
host.set("calculatedHeight", ttl);
        _yuitest_coverline("/build/charts-base/charts-base.js", 1909);
graphic.set("y", ttl - topTickOffset);
    }
};
_yuitest_coverline("/build/charts-base/charts-base.js", 1912);
Y.TopAxisLayout = TopAxisLayout;

/**
 * The Axis class. Generates axes for a chart.
 *
 * @module charts
 * @submodule charts-base
 * @class Axis
 * @extends Widget
 * @uses Renderer
 * @constructor
 * @param {Object} config (optional) Configuration parameters for the Chart.
 */
_yuitest_coverline("/build/charts-base/charts-base.js", 1925);
Y.Axis = Y.Base.create("axis", Y.Widget, [Y.Renderer], {
    /**
     * Storage for calculatedWidth value.
     *
     * @property _calculatedWidth
     * @type Number
     * @private
     */
    _calculatedWidth: 0,

    /**
     * Storage for calculatedHeight value.
     *
     * @property _calculatedHeight
     * @type Number
     * @private
     */
    _calculatedHeight: 0,

    /**
     * Handles change to the dataProvider
     * 
     * @method _dataChangeHandler
     * @param {Object} e Event object
     * @private
     */
    _dataChangeHandler: function(e)
    {
        _yuitest_coverfunc("/build/charts-base/charts-base.js", "_dataChangeHandler", 1951);
_yuitest_coverline("/build/charts-base/charts-base.js", 1953);
if(this.get("rendered"))
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 1955);
this._drawAxis();
        }
    },

    /**
     * Handles change to the position attribute
     *
     * @method _positionChangeHandler
     * @param {Object} e Event object
     * @private
     */
    _positionChangeHandler: function(e)
    {
        _yuitest_coverfunc("/build/charts-base/charts-base.js", "_positionChangeHandler", 1966);
_yuitest_coverline("/build/charts-base/charts-base.js", 1968);
this._updateGraphic(e.newVal);
        _yuitest_coverline("/build/charts-base/charts-base.js", 1969);
this._updateHandler();
    },

    /**
     * Updates the the Graphic instance
     *
     * @method _updateGraphic
     * @param {String} position Position of axis 
     * @private
     */
    _updateGraphic: function(position)
    {
        _yuitest_coverfunc("/build/charts-base/charts-base.js", "_updateGraphic", 1979);
_yuitest_coverline("/build/charts-base/charts-base.js", 1981);
var graphic = this.get("graphic");
        _yuitest_coverline("/build/charts-base/charts-base.js", 1982);
if(position == "none")
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 1984);
if(graphic)
            {
                _yuitest_coverline("/build/charts-base/charts-base.js", 1986);
graphic.destroy();
            }
        }
        else
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 1991);
if(!graphic)
            {
                _yuitest_coverline("/build/charts-base/charts-base.js", 1993);
this._setCanvas();
            }
        }
    },

    /**
     * Handles changes to axis.
     *
     * @method _updateHandler
     * @param {Object} e Event object
     * @private
     */
    _updateHandler: function(e)
    {
        _yuitest_coverfunc("/build/charts-base/charts-base.js", "_updateHandler", 2005);
_yuitest_coverline("/build/charts-base/charts-base.js", 2007);
if(this.get("rendered"))
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 2009);
this._drawAxis();
        }
    },
   
    /**
     * @method renderUI
     * @private
     */
    renderUI: function()
    {
        _yuitest_coverfunc("/build/charts-base/charts-base.js", "renderUI", 2017);
_yuitest_coverline("/build/charts-base/charts-base.js", 2019);
this._updateGraphic(this.get("position"));
    },

    /**
     * @method syncUI
     * @private
     */
    syncUI: function()
    {
        _yuitest_coverfunc("/build/charts-base/charts-base.js", "syncUI", 2026);
_yuitest_coverline("/build/charts-base/charts-base.js", 2028);
var layout = this._layout,
            defaultMargins,
            styles,
            label,
            title,
            i;
        _yuitest_coverline("/build/charts-base/charts-base.js", 2034);
if(layout)
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 2036);
defaultMargins = layout._getDefaultMargins();
            _yuitest_coverline("/build/charts-base/charts-base.js", 2037);
styles = this.get("styles");
            _yuitest_coverline("/build/charts-base/charts-base.js", 2038);
label = styles.label.margin;
            _yuitest_coverline("/build/charts-base/charts-base.js", 2039);
title =styles.title.margin;
            //need to defaultMargins method to the layout classes.
            _yuitest_coverline("/build/charts-base/charts-base.js", 2041);
for(i in defaultMargins)
            {
                _yuitest_coverline("/build/charts-base/charts-base.js", 2043);
if(defaultMargins.hasOwnProperty(i))
                {
                    _yuitest_coverline("/build/charts-base/charts-base.js", 2045);
label[i] = label[i] === undefined ? defaultMargins[i] : label[i];
                    _yuitest_coverline("/build/charts-base/charts-base.js", 2046);
title[i] = title[i] === undefined ? defaultMargins[i] : title[i];
                }
            }
        }
        _yuitest_coverline("/build/charts-base/charts-base.js", 2050);
this._drawAxis();
    },

    /**
     * Creates a graphic instance to be used for the axis line and ticks.
     *
     * @method _setCanvas
     * @private
     */
    _setCanvas: function()
    {
        _yuitest_coverfunc("/build/charts-base/charts-base.js", "_setCanvas", 2059);
_yuitest_coverline("/build/charts-base/charts-base.js", 2061);
var cb = this.get("contentBox"),
            bb = this.get("boundingBox"),
            p = this.get("position"),
            pn = this._parentNode,
            w = this.get("width"),
            h = this.get("height");
        _yuitest_coverline("/build/charts-base/charts-base.js", 2067);
bb.setStyle("position", "absolute");
        _yuitest_coverline("/build/charts-base/charts-base.js", 2068);
bb.setStyle("zIndex", 2);
        _yuitest_coverline("/build/charts-base/charts-base.js", 2069);
w = w ? w + "px" : pn.getStyle("width");
        _yuitest_coverline("/build/charts-base/charts-base.js", 2070);
h = h ? h + "px" : pn.getStyle("height");
        _yuitest_coverline("/build/charts-base/charts-base.js", 2071);
if(p === "top" || p === "bottom")
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 2073);
cb.setStyle("width", w);
        }
        else
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 2077);
cb.setStyle("height", h);
        }
        _yuitest_coverline("/build/charts-base/charts-base.js", 2079);
cb.setStyle("position", "relative");
        _yuitest_coverline("/build/charts-base/charts-base.js", 2080);
cb.setStyle("left", "0px");
        _yuitest_coverline("/build/charts-base/charts-base.js", 2081);
cb.setStyle("top", "0px");
        _yuitest_coverline("/build/charts-base/charts-base.js", 2082);
this.set("graphic", new Y.Graphic());
        _yuitest_coverline("/build/charts-base/charts-base.js", 2083);
this.get("graphic").render(cb);
    },
	
    /**
     * Gets the default value for the `styles` attribute. Overrides
     * base implementation.
     *
     * @method _getDefaultStyles
     * @return Object
     * @protected
     */
    _getDefaultStyles: function()
    {
        _yuitest_coverfunc("/build/charts-base/charts-base.js", "_getDefaultStyles", 2094);
_yuitest_coverline("/build/charts-base/charts-base.js", 2096);
var axisstyles = {
            majorTicks: {
                display:"inside",
                length:4,
                color:"#dad8c9",
                weight:1,
                alpha:1
            },
            minorTicks: {
                display:"none",
                length:2,
                color:"#dad8c9",
                weight:1
            },
            line: {
                weight:1,
                color:"#dad8c9",
                alpha:1
            },
            majorUnit: {
                determinant:"count",
                count:11,
                distance:75
            },
            top: "0px",
            left: "0px",
            width: "100px",
            height: "100px",
            label: {
                color:"#808080",
                alpha: 1,
                fontSize:"85%",
                rotation: 0,
                margin: {
                    top: undefined,
                    right: undefined,
                    bottom: undefined,
                    left: undefined
                }
            },
            title: {
                color:"#808080",
                alpha: 1,
                fontSize:"85%",
                rotation: undefined,
                margin: {
                    top: undefined,
                    right: undefined,
                    bottom: undefined,
                    left: undefined
                }
            },
            hideOverlappingLabelTicks: false
        };
        
        _yuitest_coverline("/build/charts-base/charts-base.js", 2151);
return Y.merge(Y.Renderer.prototype._getDefaultStyles(), axisstyles); 
    },

    /**
     * Updates the axis when the size changes.
     *
     * @method _handleSizeChange
     * @param {Object} e Event object.
     * @private
     */
    _handleSizeChange: function(e)
    {
        _yuitest_coverfunc("/build/charts-base/charts-base.js", "_handleSizeChange", 2161);
_yuitest_coverline("/build/charts-base/charts-base.js", 2163);
var attrName = e.attrName,
            pos = this.get("position"),
            vert = pos == "left" || pos == "right",
            cb = this.get("contentBox"),
            hor = pos == "bottom" || pos == "top";
        _yuitest_coverline("/build/charts-base/charts-base.js", 2168);
cb.setStyle("width", this.get("width"));
        _yuitest_coverline("/build/charts-base/charts-base.js", 2169);
cb.setStyle("height", this.get("height"));
        _yuitest_coverline("/build/charts-base/charts-base.js", 2170);
if((hor && attrName == "width") || (vert && attrName == "height"))
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 2172);
this._drawAxis();
        }
    },
   
    /**
     * Maps key values to classes containing layout algorithms
     *
     * @property _layoutClasses
     * @type Object
     * @private
     */
    _layoutClasses: 
    {
        top : TopAxisLayout,
        bottom: BottomAxisLayout,
        left: LeftAxisLayout,
        right : RightAxisLayout
    },
    
    /**
     * Draws a line segment between 2 points
     *
     * @method drawLine
     * @param {Object} startPoint x and y coordinates for the start point of the line segment
     * @param {Object} endPoint x and y coordinates for the for the end point of the line segment
     * @param {Object} line styles (weight, color and alpha to be applied to the line segment)
     * @private
     */
    drawLine: function(path, startPoint, endPoint)
    {
        _yuitest_coverfunc("/build/charts-base/charts-base.js", "drawLine", 2200);
_yuitest_coverline("/build/charts-base/charts-base.js", 2202);
path.moveTo(startPoint.x, startPoint.y);
        _yuitest_coverline("/build/charts-base/charts-base.js", 2203);
path.lineTo(endPoint.x, endPoint.y);
    },

    /**
     * Generates the properties necessary for rotating and positioning a text field.
     *
     * @method _getTextRotationProps
     * @param {Object} styles properties for the text field
     * @return Object
     * @private
     */
    _getTextRotationProps: function(styles)
    {
        _yuitest_coverfunc("/build/charts-base/charts-base.js", "_getTextRotationProps", 2214);
_yuitest_coverline("/build/charts-base/charts-base.js", 2216);
if(styles.rotation === undefined)
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 2218);
switch(this.get("position"))
            {
                case "left" :
                    _yuitest_coverline("/build/charts-base/charts-base.js", 2221);
styles.rotation = -90;
                _yuitest_coverline("/build/charts-base/charts-base.js", 2222);
break; 
                case "right" : 
                    _yuitest_coverline("/build/charts-base/charts-base.js", 2224);
styles.rotation = 90;
                _yuitest_coverline("/build/charts-base/charts-base.js", 2225);
break;
                default :
                    _yuitest_coverline("/build/charts-base/charts-base.js", 2227);
styles.rotation = 0;
                _yuitest_coverline("/build/charts-base/charts-base.js", 2228);
break;
            }
        }
        _yuitest_coverline("/build/charts-base/charts-base.js", 2231);
var rot =  Math.min(90, Math.max(-90, styles.rotation)),
            absRot = Math.abs(rot),
            radCon = Math.PI/180,
            sinRadians = parseFloat(parseFloat(Math.sin(absRot * radCon)).toFixed(8)),
            cosRadians = parseFloat(parseFloat(Math.cos(absRot * radCon)).toFixed(8));
        _yuitest_coverline("/build/charts-base/charts-base.js", 2236);
return {
            rot: rot,
            absRot: absRot,
            radCon: radCon,
            sinRadians: sinRadians,
            cosRadians: cosRadians,
            textAlpha: styles.alpha
        };
    },

    /**
     * Draws an axis. 
     *
     * @method _drawAxis
     * @private
     */
    _drawAxis: function ()
    {
        _yuitest_coverfunc("/build/charts-base/charts-base.js", "_drawAxis", 2252);
_yuitest_coverline("/build/charts-base/charts-base.js", 2254);
if(this._drawing)
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 2256);
this._callLater = true;
            _yuitest_coverline("/build/charts-base/charts-base.js", 2257);
return;
        }
        _yuitest_coverline("/build/charts-base/charts-base.js", 2259);
this._drawing = true;
        _yuitest_coverline("/build/charts-base/charts-base.js", 2260);
this._callLater = false;
        _yuitest_coverline("/build/charts-base/charts-base.js", 2261);
if(this._layout)
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 2263);
var styles = this.get("styles"),
                line = styles.line,
                labelStyles = styles.label,
                majorTickStyles = styles.majorTicks,
                drawTicks = majorTickStyles.display != "none",
                tickPoint,
                majorUnit = styles.majorUnit,
                len,
                majorUnitDistance,
                i = 0,
                layout = this._layout,
                layoutLength,
                position,
                lineStart,
                label,
                labelWidth,
                labelHeight,
                labelFunction = this.get("labelFunction"),
                labelFunctionScope = this.get("labelFunctionScope"),
                labelFormat = this.get("labelFormat"),
                graphic = this.get("graphic"),
                path = this.get("path"),
                tickPath,
                explicitlySized;
            _yuitest_coverline("/build/charts-base/charts-base.js", 2287);
this._labelWidths = [];
            _yuitest_coverline("/build/charts-base/charts-base.js", 2288);
this._labelHeights = [];
            _yuitest_coverline("/build/charts-base/charts-base.js", 2289);
graphic.set("autoDraw", false);
            _yuitest_coverline("/build/charts-base/charts-base.js", 2290);
path.clear();
            _yuitest_coverline("/build/charts-base/charts-base.js", 2291);
path.set("stroke", {
                weight: line.weight, 
                color: line.color, 
                opacity: line.alpha
            });
            _yuitest_coverline("/build/charts-base/charts-base.js", 2296);
this._labelRotationProps = this._getTextRotationProps(labelStyles);
            _yuitest_coverline("/build/charts-base/charts-base.js", 2297);
this._labelRotationProps.transformOrigin = layout._getTransformOrigin(this._labelRotationProps.rot);
            _yuitest_coverline("/build/charts-base/charts-base.js", 2298);
layout.setTickOffsets.apply(this);
            _yuitest_coverline("/build/charts-base/charts-base.js", 2299);
layoutLength = this.getLength();
            _yuitest_coverline("/build/charts-base/charts-base.js", 2300);
lineStart = layout.getLineStart.apply(this);
            _yuitest_coverline("/build/charts-base/charts-base.js", 2301);
len = this.getTotalMajorUnits(majorUnit);
            _yuitest_coverline("/build/charts-base/charts-base.js", 2302);
majorUnitDistance = this.getMajorUnitDistance(len, layoutLength, majorUnit);
            _yuitest_coverline("/build/charts-base/charts-base.js", 2303);
this.set("edgeOffset", this.getEdgeOffset(len, layoutLength) * 0.5);
            _yuitest_coverline("/build/charts-base/charts-base.js", 2304);
if(len < 1)
            {
                _yuitest_coverline("/build/charts-base/charts-base.js", 2306);
this._clearLabelCache();
            }
            else
            {
                _yuitest_coverline("/build/charts-base/charts-base.js", 2310);
tickPoint = this.getFirstPoint(lineStart);
                _yuitest_coverline("/build/charts-base/charts-base.js", 2311);
this.drawLine(path, lineStart, this.getLineEnd(tickPoint));
                _yuitest_coverline("/build/charts-base/charts-base.js", 2312);
if(drawTicks) 
                {
                    _yuitest_coverline("/build/charts-base/charts-base.js", 2314);
tickPath = this.get("tickPath");
                    _yuitest_coverline("/build/charts-base/charts-base.js", 2315);
tickPath.clear();
                    _yuitest_coverline("/build/charts-base/charts-base.js", 2316);
tickPath.set("stroke", {
                        weight: majorTickStyles.weight,
                        color: majorTickStyles.color,
                        opacity: majorTickStyles.alpha
                    });
                   _yuitest_coverline("/build/charts-base/charts-base.js", 2321);
layout.drawTick.apply(this, [tickPath, tickPoint, majorTickStyles]);
                }
                _yuitest_coverline("/build/charts-base/charts-base.js", 2323);
this._createLabelCache();
                _yuitest_coverline("/build/charts-base/charts-base.js", 2324);
this._tickPoints = [];
                _yuitest_coverline("/build/charts-base/charts-base.js", 2325);
this._maxLabelSize = 0; 
                _yuitest_coverline("/build/charts-base/charts-base.js", 2326);
this._totalTitleSize = 0;
                _yuitest_coverline("/build/charts-base/charts-base.js", 2327);
this._titleSize = 0;
                _yuitest_coverline("/build/charts-base/charts-base.js", 2328);
this._setTitle();
                _yuitest_coverline("/build/charts-base/charts-base.js", 2329);
explicitlySized = layout.getExplicitlySized.apply(this, [styles]);
                _yuitest_coverline("/build/charts-base/charts-base.js", 2330);
for(; i < len; ++i)
                {
                    _yuitest_coverline("/build/charts-base/charts-base.js", 2332);
if(drawTicks) 
                    {
                        _yuitest_coverline("/build/charts-base/charts-base.js", 2334);
layout.drawTick.apply(this, [tickPath, tickPoint, majorTickStyles]);
                    }
                    _yuitest_coverline("/build/charts-base/charts-base.js", 2336);
position = this.getPosition(tickPoint);
                    _yuitest_coverline("/build/charts-base/charts-base.js", 2337);
label = this.getLabel(tickPoint, labelStyles);
                    _yuitest_coverline("/build/charts-base/charts-base.js", 2338);
this._labels.push(label);
                    _yuitest_coverline("/build/charts-base/charts-base.js", 2339);
this._tickPoints.push({x:tickPoint.x, y:tickPoint.y});
                    _yuitest_coverline("/build/charts-base/charts-base.js", 2340);
this.get("appendLabelFunction")(label, labelFunction.apply(labelFunctionScope, [this.getLabelByIndex(i, len), labelFormat]));
                    _yuitest_coverline("/build/charts-base/charts-base.js", 2341);
labelWidth = Math.round(label.offsetWidth);
                    _yuitest_coverline("/build/charts-base/charts-base.js", 2342);
labelHeight = Math.round(label.offsetHeight);
                    _yuitest_coverline("/build/charts-base/charts-base.js", 2343);
if(!explicitlySized)
                    {
                        _yuitest_coverline("/build/charts-base/charts-base.js", 2345);
this._layout.updateMaxLabelSize.apply(this, [labelWidth, labelHeight]);
                    }
                    _yuitest_coverline("/build/charts-base/charts-base.js", 2347);
this._labelWidths.push(labelWidth);
                    _yuitest_coverline("/build/charts-base/charts-base.js", 2348);
this._labelHeights.push(labelHeight);
                    _yuitest_coverline("/build/charts-base/charts-base.js", 2349);
tickPoint = this.getNextPoint(tickPoint, majorUnitDistance);
                }
                _yuitest_coverline("/build/charts-base/charts-base.js", 2351);
this._clearLabelCache();
                _yuitest_coverline("/build/charts-base/charts-base.js", 2352);
if(this.get("overlapGraph"))
                {
                   _yuitest_coverline("/build/charts-base/charts-base.js", 2354);
layout.offsetNodeForTick.apply(this, [this.get("contentBox")]);
                }
                _yuitest_coverline("/build/charts-base/charts-base.js", 2356);
layout.setCalculatedSize.apply(this);
                _yuitest_coverline("/build/charts-base/charts-base.js", 2357);
if(this._titleTextField)
                {
                    _yuitest_coverline("/build/charts-base/charts-base.js", 2359);
this._layout.positionTitle.apply(this, [this._titleTextField]);
                }
                _yuitest_coverline("/build/charts-base/charts-base.js", 2361);
for(i = 0; i < len; ++i)
                {
                    _yuitest_coverline("/build/charts-base/charts-base.js", 2363);
layout.positionLabel.apply(this, [this.get("labels")[i], this._tickPoints[i], styles, i]);
                }
            }
        }
        _yuitest_coverline("/build/charts-base/charts-base.js", 2367);
this._drawing = false;
        _yuitest_coverline("/build/charts-base/charts-base.js", 2368);
if(this._callLater)
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 2370);
this._drawAxis();
        }
        else
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 2374);
this._updatePathElement();
            _yuitest_coverline("/build/charts-base/charts-base.js", 2375);
this.fire("axisRendered");
        }
    },
    
    /**
     * Calculates and sets the total size of a title.
     *
     * @method _setTotalTitleSize
     * @param {Object} styles Properties for the title field.
     * @private
     */
    _setTotalTitleSize: function(styles)
    {
        _yuitest_coverfunc("/build/charts-base/charts-base.js", "_setTotalTitleSize", 2386);
_yuitest_coverline("/build/charts-base/charts-base.js", 2388);
var title = this._titleTextField,
            w = title.offsetWidth,
            h = title.offsetHeight,
            rot = this._titleRotationProps.rot,
            bounds,
            size,
            margin = styles.margin,
            position = this.get("position"),
            matrix = new Y.Matrix();
        _yuitest_coverline("/build/charts-base/charts-base.js", 2397);
matrix.rotate(rot);
        _yuitest_coverline("/build/charts-base/charts-base.js", 2398);
bounds = matrix.getContentRect(w, h);
        _yuitest_coverline("/build/charts-base/charts-base.js", 2399);
if(position == "left" || position == "right")
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 2401);
size = bounds.right - bounds.left;
            _yuitest_coverline("/build/charts-base/charts-base.js", 2402);
if(margin)
            {
                _yuitest_coverline("/build/charts-base/charts-base.js", 2404);
size += margin.left + margin.right;
            }
        }
        else
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 2409);
size = bounds.bottom - bounds.top;
            _yuitest_coverline("/build/charts-base/charts-base.js", 2410);
if(margin)
            {
                _yuitest_coverline("/build/charts-base/charts-base.js", 2412);
size += margin.top + margin.bottom;
            }
        }
        _yuitest_coverline("/build/charts-base/charts-base.js", 2415);
this._titleBounds = bounds;
        _yuitest_coverline("/build/charts-base/charts-base.js", 2416);
this._totalTitleSize = size;
    },

    /**
     *  Updates path.
     *
     *  @method _updatePathElement
     *  @private
     */
    _updatePathElement: function()
    {
        _yuitest_coverfunc("/build/charts-base/charts-base.js", "_updatePathElement", 2425);
_yuitest_coverline("/build/charts-base/charts-base.js", 2427);
var path = this._path,
            tickPath = this._tickPath,
            redrawGraphic = false,
            graphic = this.get("graphic");
        _yuitest_coverline("/build/charts-base/charts-base.js", 2431);
if(path)
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 2433);
redrawGraphic = true;
            _yuitest_coverline("/build/charts-base/charts-base.js", 2434);
path.end();
        }
        _yuitest_coverline("/build/charts-base/charts-base.js", 2436);
if(tickPath)
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 2438);
redrawGraphic = true;
            _yuitest_coverline("/build/charts-base/charts-base.js", 2439);
tickPath.end();
        }
        _yuitest_coverline("/build/charts-base/charts-base.js", 2441);
if(redrawGraphic)
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 2443);
graphic._redraw();
        }
    },

    /**
     * Updates the content and style properties for a title field.
     *
     * @method _updateTitle
     * @private
     */
    _setTitle: function()
    {
        _yuitest_coverfunc("/build/charts-base/charts-base.js", "_setTitle", 2453);
_yuitest_coverline("/build/charts-base/charts-base.js", 2455);
var i,
            styles,
            customStyles,
            title = this.get("title"),
            titleTextField = this._titleTextField,
            parentNode;
        _yuitest_coverline("/build/charts-base/charts-base.js", 2461);
if(title !== null && title !== undefined)
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 2463);
customStyles = {
                    rotation: "rotation",
                    margin: "margin",
                    alpha: "alpha"
            };
            _yuitest_coverline("/build/charts-base/charts-base.js", 2468);
styles = this.get("styles").title;
            _yuitest_coverline("/build/charts-base/charts-base.js", 2469);
if(!titleTextField)
            {
                _yuitest_coverline("/build/charts-base/charts-base.js", 2471);
titleTextField = DOCUMENT.createElement('span');
                _yuitest_coverline("/build/charts-base/charts-base.js", 2472);
titleTextField.style.display = "block";
                _yuitest_coverline("/build/charts-base/charts-base.js", 2473);
titleTextField.style.whiteSpace = "nowrap";
                _yuitest_coverline("/build/charts-base/charts-base.js", 2474);
titleTextField.setAttribute("class", "axisTitle");
                _yuitest_coverline("/build/charts-base/charts-base.js", 2475);
this.get("contentBox").append(titleTextField);
            }
            else {_yuitest_coverline("/build/charts-base/charts-base.js", 2477);
if(!DOCUMENT.createElementNS)
            {
                _yuitest_coverline("/build/charts-base/charts-base.js", 2479);
if(titleTextField.style.filter)
                {
                    _yuitest_coverline("/build/charts-base/charts-base.js", 2481);
titleTextField.style.filter = null;
                }
            }}
            _yuitest_coverline("/build/charts-base/charts-base.js", 2484);
titleTextField.style.position = "absolute";
            _yuitest_coverline("/build/charts-base/charts-base.js", 2485);
for(i in styles)
            {
                _yuitest_coverline("/build/charts-base/charts-base.js", 2487);
if(styles.hasOwnProperty(i) && !customStyles.hasOwnProperty(i))
                {
                    _yuitest_coverline("/build/charts-base/charts-base.js", 2489);
titleTextField.style[i] = styles[i];
                }
            }
            _yuitest_coverline("/build/charts-base/charts-base.js", 2492);
this.get("appendTitleFunction")(titleTextField, title);
            _yuitest_coverline("/build/charts-base/charts-base.js", 2493);
this._titleTextField = titleTextField;
            _yuitest_coverline("/build/charts-base/charts-base.js", 2494);
this._titleRotationProps = this._getTextRotationProps(styles);
            _yuitest_coverline("/build/charts-base/charts-base.js", 2495);
this._setTotalTitleSize(styles);
        }
        else {_yuitest_coverline("/build/charts-base/charts-base.js", 2497);
if(titleTextField)
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 2499);
parentNode = titleTextField.parentNode;
            _yuitest_coverline("/build/charts-base/charts-base.js", 2500);
if(parentNode)
            {
                _yuitest_coverline("/build/charts-base/charts-base.js", 2502);
parentNode.removeChild(titleTextField);
            }
            _yuitest_coverline("/build/charts-base/charts-base.js", 2504);
this._titleTextField = null;
            _yuitest_coverline("/build/charts-base/charts-base.js", 2505);
this._totalTitleSize = 0;
        }}
    },

    /**
     * Creates or updates an axis label.
     *
     * @method getLabel
     * @param {Object} pt x and y coordinates for the label
     * @param {Object} styles styles applied to label
     * @return HTMLElement 
     * @private
     */
    getLabel: function(pt, styles)
    {
        _yuitest_coverfunc("/build/charts-base/charts-base.js", "getLabel", 2518);
_yuitest_coverline("/build/charts-base/charts-base.js", 2520);
var i,
            label,
            labelCache = this._labelCache,
            customStyles = {
                rotation: "rotation",
                margin: "margin",
                alpha: "alpha"
            };
        _yuitest_coverline("/build/charts-base/charts-base.js", 2528);
if(labelCache && labelCache.length > 0)
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 2530);
label = labelCache.shift();
        }
        else
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 2534);
label = DOCUMENT.createElement("span");
            _yuitest_coverline("/build/charts-base/charts-base.js", 2535);
label.className = Y.Lang.trim([label.className, "axisLabel"].join(' '));
            _yuitest_coverline("/build/charts-base/charts-base.js", 2536);
this.get("contentBox").append(label);
        }
        _yuitest_coverline("/build/charts-base/charts-base.js", 2538);
if(!DOCUMENT.createElementNS)
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 2540);
if(label.style.filter)
            {
                _yuitest_coverline("/build/charts-base/charts-base.js", 2542);
label.style.filter = null;
            }
        }
        _yuitest_coverline("/build/charts-base/charts-base.js", 2545);
label.style.display = "block";
        _yuitest_coverline("/build/charts-base/charts-base.js", 2546);
label.style.whiteSpace = "nowrap";
        _yuitest_coverline("/build/charts-base/charts-base.js", 2547);
label.style.position = "absolute";
        _yuitest_coverline("/build/charts-base/charts-base.js", 2548);
for(i in styles)
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 2550);
if(styles.hasOwnProperty(i) && !customStyles.hasOwnProperty(i))
            {
                _yuitest_coverline("/build/charts-base/charts-base.js", 2552);
label.style[i] = styles[i];
            }
        }
        _yuitest_coverline("/build/charts-base/charts-base.js", 2555);
return label;
    },

    /**
     * Creates a cache of labels that can be re-used when the axis redraws.
     *
     * @method _createLabelCache
     * @private
     */
    _createLabelCache: function()
    {
        _yuitest_coverfunc("/build/charts-base/charts-base.js", "_createLabelCache", 2564);
_yuitest_coverline("/build/charts-base/charts-base.js", 2566);
if(this._labels)
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 2568);
while(this._labels.length > 0)
            {
                _yuitest_coverline("/build/charts-base/charts-base.js", 2570);
this._labelCache.push(this._labels.shift());
            }
        }
        else
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 2575);
this._clearLabelCache();
        }
        _yuitest_coverline("/build/charts-base/charts-base.js", 2577);
this._labels = [];
    },
    
    /**
     * Removes axis labels from the dom and clears the label cache.
     *
     * @method _clearLabelCache
     * @private
     */
    _clearLabelCache: function()
    {
        _yuitest_coverfunc("/build/charts-base/charts-base.js", "_clearLabelCache", 2586);
_yuitest_coverline("/build/charts-base/charts-base.js", 2588);
if(this._labelCache)
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 2590);
var len = this._labelCache.length,
                i = 0,
                label;
            _yuitest_coverline("/build/charts-base/charts-base.js", 2593);
for(; i < len; ++i)
            {
                _yuitest_coverline("/build/charts-base/charts-base.js", 2595);
label = this._labelCache[i];
                _yuitest_coverline("/build/charts-base/charts-base.js", 2596);
this._removeChildren(label);
                _yuitest_coverline("/build/charts-base/charts-base.js", 2597);
Y.Event.purgeElement(label, true);
                _yuitest_coverline("/build/charts-base/charts-base.js", 2598);
label.parentNode.removeChild(label);
            }
        }
        _yuitest_coverline("/build/charts-base/charts-base.js", 2601);
this._labelCache = [];
    },

    /**
     * Gets the end point of an axis.
     *
     * @method getLineEnd
     * @return Object
     * @private 
     */
    getLineEnd: function(pt)
    {
        _yuitest_coverfunc("/build/charts-base/charts-base.js", "getLineEnd", 2611);
_yuitest_coverline("/build/charts-base/charts-base.js", 2613);
var w = this.get("width"),
            h = this.get("height"),
            pos = this.get("position");
        _yuitest_coverline("/build/charts-base/charts-base.js", 2616);
if(pos === "top" || pos === "bottom")
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 2618);
return {x:w, y:pt.y};
        }
        else
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 2622);
return {x:pt.x, y:h};
        }
    },

    /**
     * Calcuates the width or height of an axis depending on its direction.
     *
     * @method getLength
     * @return Number
     * @private
     */
    getLength: function()
    {
        _yuitest_coverfunc("/build/charts-base/charts-base.js", "getLength", 2633);
_yuitest_coverline("/build/charts-base/charts-base.js", 2635);
var l,
            style = this.get("styles"),
            padding = style.padding,
            w = this.get("width"),
            h = this.get("height"),
            pos = this.get("position");
        _yuitest_coverline("/build/charts-base/charts-base.js", 2641);
if(pos === "top" || pos === "bottom")
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 2643);
l = w - (padding.left + padding.right);
        }
        else
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 2647);
l = h - (padding.top + padding.bottom);
        }
        _yuitest_coverline("/build/charts-base/charts-base.js", 2649);
return l;
    },

    /**
     * Gets the position of the first point on an axis.
     *
     * @method getFirstPoint
     * @param {Object} pt Object containing x and y coordinates.
     * @return Object
     * @private
     */
    getFirstPoint:function(pt)
    {
        _yuitest_coverfunc("/build/charts-base/charts-base.js", "getFirstPoint", 2660);
_yuitest_coverline("/build/charts-base/charts-base.js", 2662);
var style = this.get("styles"),
            pos = this.get("position"),
            padding = style.padding,
            np = {x:pt.x, y:pt.y};
        _yuitest_coverline("/build/charts-base/charts-base.js", 2666);
if(pos === "top" || pos === "bottom")
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 2668);
np.x += padding.left + this.get("edgeOffset");
        }
        else
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 2672);
np.y += this.get("height") - (padding.top + this.get("edgeOffset"));
        }
        _yuitest_coverline("/build/charts-base/charts-base.js", 2674);
return np;
    },

    /**
     * Gets the position of the next point on an axis.
     *
     * @method getNextPoint
     * @param {Object} point Object containing x and y coordinates.
     * @param {Number} majorUnitDistance Distance in pixels between ticks.
     * @return Object
     * @private
     */
    getNextPoint: function(point, majorUnitDistance)
    {
        _yuitest_coverfunc("/build/charts-base/charts-base.js", "getNextPoint", 2686);
_yuitest_coverline("/build/charts-base/charts-base.js", 2688);
var pos = this.get("position");
        _yuitest_coverline("/build/charts-base/charts-base.js", 2689);
if(pos === "top" || pos === "bottom")
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 2691);
point.x = point.x + majorUnitDistance;		
        }
        else
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 2695);
point.y = point.y - majorUnitDistance;
        }
        _yuitest_coverline("/build/charts-base/charts-base.js", 2697);
return point;
    },

    /**
     * Calculates the placement of last tick on an axis.
     *
     * @method getLastPoint
     * @return Object
     * @private 
     */
    getLastPoint: function()
    {
        _yuitest_coverfunc("/build/charts-base/charts-base.js", "getLastPoint", 2707);
_yuitest_coverline("/build/charts-base/charts-base.js", 2709);
var style = this.get("styles"),
            padding = style.padding,
            w = this.get("width"),
            pos = this.get("position");
        _yuitest_coverline("/build/charts-base/charts-base.js", 2713);
if(pos === "top" || pos === "bottom")
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 2715);
return {x:w - padding.right, y:padding.top};
        }
        else
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 2719);
return {x:padding.left, y:padding.top};
        }
    },

    /**
     * Calculates position on the axis.
     *
     * @method getPosition
     * @param {Object} point contains x and y values
     * @private 
     */
    getPosition: function(point)
    {
        _yuitest_coverfunc("/build/charts-base/charts-base.js", "getPosition", 2730);
_yuitest_coverline("/build/charts-base/charts-base.js", 2732);
var p,
            h = this.get("height"),
            style = this.get("styles"),
            padding = style.padding,
            pos = this.get("position"),
            dataType = this.get("dataType");
        _yuitest_coverline("/build/charts-base/charts-base.js", 2738);
if(pos === "left" || pos === "right") 
        {
            //Numeric data on a vertical axis is displayed from bottom to top.
            //Categorical and Timeline data is displayed from top to bottom.
            _yuitest_coverline("/build/charts-base/charts-base.js", 2742);
if(dataType === "numeric")
            {
                _yuitest_coverline("/build/charts-base/charts-base.js", 2744);
p = (h - (padding.top + padding.bottom)) - (point.y - padding.top);
            }
            else
            {
                _yuitest_coverline("/build/charts-base/charts-base.js", 2748);
p = point.y - padding.top;
            }
        }
        else
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 2753);
p = point.x - padding.left;
        }
        _yuitest_coverline("/build/charts-base/charts-base.js", 2755);
return p;
    },

    /**
     * Rotates and positions a text field.
     *
     * @method _rotate
     * @param {HTMLElement} label text field to rotate and position
     * @param {Object} props properties to be applied to the text field. 
     * @private
     */
    _rotate: function(label, props)
    {
        _yuitest_coverfunc("/build/charts-base/charts-base.js", "_rotate", 2766);
_yuitest_coverline("/build/charts-base/charts-base.js", 2768);
var rot = props.rot,
            x = props.x,
            y = props.y,
            filterString,
            textAlpha,
            matrix = new Y.Matrix(),
            transformOrigin = props.transformOrigin || [0, 0],
            offsetRect;
        _yuitest_coverline("/build/charts-base/charts-base.js", 2776);
if(DOCUMENT.createElementNS)
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 2778);
matrix.translate(x, y);
            _yuitest_coverline("/build/charts-base/charts-base.js", 2779);
matrix.rotate(rot);
            _yuitest_coverline("/build/charts-base/charts-base.js", 2780);
label.style.MozTransformOrigin = (transformOrigin[0] * 100) + "% " + (transformOrigin[1] * 100) + "%";
            _yuitest_coverline("/build/charts-base/charts-base.js", 2781);
label.style.MozTransform = matrix.toCSSText();
            _yuitest_coverline("/build/charts-base/charts-base.js", 2782);
label.style.webkitTransformOrigin = (transformOrigin[0] * 100) + "% " + (transformOrigin[1] * 100) + "%";
            _yuitest_coverline("/build/charts-base/charts-base.js", 2783);
label.style.webkitTransform = matrix.toCSSText();
            _yuitest_coverline("/build/charts-base/charts-base.js", 2784);
label.style.msTransformOrigin = (transformOrigin[0] * 100) + "% " + (transformOrigin[1] * 100) + "%";
            _yuitest_coverline("/build/charts-base/charts-base.js", 2785);
label.style.msTransform = matrix.toCSSText();
            _yuitest_coverline("/build/charts-base/charts-base.js", 2786);
label.style.OTransformOrigin = (transformOrigin[0] * 100) + "% " + (transformOrigin[1] * 100) + "%";
            _yuitest_coverline("/build/charts-base/charts-base.js", 2787);
label.style.OTransform = matrix.toCSSText();
        }
        else
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 2791);
textAlpha = props.textAlpha;
            _yuitest_coverline("/build/charts-base/charts-base.js", 2792);
if(Y_Lang.isNumber(textAlpha) && textAlpha < 1 && textAlpha > -1 && !isNaN(textAlpha))
            {
                _yuitest_coverline("/build/charts-base/charts-base.js", 2794);
filterString = "progid:DXImageTransform.Microsoft.Alpha(Opacity=" + Math.round(textAlpha * 100) + ")";
            }
            _yuitest_coverline("/build/charts-base/charts-base.js", 2796);
if(rot !== 0)
            {
                //ms filters kind of, sort of uses a transformOrigin of 0, 0. 
                //we'll translate the difference to create a true 0, 0 origin.
                _yuitest_coverline("/build/charts-base/charts-base.js", 2800);
matrix.rotate(rot);
                _yuitest_coverline("/build/charts-base/charts-base.js", 2801);
offsetRect = matrix.getContentRect(props.labelWidth, props.labelHeight);
                _yuitest_coverline("/build/charts-base/charts-base.js", 2802);
matrix.init();
                _yuitest_coverline("/build/charts-base/charts-base.js", 2803);
matrix.translate(offsetRect.left, offsetRect.top);
                _yuitest_coverline("/build/charts-base/charts-base.js", 2804);
matrix.translate(x, y);
                _yuitest_coverline("/build/charts-base/charts-base.js", 2805);
this._simulateRotateWithTransformOrigin(matrix, rot, transformOrigin, props.labelWidth, props.labelHeight);
                _yuitest_coverline("/build/charts-base/charts-base.js", 2806);
if(filterString)
                {
                    _yuitest_coverline("/build/charts-base/charts-base.js", 2808);
filterString += " ";
                }
                else
                {
                    _yuitest_coverline("/build/charts-base/charts-base.js", 2812);
filterString = ""; 
                }
                _yuitest_coverline("/build/charts-base/charts-base.js", 2814);
filterString += matrix.toFilterText();
                _yuitest_coverline("/build/charts-base/charts-base.js", 2815);
label.style.left = matrix.dx + "px";
                _yuitest_coverline("/build/charts-base/charts-base.js", 2816);
label.style.top = matrix.dy + "px";
            }
            else
            {
                _yuitest_coverline("/build/charts-base/charts-base.js", 2820);
label.style.left = x + "px";
                _yuitest_coverline("/build/charts-base/charts-base.js", 2821);
label.style.top = y + "px";
            }
            _yuitest_coverline("/build/charts-base/charts-base.js", 2823);
if(filterString)
            {
                _yuitest_coverline("/build/charts-base/charts-base.js", 2825);
label.style.filter = filterString;
            }
        }
    },
    
    /**
     * Simulates a rotation with a specified transformOrigin. 
     *
     * @method _simulateTransformOrigin
     * @param {Matrix} matrix Reference to a `Matrix` instance.
     * @param {Number} rot The rotation (in degrees) that will be performed on a matrix.
     * @param {Array} transformOrigin An array represeniting the origin in which to perform the transform. The first 
     * index represents the x origin and the second index represents the y origin.
     * @param {Number} w The width of the object that will be transformed.
     * @param {Number} h The height of the object that will be transformed.
     * @private
     */
    _simulateRotateWithTransformOrigin: function(matrix, rot, transformOrigin, w, h)
    {
        _yuitest_coverfunc("/build/charts-base/charts-base.js", "_simulateRotateWithTransformOrigin", 2842);
_yuitest_coverline("/build/charts-base/charts-base.js", 2844);
var transformX = transformOrigin[0] * w,
            transformY = transformOrigin[1] * h;
        _yuitest_coverline("/build/charts-base/charts-base.js", 2846);
transformX = !isNaN(transformX) ? transformX : 0;
        _yuitest_coverline("/build/charts-base/charts-base.js", 2847);
transformY = !isNaN(transformY) ? transformY : 0;
        _yuitest_coverline("/build/charts-base/charts-base.js", 2848);
matrix.translate(transformX, transformY);
        _yuitest_coverline("/build/charts-base/charts-base.js", 2849);
matrix.rotate(rot);
        _yuitest_coverline("/build/charts-base/charts-base.js", 2850);
matrix.translate(-transformX, -transformY);
    },

    /**
     * Returns the coordinates (top, right, bottom, left) for the bounding box of the last label. 
     *
     * @method getMaxLabelBounds
     * @return Object
     */
    getMaxLabelBounds: function()
    {
        _yuitest_coverfunc("/build/charts-base/charts-base.js", "getMaxLabelBounds", 2859);
_yuitest_coverline("/build/charts-base/charts-base.js", 2861);
return this._getLabelBounds(this.getMaximumValue());
    },

    /**
     * Returns the coordinates (top, right, bottom, left) for the bounding box of the first label. 
     *
     * @method getMinLabelBounds
     * @return Object
     */
    getMinLabelBounds: function()
    {
        _yuitest_coverfunc("/build/charts-base/charts-base.js", "getMinLabelBounds", 2870);
_yuitest_coverline("/build/charts-base/charts-base.js", 2872);
return this._getLabelBounds(this.getMinimumValue());
    },
    
    /**
     * Returns the coordinates (top, right, bottom, left) for the bounding box of a label. 
     *
     * @method _getLabelBounds
     * @param {String} Value of the label
     * @return Object
     * @private
     */
    _getLabelBounds: function(val)
    {
        _yuitest_coverfunc("/build/charts-base/charts-base.js", "_getLabelBounds", 2883);
_yuitest_coverline("/build/charts-base/charts-base.js", 2885);
var layout = this._layout,
            labelStyles = this.get("styles").label,
            matrix = new Y.Matrix(),
            label,
            props = this._getTextRotationProps(labelStyles);
            _yuitest_coverline("/build/charts-base/charts-base.js", 2890);
props.transformOrigin = layout._getTransformOrigin(props.rot);
        _yuitest_coverline("/build/charts-base/charts-base.js", 2891);
label = this.getLabel({x: 0, y: 0}, labelStyles);
        _yuitest_coverline("/build/charts-base/charts-base.js", 2892);
this.get("appendLabelFunction")(label, this.get("labelFunction").apply(this, [val, this.get("labelFormat")]));
        _yuitest_coverline("/build/charts-base/charts-base.js", 2893);
props.labelWidth = label.offsetWidth;
        _yuitest_coverline("/build/charts-base/charts-base.js", 2894);
props.labelHeight = label.offsetHeight;
        _yuitest_coverline("/build/charts-base/charts-base.js", 2895);
this._removeChildren(label);
        _yuitest_coverline("/build/charts-base/charts-base.js", 2896);
Y.Event.purgeElement(label, true);
        _yuitest_coverline("/build/charts-base/charts-base.js", 2897);
label.parentNode.removeChild(label);
        _yuitest_coverline("/build/charts-base/charts-base.js", 2898);
props.x = 0;
        _yuitest_coverline("/build/charts-base/charts-base.js", 2899);
props.y = 0;
        _yuitest_coverline("/build/charts-base/charts-base.js", 2900);
layout._setRotationCoords(props);
        _yuitest_coverline("/build/charts-base/charts-base.js", 2901);
matrix.translate(props.x, props.y);
        _yuitest_coverline("/build/charts-base/charts-base.js", 2902);
this._simulateRotateWithTransformOrigin(matrix, props.rot, props.transformOrigin, props.labelWidth, props.labelHeight);
        _yuitest_coverline("/build/charts-base/charts-base.js", 2903);
return matrix.getContentRect(props.labelWidth, props.labelHeight);
    },

    /**
     * Removes all DOM elements from an HTML element. Used to clear out labels during detruction
     * phase.
     *
     * @method _removeChildren
     * @private
     */
    _removeChildren: function(node)
    {
        _yuitest_coverfunc("/build/charts-base/charts-base.js", "_removeChildren", 2913);
_yuitest_coverline("/build/charts-base/charts-base.js", 2915);
if(node.hasChildNodes())
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 2917);
var child;
            _yuitest_coverline("/build/charts-base/charts-base.js", 2918);
while(node.firstChild)
            {
                _yuitest_coverline("/build/charts-base/charts-base.js", 2920);
child = node.firstChild;
                _yuitest_coverline("/build/charts-base/charts-base.js", 2921);
this._removeChildren(child);
                _yuitest_coverline("/build/charts-base/charts-base.js", 2922);
node.removeChild(child);
            }
        }
    },
    
    /**
     * Destructor implementation Axis class. Removes all labels and the Graphic instance from the widget.
     *
     * @method destructor
     * @protected
     */
    destructor: function()
    {
        _yuitest_coverfunc("/build/charts-base/charts-base.js", "destructor", 2933);
_yuitest_coverline("/build/charts-base/charts-base.js", 2935);
var cb = this.get("contentBox").getDOMNode(),
            labels = this.get("labels"),
            graphic = this.get("graphic"),
            label,
            len = labels ? labels.length : 0;
        _yuitest_coverline("/build/charts-base/charts-base.js", 2940);
if(len > 0)
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 2942);
while(labels.length > 0)
            {
                _yuitest_coverline("/build/charts-base/charts-base.js", 2944);
label = labels.shift();
                _yuitest_coverline("/build/charts-base/charts-base.js", 2945);
this._removeChildren(label);
                _yuitest_coverline("/build/charts-base/charts-base.js", 2946);
cb.removeChild(label);
                _yuitest_coverline("/build/charts-base/charts-base.js", 2947);
label = null;
            }
        }
        _yuitest_coverline("/build/charts-base/charts-base.js", 2950);
if(graphic)
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 2952);
graphic.destroy();
        }
    },

    /**
     * Length in pixels of largest text bounding box. Used to calculate the height of the axis.
     *
     * @property maxLabelSize
     * @type Number
     * @protected
     */
    _maxLabelSize: 0,
    
    /**
     * Updates the content of text field. This method writes a value into a text field using 
     * `appendChild`. If the value is a `String`, it is converted to a `TextNode` first. 
     *
     * @method _setText
     * @param label {HTMLElement} label to be updated
     * @param val {String} value with which to update the label
     * @private
     */
    _setText: function(textField, val)
    { 
        _yuitest_coverfunc("/build/charts-base/charts-base.js", "_setText", 2974);
_yuitest_coverline("/build/charts-base/charts-base.js", 2976);
textField.innerHTML = "";
        _yuitest_coverline("/build/charts-base/charts-base.js", 2977);
if(Y_Lang.isNumber(val))
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 2979);
val = val + "";
        }
        else {_yuitest_coverline("/build/charts-base/charts-base.js", 2981);
if(!val)
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 2983);
val = "";
        }}
        _yuitest_coverline("/build/charts-base/charts-base.js", 2985);
if(IS_STRING(val))
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 2987);
val = DOCUMENT.createTextNode(val);
        }
        _yuitest_coverline("/build/charts-base/charts-base.js", 2989);
textField.appendChild(val);
    }
}, {
    ATTRS: 
    {
        /**
         * When set, defines the width of a vertical axis instance. By default, vertical axes automatically size based on their contents. When the
         * width attribute is set, the axis will not calculate its width. When the width attribute is explicitly set, axis labels will postion themselves off of the 
         * the inner edge of the axis and the title, if present, will position itself off of the outer edge. If a specified width is less than the sum of 
         * the axis' contents, excess content will overflow.
         *
         * @attribute width
         * @type Number
         */
        width: {
            lazyAdd: false,

            getter: function() 
            {
                _yuitest_coverfunc("/build/charts-base/charts-base.js", "getter", 3006);
_yuitest_coverline("/build/charts-base/charts-base.js", 3008);
if(this._explicitWidth)
                {
                    _yuitest_coverline("/build/charts-base/charts-base.js", 3010);
return this._explicitWidth;        
                }
                _yuitest_coverline("/build/charts-base/charts-base.js", 3012);
return this._calculatedWidth;
            },

            setter: function(val)
            {
                _yuitest_coverfunc("/build/charts-base/charts-base.js", "setter", 3015);
_yuitest_coverline("/build/charts-base/charts-base.js", 3017);
this._explicitWidth = val;
                _yuitest_coverline("/build/charts-base/charts-base.js", 3018);
return val;
            }
        },

        /**
         * When set, defines the height of a horizontal axis instance. By default, horizontal axes automatically size based on their contents. When the
         * height attribute is set, the axis will not calculate its height. When the height attribute is explicitly set, axis labels will postion themselves off of the 
         * the inner edge of the axis and the title, if present, will position itself off of the outer edge. If a specified height is less than the sum of 
         * the axis' contents, excess content will overflow.
         *
         * @attribute height
         * @type Number
         */
        height: {
            lazyAdd: false,

            getter: function() 
            {
                _yuitest_coverfunc("/build/charts-base/charts-base.js", "getter", 3034);
_yuitest_coverline("/build/charts-base/charts-base.js", 3036);
if(this._explicitHeight)
                {
                    _yuitest_coverline("/build/charts-base/charts-base.js", 3038);
return this._explicitHeight;        
                }
                _yuitest_coverline("/build/charts-base/charts-base.js", 3040);
return this._calculatedHeight;
            },

            setter: function(val)
            {
                _yuitest_coverfunc("/build/charts-base/charts-base.js", "setter", 3043);
_yuitest_coverline("/build/charts-base/charts-base.js", 3045);
this._explicitHeight = val;
                _yuitest_coverline("/build/charts-base/charts-base.js", 3046);
return val;
            }
        },

        /**
         * Calculated value of an axis' width. By default, the value is used internally for vertical axes. If the `width` attribute is explicitly set, this value will be ignored.
         *
         * @attribute calculatedWidth
         * @type Number
         * @private
         */
        calculatedWidth: {
            getter: function()
            {
                _yuitest_coverfunc("/build/charts-base/charts-base.js", "getter", 3058);
_yuitest_coverline("/build/charts-base/charts-base.js", 3060);
return this._calculatedWidth;
            },

            setter: function(val)
            {
                _yuitest_coverfunc("/build/charts-base/charts-base.js", "setter", 3063);
_yuitest_coverline("/build/charts-base/charts-base.js", 3065);
this._calculatedWidth = val;
                _yuitest_coverline("/build/charts-base/charts-base.js", 3066);
return val;
            }
        },

        /**
         * Calculated value of an axis' height. By default, the value is used internally for horizontal axes. If the `height` attribute is explicitly set, this value will be ignored.
         *
         * @attribute calculatedHeight
         * @type Number
         * @private
         */
        calculatedHeight: {
            getter: function()
            {
                _yuitest_coverfunc("/build/charts-base/charts-base.js", "getter", 3078);
_yuitest_coverline("/build/charts-base/charts-base.js", 3080);
return this._calculatedHeight;
            },

            setter: function(val)
            {
                _yuitest_coverfunc("/build/charts-base/charts-base.js", "setter", 3083);
_yuitest_coverline("/build/charts-base/charts-base.js", 3085);
this._calculatedHeight = val;
                _yuitest_coverline("/build/charts-base/charts-base.js", 3086);
return val;
            }
        },

        /**
         * Difference betweend the first/last tick and edge of axis.
         *
         * @attribute edgeOffset
         * @type Number
         * @protected
         */
        edgeOffset: 
        {
            value: 0
        },

        /**
         * The graphic in which the axis line and ticks will be rendered.
         *
         * @attribute graphic
         * @type Graphic
         */
        graphic: {},
    
        /**
         *  @attribute path
         *  @type Shape
         *  @readOnly
         *  @private
         */
        path: {
            readOnly: true,

            getter: function()
            {
                _yuitest_coverfunc("/build/charts-base/charts-base.js", "getter", 3119);
_yuitest_coverline("/build/charts-base/charts-base.js", 3121);
if(!this._path)
                {
                    _yuitest_coverline("/build/charts-base/charts-base.js", 3123);
var graphic = this.get("graphic");
                    _yuitest_coverline("/build/charts-base/charts-base.js", 3124);
if(graphic)
                    {
                        _yuitest_coverline("/build/charts-base/charts-base.js", 3126);
this._path = graphic.addShape({type:"path"});
                    }
                }
                _yuitest_coverline("/build/charts-base/charts-base.js", 3129);
return this._path;
            }
        },

        /**
         *  @attribute tickPath
         *  @type Shape
         *  @readOnly
         *  @private
         */
        tickPath: {
            readOnly: true,

            getter: function()
            {
                _yuitest_coverfunc("/build/charts-base/charts-base.js", "getter", 3142);
_yuitest_coverline("/build/charts-base/charts-base.js", 3144);
if(!this._tickPath)
                {
                    _yuitest_coverline("/build/charts-base/charts-base.js", 3146);
var graphic = this.get("graphic");
                    _yuitest_coverline("/build/charts-base/charts-base.js", 3147);
if(graphic)
                    {
                        _yuitest_coverline("/build/charts-base/charts-base.js", 3149);
this._tickPath = graphic.addShape({type:"path"});
                    }
                }
                _yuitest_coverline("/build/charts-base/charts-base.js", 3152);
return this._tickPath;
            }
        },
        
        /**
         * Contains the contents of the axis. 
         *
         * @attribute node
         * @type HTMLElement
         */
        node: {},

        /**
         * Direction of the axis.
         *
         * @attribute position
         * @type String
         */
        position: {
            setter: function(val)
            {
                _yuitest_coverfunc("/build/charts-base/charts-base.js", "setter", 3171);
_yuitest_coverline("/build/charts-base/charts-base.js", 3173);
var layoutClass = this._layoutClasses[val];
                _yuitest_coverline("/build/charts-base/charts-base.js", 3174);
if(val && val != "none")
                {
                    _yuitest_coverline("/build/charts-base/charts-base.js", 3176);
this._layout = new layoutClass();
                }
                _yuitest_coverline("/build/charts-base/charts-base.js", 3178);
return val;
            }
        },

        /**
         * Distance determined by the tick styles used to calculate the distance between the axis
         * line in relation to the top of the axis.
         *
         * @attribute topTickOffset
         * @type Number
         */
        topTickOffset: {
            value: 0
        },

        /**
         * Distance determined by the tick styles used to calculate the distance between the axis
         * line in relation to the bottom of the axis.
         *
         * @attribute bottomTickOffset
         * @type Number
         */
        bottomTickOffset: {
            value: 0
        },

        /**
         * Distance determined by the tick styles used to calculate the distance between the axis
         * line in relation to the left of the axis.
         *
         * @attribute leftTickOffset
         * @type Number
         */
        leftTickOffset: {
            value: 0
        },

        /**
         * Distance determined by the tick styles used to calculate the distance between the axis
         * line in relation to the right side of the axis.
         *
         * @attribute rightTickOffset
         * @type Number
         */
        rightTickOffset: {
            value: 0
        },
        
        /**
         * Collection of labels used to render the axis.
         *
         * @attribute labels
         * @type Array
         */
        labels: {
            readOnly: true,
            getter: function()
            {
                _yuitest_coverfunc("/build/charts-base/charts-base.js", "getter", 3234);
_yuitest_coverline("/build/charts-base/charts-base.js", 3236);
return this._labels;
            }
        },

        /**
         * Collection of points used for placement of labels and ticks along the axis.
         *
         * @attribute tickPoints
         * @type Array
         */
        tickPoints: {
            readOnly: true,

            getter: function()
            {
                _yuitest_coverfunc("/build/charts-base/charts-base.js", "getter", 3249);
_yuitest_coverline("/build/charts-base/charts-base.js", 3251);
if(this.get("position") == "none")
                {
                    _yuitest_coverline("/build/charts-base/charts-base.js", 3253);
return this.get("styles").majorUnit.count;
                }
                _yuitest_coverline("/build/charts-base/charts-base.js", 3255);
return this._tickPoints;
            }
        },

        /**
         * Indicates whether the axis overlaps the graph. If an axis is the inner most axis on a given
         * position and the tick position is inside or cross, the axis will need to overlap the graph.
         *
         * @attribute overlapGraph
         * @type Boolean
         */
        overlapGraph: {
            value:true,

            validator: function(val)
            {
                _yuitest_coverfunc("/build/charts-base/charts-base.js", "validator", 3269);
_yuitest_coverline("/build/charts-base/charts-base.js", 3271);
return Y_Lang.isBoolean(val);
            }
        },

        /**
         * Object which should have by the labelFunction
         *
         * @attribute labelFunctionScope
         * @type Object
         */
        labelFunctionScope: {},
        
        /**
         * Length in pixels of largest text bounding box. Used to calculate the height of the axis.
         *
         * @attribute maxLabelSize
         * @type Number
         * @protected
         */
        maxLabelSize: {
            getter: function()
            {
                _yuitest_coverfunc("/build/charts-base/charts-base.js", "getter", 3291);
_yuitest_coverline("/build/charts-base/charts-base.js", 3293);
return this._maxLabelSize;
            },

            setter: function(val)
            {
                _yuitest_coverfunc("/build/charts-base/charts-base.js", "setter", 3296);
_yuitest_coverline("/build/charts-base/charts-base.js", 3298);
this._maxLabelSize = val;
                _yuitest_coverline("/build/charts-base/charts-base.js", 3299);
return val; 
            }
        },
        
        /**
         *  Title for the axis. When specified, the title will display. The position of the title is determined by the axis position. 
         *  <dl>
         *      <dt>top</dt><dd>Appears above the axis and it labels. The default rotation is 0.</dd>
         *      <dt>right</dt><dd>Appears to the right of the axis and its labels. The default rotation is 90.</dd>
         *      <dt>bottom</dt><dd>Appears below the axis and its labels. The default rotation is 0.</dd>
         *      <dt>left</dt><dd>Appears to the left of the axis and its labels. The default rotation is -90.</dd>
         *  </dl>
         *
         *  @attribute title
         *  @type String
         */
        title: {
            value: null
        },
        
        /**
         * Method used for formatting a label. This attribute allows for the default label formatting method to overridden. The method use would need
         * to implement the arguments below and return a `String` or `HTMLElement`. 
         * <dl>
         *      <dt>val</dt><dd>Label to be formatted. (`String`)</dd>
         *      <dt>format</dt><dd>Template for formatting label. (optional)</dd>
         * </dl>
         *
         * @attribute labelFunction
         * @type Function
         */
        labelFunction: {
            value: function(val, format)
            {
                _yuitest_coverfunc("/build/charts-base/charts-base.js", "value", 3331);
_yuitest_coverline("/build/charts-base/charts-base.js", 3333);
return val;
            }
        },
        
        /**
         * Function used to append an axis value to an axis label. This function has the following signature:
         *  <dl>
         *      <dt>textField</dt><dd>The axis label to be appended. (`HTMLElement`)</dd>
         *      <dt>val</dt><dd>The value to attach to the text field. This method will accept an `HTMLELement`
         *      or a `String`. This method does not use (`HTMLElement` | `String`)</dd>
         *  </dl>
         * The default method appends a value to the `HTMLElement` using the `appendChild` method. If the given 
         * value is a `String`, the method will convert the the value to a `textNode` before appending to the 
         * `HTMLElement`. This method will not convert an `HTMLString` to an `HTMLElement`. 
         *
         * @attribute appendLabelFunction
         * @type Function
         */
        appendLabelFunction: {
            valueFn: function()
            {
                _yuitest_coverfunc("/build/charts-base/charts-base.js", "valueFn", 3352);
_yuitest_coverline("/build/charts-base/charts-base.js", 3354);
return this._setText;
            }
        },
        
        /**
         * Function used to append a title value to the title object. This function has the following signature:
         *  <dl>
         *      <dt>textField</dt><dd>The title text field to be appended. (`HTMLElement`)</dd>
         *      <dt>val</dt><dd>The value to attach to the text field. This method will accept an `HTMLELement`
         *      or a `String`. This method does not use (`HTMLElement` | `String`)</dd>
         *  </dl>
         * The default method appends a value to the `HTMLElement` using the `appendChild` method. If the given 
         * value is a `String`, the method will convert the the value to a `textNode` before appending to the 
         * `HTMLElement` element. This method will not convert an `HTMLString` to an `HTMLElement`. 
         *
         * @attribute appendTitleFunction
         * @type Function
         */
        appendTitleFunction: {
            valueFn: function()
            {
                _yuitest_coverfunc("/build/charts-base/charts-base.js", "valueFn", 3373);
_yuitest_coverline("/build/charts-base/charts-base.js", 3375);
return this._setText;
            }
        }
            
        /**
         * Style properties used for drawing an axis. This attribute is inherited from `Renderer`. Below are the default values:
         *  <dl>
         *      <dt>majorTicks</dt><dd>Properties used for drawing ticks.
         *          <dl>
         *              <dt>display</dt><dd>Position of the tick. Possible values are `inside`, `outside`, `cross` and `none`. The
         *              default value is `inside`.</dd>
         *              <dt>length</dt><dd>The length (in pixels) of the tick. The default value is 4.</dd>
         *              <dt>color</dt><dd>The color of the tick. The default value is `#dad8c9`</dd>
         *              <dt>weight</dt><dd>Number indicating the width of the tick. The default value is 1.</dd>
         *              <dt>alpha</dt><dd>Number from 0 to 1 indicating the opacity of the tick. The default value is 1.</dd>
         *          </dl>
         *      </dd>
         *      <dt>line</dt><dd>Properties used for drawing the axis line. 
         *          <dl>
         *              <dt>weight</dt><dd>Number indicating the width of the axis line. The default value is 1.</dd>
         *              <dt>color</dt><dd>The color of the axis line. The default value is `#dad8c9`.</dd>
         *              <dt>alpha</dt><dd>Number from 0 to 1 indicating the opacity of the tick. The default value is 1.</dd>
         *          </dl>
         *      </dd>
         *      <dt>majorUnit</dt><dd>Properties used to calculate the `majorUnit` for the axis. 
         *          <dl>
         *              <dt>determinant</dt><dd>The algorithm used for calculating distance between ticks. The possible options are `count` and `distance`. If
         *              the `determinant` is `count`, the axis ticks will spaced so that a specified number of ticks appear on the axis. If the `determinant`
         *              is `distance`, the axis ticks will spaced out according to the specified distance. The default value is `count`.</dd>
         *              <dt>count</dt><dd>Number of ticks to appear on the axis when the `determinant` is `count`. The default value is 11.</dd>
         *              <dt>distance</dt><dd>The distance (in pixels) between ticks when the `determinant` is `distance`. The default value is 75.</dd>
         *          </dl>
         *      </dd>
         *      <dt>label</dt><dd>Properties and styles applied to the axis labels.
         *          <dl>
         *              <dt>color</dt><dd>The color of the labels. The default value is `#808080`.</dd>
         *              <dt>alpha</dt><dd>Number between 0 and 1 indicating the opacity of the labels. The default value is 1.</dd>
         *              <dt>fontSize</dt><dd>The font-size of the labels. The default value is 85%</dd>
         *              <dt>rotation</dt><dd>The rotation, in degrees (between -90 and 90) of the labels. The default value is 0.</dd>
         *              <dt>margin</dt><dd>The distance between the label and the axis/tick. Depending on the position of the `Axis`, only one of the properties used.
         *                  <dl>
         *                      <dt>top</dt><dd>Pixel value used for an axis with a `position` of `bottom`. The default value is 4.</dd>
         *                      <dt>right</dt><dd>Pixel value used for an axis with a `position` of `left`. The default value is 4.</dd>
         *                      <dt>bottom</dt><dd>Pixel value used for an axis with a `position` of `top`. The default value is 4.</dd>
         *                      <dt>left</dt><dd>Pixel value used for an axis with a `position` of `right`. The default value is 4.</dd>
         *                  </dl>
         *              </dd>
         *          </dl>
         *      </dd>
         *  </dl>
         *
         * @attribute styles
         * @type Object
         */
    }
});
/**
 * AxisType is an abstract class that manages the data for an axis.
 *
 * @module charts
 * @submodule charts-base
 * @class AxisType
 * @constructor
 * @extends Axis
 */
_yuitest_coverline("/build/charts-base/charts-base.js", 3440);
Y.AxisType = Y.Base.create("baseAxis", Y.Axis, [], {
    /**
     * @method initializer
     * @private
     */
    initializer: function()
    {
        _yuitest_coverfunc("/build/charts-base/charts-base.js", "initializer", 3445);
_yuitest_coverline("/build/charts-base/charts-base.js", 3447);
this.after("dataReady", Y.bind(this._dataChangeHandler, this));
        _yuitest_coverline("/build/charts-base/charts-base.js", 3448);
this.after("dataUpdate", Y.bind(this._dataChangeHandler, this));
        _yuitest_coverline("/build/charts-base/charts-base.js", 3449);
this.after("minimumChange", Y.bind(this._keyChangeHandler, this));
        _yuitest_coverline("/build/charts-base/charts-base.js", 3450);
this.after("maximumChange", Y.bind(this._keyChangeHandler, this));
        _yuitest_coverline("/build/charts-base/charts-base.js", 3451);
this.after("keysChange", this._keyChangeHandler);
        _yuitest_coverline("/build/charts-base/charts-base.js", 3452);
this.after("dataProviderChange", this._dataProviderChangeHandler);
        _yuitest_coverline("/build/charts-base/charts-base.js", 3453);
this.after("alwaysShowZeroChange", this._keyChangeHandler);
        _yuitest_coverline("/build/charts-base/charts-base.js", 3454);
this.after("roundingMethodChange", this._keyChangeHandler);
    },

    /**
     * @method bindUI
     * @private
     */
    bindUI: function()
    {
        _yuitest_coverfunc("/build/charts-base/charts-base.js", "bindUI", 3461);
_yuitest_coverline("/build/charts-base/charts-base.js", 3463);
this.after("stylesChange", this._updateHandler);
        _yuitest_coverline("/build/charts-base/charts-base.js", 3464);
this.after("overlapGraphChange", this._updateHandler);
        _yuitest_coverline("/build/charts-base/charts-base.js", 3465);
this.after("positionChange", this._positionChangeHandler);
        _yuitest_coverline("/build/charts-base/charts-base.js", 3466);
this.after("widthChange", this._handleSizeChange);
        _yuitest_coverline("/build/charts-base/charts-base.js", 3467);
this.after("heightChange", this._handleSizeChange);
        _yuitest_coverline("/build/charts-base/charts-base.js", 3468);
this.after("calculatedWidthChange", this._handleSizeChange);
        _yuitest_coverline("/build/charts-base/charts-base.js", 3469);
this.after("calculatedHeightChange", this._handleSizeChange);
    },

    /**
     * Handles changes to `dataProvider`.
     *
     * @method _dataProviderChangeHandler
     * @param {Object} e Event object.
     * @private
     */
    _dataProviderChangeHandler: function(e)
    {
        _yuitest_coverfunc("/build/charts-base/charts-base.js", "_dataProviderChangeHandler", 3479);
_yuitest_coverline("/build/charts-base/charts-base.js", 3481);
var keyCollection = this.get("keyCollection").concat(),
            keys = this.get("keys"),
            i;
        _yuitest_coverline("/build/charts-base/charts-base.js", 3484);
if(keys)
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 3486);
for(i in keys)
            {
                _yuitest_coverline("/build/charts-base/charts-base.js", 3488);
if(keys.hasOwnProperty(i))
                {
                    _yuitest_coverline("/build/charts-base/charts-base.js", 3490);
delete keys[i];
                }
            }
        }
        _yuitest_coverline("/build/charts-base/charts-base.js", 3494);
if(keyCollection && keyCollection.length)
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 3496);
this.set("keys", keyCollection);
        }
    },

    /**
     * Constant used to generate unique id.
     *
     * @property GUID
     * @type String
     * @private
     */
    GUID: "yuibaseaxis",
	
    /**
     * Type of data used in `Axis`.
     *
     * @property _type
     * @type String 
     * @readOnly
     * @private
     */
    _type: null,
	
    /**
     * Storage for `setMaximum` attribute.
     *
     * @property _setMaximum
     * @type Object
     * @private
     */
    _setMaximum: null,
	
    /**
     * Storage for `dataMaximum` attribute.
     *
     * @property _dataMaximum
     * @type Object
     * @private
     */
    _dataMaximum: null,
	
    /**
     * Storage for `setMinimum` attribute.
     *
     * @property _setMinimum
     * @type Object
     * @private
     */
    _setMinimum: null,
	
    /**
     * Reference to data array.
     *
     * @property _data
     * @type Array
     * @private
     */
    _data: null,

    /**
     * Indicates whether the all data is up to date.
     *
     * @property _updateTotalDataFlag
     * @type Boolean
     * @private
     */
    _updateTotalDataFlag: true,

    /**
     * Storage for `dataReady` attribute.
     *
     * @property _dataReady
     * @type Boolean
     * @readOnly
     * @private
     */
    _dataReady: false,
	
    /**
     * Adds an array to the key hash.
     *
     * @method addKey
     * @param value Indicates what key to use in retrieving
     * the array.
     */
    addKey: function (value)
	{
        _yuitest_coverfunc("/build/charts-base/charts-base.js", "addKey", 3581);
_yuitest_coverline("/build/charts-base/charts-base.js", 3583);
this.set("keys", value);
	},

    /**
     * Gets an array of values based on a key.
     *
     * @method _getKeyArray
     * @param {String} key Value key associated with the data array.
     * @param {Array} data Array in which the data resides.
     * @return Array
     * @private
     */
    _getKeyArray: function(key, data)
    {
        _yuitest_coverfunc("/build/charts-base/charts-base.js", "_getKeyArray", 3595);
_yuitest_coverline("/build/charts-base/charts-base.js", 3597);
var i = 0,
            obj,
            keyArray = [],
            len = data.length;
        _yuitest_coverline("/build/charts-base/charts-base.js", 3601);
for(; i < len; ++i)
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 3603);
obj = data[i];
            _yuitest_coverline("/build/charts-base/charts-base.js", 3604);
keyArray[i] = obj[key];
        }
        _yuitest_coverline("/build/charts-base/charts-base.js", 3606);
return keyArray;
    },

    /**
     * Sets data by key
     *
     * @method _setDataByKey
     * @param {String} key Key value to use.
     * @param {Array} data Array to use.
     * @private 
     */
    _setDataByKey: function(key, data)
    {
        _yuitest_coverfunc("/build/charts-base/charts-base.js", "_setDataByKey", 3617);
_yuitest_coverline("/build/charts-base/charts-base.js", 3619);
var i,
            obj, 
            arr = [], 
            dv = this._dataClone.concat(), 
            len = dv.length;
        _yuitest_coverline("/build/charts-base/charts-base.js", 3624);
for(i = 0; i < len; ++i)
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 3626);
obj = dv[i];
            _yuitest_coverline("/build/charts-base/charts-base.js", 3627);
arr[i] = obj[key];
        }
        _yuitest_coverline("/build/charts-base/charts-base.js", 3629);
this.get("keys")[key] = arr;
        _yuitest_coverline("/build/charts-base/charts-base.js", 3630);
this._updateTotalDataFlag = true;
    },

    /**
     * Updates the total data array.
     *
     * @method _updateTotalData
     * @private
     */
    _updateTotalData: function()
    {
		_yuitest_coverfunc("/build/charts-base/charts-base.js", "_updateTotalData", 3639);
_yuitest_coverline("/build/charts-base/charts-base.js", 3641);
var keys = this.get("keys"),
            i;
        _yuitest_coverline("/build/charts-base/charts-base.js", 3643);
this._data = [];
        _yuitest_coverline("/build/charts-base/charts-base.js", 3644);
for(i in keys)
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 3646);
if(keys.hasOwnProperty(i))
            {
                _yuitest_coverline("/build/charts-base/charts-base.js", 3648);
this._data = this._data.concat(keys[i]);
            }
        }
        _yuitest_coverline("/build/charts-base/charts-base.js", 3651);
this._updateTotalDataFlag = false;
    },

    /**
     * Removes an array from the key hash.
     * 
     * @method removeKey
     * @param {String} value Indicates what key to use in removing from 
     * the hash.
     */
    removeKey: function(value)
    {
        _yuitest_coverfunc("/build/charts-base/charts-base.js", "removeKey", 3661);
_yuitest_coverline("/build/charts-base/charts-base.js", 3663);
var keys = this.get("keys");
        _yuitest_coverline("/build/charts-base/charts-base.js", 3664);
if(keys.hasOwnProperty(value)) 
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 3666);
delete keys[value];
            _yuitest_coverline("/build/charts-base/charts-base.js", 3667);
this._keyChangeHandler();
        }
    },

    /**
     * Returns a value based of a key value and an index.
     *
     * @method getKeyValueAt
     * @param {String} key value used to look up the correct array
     * @param {Number} index within the array
     * @return Number 
     */
    getKeyValueAt: function(key, index)
    {
        _yuitest_coverfunc("/build/charts-base/charts-base.js", "getKeyValueAt", 3679);
_yuitest_coverline("/build/charts-base/charts-base.js", 3681);
var value = NaN,
            keys = this.get("keys");
        _yuitest_coverline("/build/charts-base/charts-base.js", 3683);
if(keys[key] && Y_Lang.isNumber(parseFloat(keys[key][index])))
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 3685);
value = keys[key][index];
        }
        _yuitest_coverline("/build/charts-base/charts-base.js", 3687);
return parseFloat(value);
    },

    /**
     * Returns an array of values based on an identifier key.
     *
     * @method getDataByKey
     * @param {String} value value used to identify the array
     * @return Object
     */
    getDataByKey: function (value)
    {
        _yuitest_coverfunc("/build/charts-base/charts-base.js", "getDataByKey", 3697);
_yuitest_coverline("/build/charts-base/charts-base.js", 3699);
var keys = this.get("keys");
        _yuitest_coverline("/build/charts-base/charts-base.js", 3700);
if(keys[value])
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 3702);
return keys[value];
        }
        _yuitest_coverline("/build/charts-base/charts-base.js", 3704);
return null;
    },

    /**
     * Calculates the maximum and minimum values for the `Axis`.
     *
     * @method _updateMinAndMax
     * @private 
     */
    _updateMinAndMax: function() 
    {
        _yuitest_coverfunc("/build/charts-base/charts-base.js", "_updateMinAndMax", 3713);
_yuitest_coverline("/build/charts-base/charts-base.js", 3715);
var data = this.get("data"),
            max = 0,
            min = 0,
            len,
            num,
            i;
        _yuitest_coverline("/build/charts-base/charts-base.js", 3721);
if(data && data.length && data.length > 0)
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 3723);
len = data.length;
            _yuitest_coverline("/build/charts-base/charts-base.js", 3724);
max = min = data[0];
            _yuitest_coverline("/build/charts-base/charts-base.js", 3725);
if(len > 1)
            {
                _yuitest_coverline("/build/charts-base/charts-base.js", 3727);
for(i = 1; i < len; i++)
                {	
                    _yuitest_coverline("/build/charts-base/charts-base.js", 3729);
num = data[i];
                    _yuitest_coverline("/build/charts-base/charts-base.js", 3730);
if(isNaN(num))
                    {
                        _yuitest_coverline("/build/charts-base/charts-base.js", 3732);
continue;
                    }
                    _yuitest_coverline("/build/charts-base/charts-base.js", 3734);
max = Math.max(num, max);
                    _yuitest_coverline("/build/charts-base/charts-base.js", 3735);
min = Math.min(num, min);
                }
            }
        }
        _yuitest_coverline("/build/charts-base/charts-base.js", 3739);
this._dataMaximum = max;
        _yuitest_coverline("/build/charts-base/charts-base.js", 3740);
this._dataMinimum = min;
    },

    /**
     * Returns the total number of majorUnits that will appear on an axis.
     *
     * @method getTotalMajorUnits
     * @return Number
     */
    getTotalMajorUnits: function()
    {
        _yuitest_coverfunc("/build/charts-base/charts-base.js", "getTotalMajorUnits", 3749);
_yuitest_coverline("/build/charts-base/charts-base.js", 3751);
var units,
            majorUnit = this.get("styles").majorUnit,
            len = this.get("length");
        _yuitest_coverline("/build/charts-base/charts-base.js", 3754);
if(majorUnit.determinant === "count") 
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 3756);
units = majorUnit.count;
        }
        else {_yuitest_coverline("/build/charts-base/charts-base.js", 3758);
if(majorUnit.determinant === "distance") 
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 3760);
units = (len/majorUnit.distance) + 1;
        }}
        _yuitest_coverline("/build/charts-base/charts-base.js", 3762);
return units; 
    },

    /**
     * Returns the distance between major units on an axis.
     *
     * @method getMajorUnitDistance
     * @param {Number} len Number of ticks
     * @param {Number} uiLen Size of the axis.
     * @param {Object} majorUnit Hash of properties used to determine the majorUnit
     * @return Number
     */
    getMajorUnitDistance: function(len, uiLen, majorUnit)
    {
        _yuitest_coverfunc("/build/charts-base/charts-base.js", "getMajorUnitDistance", 3774);
_yuitest_coverline("/build/charts-base/charts-base.js", 3776);
var dist;
        _yuitest_coverline("/build/charts-base/charts-base.js", 3777);
if(majorUnit.determinant === "count")
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 3779);
dist = uiLen/(len - 1);
        }
        else {_yuitest_coverline("/build/charts-base/charts-base.js", 3781);
if(majorUnit.determinant === "distance")
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 3783);
dist = majorUnit.distance;
        }}
        _yuitest_coverline("/build/charts-base/charts-base.js", 3785);
return dist;
    },
    
    /**
     * Gets the distance that the first and last ticks are offset from there respective
     * edges.
     *
     * @method getEdgeOffset
     * @param {Number} ct Number of ticks on the axis.
     * @param {Number} l Length (in pixels) of the axis.
     * @return Number
     */
    getEdgeOffset: function(ct, l)
    {
        _yuitest_coverfunc("/build/charts-base/charts-base.js", "getEdgeOffset", 3797);
_yuitest_coverline("/build/charts-base/charts-base.js", 3799);
return 0;
    },

    /**
     * Calculates and returns a value based on the number of labels and the index of
     * the current label.
     *
     * @method getLabelByIndex
     * @param {Number} i Index of the label.
     * @param {Number} l Total number of labels.
     * @return String
     */
    getLabelByIndex: function(i, l)
    {
        _yuitest_coverfunc("/build/charts-base/charts-base.js", "getLabelByIndex", 3811);
_yuitest_coverline("/build/charts-base/charts-base.js", 3813);
var min = this.get("minimum"),
            max = this.get("maximum"),
            increm = (max - min)/(l-1),
            label;
            _yuitest_coverline("/build/charts-base/charts-base.js", 3817);
l -= 1;
        _yuitest_coverline("/build/charts-base/charts-base.js", 3818);
label = min + (i * increm);
        _yuitest_coverline("/build/charts-base/charts-base.js", 3819);
return label;
    },

    /**
     * Updates the `Axis` after a change in keys.
     *
     * @method _keyChangeHandler
     * @param {Object} e Event object.
     * @private
     */
    _keyChangeHandler: function(e)
    {
        _yuitest_coverfunc("/build/charts-base/charts-base.js", "_keyChangeHandler", 3829);
_yuitest_coverline("/build/charts-base/charts-base.js", 3831);
this._updateMinAndMax();
        _yuitest_coverline("/build/charts-base/charts-base.js", 3832);
this.fire("dataUpdate");
    },

    /**
     * Checks to see if data extends beyond the range of the axis. If so,
     * that data will need to be hidden. This method is internal, temporary and subject
     * to removal in the future.
     *
     * @method _hasDataOverflow
     * @protected
     * @return Boolean
     */
    _hasDataOverflow: function()
    {
        _yuitest_coverfunc("/build/charts-base/charts-base.js", "_hasDataOverflow", 3844);
_yuitest_coverline("/build/charts-base/charts-base.js", 3846);
if(this.get("setMin") || this.get("setMax"))
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 3848);
return true;
        }
        _yuitest_coverline("/build/charts-base/charts-base.js", 3850);
return false;
    },

    /**
     * Returns a string corresponding to the first label on an 
     * axis.
     *
     * @method getMinimumValue
     * @return String
     */
    getMinimumValue: function()
    {
        _yuitest_coverfunc("/build/charts-base/charts-base.js", "getMinimumValue", 3860);
_yuitest_coverline("/build/charts-base/charts-base.js", 3862);
return this.get("minimum");
    },

    /**
     * Returns a string corresponding to the last label on an 
     * axis.
     *
     * @method getMaximumValue
     * @return String
     */
    getMaximumValue: function()
    {
        _yuitest_coverfunc("/build/charts-base/charts-base.js", "getMaximumValue", 3872);
_yuitest_coverline("/build/charts-base/charts-base.js", 3874);
return this.get("maximum");
    }
}, {
    ATTRS: {
        /**
         * Hash of array identifed by a string value.
         *
         * @attribute keys
         * @type Object
         */
        keys: {
            value: {},

            setter: function(val)
            {
                _yuitest_coverfunc("/build/charts-base/charts-base.js", "setter", 3887);
_yuitest_coverline("/build/charts-base/charts-base.js", 3889);
var keys = {},
                    i, 
                    len,
                    data = this.get("dataProvider");
                _yuitest_coverline("/build/charts-base/charts-base.js", 3893);
if(Y_Lang.isArray(val))
                {
                    _yuitest_coverline("/build/charts-base/charts-base.js", 3895);
len = val.length;
                    _yuitest_coverline("/build/charts-base/charts-base.js", 3896);
for(i = 0; i < len; ++i)
                    {
                        _yuitest_coverline("/build/charts-base/charts-base.js", 3898);
keys[val[i]] = this._getKeyArray(val[i], data);   
                    }
                    
                }
                else {_yuitest_coverline("/build/charts-base/charts-base.js", 3902);
if(Y_Lang.isString(val))
                {
                    _yuitest_coverline("/build/charts-base/charts-base.js", 3904);
keys = this.get("keys");
                    _yuitest_coverline("/build/charts-base/charts-base.js", 3905);
keys[val] = this._getKeyArray(val, data);
                }
                else
                {
                    _yuitest_coverline("/build/charts-base/charts-base.js", 3909);
for(i in val)
                    {
                        _yuitest_coverline("/build/charts-base/charts-base.js", 3911);
if(val.hasOwnProperty(i))
                        {
                            _yuitest_coverline("/build/charts-base/charts-base.js", 3913);
keys[i] = this._getKeyArray(i, data);
                        }
                    }
                }}
	            _yuitest_coverline("/build/charts-base/charts-base.js", 3917);
this._updateTotalDataFlag = true;
                _yuitest_coverline("/build/charts-base/charts-base.js", 3918);
return keys;
            }
        },

        /**
         *Indicates how to round unit values.
         *  <dl>
         *      <dt>niceNumber</dt><dd>Units will be smoothed based on the number of ticks and data range.</dd>
         *      <dt>auto</dt><dd>If the range is greater than 1, the units will be rounded.</dd>
         *      <dt>numeric value</dt><dd>Units will be equal to the numeric value.</dd>
         *      <dt>null</dt><dd>No rounding will occur.</dd>
         *  </dl>
         *
         * @attribute roundingMethod
         * @type String
         * @default niceNumber
         */
        roundingMethod: {
            value: "niceNumber"
        },

        /**
         *Returns the type of axis data
         *  <dl>
         *      <dt>time</dt><dd>Manages time data</dd>
         *      <dt>stacked</dt><dd>Manages stacked numeric data</dd>      
         *      <dt>numeric</dt><dd>Manages numeric data</dd>
         *      <dt>category</dt><dd>Manages categorical data</dd>
         *  </dl>
         *
         * @attribute type
         * @type String
         */
        type:
        {
            readOnly: true,

            getter: function ()
            {
                _yuitest_coverfunc("/build/charts-base/charts-base.js", "getter", 3955);
_yuitest_coverline("/build/charts-base/charts-base.js", 3957);
return this._type;
            }
        },

        /**
         * Instance of `ChartDataProvider` that the class uses
         * to build its own data.
         *
         * @attribute dataProvider
         * @type Array
         */
        dataProvider:{
            setter: function (value)
            {
                _yuitest_coverfunc("/build/charts-base/charts-base.js", "setter", 3969);
_yuitest_coverline("/build/charts-base/charts-base.js", 3971);
return value;
            }
        },

        /**
         * The maximum value contained in the `data` array. Used for
         * `maximum` when `autoMax` is true.
         *
         * @attribute dataMaximum
         * @type Number
         */
        dataMaximum: {
            getter: function ()
            {
                _yuitest_coverfunc("/build/charts-base/charts-base.js", "getter", 3983);
_yuitest_coverline("/build/charts-base/charts-base.js", 3985);
if(!this._dataMaximum)
                {   
                    _yuitest_coverline("/build/charts-base/charts-base.js", 3987);
this._updateMinAndMax();
                }
                _yuitest_coverline("/build/charts-base/charts-base.js", 3989);
return this._dataMaximum;
            }
        },

        /**
         * The maximum value that will appear on an axis.
         *
         * @attribute maximum
         * @type Number
         */
        maximum: {
            lazyAdd: false,

            getter: function ()
            {
                _yuitest_coverfunc("/build/charts-base/charts-base.js", "getter", 4002);
_yuitest_coverline("/build/charts-base/charts-base.js", 4004);
var max = this.get("dataMaximum"),
                    min = this.get("minimum");
                //If all values are zero, force a range so that the Axis and related series
                //will still render.
                _yuitest_coverline("/build/charts-base/charts-base.js", 4008);
if(min === 0 && max === 0)
                {
                    _yuitest_coverline("/build/charts-base/charts-base.js", 4010);
max = 10;
                }
                _yuitest_coverline("/build/charts-base/charts-base.js", 4012);
if(Y_Lang.isNumber(this._setMaximum))
                {
                    _yuitest_coverline("/build/charts-base/charts-base.js", 4014);
max = this._setMaximum;
                }
                _yuitest_coverline("/build/charts-base/charts-base.js", 4016);
return parseFloat(max);
            },
            setter: function (value)
            {
                _yuitest_coverfunc("/build/charts-base/charts-base.js", "setter", 4018);
_yuitest_coverline("/build/charts-base/charts-base.js", 4020);
this._setMaximum = parseFloat(value);
                _yuitest_coverline("/build/charts-base/charts-base.js", 4021);
return value;
            }
        },

        /**
         * The minimum value contained in the `data` array. Used for
         * `minimum` when `autoMin` is true.
         *
         * @attribute dataMinimum
         * @type Number
         */
        dataMinimum: {
            getter: function ()
            {
                _yuitest_coverfunc("/build/charts-base/charts-base.js", "getter", 4033);
_yuitest_coverline("/build/charts-base/charts-base.js", 4035);
if(!this._dataMinimum)
                {
                    _yuitest_coverline("/build/charts-base/charts-base.js", 4037);
this._updateMinAndMax();
                }
                _yuitest_coverline("/build/charts-base/charts-base.js", 4039);
return this._dataMinimum;
            }
        },

        /**
         * The minimum value that will appear on an axis.
         *
         * @attribute minimum
         * @type Number
         */
        minimum: {
            lazyAdd: false,

            getter: function ()
            {
                _yuitest_coverfunc("/build/charts-base/charts-base.js", "getter", 4052);
_yuitest_coverline("/build/charts-base/charts-base.js", 4054);
var min = this.get("dataMinimum");
                _yuitest_coverline("/build/charts-base/charts-base.js", 4055);
if(Y_Lang.isNumber(this._setMinimum))
                {
                    _yuitest_coverline("/build/charts-base/charts-base.js", 4057);
min = this._setMinimum;
                }
                _yuitest_coverline("/build/charts-base/charts-base.js", 4059);
return parseFloat(min);
            },
            setter: function(val)
            {
                _yuitest_coverfunc("/build/charts-base/charts-base.js", "setter", 4061);
_yuitest_coverline("/build/charts-base/charts-base.js", 4063);
this._setMinimum = parseFloat(val);
                _yuitest_coverline("/build/charts-base/charts-base.js", 4064);
return val;
            }
        },

        /**
         * Determines whether the maximum is calculated or explicitly 
         * set by the user.
         *
         * @attribute setMax
         * @type Boolean
         */
        setMax: {
            readOnly: true,

            getter: function()
            {
                _yuitest_coverfunc("/build/charts-base/charts-base.js", "getter", 4078);
_yuitest_coverline("/build/charts-base/charts-base.js", 4080);
return Y_Lang.isNumber(this._setMaximum);
            }
        },

        /**
         * Determines whether the minimum is calculated or explicitly
         * set by the user.
         *
         * @attribute setMin
         * @type Boolean
         */
        setMin: {
            readOnly: true,

            getter: function()
            {
                _yuitest_coverfunc("/build/charts-base/charts-base.js", "getter", 4094);
_yuitest_coverline("/build/charts-base/charts-base.js", 4096);
return Y_Lang.isNumber(this._setMinimum);
            }
        },

        /**
         * Array of axis data
         *
         * @attribute data
         * @type Array
         */
        data: {
            getter: function ()
            {
                _yuitest_coverfunc("/build/charts-base/charts-base.js", "getter", 4107);
_yuitest_coverline("/build/charts-base/charts-base.js", 4109);
if(!this._data || this._updateTotalDataFlag)
                {
                    _yuitest_coverline("/build/charts-base/charts-base.js", 4111);
this._updateTotalData();
                }
                _yuitest_coverline("/build/charts-base/charts-base.js", 4113);
return this._data;
            }
        },

        /**
         * Array containing all the keys in the axis.
        
         * @attribute keyCollection
         * @type Array
         */
        keyCollection: {
            getter: function()
            {
                _yuitest_coverfunc("/build/charts-base/charts-base.js", "getter", 4124);
_yuitest_coverline("/build/charts-base/charts-base.js", 4126);
var keys = this.get("keys"),
                    i, 
                    col = [];
                _yuitest_coverline("/build/charts-base/charts-base.js", 4129);
for(i in keys)
                {
                    _yuitest_coverline("/build/charts-base/charts-base.js", 4131);
if(keys.hasOwnProperty(i))
                    {
                        _yuitest_coverline("/build/charts-base/charts-base.js", 4133);
col.push(i);
                    }
                }
                _yuitest_coverline("/build/charts-base/charts-base.js", 4136);
return col;
            },
            readOnly: true
        }
    }
});
/**
 * NumericAxis manages numeric data on an axis.
 *
 * @module charts
 * @submodule charts-base
 * @class NumericAxis
 * @constructor
 * @param {Object} config (optional) Configuration parameters for the Chart.
 * @extends AxisType
 */
_yuitest_coverline("/build/charts-base/charts-base.js", 4152);
function NumericAxis(config)
{
	_yuitest_coverfunc("/build/charts-base/charts-base.js", "NumericAxis", 4152);
_yuitest_coverline("/build/charts-base/charts-base.js", 4154);
NumericAxis.superclass.constructor.apply(this, arguments);
}

_yuitest_coverline("/build/charts-base/charts-base.js", 4157);
NumericAxis.NAME = "numericAxis";

_yuitest_coverline("/build/charts-base/charts-base.js", 4159);
NumericAxis.ATTRS = {
    /**
     * Indicates whether 0 should always be displayed.
     *
     * @attribute alwaysShowZero
     * @type Boolean
     */
	alwaysShowZero: {
	    value: true	
	},
    
    /**
     * Method used for formatting a label. This attribute allows for the default label formatting method to overridden. The method use would need
     * to implement the arguments below and return a `String` or an `HTMLElement`. The default implementation of the method returns a `String`. The output of this method
     * will be rendered to the DOM using `appendChild`. If you override the `labelFunction` method and return an html string, you will also need to override the Axis' 
     * `appendLabelFunction` to accept html as a `String`.
     * <dl>
     *      <dt>val</dt><dd>Label to be formatted. (`String`)</dd>
     *      <dt>format</dt><dd>Object containing properties used to format the label. (optional)</dd>
     * </dl>
     *
     * @attribute labelFunction
     * @type Function
     */
    labelFunction: { 
        value: function(val, format)
        {
            _yuitest_coverfunc("/build/charts-base/charts-base.js", "value", 4184);
_yuitest_coverline("/build/charts-base/charts-base.js", 4186);
if(format)
            {
                _yuitest_coverline("/build/charts-base/charts-base.js", 4188);
return Y.DataType.Number.format(val, format);
            }
            _yuitest_coverline("/build/charts-base/charts-base.js", 4190);
return val;
        }
    },

    /**
     * Object containing properties used by the `labelFunction` to format a
     * label.
     *
     * @attribute labelFormat
     * @type Object
     */
    labelFormat: {
        value: {
            prefix: "",
            thousandsSeparator: "",
            decimalSeparator: "",
            decimalPlaces: "0",
            suffix: ""
        }
    }
};

_yuitest_coverline("/build/charts-base/charts-base.js", 4212);
Y.extend(NumericAxis, Y.AxisType,
{
    /**
     * Formats a label based on the axis type and optionally specified format.
     *
     * @method formatLabel
     * @param {Object} value
     * @param {Object} format Pattern used to format the value.
     * @return String
     */
    formatLabel: function(val, format)
    {
        _yuitest_coverfunc("/build/charts-base/charts-base.js", "formatLabel", 4222);
_yuitest_coverline("/build/charts-base/charts-base.js", 4224);
if(format)
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 4226);
return Y.DataType.Number.format(val, format);
        }
        _yuitest_coverline("/build/charts-base/charts-base.js", 4228);
return val;
    },

    /**
     * Returns the sum of all values per key.
     *
     * @method getTotalByKey
     * @param {String} key The identifier for the array whose values will be calculated.
     * @return Number
     */
    getTotalByKey: function(key)
    {
        _yuitest_coverfunc("/build/charts-base/charts-base.js", "getTotalByKey", 4238);
_yuitest_coverline("/build/charts-base/charts-base.js", 4240);
var total = 0,
            values = this.getDataByKey(key),
            i = 0,
            val,
            len = values ? values.length : 0;
        _yuitest_coverline("/build/charts-base/charts-base.js", 4245);
for(; i < len; ++i)
        {
           _yuitest_coverline("/build/charts-base/charts-base.js", 4247);
val = parseFloat(values[i]);
           _yuitest_coverline("/build/charts-base/charts-base.js", 4248);
if(!isNaN(val))
           {
                _yuitest_coverline("/build/charts-base/charts-base.js", 4250);
total += val;
           }
        }
        _yuitest_coverline("/build/charts-base/charts-base.js", 4253);
return total;
    },

    /**
     * Type of data used in `Axis`.
     *
     * @property _type
     * @readOnly
     * @private
     */
    _type: "numeric",

    /**
     * Helper method for getting a `roundingUnit` when calculating the minimum and maximum values.
     *
     * @method _getMinimumUnit
     * @param {Number} max Maximum number
     * @param {Number} min Minimum number
     * @param {Number} units Number of units on the axis
     * @return Number
     * @private
     */
    _getMinimumUnit:function(max, min, units)
    {
        _yuitest_coverfunc("/build/charts-base/charts-base.js", "_getMinimumUnit", 4275);
_yuitest_coverline("/build/charts-base/charts-base.js", 4277);
return this._getNiceNumber(Math.ceil((max - min)/units));
    },

    /**
     * Calculates a nice rounding unit based on the range.
     *
     * @method _getNiceNumber
     * @param {Number} roundingUnit The calculated rounding unit.
     * @return Number
     * @private
     */
    _getNiceNumber: function(roundingUnit)
    {
        _yuitest_coverfunc("/build/charts-base/charts-base.js", "_getNiceNumber", 4288);
_yuitest_coverline("/build/charts-base/charts-base.js", 4290);
var tempMajorUnit = roundingUnit,
            order = Math.ceil(Math.log(tempMajorUnit) * 0.4342944819032518),
            roundedMajorUnit = Math.pow(10, order),
            roundedDiff;

        _yuitest_coverline("/build/charts-base/charts-base.js", 4295);
if (roundedMajorUnit / 2 >= tempMajorUnit) 
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 4297);
roundedDiff = Math.floor((roundedMajorUnit / 2 - tempMajorUnit) / (Math.pow(10,order-1)/2));
            _yuitest_coverline("/build/charts-base/charts-base.js", 4298);
tempMajorUnit = roundedMajorUnit/2 - roundedDiff*Math.pow(10,order-1)/2;
        }
        else 
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 4302);
tempMajorUnit = roundedMajorUnit;
        }
        _yuitest_coverline("/build/charts-base/charts-base.js", 4304);
if(!isNaN(tempMajorUnit))
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 4306);
return tempMajorUnit;
        }
        _yuitest_coverline("/build/charts-base/charts-base.js", 4308);
return roundingUnit;

    },

    /**
     * Calculates the maximum and minimum values for the `Axis`.
     *
     * @method _updateMinAndMax
     * @private 
     */
    _updateMinAndMax: function()
    {
        _yuitest_coverfunc("/build/charts-base/charts-base.js", "_updateMinAndMax", 4318);
_yuitest_coverline("/build/charts-base/charts-base.js", 4320);
var data = this.get("data"),
            max, 
            min,
            len,
            num,
            i = 0,
            key,
            setMax = this.get("setMax"),
            setMin = this.get("setMin");
        _yuitest_coverline("/build/charts-base/charts-base.js", 4329);
if(!setMax || !setMin)
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 4331);
if(data && data.length && data.length > 0)
            {
                _yuitest_coverline("/build/charts-base/charts-base.js", 4333);
len = data.length;
                _yuitest_coverline("/build/charts-base/charts-base.js", 4334);
for(; i < len; i++)
                {	
                    _yuitest_coverline("/build/charts-base/charts-base.js", 4336);
num = data[i];
                    _yuitest_coverline("/build/charts-base/charts-base.js", 4337);
if(isNaN(num))
                    {
                        _yuitest_coverline("/build/charts-base/charts-base.js", 4339);
if(Y_Lang.isObject(num))
                        {
                            _yuitest_coverline("/build/charts-base/charts-base.js", 4341);
min = max = 0;
                            //hloc values
                            _yuitest_coverline("/build/charts-base/charts-base.js", 4343);
for(key in num)
                            {
                               _yuitest_coverline("/build/charts-base/charts-base.js", 4345);
if(num.hasOwnProperty(key))
                               {
                                    _yuitest_coverline("/build/charts-base/charts-base.js", 4347);
max = Math.max(num[key], max);
                                    _yuitest_coverline("/build/charts-base/charts-base.js", 4348);
min = Math.min(num[key], min);
                               }
                            }
                        }
                        _yuitest_coverline("/build/charts-base/charts-base.js", 4352);
max = setMax ? this._setMaximum : max;
                        _yuitest_coverline("/build/charts-base/charts-base.js", 4353);
min = setMin ? this._setMinimum : min;
                        _yuitest_coverline("/build/charts-base/charts-base.js", 4354);
continue;
                    }
                    
                    _yuitest_coverline("/build/charts-base/charts-base.js", 4357);
if(setMin)
                    {
                        _yuitest_coverline("/build/charts-base/charts-base.js", 4359);
min = this._setMinimum;
                    }
                    else {_yuitest_coverline("/build/charts-base/charts-base.js", 4361);
if(min === undefined)
                    {
                        _yuitest_coverline("/build/charts-base/charts-base.js", 4363);
min = num;
                    }
                    else
                    {
                        _yuitest_coverline("/build/charts-base/charts-base.js", 4367);
min = Math.min(num, min); 
                    }}
                    _yuitest_coverline("/build/charts-base/charts-base.js", 4369);
if(setMax)
                    {
                        _yuitest_coverline("/build/charts-base/charts-base.js", 4371);
max = this._setMaximum;
                    }
                    else {_yuitest_coverline("/build/charts-base/charts-base.js", 4373);
if(max === undefined)
                    {
                        _yuitest_coverline("/build/charts-base/charts-base.js", 4375);
max = num;
                    }
                    else
                    {
                        _yuitest_coverline("/build/charts-base/charts-base.js", 4379);
max = Math.max(num, max);
                    }}
                    
                    _yuitest_coverline("/build/charts-base/charts-base.js", 4382);
this._actualMaximum = max;
                    _yuitest_coverline("/build/charts-base/charts-base.js", 4383);
this._actualMinimum = min;
                }
            }
            _yuitest_coverline("/build/charts-base/charts-base.js", 4386);
this._roundMinAndMax(min, max, setMin, setMax);
        }
    },

    /**
     * Rounds the mimimum and maximum values based on the `roundingUnit` attribute.
     *
     * @method _roundMinAndMax
     * @param {Number} min Minimum value
     * @param {Number} max Maximum value
     * @private
     */
    _roundMinAndMax: function(min, max, setMin, setMax)
    {
        _yuitest_coverfunc("/build/charts-base/charts-base.js", "_roundMinAndMax", 4398);
_yuitest_coverline("/build/charts-base/charts-base.js", 4400);
var roundingUnit,
            minimumRange,
            minGreaterThanZero = min >= 0,
            maxGreaterThanZero = max > 0,
            dataRangeGreater,
            maxRound,
            minRound,
            topTicks,
            botTicks,
            tempMax,
            tempMin,
            units = this.getTotalMajorUnits() - 1,
            alwaysShowZero = this.get("alwaysShowZero"),
            roundingMethod = this.get("roundingMethod"),
            useIntegers = (max - min)/units >= 1;
        _yuitest_coverline("/build/charts-base/charts-base.js", 4415);
if(roundingMethod)
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 4417);
if(roundingMethod == "niceNumber")
            {
                _yuitest_coverline("/build/charts-base/charts-base.js", 4419);
roundingUnit = this._getMinimumUnit(max, min, units);
                _yuitest_coverline("/build/charts-base/charts-base.js", 4420);
if(minGreaterThanZero && maxGreaterThanZero)
                {
                    _yuitest_coverline("/build/charts-base/charts-base.js", 4422);
if((alwaysShowZero || min < roundingUnit) && !setMin)
                    {
                        _yuitest_coverline("/build/charts-base/charts-base.js", 4424);
min = 0;
                        _yuitest_coverline("/build/charts-base/charts-base.js", 4425);
roundingUnit = this._getMinimumUnit(max, min, units);
                    }
                    else
                    {
                       _yuitest_coverline("/build/charts-base/charts-base.js", 4429);
min = this._roundDownToNearest(min, roundingUnit);
                    }
                    _yuitest_coverline("/build/charts-base/charts-base.js", 4431);
if(setMax)
                    {
                        _yuitest_coverline("/build/charts-base/charts-base.js", 4433);
if(!alwaysShowZero)
                        {
                            _yuitest_coverline("/build/charts-base/charts-base.js", 4435);
min = max - (roundingUnit * units);
                        }
                    }
                    else {_yuitest_coverline("/build/charts-base/charts-base.js", 4438);
if(setMin)
                    {
                        _yuitest_coverline("/build/charts-base/charts-base.js", 4440);
max = min + (roundingUnit * units);
                    }
                    else
                    {
                        _yuitest_coverline("/build/charts-base/charts-base.js", 4444);
max = this._roundUpToNearest(max, roundingUnit);
                    }}
                }
                else {_yuitest_coverline("/build/charts-base/charts-base.js", 4447);
if(maxGreaterThanZero && !minGreaterThanZero)
                {
                    _yuitest_coverline("/build/charts-base/charts-base.js", 4449);
if(alwaysShowZero)
                    {
                        _yuitest_coverline("/build/charts-base/charts-base.js", 4451);
topTicks = Math.round(units/((-1 * min)/max + 1));
                        _yuitest_coverline("/build/charts-base/charts-base.js", 4452);
topTicks = Math.max(Math.min(topTicks, units - 1), 1);
                        _yuitest_coverline("/build/charts-base/charts-base.js", 4453);
botTicks = units - topTicks;
                        _yuitest_coverline("/build/charts-base/charts-base.js", 4454);
tempMax = Math.ceil( max/topTicks );
                        _yuitest_coverline("/build/charts-base/charts-base.js", 4455);
tempMin = Math.floor( min/botTicks ) * -1;
                        
                        _yuitest_coverline("/build/charts-base/charts-base.js", 4457);
if(setMin)
                        {
                            _yuitest_coverline("/build/charts-base/charts-base.js", 4459);
while(tempMin < tempMax && botTicks >= 0)
                            {
                                _yuitest_coverline("/build/charts-base/charts-base.js", 4461);
botTicks--;
                                _yuitest_coverline("/build/charts-base/charts-base.js", 4462);
topTicks++;
                                _yuitest_coverline("/build/charts-base/charts-base.js", 4463);
tempMax = Math.ceil( max/topTicks );
                                _yuitest_coverline("/build/charts-base/charts-base.js", 4464);
tempMin = Math.floor( min/botTicks ) * -1;
                            }
                            //if there are any bottom ticks left calcualate the maximum by multiplying by the tempMin value
                            //if not, it's impossible to ensure that a zero is shown. skip it
                            _yuitest_coverline("/build/charts-base/charts-base.js", 4468);
if(botTicks > 0)
                            {
                                _yuitest_coverline("/build/charts-base/charts-base.js", 4470);
max = tempMin * topTicks;
                            }
                            else
                            {
                                _yuitest_coverline("/build/charts-base/charts-base.js", 4474);
max = min + (roundingUnit * units);
                            }
                        }
                        else {_yuitest_coverline("/build/charts-base/charts-base.js", 4477);
if(setMax)
                        {
                            _yuitest_coverline("/build/charts-base/charts-base.js", 4479);
while(tempMax < tempMin && topTicks >= 0)
                            {
                                _yuitest_coverline("/build/charts-base/charts-base.js", 4481);
botTicks++;
                                _yuitest_coverline("/build/charts-base/charts-base.js", 4482);
topTicks--;
                                _yuitest_coverline("/build/charts-base/charts-base.js", 4483);
tempMin = Math.floor( min/botTicks ) * -1;
                                _yuitest_coverline("/build/charts-base/charts-base.js", 4484);
tempMax = Math.ceil( max/topTicks );
                            }
                            //if there are any top ticks left calcualate the minimum by multiplying by the tempMax value
                            //if not, it's impossible to ensure that a zero is shown. skip it
                            _yuitest_coverline("/build/charts-base/charts-base.js", 4488);
if(topTicks > 0)
                            {
                                _yuitest_coverline("/build/charts-base/charts-base.js", 4490);
min = tempMax * botTicks * -1;
                            }
                            else
                            {
                                _yuitest_coverline("/build/charts-base/charts-base.js", 4494);
min = max - (roundingUnit * units);
                            }
                        }
                        else
                        {
                            _yuitest_coverline("/build/charts-base/charts-base.js", 4499);
roundingUnit = Math.max(tempMax, tempMin);
                            _yuitest_coverline("/build/charts-base/charts-base.js", 4500);
roundingUnit = this._getNiceNumber(roundingUnit);  
                            _yuitest_coverline("/build/charts-base/charts-base.js", 4501);
max = roundingUnit * topTicks;
                            _yuitest_coverline("/build/charts-base/charts-base.js", 4502);
min = roundingUnit * botTicks * -1;
                        }}
                    }
                    else 
                    {
                        _yuitest_coverline("/build/charts-base/charts-base.js", 4507);
if(setMax)
                        {
                            _yuitest_coverline("/build/charts-base/charts-base.js", 4509);
min = max - (roundingUnit * units);
                        }
                        else {_yuitest_coverline("/build/charts-base/charts-base.js", 4511);
if(setMin)
                        {
                            _yuitest_coverline("/build/charts-base/charts-base.js", 4513);
max = min + (roundingUnit * units);
                        }
                        else
                        {
                            _yuitest_coverline("/build/charts-base/charts-base.js", 4517);
min = this._roundDownToNearest(min, roundingUnit);
                            _yuitest_coverline("/build/charts-base/charts-base.js", 4518);
max = this._roundUpToNearest(max, roundingUnit);
                        }}
                    }
                }
                else
                {
                    _yuitest_coverline("/build/charts-base/charts-base.js", 4524);
if(setMin)
                    {
                        _yuitest_coverline("/build/charts-base/charts-base.js", 4526);
if(alwaysShowZero)
                        {
                            _yuitest_coverline("/build/charts-base/charts-base.js", 4528);
max = 0;
                        }
                        else
                        {
                            _yuitest_coverline("/build/charts-base/charts-base.js", 4532);
max = min + (roundingUnit * units);
                        }
                    }
                    else {_yuitest_coverline("/build/charts-base/charts-base.js", 4535);
if(!setMax)
                    {
                        _yuitest_coverline("/build/charts-base/charts-base.js", 4537);
if(alwaysShowZero || max === 0 || max + roundingUnit > 0)
                        {
                            _yuitest_coverline("/build/charts-base/charts-base.js", 4539);
max = 0;
                            _yuitest_coverline("/build/charts-base/charts-base.js", 4540);
roundingUnit = this._getMinimumUnit(max, min, units);
                            _yuitest_coverline("/build/charts-base/charts-base.js", 4541);
min = max - (roundingUnit * units);
                        }
                        else
                        {
                            _yuitest_coverline("/build/charts-base/charts-base.js", 4545);
min = this._roundDownToNearest(min, roundingUnit);
                            _yuitest_coverline("/build/charts-base/charts-base.js", 4546);
max = this._roundUpToNearest(max, roundingUnit);
                        }
                    }
                    else
                    {
                        _yuitest_coverline("/build/charts-base/charts-base.js", 4551);
min = max - (roundingUnit * units);
                    }}
                }}
            }
            else {_yuitest_coverline("/build/charts-base/charts-base.js", 4555);
if(roundingMethod == "auto") 
            {
                _yuitest_coverline("/build/charts-base/charts-base.js", 4557);
if(minGreaterThanZero && maxGreaterThanZero)
                {
                    _yuitest_coverline("/build/charts-base/charts-base.js", 4559);
if((alwaysShowZero || min < (max-min)/units) && !setMin)
                    {
                        _yuitest_coverline("/build/charts-base/charts-base.js", 4561);
min = 0;
                    }
                
                    _yuitest_coverline("/build/charts-base/charts-base.js", 4564);
roundingUnit = (max - min)/units;
                    _yuitest_coverline("/build/charts-base/charts-base.js", 4565);
if(useIntegers)
                    {
                        _yuitest_coverline("/build/charts-base/charts-base.js", 4567);
roundingUnit = Math.ceil(roundingUnit);
                    }
                    _yuitest_coverline("/build/charts-base/charts-base.js", 4569);
max = min + (roundingUnit * units);
                }
                else {_yuitest_coverline("/build/charts-base/charts-base.js", 4571);
if(maxGreaterThanZero && !minGreaterThanZero)
                {
                    _yuitest_coverline("/build/charts-base/charts-base.js", 4573);
if(alwaysShowZero)
                    {
                        _yuitest_coverline("/build/charts-base/charts-base.js", 4575);
topTicks = Math.round( units / ( (-1 * min) /max + 1) );
                        _yuitest_coverline("/build/charts-base/charts-base.js", 4576);
topTicks = Math.max(Math.min(topTicks, units - 1), 1);
                        _yuitest_coverline("/build/charts-base/charts-base.js", 4577);
botTicks = units - topTicks;

                        _yuitest_coverline("/build/charts-base/charts-base.js", 4579);
if(useIntegers)
                        {
                            _yuitest_coverline("/build/charts-base/charts-base.js", 4581);
tempMax = Math.ceil( max/topTicks );
                            _yuitest_coverline("/build/charts-base/charts-base.js", 4582);
tempMin = Math.floor( min/botTicks ) * -1;
                        }
                        else
                        {
                            _yuitest_coverline("/build/charts-base/charts-base.js", 4586);
tempMax = max/topTicks;
                            _yuitest_coverline("/build/charts-base/charts-base.js", 4587);
tempMin = min/botTicks * -1;
                        }
                        _yuitest_coverline("/build/charts-base/charts-base.js", 4589);
roundingUnit = Math.max(tempMax, tempMin);
                        _yuitest_coverline("/build/charts-base/charts-base.js", 4590);
max = roundingUnit * topTicks;
                        _yuitest_coverline("/build/charts-base/charts-base.js", 4591);
min = roundingUnit * botTicks * -1;
                    }
                    else
                    {
                        _yuitest_coverline("/build/charts-base/charts-base.js", 4595);
roundingUnit = (max - min)/units;
                        _yuitest_coverline("/build/charts-base/charts-base.js", 4596);
if(useIntegers)
                        {
                            _yuitest_coverline("/build/charts-base/charts-base.js", 4598);
roundingUnit = Math.ceil(roundingUnit);
                        }
                        _yuitest_coverline("/build/charts-base/charts-base.js", 4600);
min = this._roundDownToNearest(min, roundingUnit);
                        _yuitest_coverline("/build/charts-base/charts-base.js", 4601);
max = this._roundUpToNearest(max, roundingUnit);
                    }
                }
                else
                {
                    _yuitest_coverline("/build/charts-base/charts-base.js", 4606);
roundingUnit = (max - min)/units;
                    _yuitest_coverline("/build/charts-base/charts-base.js", 4607);
if(useIntegers)
                    {   
                        _yuitest_coverline("/build/charts-base/charts-base.js", 4609);
roundingUnit = Math.ceil(roundingUnit);
                    }
                    _yuitest_coverline("/build/charts-base/charts-base.js", 4611);
if(alwaysShowZero || max === 0 || max + roundingUnit > 0)
                    {
                        _yuitest_coverline("/build/charts-base/charts-base.js", 4613);
max = 0;
                        _yuitest_coverline("/build/charts-base/charts-base.js", 4614);
roundingUnit = (max - min)/units;
                        _yuitest_coverline("/build/charts-base/charts-base.js", 4615);
if(useIntegers)
                        {
                            _yuitest_coverline("/build/charts-base/charts-base.js", 4617);
Math.ceil(roundingUnit);
                        }
                        _yuitest_coverline("/build/charts-base/charts-base.js", 4619);
min = max - (roundingUnit * units);
                    }
                    else
                    {
                        _yuitest_coverline("/build/charts-base/charts-base.js", 4623);
min = this._roundDownToNearest(min, roundingUnit);
                        _yuitest_coverline("/build/charts-base/charts-base.js", 4624);
max = this._roundUpToNearest(max, roundingUnit);
                    }

                }}
            }
            else {_yuitest_coverline("/build/charts-base/charts-base.js", 4629);
if(!isNaN(roundingMethod) && isFinite(roundingMethod))
            {
                _yuitest_coverline("/build/charts-base/charts-base.js", 4631);
roundingUnit = roundingMethod;
                _yuitest_coverline("/build/charts-base/charts-base.js", 4632);
minimumRange = roundingUnit * units;
                _yuitest_coverline("/build/charts-base/charts-base.js", 4633);
dataRangeGreater = (max - min) > minimumRange;
                _yuitest_coverline("/build/charts-base/charts-base.js", 4634);
minRound = this._roundDownToNearest(min, roundingUnit);
                _yuitest_coverline("/build/charts-base/charts-base.js", 4635);
maxRound = this._roundUpToNearest(max, roundingUnit);
                _yuitest_coverline("/build/charts-base/charts-base.js", 4636);
if(setMax)
                {
                    _yuitest_coverline("/build/charts-base/charts-base.js", 4638);
min = max - minimumRange;
                }
                else {_yuitest_coverline("/build/charts-base/charts-base.js", 4640);
if(setMin)
                {
                    _yuitest_coverline("/build/charts-base/charts-base.js", 4642);
max = min + minimumRange;
                }
                else {_yuitest_coverline("/build/charts-base/charts-base.js", 4644);
if(minGreaterThanZero && maxGreaterThanZero)
                {
                    _yuitest_coverline("/build/charts-base/charts-base.js", 4646);
if(alwaysShowZero || minRound <= 0)
                    {
                        _yuitest_coverline("/build/charts-base/charts-base.js", 4648);
min = 0;
                    }
                    else
                    {
                        _yuitest_coverline("/build/charts-base/charts-base.js", 4652);
min = minRound;
                    }
                    _yuitest_coverline("/build/charts-base/charts-base.js", 4654);
max = min + minimumRange;
                }
                else {_yuitest_coverline("/build/charts-base/charts-base.js", 4656);
if(maxGreaterThanZero && !minGreaterThanZero)
                {
                    _yuitest_coverline("/build/charts-base/charts-base.js", 4658);
min = minRound;
                    _yuitest_coverline("/build/charts-base/charts-base.js", 4659);
max = maxRound;
                }
                else
                {
                    _yuitest_coverline("/build/charts-base/charts-base.js", 4663);
if(alwaysShowZero || maxRound >= 0)
                    {
                        _yuitest_coverline("/build/charts-base/charts-base.js", 4665);
max = 0;
                    }
                    else
                    {
                        _yuitest_coverline("/build/charts-base/charts-base.js", 4669);
max = maxRound;
                    }
                    _yuitest_coverline("/build/charts-base/charts-base.js", 4671);
min = max - minimumRange;
                }}}}
            }}}
        }
        _yuitest_coverline("/build/charts-base/charts-base.js", 4675);
this._dataMaximum = max;
        _yuitest_coverline("/build/charts-base/charts-base.js", 4676);
this._dataMinimum = min;
    },

    /**
     * Calculates and returns a value based on the number of labels and the index of
     * the current label.
     *
     * @method getLabelByIndex
     * @param {Number} i Index of the label.
     * @param {Number} l Total number of labels.
     * @return String
     */
    getLabelByIndex: function(i, l)
    {
        _yuitest_coverfunc("/build/charts-base/charts-base.js", "getLabelByIndex", 4688);
_yuitest_coverline("/build/charts-base/charts-base.js", 4690);
var min = this.get("minimum"),
            max = this.get("maximum"),
            increm = (max - min)/(l-1),
            label,
            roundingMethod = this.get("roundingMethod");
            _yuitest_coverline("/build/charts-base/charts-base.js", 4695);
l -= 1;
        //respect the min and max. calculate all other labels.
        _yuitest_coverline("/build/charts-base/charts-base.js", 4697);
if(i === 0)
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 4699);
label = min;
        }
        else {_yuitest_coverline("/build/charts-base/charts-base.js", 4701);
if(i === l)
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 4703);
label = max;
        }
        else
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 4707);
label = (i * increm);
            _yuitest_coverline("/build/charts-base/charts-base.js", 4708);
if(roundingMethod == "niceNumber")
            {
                _yuitest_coverline("/build/charts-base/charts-base.js", 4710);
label = this._roundToNearest(label, increm);
            }
            _yuitest_coverline("/build/charts-base/charts-base.js", 4712);
label += min;
        }}
        _yuitest_coverline("/build/charts-base/charts-base.js", 4714);
return parseFloat(label);
    },

    /**
     * Rounds a Number to the nearest multiple of an input. For example, by rounding
     * 16 to the nearest 10, you will receive 20. Similar to the built-in function Math.round().
     *
     * @method _roundToNearest
     * @param {Number} number Number to round
     * @param {Number} nearest Multiple to round towards.
     * @return Number
     * @private
     */
    _roundToNearest: function(number, nearest)
    {
        _yuitest_coverfunc("/build/charts-base/charts-base.js", "_roundToNearest", 4727);
_yuitest_coverline("/build/charts-base/charts-base.js", 4729);
nearest = nearest || 1;
        _yuitest_coverline("/build/charts-base/charts-base.js", 4730);
if(nearest === 0)
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 4732);
return number;
        }
        _yuitest_coverline("/build/charts-base/charts-base.js", 4734);
var roundedNumber = Math.round(this._roundToPrecision(number / nearest, 10)) * nearest;
        _yuitest_coverline("/build/charts-base/charts-base.js", 4735);
return this._roundToPrecision(roundedNumber, 10);
    },
	
    /**
     * Rounds a Number up to the nearest multiple of an input. For example, by rounding
     * 16 up to the nearest 10, you will receive 20. Similar to the built-in function Math.ceil().
     *
     * @method _roundUpToNearest
     * @param {Number} number Number to round
     * @param {Number} nearest Multiple to round towards.
     * @return Number
     * @private
     */
    _roundUpToNearest: function(number, nearest)
    {
        _yuitest_coverfunc("/build/charts-base/charts-base.js", "_roundUpToNearest", 4748);
_yuitest_coverline("/build/charts-base/charts-base.js", 4750);
nearest = nearest || 1;
        _yuitest_coverline("/build/charts-base/charts-base.js", 4751);
if(nearest === 0)
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 4753);
return number;
        }
        _yuitest_coverline("/build/charts-base/charts-base.js", 4755);
return Math.ceil(this._roundToPrecision(number / nearest, 10)) * nearest;
    },
	
    /**
     * Rounds a Number down to the nearest multiple of an input. For example, by rounding
     * 16 down to the nearest 10, you will receive 10. Similar to the built-in function Math.floor().
     *
     * @method _roundDownToNearest
     * @param {Number} number Number to round
     * @param {Number} nearest Multiple to round towards.
     * @return Number
     * @private
     */
    _roundDownToNearest: function(number, nearest)
    {
        _yuitest_coverfunc("/build/charts-base/charts-base.js", "_roundDownToNearest", 4768);
_yuitest_coverline("/build/charts-base/charts-base.js", 4770);
nearest = nearest || 1;
        _yuitest_coverline("/build/charts-base/charts-base.js", 4771);
if(nearest === 0)
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 4773);
return number;
        }
        _yuitest_coverline("/build/charts-base/charts-base.js", 4775);
return Math.floor(this._roundToPrecision(number / nearest, 10)) * nearest;
    },

    /**
     * Rounds a number to a certain level of precision. Useful for limiting the number of
     * decimal places on a fractional number.
     *
     * @method _roundToPrecision
     * @param {Number} number Number to round
     * @param {Number} precision Multiple to round towards.
     * @return Number
     * @private
     */
    _roundToPrecision: function(number, precision)
    {
        _yuitest_coverfunc("/build/charts-base/charts-base.js", "_roundToPrecision", 4788);
_yuitest_coverline("/build/charts-base/charts-base.js", 4790);
precision = precision || 0;
        _yuitest_coverline("/build/charts-base/charts-base.js", 4791);
var decimalPlaces = Math.pow(10, precision);
        _yuitest_coverline("/build/charts-base/charts-base.js", 4792);
return Math.round(decimalPlaces * number) / decimalPlaces;
    },
    
    /**
     * Checks to see if data extends beyond the range of the axis. If so,
     * that data will need to be hidden. This method is internal, temporary and subject
     * to removal in the future.
     *
     * @method _hasDataOverflow
     * @protected
     * @return Boolean
     */
    _hasDataOverflow: function()
    {
        _yuitest_coverfunc("/build/charts-base/charts-base.js", "_hasDataOverflow", 4804);
_yuitest_coverline("/build/charts-base/charts-base.js", 4806);
var roundingMethod,
            min,
            max;
        _yuitest_coverline("/build/charts-base/charts-base.js", 4809);
if(this.get("setMin") || this.get("setMax"))
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 4811);
return true;
        }
        _yuitest_coverline("/build/charts-base/charts-base.js", 4813);
roundingMethod = this.get("roundingMethod");
        _yuitest_coverline("/build/charts-base/charts-base.js", 4814);
min = this._actualMinimum;
        _yuitest_coverline("/build/charts-base/charts-base.js", 4815);
max = this._actualMaximum;
        _yuitest_coverline("/build/charts-base/charts-base.js", 4816);
if(Y_Lang.isNumber(roundingMethod) && ((Y_Lang.isNumber(max) && max > this._dataMaximum) || (Y_Lang.isNumber(min) && min < this._dataMinimum)))
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 4818);
return true;
        }
        _yuitest_coverline("/build/charts-base/charts-base.js", 4820);
return false;
    }
});

_yuitest_coverline("/build/charts-base/charts-base.js", 4824);
Y.NumericAxis = NumericAxis;
		
/**
 * StackedAxis manages stacked numeric data on an axis.
 *
 * @module charts
 * @submodule charts-base
 * @class StackedAxis
 * @constructor
 * @param {Object} config (optional) Configuration parameters for the Chart.
 * @extends NumericAxis
 */
_yuitest_coverline("/build/charts-base/charts-base.js", 4836);
function StackedAxis(config)
{
	_yuitest_coverfunc("/build/charts-base/charts-base.js", "StackedAxis", 4836);
_yuitest_coverline("/build/charts-base/charts-base.js", 4838);
StackedAxis.superclass.constructor.apply(this, arguments);
}

_yuitest_coverline("/build/charts-base/charts-base.js", 4841);
StackedAxis.NAME = "stackedAxis";


_yuitest_coverline("/build/charts-base/charts-base.js", 4844);
Y.extend(StackedAxis, Y.NumericAxis,
{
    /**
     * Calculates the maximum and minimum values for the `Axis`.
     *
     * @method _updateMinAndMax
     * @private 
     */
    _updateMinAndMax: function()
    {
        _yuitest_coverfunc("/build/charts-base/charts-base.js", "_updateMinAndMax", 4852);
_yuitest_coverline("/build/charts-base/charts-base.js", 4854);
var max = 0,
            min = 0,
            pos = 0,
            neg = 0,
            len = 0,
            i = 0,
            key,
            num,
            keys = this.get("keys"),
            setMin = this.get("setMin"),
            setMax = this.get("setMax");

        _yuitest_coverline("/build/charts-base/charts-base.js", 4866);
for(key in keys)
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 4868);
if(keys.hasOwnProperty(key))
            {
                _yuitest_coverline("/build/charts-base/charts-base.js", 4870);
len = Math.max(len, keys[key].length);
            }
        }
        _yuitest_coverline("/build/charts-base/charts-base.js", 4873);
for(; i < len; ++i)
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 4875);
pos = 0;
            _yuitest_coverline("/build/charts-base/charts-base.js", 4876);
neg = 0;
            _yuitest_coverline("/build/charts-base/charts-base.js", 4877);
for(key in keys)
            {
                _yuitest_coverline("/build/charts-base/charts-base.js", 4879);
if(keys.hasOwnProperty(key))
                {
                    _yuitest_coverline("/build/charts-base/charts-base.js", 4881);
num = keys[key][i];
                    _yuitest_coverline("/build/charts-base/charts-base.js", 4882);
if(isNaN(num))
                    {
                        _yuitest_coverline("/build/charts-base/charts-base.js", 4884);
continue;
                    }
                    _yuitest_coverline("/build/charts-base/charts-base.js", 4886);
if(num >= 0)
                    {
                        _yuitest_coverline("/build/charts-base/charts-base.js", 4888);
pos += num;
                    }
                    else
                    {
                        _yuitest_coverline("/build/charts-base/charts-base.js", 4892);
neg += num;
                    }
                }
            }
            _yuitest_coverline("/build/charts-base/charts-base.js", 4896);
if(pos > 0)
            {
                _yuitest_coverline("/build/charts-base/charts-base.js", 4898);
max = Math.max(max, pos);
            }
            else 
            {
                _yuitest_coverline("/build/charts-base/charts-base.js", 4902);
max = Math.max(max, neg);
            }
            _yuitest_coverline("/build/charts-base/charts-base.js", 4904);
if(neg < 0)
            {
                _yuitest_coverline("/build/charts-base/charts-base.js", 4906);
min = Math.min(min, neg);
            }
            else
            {
                _yuitest_coverline("/build/charts-base/charts-base.js", 4910);
min = Math.min(min, pos);
            }
        }
        _yuitest_coverline("/build/charts-base/charts-base.js", 4913);
this._actualMaximum = max;
        _yuitest_coverline("/build/charts-base/charts-base.js", 4914);
this._actualMinimum = min;
        _yuitest_coverline("/build/charts-base/charts-base.js", 4915);
if(setMax)
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 4917);
max = this._setMaximum;
        }
        _yuitest_coverline("/build/charts-base/charts-base.js", 4919);
if(setMin)
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 4921);
min = this._setMinimum;
        }
        _yuitest_coverline("/build/charts-base/charts-base.js", 4923);
this._roundMinAndMax(min, max, setMin, setMax);
    }
});

_yuitest_coverline("/build/charts-base/charts-base.js", 4927);
Y.StackedAxis = StackedAxis;
		
/**
 * TimeAxis manages time data on an axis.
 *
 * @module charts
 * @submodule charts-base
 * @class TimeAxis
 * @constructor
 * @param {Object} config (optional) Configuration parameters for the Chart.
 * @extends AxisType
 */
_yuitest_coverline("/build/charts-base/charts-base.js", 4939);
function TimeAxis(config)
{
	_yuitest_coverfunc("/build/charts-base/charts-base.js", "TimeAxis", 4939);
_yuitest_coverline("/build/charts-base/charts-base.js", 4941);
TimeAxis.superclass.constructor.apply(this, arguments);
}

_yuitest_coverline("/build/charts-base/charts-base.js", 4944);
TimeAxis.NAME = "timeAxis";

_yuitest_coverline("/build/charts-base/charts-base.js", 4946);
TimeAxis.ATTRS = 
{
    /**
     * Indicates whether the maximum is calculated or explicitly set. 
     *
     * @attribute setMax
     * @readOnly
     * @type Boolean
     * @private
     */
    setMax: {
        readOnly: true,

        getter: function()
        {
            _yuitest_coverfunc("/build/charts-base/charts-base.js", "getter", 4959);
_yuitest_coverline("/build/charts-base/charts-base.js", 4961);
var max = this._getNumber(this._setMaximum);
            _yuitest_coverline("/build/charts-base/charts-base.js", 4962);
return (Y_Lang.isNumber(max));
        }
    },

    /**
     * Indicates whether the minimum is calculated or explicitly set. 
     *
     * @attribute setMin
     * @readOnly
     * @type Boolean
     * @private
     */
    setMin: {
        readOnly: true,

        getter: function()
        {
            _yuitest_coverfunc("/build/charts-base/charts-base.js", "getter", 4977);
_yuitest_coverline("/build/charts-base/charts-base.js", 4979);
var min = this._getNumber(this._setMinimum);
            _yuitest_coverline("/build/charts-base/charts-base.js", 4980);
return (Y_Lang.isNumber(min));
        }
    },

    /**
     * The maximum value that will appear on an axis. Unless explicitly set, this value is calculated by the `Axis`.
     *
     * @attribute maximum
     * @type Number
     */
    maximum: {
        getter: function ()
        {
            _yuitest_coverfunc("/build/charts-base/charts-base.js", "getter", 4991);
_yuitest_coverline("/build/charts-base/charts-base.js", 4993);
var max = this._getNumber(this._setMaximum);
            _yuitest_coverline("/build/charts-base/charts-base.js", 4994);
if(!Y_Lang.isNumber(max))
            {
                _yuitest_coverline("/build/charts-base/charts-base.js", 4996);
max = this._getNumber(this.get("dataMaximum"));
            }
            _yuitest_coverline("/build/charts-base/charts-base.js", 4998);
return parseFloat(max);
        },
        setter: function (value)
        {
            _yuitest_coverfunc("/build/charts-base/charts-base.js", "setter", 5000);
_yuitest_coverline("/build/charts-base/charts-base.js", 5002);
this._setMaximum = this._getNumber(value);
            _yuitest_coverline("/build/charts-base/charts-base.js", 5003);
return value;
        }
    },

    /**
     * The minimum value that will appear on an axis. Unless explicitly set, this value is calculated by the `Axis`.
     *
     * @attribute minimum
     * @type Number
     */
    minimum: {
        getter: function ()
        {
            _yuitest_coverfunc("/build/charts-base/charts-base.js", "getter", 5014);
_yuitest_coverline("/build/charts-base/charts-base.js", 5016);
var min = this._getNumber(this._setMinimum);
            _yuitest_coverline("/build/charts-base/charts-base.js", 5017);
if(!Y_Lang.isNumber(min)) 
            {
                _yuitest_coverline("/build/charts-base/charts-base.js", 5019);
min = this._getNumber(this.get("dataMinimum"));
            }
            _yuitest_coverline("/build/charts-base/charts-base.js", 5021);
return parseFloat(min);
        },
        setter: function (value)
        {
            _yuitest_coverfunc("/build/charts-base/charts-base.js", "setter", 5023);
_yuitest_coverline("/build/charts-base/charts-base.js", 5025);
this._setMinimum = this._getNumber(value);
            _yuitest_coverline("/build/charts-base/charts-base.js", 5026);
return value;
        }
    },

    /**
     * Method used for formatting a label. This attribute allows for the default label formatting method to overridden. The method use would need
     * to implement the arguments below and return a `String` or an `HTMLElement`. The default implementation of the method returns a `String`. The output of this method
     * will be rendered to the DOM using `appendChild`. If you override the `labelFunction` method and return an html string, you will also need to override the Axis' 
     * `appendLabelFunction` to accept html as a `String`.
     * <dl>
     *      <dt>val</dt><dd>Label to be formatted. (`String`)</dd>
     *      <dt>format</dt><dd>STRFTime string used to format the label. (optional)</dd>
     * </dl>
     *
     * @attribute labelFunction
     * @type Function
     */
    labelFunction: {
        value: function(val, format)
        {
            _yuitest_coverfunc("/build/charts-base/charts-base.js", "value", 5044);
_yuitest_coverline("/build/charts-base/charts-base.js", 5046);
val = Y.DataType.Date.parse(val);
            _yuitest_coverline("/build/charts-base/charts-base.js", 5047);
if(format)
            {
                _yuitest_coverline("/build/charts-base/charts-base.js", 5049);
return Y.DataType.Date.format(val, {format:format});
            }
            _yuitest_coverline("/build/charts-base/charts-base.js", 5051);
return val;
        }
    },

    /**
     * Pattern used by the `labelFunction` to format a label.
     *
     * @attribute labelFormat
     * @type String
     */
    labelFormat: {
        value: "%b %d, %y"
    }
};

_yuitest_coverline("/build/charts-base/charts-base.js", 5066);
Y.extend(TimeAxis, Y.AxisType, {
    /**
     * Formats a label based on the axis type and optionally specified format.
     *
     * @method formatLabel
     * @param {Object} value
     * @param {Object} format Pattern used to format the value.
     * @return String
     */
    formatLabel: function(val, format)
    {
        _yuitest_coverfunc("/build/charts-base/charts-base.js", "formatLabel", 5075);
_yuitest_coverline("/build/charts-base/charts-base.js", 5077);
val = Y.DataType.Date.parse(val);
        _yuitest_coverline("/build/charts-base/charts-base.js", 5078);
if(format)
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 5080);
return Y.DataType.Date.format(val, {format:format});
        }
        _yuitest_coverline("/build/charts-base/charts-base.js", 5082);
return val;
    },

    /**
     * Constant used to generate unique id.
     *
     * @property GUID
     * @type String
     * @private
     */
    GUID: "yuitimeaxis",
	
    /**
     * Type of data used in `Axis`.
     *
     * @property _dataType
     * @readOnly
     * @private
     */
    _dataType: "time",
	
    /**
     * Calculates and returns a value based on the number of labels and the index of
     * the current label.
     *
     * @method getLabelByIndex
     * @param {Number} i Index of the label.
     * @param {Number} l Total number of labels.
     * @return String
     */
    getLabelByIndex: function(i, l)
    {
        _yuitest_coverfunc("/build/charts-base/charts-base.js", "getLabelByIndex", 5112);
_yuitest_coverline("/build/charts-base/charts-base.js", 5114);
var min = this.get("minimum"),
            max = this.get("maximum"),
            position = this.get("position"),
            increm,
            label;
            _yuitest_coverline("/build/charts-base/charts-base.js", 5119);
l -= 1;
        _yuitest_coverline("/build/charts-base/charts-base.js", 5120);
increm = ((max - min)/l) * i;
        _yuitest_coverline("/build/charts-base/charts-base.js", 5121);
if(position == "bottom" || position == "top")
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 5123);
label = min + increm;
        }
        else
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 5127);
label = max - increm;
        }
        _yuitest_coverline("/build/charts-base/charts-base.js", 5129);
return label;
    },

    /**
     * Gets an array of values based on a key.
     *
     * @method _getKeyArray
     * @param {String} key Value key associated with the data array.
     * @param {Array} data Array in which the data resides.
     * @return Array
     * @private
     */
    _getKeyArray: function(key, data)
    {
        _yuitest_coverfunc("/build/charts-base/charts-base.js", "_getKeyArray", 5141);
_yuitest_coverline("/build/charts-base/charts-base.js", 5143);
var obj,
            keyArray = [],
            i = 0,
            val,
            len = data.length;
        _yuitest_coverline("/build/charts-base/charts-base.js", 5148);
for(; i < len; ++i)
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 5150);
obj = data[i][key];
            _yuitest_coverline("/build/charts-base/charts-base.js", 5151);
if(Y_Lang.isDate(obj))
            {   
                _yuitest_coverline("/build/charts-base/charts-base.js", 5153);
val = obj.valueOf();
            }
            else
            {
                _yuitest_coverline("/build/charts-base/charts-base.js", 5157);
val = new Date(obj);
                _yuitest_coverline("/build/charts-base/charts-base.js", 5158);
if(Y_Lang.isDate(val))
                {
                    _yuitest_coverline("/build/charts-base/charts-base.js", 5160);
val = val.valueOf();
                }
                else {_yuitest_coverline("/build/charts-base/charts-base.js", 5162);
if(!Y_Lang.isNumber(obj))
                {
                    _yuitest_coverline("/build/charts-base/charts-base.js", 5164);
if(Y_Lang.isNumber(parseFloat(obj)))
                    {
                        _yuitest_coverline("/build/charts-base/charts-base.js", 5166);
val = parseFloat(obj);
                    }
                    else
                    {
                        _yuitest_coverline("/build/charts-base/charts-base.js", 5170);
if(typeof obj != "string")
                        {
                            _yuitest_coverline("/build/charts-base/charts-base.js", 5172);
obj = obj;
                        }
                        _yuitest_coverline("/build/charts-base/charts-base.js", 5174);
val = new Date(obj).valueOf();
                    }
                }
                else
                {
                    _yuitest_coverline("/build/charts-base/charts-base.js", 5179);
val = obj;
                }}
            }
            _yuitest_coverline("/build/charts-base/charts-base.js", 5182);
keyArray[i] = val;
        }
        _yuitest_coverline("/build/charts-base/charts-base.js", 5184);
return keyArray;
    },

    /**
     * Sets data by key
     *
     * @method _setDataByKey
     * @param {String} key Key value to use.
     * @param {Array} data Array to use.
     * @private 
     */
    _setDataByKey: function(key, data)
    {
        _yuitest_coverfunc("/build/charts-base/charts-base.js", "_setDataByKey", 5195);
_yuitest_coverline("/build/charts-base/charts-base.js", 5197);
var obj, 
            arr = [], 
            dv = this._dataClone.concat(), 
            i, 
            val,
            len = dv.length;
        _yuitest_coverline("/build/charts-base/charts-base.js", 5203);
for(i = 0; i < len; ++i)
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 5205);
obj = dv[i][key];
            _yuitest_coverline("/build/charts-base/charts-base.js", 5206);
if(Y_Lang.isDate(obj))
            {   
                _yuitest_coverline("/build/charts-base/charts-base.js", 5208);
val = obj.valueOf();
            }
            else
            {
                _yuitest_coverline("/build/charts-base/charts-base.js", 5212);
val = new Date(obj);
                _yuitest_coverline("/build/charts-base/charts-base.js", 5213);
if(Y_Lang.isDate(val))
                {
                    _yuitest_coverline("/build/charts-base/charts-base.js", 5215);
val = val.valueOf();
                }
                else {_yuitest_coverline("/build/charts-base/charts-base.js", 5217);
if(!Y_Lang.isNumber(obj))
                {
                    _yuitest_coverline("/build/charts-base/charts-base.js", 5219);
if(Y_Lang.isNumber(parseFloat(obj)))
                    {
                        _yuitest_coverline("/build/charts-base/charts-base.js", 5221);
val = parseFloat(obj);
                    }
                    else
                    {
                        _yuitest_coverline("/build/charts-base/charts-base.js", 5225);
if(typeof obj != "string")
                        {
                            _yuitest_coverline("/build/charts-base/charts-base.js", 5227);
obj = obj.toString();
                        }
                        _yuitest_coverline("/build/charts-base/charts-base.js", 5229);
val = new Date(obj).valueOf();
                    }
                }
                else
                {
                    _yuitest_coverline("/build/charts-base/charts-base.js", 5234);
val = obj;
                }}
            }
            _yuitest_coverline("/build/charts-base/charts-base.js", 5237);
arr[i] = val;
        }
        _yuitest_coverline("/build/charts-base/charts-base.js", 5239);
this.get("keys")[key] = arr;
        _yuitest_coverline("/build/charts-base/charts-base.js", 5240);
this._updateTotalDataFlag = true;
    },

    /**
     * Parses value into a number.
     *
     * @method _getNumber
     * @param val {Object} Value to parse into a number
     * @return Number
     * @private
     */
    _getNumber: function(val)
    {
        _yuitest_coverfunc("/build/charts-base/charts-base.js", "_getNumber", 5251);
_yuitest_coverline("/build/charts-base/charts-base.js", 5253);
if(Y_Lang.isDate(val))
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 5255);
val = val.valueOf();
        }
        else {_yuitest_coverline("/build/charts-base/charts-base.js", 5257);
if(!Y_Lang.isNumber(val) && val)
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 5259);
val = new Date(val).valueOf();
        }}

        _yuitest_coverline("/build/charts-base/charts-base.js", 5262);
return val;
    }
});

_yuitest_coverline("/build/charts-base/charts-base.js", 5266);
Y.TimeAxis = TimeAxis;
		
/**
 * CategoryAxis manages category data on an axis.
 *
 * @module charts
 * @submodule charts-base
 * @class CategoryAxis
 * @constructor
 * @param {Object} config (optional) Configuration parameters for the Chart.
 * @extends AxisType
 */
_yuitest_coverline("/build/charts-base/charts-base.js", 5278);
function CategoryAxis(config)
{
	_yuitest_coverfunc("/build/charts-base/charts-base.js", "CategoryAxis", 5278);
_yuitest_coverline("/build/charts-base/charts-base.js", 5280);
CategoryAxis.superclass.constructor.apply(this, arguments);
}

_yuitest_coverline("/build/charts-base/charts-base.js", 5283);
CategoryAxis.NAME = "categoryAxis";

_yuitest_coverline("/build/charts-base/charts-base.js", 5285);
Y.extend(CategoryAxis, Y.AxisType,
{
    /**
     * Formats a label based on the axis type and optionally specified format.
     *
     * @method formatLabel
     * @param {Object} value
     * @param {Object} format Pattern used to format the value.
     * @return String
     */
    formatLabel: function(val, format)
    {
        _yuitest_coverfunc("/build/charts-base/charts-base.js", "formatLabel", 5295);
_yuitest_coverline("/build/charts-base/charts-base.js", 5297);
return val;
    },

    /**
     * Object storing key data.
     *
     * @property _indices
     * @private
     */
    _indices: null,

    /**
     * Constant used to generate unique id.
     *
     * @property GUID
     * @type String
     * @private
     */
    GUID: "yuicategoryaxis",

    /**
     * Type of data used in `Axis`.
     *
     * @property _dataType
     * @readOnly
     * @private
     */
    _type: "category",
        
    /**
     * Calculates the maximum and minimum values for the `Axis`.
     *
     * @method _updateMinAndMax
     * @private 
     */
    _updateMinAndMax: function()
    {
        _yuitest_coverfunc("/build/charts-base/charts-base.js", "_updateMinAndMax", 5332);
_yuitest_coverline("/build/charts-base/charts-base.js", 5334);
this._dataMaximum = Math.max(this.get("data").length - 1, 0);
        _yuitest_coverline("/build/charts-base/charts-base.js", 5335);
this._dataMinimum = 0;
    },

    /**
     * Gets an array of values based on a key.
     *
     * @method _getKeyArray
     * @param {String} key Value key associated with the data array.
     * @param {Array} data Array in which the data resides.
     * @return Array
     * @private
     */
    _getKeyArray: function(key, data)
    {
        _yuitest_coverfunc("/build/charts-base/charts-base.js", "_getKeyArray", 5347);
_yuitest_coverline("/build/charts-base/charts-base.js", 5349);
var i = 0,
            obj,
            keyArr = [],
            labels = [],
            len = data.length;
        _yuitest_coverline("/build/charts-base/charts-base.js", 5354);
if(!this._indices)
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 5356);
this._indices = {};
        }
        _yuitest_coverline("/build/charts-base/charts-base.js", 5358);
for(; i < len; ++i)
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 5360);
obj = data[i];
            _yuitest_coverline("/build/charts-base/charts-base.js", 5361);
keyArr[i] = i;
            _yuitest_coverline("/build/charts-base/charts-base.js", 5362);
labels[i] = obj[key];
        }
        _yuitest_coverline("/build/charts-base/charts-base.js", 5364);
this._indices[key] = keyArr;
        _yuitest_coverline("/build/charts-base/charts-base.js", 5365);
return labels;
    },

    /**
     * Sets data by key
     *
     * @method _setDataByKey
     * @param {String} key Key value to use.
     * @param {Array} data Array to use.
     * @private 
     */
    _setDataByKey: function(key)
    {
        _yuitest_coverfunc("/build/charts-base/charts-base.js", "_setDataByKey", 5376);
_yuitest_coverline("/build/charts-base/charts-base.js", 5378);
var i,
            obj, 
            arr = [], 
            labels = [], 
            dv = this._dataClone.concat(), 
            len = dv.length;
        _yuitest_coverline("/build/charts-base/charts-base.js", 5384);
if(!this._indices)
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 5386);
this._indices = {};
        }
        _yuitest_coverline("/build/charts-base/charts-base.js", 5388);
for(i = 0; i < len; ++i)
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 5390);
obj = dv[i];
            _yuitest_coverline("/build/charts-base/charts-base.js", 5391);
arr[i] = i;
            _yuitest_coverline("/build/charts-base/charts-base.js", 5392);
labels[i] = obj[key];
        }
        _yuitest_coverline("/build/charts-base/charts-base.js", 5394);
this._indices[key] = arr;
        _yuitest_coverline("/build/charts-base/charts-base.js", 5395);
this.get("keys")[key] = labels.concat();
        _yuitest_coverline("/build/charts-base/charts-base.js", 5396);
this._updateTotalDataFlag = true;
    },

    /**
     * Returns an array of values based on an identifier key.
     *
     * @method getDataByKey
     * @param {String} value value used to identify the array
     * @return Array
     */
    getDataByKey: function (value)
    {
        _yuitest_coverfunc("/build/charts-base/charts-base.js", "getDataByKey", 5406);
_yuitest_coverline("/build/charts-base/charts-base.js", 5408);
if(!this._indices)
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 5410);
this.get("keys");
        }
        _yuitest_coverline("/build/charts-base/charts-base.js", 5412);
var keys = this._indices;
        _yuitest_coverline("/build/charts-base/charts-base.js", 5413);
if(keys[value])
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 5415);
return keys[value];
        }
        _yuitest_coverline("/build/charts-base/charts-base.js", 5417);
return null;
    },

    /**
     * Returns the total number of majorUnits that will appear on an axis.
     *
     * @method getTotalMajorUnits
     * @param {Object} majorUnit Object containing properties related to the majorUnit.
     * @param {Number} len Length of the axis.
     * @return Number
     */
    getTotalMajorUnits: function(majorUnit, len)
    {
        _yuitest_coverfunc("/build/charts-base/charts-base.js", "getTotalMajorUnits", 5428);
_yuitest_coverline("/build/charts-base/charts-base.js", 5430);
return this.get("data").length;
    },
    
    /**
     * Returns the distance between major units on an axis.
     *
     * @method getMajorUnitDistance
     * @param {Number} len Number of ticks
     * @param {Number} uiLen Size of the axis.
     * @param {Object} majorUnit Hash of properties used to determine the majorUnit
     * @return Number
     */
    getMajorUnitDistance: function(len, uiLen, majorUnit)
    {
        _yuitest_coverfunc("/build/charts-base/charts-base.js", "getMajorUnitDistance", 5442);
_yuitest_coverline("/build/charts-base/charts-base.js", 5444);
var dist;
        _yuitest_coverline("/build/charts-base/charts-base.js", 5445);
if(majorUnit.determinant === "count")
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 5447);
dist = uiLen/len;
        }
        else {_yuitest_coverline("/build/charts-base/charts-base.js", 5449);
if(majorUnit.determinant === "distance")
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 5451);
dist = majorUnit.distance;
        }}
        _yuitest_coverline("/build/charts-base/charts-base.js", 5453);
return dist;
    },
   
    /**
     * Gets the distance that the first and last ticks are offset from there respective
     * edges.
     *
     * @method getEdgeOffset
     * @param {Number} ct Number of ticks on the axis.
     * @param {Number} l Length (in pixels) of the axis.
     * @return Number
     */
    getEdgeOffset: function(ct, l)
    {
        _yuitest_coverfunc("/build/charts-base/charts-base.js", "getEdgeOffset", 5465);
_yuitest_coverline("/build/charts-base/charts-base.js", 5467);
return l/ct;
    },

    /**
     * Returns a value based of a key value and an index.
     *
     * @method getKeyValueAt
     * @param {String} key value used to look up the correct array
     * @param {Number} index within the array
     * @return String 
     */
    getKeyValueAt: function(key, index)
    {
        _yuitest_coverfunc("/build/charts-base/charts-base.js", "getKeyValueAt", 5478);
_yuitest_coverline("/build/charts-base/charts-base.js", 5480);
var value = NaN,
            keys = this.get("keys");
        _yuitest_coverline("/build/charts-base/charts-base.js", 5482);
if(keys[key] && keys[key][index]) 
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 5484);
value = keys[key][index];
        }
        _yuitest_coverline("/build/charts-base/charts-base.js", 5486);
return value;
    },
   
    /**
     * Calculates and returns a value based on the number of labels and the index of
     * the current label.
     *
     * @method getLabelByIndex
     * @param {Number} i Index of the label.
     * @param {Number} l Total number of labels.
     * @return String
     */
    getLabelByIndex: function(i, l)
    {
        _yuitest_coverfunc("/build/charts-base/charts-base.js", "getLabelByIndex", 5498);
_yuitest_coverline("/build/charts-base/charts-base.js", 5500);
var label,
            data = this.get("data"),
            position = this.get("position");
        _yuitest_coverline("/build/charts-base/charts-base.js", 5503);
if(position == "bottom" || position == "top")
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 5505);
label = data[i];
        }
        else
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 5509);
label = data[l - (i + 1)];
        }   
        _yuitest_coverline("/build/charts-base/charts-base.js", 5511);
return label;
    },

    /**
     * Returns a string corresponding to the first label on an 
     * axis.
     *
     * @method getMinimumValue
     * @return String
     */
    getMinimumValue: function()
    {
        _yuitest_coverfunc("/build/charts-base/charts-base.js", "getMinimumValue", 5521);
_yuitest_coverline("/build/charts-base/charts-base.js", 5523);
var data = this.get("data"),
            label = data[0];
        _yuitest_coverline("/build/charts-base/charts-base.js", 5525);
return label;
    },

    /**
     * Returns a string corresponding to the last label on an 
     * axis.
     *
     * @method getMaximumValue
     * @return String
     */
    getMaximumValue: function()
    {
        _yuitest_coverfunc("/build/charts-base/charts-base.js", "getMaximumValue", 5535);
_yuitest_coverline("/build/charts-base/charts-base.js", 5537);
var data = this.get("data"),
            len = data.length - 1,
            label = data[len];
        _yuitest_coverline("/build/charts-base/charts-base.js", 5540);
return label;
    }
});

_yuitest_coverline("/build/charts-base/charts-base.js", 5544);
Y.CategoryAxis = CategoryAxis;
		
/**
 * Utility class used for calculating curve points.
 *
 * @module charts
 * @submodule charts-base
 * @class CurveUtil
 * @constructor
 */
_yuitest_coverline("/build/charts-base/charts-base.js", 5554);
function CurveUtil()
{
}

_yuitest_coverline("/build/charts-base/charts-base.js", 5558);
CurveUtil.prototype = {
    /**
     * Creates an array of start, end and control points for splines.
     *
     * @method getCurveControlPoints
     * @param {Array} xcoords Collection of x-coordinates used for calculate the curves
     * @param {Array} ycoords Collection of y-coordinates used for calculate the curves
     * @return Object
     * @protected
     */
    getCurveControlPoints: function(xcoords, ycoords) 
    {
		_yuitest_coverfunc("/build/charts-base/charts-base.js", "getCurveControlPoints", 5568);
_yuitest_coverline("/build/charts-base/charts-base.js", 5570);
var outpoints = [],
            i = 1,
            l = xcoords.length - 1,
		    xvals = [],
		    yvals = [];
		
		
		// Too few points, need at least two
		_yuitest_coverline("/build/charts-base/charts-base.js", 5578);
if (l < 1) 
        {
			_yuitest_coverline("/build/charts-base/charts-base.js", 5580);
return null;
		} 
        
        _yuitest_coverline("/build/charts-base/charts-base.js", 5583);
outpoints[0] = {
            startx: xcoords[0], 
            starty: ycoords[0],
            endx: xcoords[1],
            endy: ycoords[1]
        };
        
		// Special case, the Bezier should be a straight line
        _yuitest_coverline("/build/charts-base/charts-base.js", 5591);
if (l === 1) 
        {
			_yuitest_coverline("/build/charts-base/charts-base.js", 5593);
outpoints[0].ctrlx1 = (2.0*xcoords[0] + xcoords[1])/3.0;  
			_yuitest_coverline("/build/charts-base/charts-base.js", 5594);
outpoints[0].ctrly2 = (2.0*ycoords[0] + ycoords[1])/3.0;
			_yuitest_coverline("/build/charts-base/charts-base.js", 5595);
outpoints[0].ctrlx2 = 2.0*outpoints[0].ctrlx1 - xcoords[0];
            _yuitest_coverline("/build/charts-base/charts-base.js", 5596);
outpoints[0].ctrly2 = 2.0*outpoints[0].ctrly1 - ycoords[0];
            _yuitest_coverline("/build/charts-base/charts-base.js", 5597);
return outpoints;
		}

		_yuitest_coverline("/build/charts-base/charts-base.js", 5600);
for (; i < l; ++i) 
        {
			_yuitest_coverline("/build/charts-base/charts-base.js", 5602);
outpoints.push({startx: Math.round(xcoords[i]), starty: Math.round(ycoords[i]), endx: Math.round(xcoords[i+1]), endy: Math.round(ycoords[i+1])});
			_yuitest_coverline("/build/charts-base/charts-base.js", 5603);
xvals[i] = 4.0 * xcoords[i] + 2*xcoords[i+1];
			_yuitest_coverline("/build/charts-base/charts-base.js", 5604);
yvals[i] = 4.0*ycoords[i] + 2*ycoords[i+1];
		}
		
		_yuitest_coverline("/build/charts-base/charts-base.js", 5607);
xvals[0] = xcoords[0] + (2.0 * xcoords[1]);
		_yuitest_coverline("/build/charts-base/charts-base.js", 5608);
xvals[l-1] = (8.0 * xcoords[l-1] + xcoords[l]) / 2.0;
		_yuitest_coverline("/build/charts-base/charts-base.js", 5609);
xvals = this.getControlPoints(xvals.concat());
        _yuitest_coverline("/build/charts-base/charts-base.js", 5610);
yvals[0] = ycoords[0] + (2.0 * ycoords[1]);
		_yuitest_coverline("/build/charts-base/charts-base.js", 5611);
yvals[l-1] = (8.0 * ycoords[l-1] + ycoords[l]) / 2.0;	
		_yuitest_coverline("/build/charts-base/charts-base.js", 5612);
yvals = this.getControlPoints(yvals.concat());
		
        _yuitest_coverline("/build/charts-base/charts-base.js", 5614);
for (i = 0; i < l; ++i) 
        {
			_yuitest_coverline("/build/charts-base/charts-base.js", 5616);
outpoints[i].ctrlx1 = Math.round(xvals[i]);
            _yuitest_coverline("/build/charts-base/charts-base.js", 5617);
outpoints[i].ctrly1 = Math.round(yvals[i]);
			
			_yuitest_coverline("/build/charts-base/charts-base.js", 5619);
if (i < l-1) 
            {
				_yuitest_coverline("/build/charts-base/charts-base.js", 5621);
outpoints[i].ctrlx2 = Math.round(2*xcoords[i+1] - xvals[i+1]);
                _yuitest_coverline("/build/charts-base/charts-base.js", 5622);
outpoints[i].ctrly2 = Math.round(2*ycoords[i+1] - yvals[i+1]);
			}
			else 
            {
				_yuitest_coverline("/build/charts-base/charts-base.js", 5626);
outpoints[i].ctrlx2 = Math.round((xcoords[l] + xvals[l-1])/2);
                _yuitest_coverline("/build/charts-base/charts-base.js", 5627);
outpoints[i].ctrly2 = Math.round((ycoords[l] + yvals[l-1])/2);
			}
		}
		
		_yuitest_coverline("/build/charts-base/charts-base.js", 5631);
return outpoints;	
	},

    /**
     * Gets the control points for the curve.
     *
     * @method getControlPoints
     * @param {Array} vals Collection of values coords used to generate control points.
     * @return Array
     * @private
     */
	getControlPoints: function(vals) 
    {
		_yuitest_coverfunc("/build/charts-base/charts-base.js", "getControlPoints", 5642);
_yuitest_coverline("/build/charts-base/charts-base.js", 5644);
var l = vals.length,
            x = [],
            tmp = [],
            b = 2.0,
            i = 1;
		_yuitest_coverline("/build/charts-base/charts-base.js", 5649);
x[0] = vals[0] / b;
		_yuitest_coverline("/build/charts-base/charts-base.js", 5650);
for (; i < l; ++i) 
        {
			_yuitest_coverline("/build/charts-base/charts-base.js", 5652);
tmp[i] = 1/b;
			_yuitest_coverline("/build/charts-base/charts-base.js", 5653);
b = (i < l-1 ? 4.0 : 3.5) - tmp[i];
			_yuitest_coverline("/build/charts-base/charts-base.js", 5654);
x[i] = (vals[i] - x[i-1]) / b;
		}
		
		_yuitest_coverline("/build/charts-base/charts-base.js", 5657);
for (i = 1; i < l; ++i) 
        {
			_yuitest_coverline("/build/charts-base/charts-base.js", 5659);
x[l-i-1] -= tmp[l-i] * x[l-i];
		}
		
		_yuitest_coverline("/build/charts-base/charts-base.js", 5662);
return x;
	}
};
_yuitest_coverline("/build/charts-base/charts-base.js", 5665);
Y.CurveUtil = CurveUtil;
/**
 * Utility class used for creating stacked series.
 *
 * @module charts
 * @submodule charts-base
 * @class StackingUtil
 * @constructor
 */
_yuitest_coverline("/build/charts-base/charts-base.js", 5674);
function StackingUtil(){}

_yuitest_coverline("/build/charts-base/charts-base.js", 5676);
StackingUtil.prototype = {
    /**
     * Indicates whether the series is stacked.
     *
     * @property _stacked
     * @private
     */
    _stacked: true,

    /**
     * @protected
     *
     * Adjusts coordinate values for stacked series.
     *
     * @method _stackCoordinates
     */
    _stackCoordinates: function() 
    {
        _yuitest_coverfunc("/build/charts-base/charts-base.js", "_stackCoordinates", 5692);
_yuitest_coverline("/build/charts-base/charts-base.js", 5694);
if(this.get("direction") == "vertical")
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 5696);
this._stackXCoords();
        }
        else
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 5700);
this._stackYCoords();
        }
    },

    /**
     * Stacks coordinates for a stacked vertical series.
     *
     * @method _stackXCoords
     * @protected
     */
    _stackXCoords: function()
    {
        _yuitest_coverfunc("/build/charts-base/charts-base.js", "_stackXCoords", 5710);
_yuitest_coverline("/build/charts-base/charts-base.js", 5712);
var order = this.get("order"),
            type = this.get("type"),
            graph = this.get("graph"),
            seriesCollection = graph.seriesTypes[type],
            i = 0,
            xcoords = this.get("xcoords"),
            ycoords = this.get("ycoords"),
            len,
            coord,
            prevCoord,
            prevOrder,
            stackedXCoords = xcoords.concat(),
            prevXCoords,
            prevYCoords,
            nullIndices = [],
            nullIndex;
        _yuitest_coverline("/build/charts-base/charts-base.js", 5728);
if(order > 0)
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 5730);
prevXCoords = seriesCollection[order - 1].get("stackedXCoords");
            _yuitest_coverline("/build/charts-base/charts-base.js", 5731);
prevYCoords = seriesCollection[order - 1].get("stackedYCoords");
            _yuitest_coverline("/build/charts-base/charts-base.js", 5732);
len = prevXCoords.length;
        }
        else
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 5736);
len = xcoords.length;
        }
        _yuitest_coverline("/build/charts-base/charts-base.js", 5738);
for(; i < len; i = i + 1)
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 5740);
if(Y_Lang.isNumber(xcoords[i]))
            {
                _yuitest_coverline("/build/charts-base/charts-base.js", 5742);
if(order > 0)
                {
                    _yuitest_coverline("/build/charts-base/charts-base.js", 5744);
prevCoord = prevXCoords[i];
                    _yuitest_coverline("/build/charts-base/charts-base.js", 5745);
if(!Y_Lang.isNumber(prevCoord))
                    {
                        _yuitest_coverline("/build/charts-base/charts-base.js", 5747);
prevOrder = order;
                        _yuitest_coverline("/build/charts-base/charts-base.js", 5748);
while(prevOrder >  - 1 && !Y_Lang.isNumber(prevCoord))
                        {
                            _yuitest_coverline("/build/charts-base/charts-base.js", 5750);
prevOrder = prevOrder - 1;
                            _yuitest_coverline("/build/charts-base/charts-base.js", 5751);
if(prevOrder > -1)
                            {
                                _yuitest_coverline("/build/charts-base/charts-base.js", 5753);
prevCoord = seriesCollection[prevOrder].get("stackedXCoords")[i];
                            }
                            else
                            {
                                _yuitest_coverline("/build/charts-base/charts-base.js", 5757);
prevCoord = this._leftOrigin;
                            }
                        }
                    }
                    _yuitest_coverline("/build/charts-base/charts-base.js", 5761);
xcoords[i] = xcoords[i] + prevCoord;
                }
                _yuitest_coverline("/build/charts-base/charts-base.js", 5763);
stackedXCoords[i] = xcoords[i];
            }
            else
            {
                _yuitest_coverline("/build/charts-base/charts-base.js", 5767);
nullIndices.push(i);
            }
        }
        _yuitest_coverline("/build/charts-base/charts-base.js", 5770);
this._cleanXNaN(stackedXCoords, ycoords);
        _yuitest_coverline("/build/charts-base/charts-base.js", 5771);
len = nullIndices.length;
        _yuitest_coverline("/build/charts-base/charts-base.js", 5772);
if(len > 0)
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 5774);
for(i = 0; i < len; i = i + 1)
            {
                _yuitest_coverline("/build/charts-base/charts-base.js", 5776);
nullIndex = nullIndices[i];
                _yuitest_coverline("/build/charts-base/charts-base.js", 5777);
coord = order > 0 ? prevXCoords[nullIndex] : this._leftOrigin;
                _yuitest_coverline("/build/charts-base/charts-base.js", 5778);
stackedXCoords[nullIndex] =  Math.max(stackedXCoords[nullIndex], coord);
            }
        }
        _yuitest_coverline("/build/charts-base/charts-base.js", 5781);
this.set("stackedXCoords", stackedXCoords);
        _yuitest_coverline("/build/charts-base/charts-base.js", 5782);
this.set("stackedYCoords", ycoords);
    },

    /**
     * Stacks coordinates for a stacked horizontal series.
     *
     * @method _stackYCoords
     * @protected
     */
    _stackYCoords: function()
    {
        _yuitest_coverfunc("/build/charts-base/charts-base.js", "_stackYCoords", 5791);
_yuitest_coverline("/build/charts-base/charts-base.js", 5793);
var order = this.get("order"),
            type = this.get("type"),
            graph = this.get("graph"),
            h = graph.get("height"), 
            seriesCollection = graph.seriesTypes[type],
            i = 0,
            xcoords = this.get("xcoords"),
            ycoords = this.get("ycoords"),
            len,
            coord,
            prevCoord,
            prevOrder,
            stackedYCoords = ycoords.concat(),
            prevXCoords,
            prevYCoords,
            nullIndices = [],
            nullIndex;
        _yuitest_coverline("/build/charts-base/charts-base.js", 5810);
if(order > 0)
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 5812);
prevXCoords = seriesCollection[order - 1].get("stackedXCoords");
            _yuitest_coverline("/build/charts-base/charts-base.js", 5813);
prevYCoords = seriesCollection[order - 1].get("stackedYCoords");
            _yuitest_coverline("/build/charts-base/charts-base.js", 5814);
len = prevYCoords.length;
        }
        else
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 5818);
len = ycoords.length;
        }
        _yuitest_coverline("/build/charts-base/charts-base.js", 5820);
for(; i < len; i = i + 1)
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 5822);
if(Y_Lang.isNumber(ycoords[i]))
            {
                _yuitest_coverline("/build/charts-base/charts-base.js", 5824);
if(order > 0)
                {
                    _yuitest_coverline("/build/charts-base/charts-base.js", 5826);
prevCoord = prevYCoords[i];
                    _yuitest_coverline("/build/charts-base/charts-base.js", 5827);
if(!Y_Lang.isNumber(prevCoord))
                    {
                        _yuitest_coverline("/build/charts-base/charts-base.js", 5829);
prevOrder = order;
                        _yuitest_coverline("/build/charts-base/charts-base.js", 5830);
while(prevOrder >  - 1 && !Y_Lang.isNumber(prevCoord))
                        {
                            _yuitest_coverline("/build/charts-base/charts-base.js", 5832);
prevOrder = prevOrder - 1;
                            _yuitest_coverline("/build/charts-base/charts-base.js", 5833);
if(prevOrder > -1)
                            {
                                _yuitest_coverline("/build/charts-base/charts-base.js", 5835);
prevCoord = seriesCollection[prevOrder].get("stackedYCoords")[i];
                            }
                            else
                            {
                                _yuitest_coverline("/build/charts-base/charts-base.js", 5839);
prevCoord = this._bottomOrigin;
                            }
                        }
                    }
                    _yuitest_coverline("/build/charts-base/charts-base.js", 5843);
ycoords[i] = prevCoord - (h - ycoords[i]);
                }
                _yuitest_coverline("/build/charts-base/charts-base.js", 5845);
stackedYCoords[i] = ycoords[i];
            }
            else
            {
                _yuitest_coverline("/build/charts-base/charts-base.js", 5849);
nullIndices.push(i);
            }
        }
        _yuitest_coverline("/build/charts-base/charts-base.js", 5852);
this._cleanYNaN(xcoords, stackedYCoords);
        _yuitest_coverline("/build/charts-base/charts-base.js", 5853);
len = nullIndices.length;
        _yuitest_coverline("/build/charts-base/charts-base.js", 5854);
if(len > 0)
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 5856);
for(i = 0; i < len; i = i + 1)
            {
                _yuitest_coverline("/build/charts-base/charts-base.js", 5858);
nullIndex = nullIndices[i];
                _yuitest_coverline("/build/charts-base/charts-base.js", 5859);
coord = order > 0 ? prevYCoords[nullIndex] : h;
                _yuitest_coverline("/build/charts-base/charts-base.js", 5860);
stackedYCoords[nullIndex] =  Math.min(stackedYCoords[nullIndex], coord);
            }
        }
        _yuitest_coverline("/build/charts-base/charts-base.js", 5863);
this.set("stackedXCoords", xcoords);
        _yuitest_coverline("/build/charts-base/charts-base.js", 5864);
this.set("stackedYCoords", stackedYCoords);
    },

    /**
     * Cleans invalid x-coordinates by calculating their value based on the corresponding y-coordinate, the previous valid x-coordinate with its 
     * corresponding y-coordinate and the next valid x-coordinate with its corresponding y-coordinate. If there is no previous or next valid x-coordinate,
     * the value will not be altered.
     *
     * @method _cleanXNaN
     * @param {Array} xcoords An array of x-coordinate values
     * @param {Array} ycoords An arry of y-coordinate values
     * @private
     */
    _cleanXNaN: function(xcoords, ycoords)
    {
        _yuitest_coverfunc("/build/charts-base/charts-base.js", "_cleanXNaN", 5877);
_yuitest_coverline("/build/charts-base/charts-base.js", 5879);
var previousValidIndex,
            nextValidIndex,
            previousValidX,
            previousValidY,
            x,
            y,
            nextValidX,
            nextValidY,
            isNumber = Y_Lang.isNumber,
            m,
            i = 0,
            len = ycoords.length;
        _yuitest_coverline("/build/charts-base/charts-base.js", 5891);
for(; i < len; ++i)
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 5893);
x = xcoords[i];
            _yuitest_coverline("/build/charts-base/charts-base.js", 5894);
y = ycoords[i];
            //if x is invalid, calculate where it should be
            _yuitest_coverline("/build/charts-base/charts-base.js", 5896);
if(!isNumber(x) && i > 0 && i < len - 1)
            {
                _yuitest_coverline("/build/charts-base/charts-base.js", 5898);
previousValidY = ycoords[i - 1];
                //check to see if the previous value is valid
                _yuitest_coverline("/build/charts-base/charts-base.js", 5900);
previousValidX = this._getPreviousValidCoordValue(xcoords, i);
                _yuitest_coverline("/build/charts-base/charts-base.js", 5901);
nextValidY = ycoords[i + 1];
                _yuitest_coverline("/build/charts-base/charts-base.js", 5902);
nextValidX = this._getNextValidCoordValue(xcoords, i);
                //check to see if the next value is valid
                _yuitest_coverline("/build/charts-base/charts-base.js", 5904);
if(isNumber(previousValidX) && isNumber(nextValidX))
                {
                    //calculate slope and solve for x
                    _yuitest_coverline("/build/charts-base/charts-base.js", 5907);
m = (nextValidY - previousValidY) / (nextValidX - previousValidX);
                    _yuitest_coverline("/build/charts-base/charts-base.js", 5908);
xcoords[i] = (y + (m * previousValidX) - previousValidY)/m;
                }
                _yuitest_coverline("/build/charts-base/charts-base.js", 5910);
previousValidIndex = NaN;
                _yuitest_coverline("/build/charts-base/charts-base.js", 5911);
nextValidIndex = NaN;
            }
        }
    },

    /**
     * Returns the previous valid (numeric) value in an array if available.
     *
     * @method _getPreviousValidCoordValue
     * @param {Array} coords Array of values
     * @param {Number} index The index in the array in which to begin searching.
     * @return Number
     * @private
     */
    _getPreviousValidCoordValue: function(coords, index)
    {
        _yuitest_coverfunc("/build/charts-base/charts-base.js", "_getPreviousValidCoordValue", 5925);
_yuitest_coverline("/build/charts-base/charts-base.js", 5927);
var coord,
            isNumber = Y_Lang.isNumber,
            limit = -1;
        _yuitest_coverline("/build/charts-base/charts-base.js", 5930);
while(!isNumber(coord) && index > limit)
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 5932);
index = index - 1;
            _yuitest_coverline("/build/charts-base/charts-base.js", 5933);
coord = coords[index];
        }
        _yuitest_coverline("/build/charts-base/charts-base.js", 5935);
return coord;
    },

    /**
     * Returns the next valid (numeric) value in an array if available.
     *
     * @method _getNextValidCoordValue
     * @param {Array} coords Array of values
     * @param {Number} index The index in the array in which to begin searching.
     * @return Number
     * @private
     */
    _getNextValidCoordValue: function(coords, index)
    {
        _yuitest_coverfunc("/build/charts-base/charts-base.js", "_getNextValidCoordValue", 5947);
_yuitest_coverline("/build/charts-base/charts-base.js", 5949);
var coord,
            isNumber = Y_Lang.isNumber,
            limit = coords.length;
        _yuitest_coverline("/build/charts-base/charts-base.js", 5952);
while(!isNumber(coord) && index < limit)
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 5954);
index = index + 1;
            _yuitest_coverline("/build/charts-base/charts-base.js", 5955);
coord = coords[index];
        }
        _yuitest_coverline("/build/charts-base/charts-base.js", 5957);
return coord;
    },

    /**
     * Cleans invalid y-coordinates by calculating their value based on the corresponding x-coordinate, the previous valid y-coordinate with its 
     * corresponding x-coordinate and the next valid y-coordinate with its corresponding x-coordinate. If there is no previous or next valid y-coordinate,
     * the value will not be altered.
     *
     * @method _cleanYNaN
     * @param {Array} xcoords An array of x-coordinate values
     * @param {Array} ycoords An arry of y-coordinate values
     * @private
     */
    _cleanYNaN: function(xcoords, ycoords)
    {
        _yuitest_coverfunc("/build/charts-base/charts-base.js", "_cleanYNaN", 5970);
_yuitest_coverline("/build/charts-base/charts-base.js", 5972);
var previousValidIndex,
            nextValidIndex,
            previousValidX,
            previousValidY,
            x,
            y,
            nextValidX,
            nextValidY,
            isNumber = Y_Lang.isNumber,
            m,
            i = 0,
            len = xcoords.length;
        _yuitest_coverline("/build/charts-base/charts-base.js", 5984);
for(; i < len; ++i)
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 5986);
x = xcoords[i];
            _yuitest_coverline("/build/charts-base/charts-base.js", 5987);
y = ycoords[i];
            //if y is invalid, calculate where it should be
            _yuitest_coverline("/build/charts-base/charts-base.js", 5989);
if(!isNumber(y) && i > 0 && i < len - 1)
            {
                //check to see if the previous value is valid
                _yuitest_coverline("/build/charts-base/charts-base.js", 5992);
previousValidX = xcoords[i - 1];
                _yuitest_coverline("/build/charts-base/charts-base.js", 5993);
previousValidY = this._getPreviousValidCoordValue(ycoords, i);
                //check to see if the next value is valid
                _yuitest_coverline("/build/charts-base/charts-base.js", 5995);
nextValidX = xcoords[i + 1];
                _yuitest_coverline("/build/charts-base/charts-base.js", 5996);
nextValidY = this._getNextValidCoordValue(ycoords, i);
                _yuitest_coverline("/build/charts-base/charts-base.js", 5997);
if(isNumber(previousValidY) && isNumber(nextValidY))
                {
                    //calculate slope and solve for y
                    _yuitest_coverline("/build/charts-base/charts-base.js", 6000);
m = (nextValidY - previousValidY) / (nextValidX - previousValidX);
                    _yuitest_coverline("/build/charts-base/charts-base.js", 6001);
ycoords[i] = previousValidY + ((m * x) - (m * previousValidX));
                }
                _yuitest_coverline("/build/charts-base/charts-base.js", 6003);
previousValidIndex = NaN;
                _yuitest_coverline("/build/charts-base/charts-base.js", 6004);
nextValidIndex = NaN;
            }
        }
    }
};
_yuitest_coverline("/build/charts-base/charts-base.js", 6009);
Y.StackingUtil = StackingUtil;
/**
 * Utility class used for drawing lines.
 *
 * @module charts
 * @submodule charts-base
 * @class Lines
 * @constructor
 */
_yuitest_coverline("/build/charts-base/charts-base.js", 6018);
function Lines(){}

_yuitest_coverline("/build/charts-base/charts-base.js", 6020);
Lines.prototype = {
    /**
     * @property _lineDefaults
     * @type Object
     * @private
     */
    _lineDefaults: null,
    
    /**
     * Creates a graphic in which to draw a series.
     *
     * @method _getGraphic
     * @return Graphic
     * @private
     */
    _getGraphic: function()
    {
        _yuitest_coverfunc("/build/charts-base/charts-base.js", "_getGraphic", 6035);
_yuitest_coverline("/build/charts-base/charts-base.js", 6037);
var graphic = this.get("graphic") || this.get("graph").get("graphic");
        _yuitest_coverline("/build/charts-base/charts-base.js", 6038);
if(!this._lineGraphic)
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 6040);
this._lineGraphic = graphic.addShape({type: "path"});
        }
        _yuitest_coverline("/build/charts-base/charts-base.js", 6042);
this._lineGraphic.clear();
        _yuitest_coverline("/build/charts-base/charts-base.js", 6043);
return this._lineGraphic;
    },
    
    /**
     * Toggles visibility
     *
     * @method _toggleVisible
     * @param {Boolean} visible indicates visibilitye
     * @private
     */
    _toggleVisible: function(visible)
    {
        _yuitest_coverfunc("/build/charts-base/charts-base.js", "_toggleVisible", 6053);
_yuitest_coverline("/build/charts-base/charts-base.js", 6055);
if(this._lineGraphic)
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 6057);
this._lineGraphic.set("visible", visible);
        }
    },

    /**
     * Draws lines for the series.
     *
     * @method drawLines
     * @protected
     */
    drawLines: function()
    {
        _yuitest_coverfunc("/build/charts-base/charts-base.js", "drawLines", 6067);
_yuitest_coverline("/build/charts-base/charts-base.js", 6069);
if(this.get("xcoords").length < 1) 
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 6071);
return;
        }
        _yuitest_coverline("/build/charts-base/charts-base.js", 6073);
var isNumber = Y_Lang.isNumber,
            xcoords,
            ycoords,
            direction = this.get("direction"),
            len,
            lastPointValid,
            pointValid,
            noPointsRendered = true,
            lastValidX,
            lastValidY,
            nextX,
            nextY,
            i,
            styles = this.get("styles").line,
            lineType = styles.lineType,
            lc = styles.color || this._getDefaultColor(this.get("graphOrder"), "line"),
            lineAlpha = styles.alpha,
            dashLength = styles.dashLength,
            gapSpace = styles.gapSpace,
            connectDiscontinuousPoints = styles.connectDiscontinuousPoints,
            discontinuousType = styles.discontinuousType,
            discontinuousDashLength = styles.discontinuousDashLength,
            discontinuousGapSpace = styles.discontinuousGapSpace,
            path = this._getGraphic();
        _yuitest_coverline("/build/charts-base/charts-base.js", 6097);
if(this._stacked)
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 6099);
xcoords = this.get("stackedXCoords");
            _yuitest_coverline("/build/charts-base/charts-base.js", 6100);
ycoords = this.get("stackedYCoords");
        }
        else
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 6104);
xcoords = this.get("xcoords");
            _yuitest_coverline("/build/charts-base/charts-base.js", 6105);
ycoords = this.get("ycoords");
        }
        _yuitest_coverline("/build/charts-base/charts-base.js", 6107);
len = direction === "vertical" ? ycoords.length : xcoords.length;
        _yuitest_coverline("/build/charts-base/charts-base.js", 6108);
path.set("stroke", {
            weight: styles.weight, 
            color: lc, 
            opacity: lineAlpha
        });
        _yuitest_coverline("/build/charts-base/charts-base.js", 6113);
for(i = 0; i < len; i = ++i)
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 6115);
nextX = xcoords[i];
            _yuitest_coverline("/build/charts-base/charts-base.js", 6116);
nextY = ycoords[i];
            _yuitest_coverline("/build/charts-base/charts-base.js", 6117);
pointValid = isNumber(nextX) && isNumber(nextY); 
            _yuitest_coverline("/build/charts-base/charts-base.js", 6118);
if(!pointValid)
            {
                _yuitest_coverline("/build/charts-base/charts-base.js", 6120);
lastPointValid = pointValid;
                _yuitest_coverline("/build/charts-base/charts-base.js", 6121);
continue;
            }
            _yuitest_coverline("/build/charts-base/charts-base.js", 6123);
if(noPointsRendered)
            {
                _yuitest_coverline("/build/charts-base/charts-base.js", 6125);
noPointsRendered = false;
                _yuitest_coverline("/build/charts-base/charts-base.js", 6126);
path.moveTo(nextX, nextY);
            }
            else {_yuitest_coverline("/build/charts-base/charts-base.js", 6128);
if(lastPointValid)
            {
                _yuitest_coverline("/build/charts-base/charts-base.js", 6130);
if(lineType != "dashed")
                {
                    _yuitest_coverline("/build/charts-base/charts-base.js", 6132);
path.lineTo(nextX, nextY);
                }
                else
                {
                    _yuitest_coverline("/build/charts-base/charts-base.js", 6136);
this.drawDashedLine(path, lastValidX, lastValidY, nextX, nextY, 
                                                dashLength, 
                                                gapSpace);
                }
            }
            else {_yuitest_coverline("/build/charts-base/charts-base.js", 6141);
if(!connectDiscontinuousPoints)
            {
                _yuitest_coverline("/build/charts-base/charts-base.js", 6143);
path.moveTo(nextX, nextY);
            }
            else
            {
                _yuitest_coverline("/build/charts-base/charts-base.js", 6147);
if(discontinuousType != "solid")
                {
                    _yuitest_coverline("/build/charts-base/charts-base.js", 6149);
this.drawDashedLine(path, lastValidX, lastValidY, nextX, nextY, 
                                                discontinuousDashLength, 
                                                discontinuousGapSpace);
                }
                else
                {
                    _yuitest_coverline("/build/charts-base/charts-base.js", 6155);
path.lineTo(nextX, nextY);
                }
            }}}
            _yuitest_coverline("/build/charts-base/charts-base.js", 6158);
lastValidX = nextX;
            _yuitest_coverline("/build/charts-base/charts-base.js", 6159);
lastValidY = nextY;
            _yuitest_coverline("/build/charts-base/charts-base.js", 6160);
lastPointValid = true;
        }
        _yuitest_coverline("/build/charts-base/charts-base.js", 6162);
path.end();
    },
    
    /**
     * Connects data points with a consistent curve for a series.
     * 
     * @method drawSpline
     * @protected
     */
    drawSpline: function()
    {
        _yuitest_coverfunc("/build/charts-base/charts-base.js", "drawSpline", 6171);
_yuitest_coverline("/build/charts-base/charts-base.js", 6173);
if(this.get("xcoords").length < 1) 
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 6175);
return;
        }
        _yuitest_coverline("/build/charts-base/charts-base.js", 6177);
var xcoords = this.get("xcoords"),
            ycoords = this.get("ycoords"),
            curvecoords = this.getCurveControlPoints(xcoords, ycoords),
            len = curvecoords.length,
            cx1,
            cx2,
            cy1,
            cy2,
            x,
            y,
            i = 0,
            styles = this.get("styles").line,
            path = this._getGraphic(),
            lineAlpha = styles.alpha,
            color = styles.color || this._getDefaultColor(this.get("graphOrder"), "line");
        _yuitest_coverline("/build/charts-base/charts-base.js", 6192);
path.set("stroke", { 
            weight: styles.weight, 
            color: color, 
            opacity: lineAlpha
        });
        _yuitest_coverline("/build/charts-base/charts-base.js", 6197);
path.moveTo(xcoords[0], ycoords[0]);
        _yuitest_coverline("/build/charts-base/charts-base.js", 6198);
for(; i < len; i = ++i)
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 6200);
x = curvecoords[i].endx;
            _yuitest_coverline("/build/charts-base/charts-base.js", 6201);
y = curvecoords[i].endy;
            _yuitest_coverline("/build/charts-base/charts-base.js", 6202);
cx1 = curvecoords[i].ctrlx1;
            _yuitest_coverline("/build/charts-base/charts-base.js", 6203);
cx2 = curvecoords[i].ctrlx2;
            _yuitest_coverline("/build/charts-base/charts-base.js", 6204);
cy1 = curvecoords[i].ctrly1;
            _yuitest_coverline("/build/charts-base/charts-base.js", 6205);
cy2 = curvecoords[i].ctrly2;
            _yuitest_coverline("/build/charts-base/charts-base.js", 6206);
path.curveTo(cx1, cy1, cx2, cy2, x, y);
        }
        _yuitest_coverline("/build/charts-base/charts-base.js", 6208);
path.end();
    },

    /**
     * Draws a dashed line between two points.
     * 
     * @method drawDashedLine
     * @param {Number} xStart	The x position of the start of the line
     * @param {Number} yStart	The y position of the start of the line
     * @param {Number} xEnd		The x position of the end of the line
     * @param {Number} yEnd		The y position of the end of the line
     * @param {Number} dashSize	the size of dashes, in pixels
     * @param {Number} gapSize	the size of gaps between dashes, in pixels
     * @private
     */
    drawDashedLine: function(path, xStart, yStart, xEnd, yEnd, dashSize, gapSize)
    {
        _yuitest_coverfunc("/build/charts-base/charts-base.js", "drawDashedLine", 6223);
_yuitest_coverline("/build/charts-base/charts-base.js", 6225);
dashSize = dashSize || 10;
        _yuitest_coverline("/build/charts-base/charts-base.js", 6226);
gapSize = gapSize || 10;
        _yuitest_coverline("/build/charts-base/charts-base.js", 6227);
var segmentLength = dashSize + gapSize,
            xDelta = xEnd - xStart,
            yDelta = yEnd - yStart,
            delta = Math.sqrt(Math.pow(xDelta, 2) + Math.pow(yDelta, 2)),
            segmentCount = Math.floor(Math.abs(delta / segmentLength)),
            radians = Math.atan2(yDelta, xDelta),
            xCurrent = xStart,
            yCurrent = yStart,
            i;
        _yuitest_coverline("/build/charts-base/charts-base.js", 6236);
xDelta = Math.cos(radians) * segmentLength;
        _yuitest_coverline("/build/charts-base/charts-base.js", 6237);
yDelta = Math.sin(radians) * segmentLength;
        
        _yuitest_coverline("/build/charts-base/charts-base.js", 6239);
for(i = 0; i < segmentCount; ++i)
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 6241);
path.moveTo(xCurrent, yCurrent);
            _yuitest_coverline("/build/charts-base/charts-base.js", 6242);
path.lineTo(xCurrent + Math.cos(radians) * dashSize, yCurrent + Math.sin(radians) * dashSize);
            _yuitest_coverline("/build/charts-base/charts-base.js", 6243);
xCurrent += xDelta;
            _yuitest_coverline("/build/charts-base/charts-base.js", 6244);
yCurrent += yDelta;
        }
        
        _yuitest_coverline("/build/charts-base/charts-base.js", 6247);
path.moveTo(xCurrent, yCurrent);
        _yuitest_coverline("/build/charts-base/charts-base.js", 6248);
delta = Math.sqrt((xEnd - xCurrent) * (xEnd - xCurrent) + (yEnd - yCurrent) * (yEnd - yCurrent));
        
        _yuitest_coverline("/build/charts-base/charts-base.js", 6250);
if(delta > dashSize)
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 6252);
path.lineTo(xCurrent + Math.cos(radians) * dashSize, yCurrent + Math.sin(radians) * dashSize);
        }
        else {_yuitest_coverline("/build/charts-base/charts-base.js", 6254);
if(delta > 0)
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 6256);
path.lineTo(xCurrent + Math.cos(radians) * delta, yCurrent + Math.sin(radians) * delta);
        }}
        
        _yuitest_coverline("/build/charts-base/charts-base.js", 6259);
path.moveTo(xEnd, yEnd);
    },

    /**
     * Default values for `styles` attribute.
     *
     * @method _getLineDefaults
     * @return Object
     * @protected
     */
    _getLineDefaults: function()
    {
        _yuitest_coverfunc("/build/charts-base/charts-base.js", "_getLineDefaults", 6269);
_yuitest_coverline("/build/charts-base/charts-base.js", 6271);
return {
            alpha: 1,
            weight: 6,
            lineType:"solid", 
            dashLength:10, 
            gapSpace:10, 
            connectDiscontinuousPoints:true, 
            discontinuousType:"solid", 
            discontinuousDashLength:10, 
            discontinuousGapSpace:10
        };
    }
};
_yuitest_coverline("/build/charts-base/charts-base.js", 6284);
Y.augment(Lines, Y.Attribute);
_yuitest_coverline("/build/charts-base/charts-base.js", 6285);
Y.Lines = Lines;
/**
 * Utility class used for drawing area fills.
 *
 * @module charts
 * @class Fills
 * @constructor
 */
_yuitest_coverline("/build/charts-base/charts-base.js", 6293);
function Fills(cfg)
{
    _yuitest_coverfunc("/build/charts-base/charts-base.js", "Fills", 6293);
_yuitest_coverline("/build/charts-base/charts-base.js", 6295);
var attrs = {
        area: {
            getter: function()
            {
                _yuitest_coverfunc("/build/charts-base/charts-base.js", "getter", 6297);
_yuitest_coverline("/build/charts-base/charts-base.js", 6299);
return this._defaults || this._getAreaDefaults();
            },

            setter: function(val)
            {
                _yuitest_coverfunc("/build/charts-base/charts-base.js", "setter", 6302);
_yuitest_coverline("/build/charts-base/charts-base.js", 6304);
var defaults = this._defaults || this._getAreaDefaults();
                _yuitest_coverline("/build/charts-base/charts-base.js", 6305);
this._defaults = Y.merge(defaults, val);
            }
        }
    };
    _yuitest_coverline("/build/charts-base/charts-base.js", 6309);
this.addAttrs(attrs, cfg);
    _yuitest_coverline("/build/charts-base/charts-base.js", 6310);
this.get("styles");
}

_yuitest_coverline("/build/charts-base/charts-base.js", 6313);
Fills.prototype = {
    /**
     * Returns a path shape used for drawing fills.
     *
     * @method _getPath
     * @return Path
     * @private
     */
    _getPath: function()
    {
        _yuitest_coverfunc("/build/charts-base/charts-base.js", "_getPath", 6321);
_yuitest_coverline("/build/charts-base/charts-base.js", 6323);
var path = this._path;
        _yuitest_coverline("/build/charts-base/charts-base.js", 6324);
if(!path)
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 6326);
path = this.get("graph").get("graphic").addShape({type:"path"});
            _yuitest_coverline("/build/charts-base/charts-base.js", 6327);
this._path = path;
        }
        _yuitest_coverline("/build/charts-base/charts-base.js", 6329);
return path;
    },
    
    /**
     * Toggles visibility
     *
     * @method _toggleVisible
     * @param {Boolean} visible indicates visibilitye
     * @private
     */
    _toggleVisible: function(visible)
    {   
        _yuitest_coverfunc("/build/charts-base/charts-base.js", "_toggleVisible", 6339);
_yuitest_coverline("/build/charts-base/charts-base.js", 6341);
if(this._path)
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 6343);
this._path.set("visible", visible);
        }
    },

    /**
     * Draws fill
     *
     * @method drawFill
     * @param {Array} xcoords The x-coordinates for the series.
     * @param {Array} ycoords The y-coordinates for the series.
     * @protected
     */
    drawFill: function(xcoords, ycoords)
    {
        _yuitest_coverfunc("/build/charts-base/charts-base.js", "drawFill", 6355);
_yuitest_coverline("/build/charts-base/charts-base.js", 6357);
if(xcoords.length < 1) 
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 6359);
return;
        }
        _yuitest_coverline("/build/charts-base/charts-base.js", 6361);
var isNumber = Y_Lang.isNumber,
            len = xcoords.length,
            firstX = xcoords[0],
            firstY = ycoords[0],
            lastValidX = firstX,
            lastValidY = firstY,
            nextX,
            nextY,
            pointValid,
            noPointsRendered = true,
            i = 0,
            styles = this.get("styles").area,
            path = this._getPath(),
            color = styles.color || this._getDefaultColor(this.get("graphOrder"), "slice");
        _yuitest_coverline("/build/charts-base/charts-base.js", 6375);
path.clear();
        _yuitest_coverline("/build/charts-base/charts-base.js", 6376);
path.set("fill", {
            color: color, 
            opacity: styles.alpha
        });
        _yuitest_coverline("/build/charts-base/charts-base.js", 6380);
path.set("stroke", {weight: 0});
        _yuitest_coverline("/build/charts-base/charts-base.js", 6381);
for(; i < len; i = ++i)
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 6383);
nextX = xcoords[i];
            _yuitest_coverline("/build/charts-base/charts-base.js", 6384);
nextY = ycoords[i];
            _yuitest_coverline("/build/charts-base/charts-base.js", 6385);
pointValid = isNumber(nextX) && isNumber(nextY); 
            _yuitest_coverline("/build/charts-base/charts-base.js", 6386);
if(!pointValid)
            {
                _yuitest_coverline("/build/charts-base/charts-base.js", 6388);
continue;
            }
            _yuitest_coverline("/build/charts-base/charts-base.js", 6390);
if(noPointsRendered)
            {
                _yuitest_coverline("/build/charts-base/charts-base.js", 6392);
this._firstValidX = nextX;
                _yuitest_coverline("/build/charts-base/charts-base.js", 6393);
this._firstValidY = nextY;
                _yuitest_coverline("/build/charts-base/charts-base.js", 6394);
noPointsRendered = false;
                _yuitest_coverline("/build/charts-base/charts-base.js", 6395);
path.moveTo(nextX, nextY);
            }
            else
            {
                _yuitest_coverline("/build/charts-base/charts-base.js", 6399);
path.lineTo(nextX, nextY);
            }
            _yuitest_coverline("/build/charts-base/charts-base.js", 6401);
lastValidX = nextX;
            _yuitest_coverline("/build/charts-base/charts-base.js", 6402);
lastValidY = nextY;
        }
        _yuitest_coverline("/build/charts-base/charts-base.js", 6404);
this._lastValidX = lastValidX;
        _yuitest_coverline("/build/charts-base/charts-base.js", 6405);
this._lastValidY = lastValidY;
        _yuitest_coverline("/build/charts-base/charts-base.js", 6406);
path.end();
    },
	
    /**
     * Draws a fill for a spline
     *
     * @method drawAreaSpline
     * @protected
     */
    drawAreaSpline: function()
    {
        _yuitest_coverfunc("/build/charts-base/charts-base.js", "drawAreaSpline", 6415);
_yuitest_coverline("/build/charts-base/charts-base.js", 6417);
if(this.get("xcoords").length < 1) 
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 6419);
return;
        }
        _yuitest_coverline("/build/charts-base/charts-base.js", 6421);
var xcoords = this.get("xcoords"),
            ycoords = this.get("ycoords"),
            curvecoords = this.getCurveControlPoints(xcoords, ycoords),
            len = curvecoords.length,
            cx1,
            cx2,
            cy1,
            cy2,
            x,
            y,
            i = 0,
            firstX = xcoords[0],
            firstY = ycoords[0],
            styles = this.get("styles").area,
            path = this._getPath(),
            color = styles.color || this._getDefaultColor(this.get("graphOrder"), "slice");
        _yuitest_coverline("/build/charts-base/charts-base.js", 6437);
path.set("fill", {
            color: color, 
            opacity: styles.alpha
        });
        _yuitest_coverline("/build/charts-base/charts-base.js", 6441);
path.set("stroke", {weight: 0});
        _yuitest_coverline("/build/charts-base/charts-base.js", 6442);
path.moveTo(firstX, firstY);
        _yuitest_coverline("/build/charts-base/charts-base.js", 6443);
for(; i < len; i = ++i)
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 6445);
x = curvecoords[i].endx;
            _yuitest_coverline("/build/charts-base/charts-base.js", 6446);
y = curvecoords[i].endy;
            _yuitest_coverline("/build/charts-base/charts-base.js", 6447);
cx1 = curvecoords[i].ctrlx1;
            _yuitest_coverline("/build/charts-base/charts-base.js", 6448);
cx2 = curvecoords[i].ctrlx2;
            _yuitest_coverline("/build/charts-base/charts-base.js", 6449);
cy1 = curvecoords[i].ctrly1;
            _yuitest_coverline("/build/charts-base/charts-base.js", 6450);
cy2 = curvecoords[i].ctrly2;
            _yuitest_coverline("/build/charts-base/charts-base.js", 6451);
path.curveTo(cx1, cy1, cx2, cy2, x, y);
        }
        _yuitest_coverline("/build/charts-base/charts-base.js", 6453);
if(this.get("direction") === "vertical")
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 6455);
path.lineTo(this._leftOrigin, y);
            _yuitest_coverline("/build/charts-base/charts-base.js", 6456);
path.lineTo(this._leftOrigin, firstY);
        }
        else
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 6460);
path.lineTo(x, this._bottomOrigin);
            _yuitest_coverline("/build/charts-base/charts-base.js", 6461);
path.lineTo(firstX, this._bottomOrigin);
        }
        _yuitest_coverline("/build/charts-base/charts-base.js", 6463);
path.lineTo(firstX, firstY);
        _yuitest_coverline("/build/charts-base/charts-base.js", 6464);
path.end();
    },
    
    /**
     * Draws a a stacked area spline
     *
     * @method drawStackedAreaSpline
     * @protected
     */
    drawStackedAreaSpline: function()
    {
        _yuitest_coverfunc("/build/charts-base/charts-base.js", "drawStackedAreaSpline", 6473);
_yuitest_coverline("/build/charts-base/charts-base.js", 6475);
if(this.get("xcoords").length < 1) 
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 6477);
return;
        }
        _yuitest_coverline("/build/charts-base/charts-base.js", 6479);
var xcoords = this.get("xcoords"),
            ycoords = this.get("ycoords"),
            curvecoords,
            order = this.get("order"),
            type = this.get("type"),
            graph = this.get("graph"),
            seriesCollection = graph.seriesTypes[type],
            prevXCoords,
            prevYCoords,
            len,
            cx1,
            cx2,
            cy1,
            cy2,
            x,
            y,
            i = 0,
            firstX,
            firstY,
            styles = this.get("styles").area,
            path = this._getPath(),
            color = styles.color || this._getDefaultColor(this.get("graphOrder"), "slice");
        _yuitest_coverline("/build/charts-base/charts-base.js", 6501);
firstX = xcoords[0];
        _yuitest_coverline("/build/charts-base/charts-base.js", 6502);
firstY = ycoords[0];
        _yuitest_coverline("/build/charts-base/charts-base.js", 6503);
curvecoords = this.getCurveControlPoints(xcoords, ycoords);
        _yuitest_coverline("/build/charts-base/charts-base.js", 6504);
len = curvecoords.length;
        _yuitest_coverline("/build/charts-base/charts-base.js", 6505);
path.set("fill", {
            color: color, 
            opacity: styles.alpha
        });
        _yuitest_coverline("/build/charts-base/charts-base.js", 6509);
path.set("stroke", {weight: 0});
        _yuitest_coverline("/build/charts-base/charts-base.js", 6510);
path.moveTo(firstX, firstY);
        _yuitest_coverline("/build/charts-base/charts-base.js", 6511);
for(; i < len; i = ++i)
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 6513);
x = curvecoords[i].endx;
            _yuitest_coverline("/build/charts-base/charts-base.js", 6514);
y = curvecoords[i].endy;
            _yuitest_coverline("/build/charts-base/charts-base.js", 6515);
cx1 = curvecoords[i].ctrlx1;
            _yuitest_coverline("/build/charts-base/charts-base.js", 6516);
cx2 = curvecoords[i].ctrlx2;
            _yuitest_coverline("/build/charts-base/charts-base.js", 6517);
cy1 = curvecoords[i].ctrly1;
            _yuitest_coverline("/build/charts-base/charts-base.js", 6518);
cy2 = curvecoords[i].ctrly2;
            _yuitest_coverline("/build/charts-base/charts-base.js", 6519);
path.curveTo(cx1, cy1, cx2, cy2, x, y);
        }
        _yuitest_coverline("/build/charts-base/charts-base.js", 6521);
if(order > 0)
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 6523);
prevXCoords = seriesCollection[order - 1].get("xcoords").concat().reverse();
            _yuitest_coverline("/build/charts-base/charts-base.js", 6524);
prevYCoords = seriesCollection[order - 1].get("ycoords").concat().reverse();
            _yuitest_coverline("/build/charts-base/charts-base.js", 6525);
curvecoords = this.getCurveControlPoints(prevXCoords, prevYCoords);
            _yuitest_coverline("/build/charts-base/charts-base.js", 6526);
i = 0;
            _yuitest_coverline("/build/charts-base/charts-base.js", 6527);
len = curvecoords.length;
            _yuitest_coverline("/build/charts-base/charts-base.js", 6528);
path.lineTo(prevXCoords[0], prevYCoords[0]);
            _yuitest_coverline("/build/charts-base/charts-base.js", 6529);
for(; i < len; i = ++i)
            {
                _yuitest_coverline("/build/charts-base/charts-base.js", 6531);
x = curvecoords[i].endx;
                _yuitest_coverline("/build/charts-base/charts-base.js", 6532);
y = curvecoords[i].endy;
                _yuitest_coverline("/build/charts-base/charts-base.js", 6533);
cx1 = curvecoords[i].ctrlx1;
                _yuitest_coverline("/build/charts-base/charts-base.js", 6534);
cx2 = curvecoords[i].ctrlx2;
                _yuitest_coverline("/build/charts-base/charts-base.js", 6535);
cy1 = curvecoords[i].ctrly1;
                _yuitest_coverline("/build/charts-base/charts-base.js", 6536);
cy2 = curvecoords[i].ctrly2;
                _yuitest_coverline("/build/charts-base/charts-base.js", 6537);
path.curveTo(cx1, cy1, cx2, cy2, x, y);
            }
        }
        else
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 6542);
if(this.get("direction") === "vertical")
            {
                _yuitest_coverline("/build/charts-base/charts-base.js", 6544);
path.lineTo(this._leftOrigin, ycoords[ycoords.length-1]);
                _yuitest_coverline("/build/charts-base/charts-base.js", 6545);
path.lineTo(this._leftOrigin, firstY);
            }
            else
            {
                _yuitest_coverline("/build/charts-base/charts-base.js", 6549);
path.lineTo(xcoords[xcoords.length-1], this._bottomOrigin);
                _yuitest_coverline("/build/charts-base/charts-base.js", 6550);
path.lineTo(firstX, this._bottomOrigin);
            }

        }
        _yuitest_coverline("/build/charts-base/charts-base.js", 6554);
path.lineTo(firstX, firstY);
        _yuitest_coverline("/build/charts-base/charts-base.js", 6555);
path.end();
    },
    
    /**
     * Storage for default area styles.
     *
     * @property _defaults
     * @type Object
     * @private
     */
    _defaults: null,

    /**
     * Concatenates coordinate array with correct coordinates for closing an area fill.
     *
     * @method _getClosingPoints
     * @return Array
     * @protected
     */
    _getClosingPoints: function()
    {
        _yuitest_coverfunc("/build/charts-base/charts-base.js", "_getClosingPoints", 6574);
_yuitest_coverline("/build/charts-base/charts-base.js", 6576);
var xcoords = this.get("xcoords").concat(),
            ycoords = this.get("ycoords").concat(),
            firstValidIndex,
            lastValidIndex;
        _yuitest_coverline("/build/charts-base/charts-base.js", 6580);
if(this.get("direction") === "vertical")
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 6582);
lastValidIndex = this._getLastValidIndex(xcoords);
            _yuitest_coverline("/build/charts-base/charts-base.js", 6583);
firstValidIndex = this._getFirstValidIndex(xcoords);
            _yuitest_coverline("/build/charts-base/charts-base.js", 6584);
ycoords.push(ycoords[lastValidIndex]);
            _yuitest_coverline("/build/charts-base/charts-base.js", 6585);
ycoords.push(ycoords[firstValidIndex]);
            _yuitest_coverline("/build/charts-base/charts-base.js", 6586);
xcoords.push(this._leftOrigin);
            _yuitest_coverline("/build/charts-base/charts-base.js", 6587);
xcoords.push(this._leftOrigin);
        }
        else
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 6591);
lastValidIndex = this._getLastValidIndex(ycoords);
            _yuitest_coverline("/build/charts-base/charts-base.js", 6592);
firstValidIndex = this._getFirstValidIndex(ycoords);
            _yuitest_coverline("/build/charts-base/charts-base.js", 6593);
xcoords.push(xcoords[lastValidIndex]);
            _yuitest_coverline("/build/charts-base/charts-base.js", 6594);
xcoords.push(xcoords[firstValidIndex]);
            _yuitest_coverline("/build/charts-base/charts-base.js", 6595);
ycoords.push(this._bottomOrigin);
            _yuitest_coverline("/build/charts-base/charts-base.js", 6596);
ycoords.push(this._bottomOrigin);
        }
        _yuitest_coverline("/build/charts-base/charts-base.js", 6598);
xcoords.push(xcoords[0]);
        _yuitest_coverline("/build/charts-base/charts-base.js", 6599);
ycoords.push(ycoords[0]);
        _yuitest_coverline("/build/charts-base/charts-base.js", 6600);
return [xcoords, ycoords];
    },

    /**
     * Returns the order of the series closest to the current series that has a valid value for the current index.
     *
     * @method _getHighestValidOrder
     * @param {Array} seriesCollection Array of series of a given type.
     * @param {Number} index Index of the series item.
     * @param {Number} order Index of the the series in the seriesCollection
     * @param {String} direction Indicates the direction of the series
     * @return Number
     * @private
     */
    _getHighestValidOrder: function(seriesCollection, index, order, direction)
    {
        _yuitest_coverfunc("/build/charts-base/charts-base.js", "_getHighestValidOrder", 6614);
_yuitest_coverline("/build/charts-base/charts-base.js", 6616);
var coords = direction == "vertical" ? "stackedXCoords" : "stackedYCoords",
            coord;
        _yuitest_coverline("/build/charts-base/charts-base.js", 6618);
while(isNaN(coord) && order > -1)
        {
          _yuitest_coverline("/build/charts-base/charts-base.js", 6620);
order = order - 1;
          _yuitest_coverline("/build/charts-base/charts-base.js", 6621);
if(order > -1)
          {
            _yuitest_coverline("/build/charts-base/charts-base.js", 6623);
coord = seriesCollection[order].get(coords)[index];
          }
        }
        _yuitest_coverline("/build/charts-base/charts-base.js", 6626);
return order;
    },
    
    /**
     * Returns an array containing the x and y coordinates for a given series and index.
     *
     * @method _getCoordsByOrderAndIndex
     * @param {Array} seriesCollection Array of series of a given type.
     * @param {Number} index Index of the series item.
     * @param {Number} order Index of the the series in the seriesCollection
     * @param {String} direction Indicates the direction of the series
     * @return Array
     * @private
     */
    _getCoordsByOrderAndIndex: function(seriesCollection, index, order, direction)
    {
        _yuitest_coverfunc("/build/charts-base/charts-base.js", "_getCoordsByOrderAndIndex", 6640);
_yuitest_coverline("/build/charts-base/charts-base.js", 6642);
var xcoord,
            ycoord;
        _yuitest_coverline("/build/charts-base/charts-base.js", 6644);
if(direction == "vertical")
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 6646);
xcoord = order < 0 ? this._leftOrigin : seriesCollection[order].get("stackedXCoords")[index];
            _yuitest_coverline("/build/charts-base/charts-base.js", 6647);
ycoord = this.get("stackedYCoords")[index];
        }
        else
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 6651);
xcoord = this.get("stackedXCoords")[index];
            _yuitest_coverline("/build/charts-base/charts-base.js", 6652);
ycoord = order < 0 ? this._bottomOrigin : seriesCollection[order].get("stackedYCoords")[index];
        }
        _yuitest_coverline("/build/charts-base/charts-base.js", 6654);
return [xcoord, ycoord];
    },
    
    /**
     * Concatenates coordinate array with the correct coordinates for closing an area stack.
     *
     * @method _getStackedClosingPoints
     * @return Array
     * @protected
     */
    _getStackedClosingPoints: function()
    {
        _yuitest_coverfunc("/build/charts-base/charts-base.js", "_getStackedClosingPoints", 6664);
_yuitest_coverline("/build/charts-base/charts-base.js", 6666);
var order = this.get("order"),
            type = this.get("type"),
            graph = this.get("graph"),
            direction = this.get("direction"),
            seriesCollection = graph.seriesTypes[type],
            firstValidIndex,
            lastValidIndex,
            xcoords = this.get("stackedXCoords"),
            ycoords = this.get("stackedYCoords"),
            limit,
            previousSeries,
            previousSeriesFirstValidIndex,
            previousSeriesLastValidIndex,
            previousXCoords,
            previousYCoords,
            coords,
            closingXCoords,
            closingYCoords,
            currentIndex,
            highestValidOrder,
            oldOrder;
        _yuitest_coverline("/build/charts-base/charts-base.js", 6687);
if(order < 1)
        {    
          _yuitest_coverline("/build/charts-base/charts-base.js", 6689);
return this._getClosingPoints();
        }
        
        _yuitest_coverline("/build/charts-base/charts-base.js", 6692);
previousSeries = seriesCollection[order - 1];
        _yuitest_coverline("/build/charts-base/charts-base.js", 6693);
previousXCoords = previousSeries.get("stackedXCoords").concat();
        _yuitest_coverline("/build/charts-base/charts-base.js", 6694);
previousYCoords = previousSeries.get("stackedYCoords").concat();
        _yuitest_coverline("/build/charts-base/charts-base.js", 6695);
if(direction == "vertical")
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 6697);
firstValidIndex = this._getFirstValidIndex(xcoords);
            _yuitest_coverline("/build/charts-base/charts-base.js", 6698);
lastValidIndex = this._getLastValidIndex(xcoords);
            _yuitest_coverline("/build/charts-base/charts-base.js", 6699);
previousSeriesFirstValidIndex = previousSeries._getFirstValidIndex(previousXCoords);
            _yuitest_coverline("/build/charts-base/charts-base.js", 6700);
previousSeriesLastValidIndex = previousSeries._getLastValidIndex(previousXCoords);
        }
        else
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 6704);
firstValidIndex = this._getFirstValidIndex(ycoords);
            _yuitest_coverline("/build/charts-base/charts-base.js", 6705);
lastValidIndex = this._getLastValidIndex(ycoords);
            _yuitest_coverline("/build/charts-base/charts-base.js", 6706);
previousSeriesFirstValidIndex = previousSeries._getFirstValidIndex(previousYCoords);
            _yuitest_coverline("/build/charts-base/charts-base.js", 6707);
previousSeriesLastValidIndex = previousSeries._getLastValidIndex(previousYCoords);
        }
        _yuitest_coverline("/build/charts-base/charts-base.js", 6709);
if(previousSeriesLastValidIndex >= firstValidIndex && previousSeriesFirstValidIndex <= lastValidIndex)
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 6711);
previousSeriesFirstValidIndex = Math.max(firstValidIndex, previousSeriesFirstValidIndex);
            _yuitest_coverline("/build/charts-base/charts-base.js", 6712);
previousSeriesLastValidIndex = Math.min(lastValidIndex, previousSeriesLastValidIndex);
            _yuitest_coverline("/build/charts-base/charts-base.js", 6713);
previousXCoords = previousXCoords.slice(previousSeriesFirstValidIndex, previousSeriesLastValidIndex + 1);
            _yuitest_coverline("/build/charts-base/charts-base.js", 6714);
previousYCoords = previousYCoords.slice(previousSeriesFirstValidIndex, previousSeriesLastValidIndex + 1);
            _yuitest_coverline("/build/charts-base/charts-base.js", 6715);
limit = previousSeriesFirstValidIndex;
        }
        else
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 6719);
limit = lastValidIndex;
        }

        _yuitest_coverline("/build/charts-base/charts-base.js", 6722);
closingXCoords = [xcoords[firstValidIndex]];
        _yuitest_coverline("/build/charts-base/charts-base.js", 6723);
closingYCoords = [ycoords[firstValidIndex]];
        _yuitest_coverline("/build/charts-base/charts-base.js", 6724);
currentIndex = firstValidIndex;
        _yuitest_coverline("/build/charts-base/charts-base.js", 6725);
while((isNaN(highestValidOrder) || highestValidOrder < order - 1) && currentIndex <= limit)
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 6727);
oldOrder = highestValidOrder;
            _yuitest_coverline("/build/charts-base/charts-base.js", 6728);
highestValidOrder = this._getHighestValidOrder(seriesCollection, currentIndex, order, direction);
            _yuitest_coverline("/build/charts-base/charts-base.js", 6729);
if(!isNaN(oldOrder) && highestValidOrder > oldOrder)
            {
                _yuitest_coverline("/build/charts-base/charts-base.js", 6731);
coords = this._getCoordsByOrderAndIndex(seriesCollection, currentIndex, oldOrder, direction);
                _yuitest_coverline("/build/charts-base/charts-base.js", 6732);
closingXCoords.push(coords[0]);
                _yuitest_coverline("/build/charts-base/charts-base.js", 6733);
closingYCoords.push(coords[1]);
            }
            _yuitest_coverline("/build/charts-base/charts-base.js", 6735);
coords = this._getCoordsByOrderAndIndex(seriesCollection, currentIndex, highestValidOrder, direction);
            _yuitest_coverline("/build/charts-base/charts-base.js", 6736);
closingXCoords.push(coords[0]);
            _yuitest_coverline("/build/charts-base/charts-base.js", 6737);
closingYCoords.push(coords[1]);
            _yuitest_coverline("/build/charts-base/charts-base.js", 6738);
currentIndex = currentIndex + 1;
        }
        _yuitest_coverline("/build/charts-base/charts-base.js", 6740);
if(previousXCoords && previousXCoords.length > 0 && previousSeriesLastValidIndex > firstValidIndex && previousSeriesFirstValidIndex < lastValidIndex)
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 6742);
closingXCoords = closingXCoords.concat(previousXCoords);
            _yuitest_coverline("/build/charts-base/charts-base.js", 6743);
closingYCoords = closingYCoords.concat(previousYCoords);
            _yuitest_coverline("/build/charts-base/charts-base.js", 6744);
highestValidOrder = order -1; 
        }
        _yuitest_coverline("/build/charts-base/charts-base.js", 6746);
currentIndex = Math.max(firstValidIndex, previousSeriesLastValidIndex);
        _yuitest_coverline("/build/charts-base/charts-base.js", 6747);
order = order - 1;
        _yuitest_coverline("/build/charts-base/charts-base.js", 6748);
highestValidOrder = NaN;
        _yuitest_coverline("/build/charts-base/charts-base.js", 6749);
while(currentIndex <= lastValidIndex)
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 6751);
oldOrder = highestValidOrder;
            _yuitest_coverline("/build/charts-base/charts-base.js", 6752);
highestValidOrder = this._getHighestValidOrder(seriesCollection, currentIndex, order, direction);
            _yuitest_coverline("/build/charts-base/charts-base.js", 6753);
if(!isNaN(oldOrder))
            {
                _yuitest_coverline("/build/charts-base/charts-base.js", 6755);
if(highestValidOrder > oldOrder)
                {
                    _yuitest_coverline("/build/charts-base/charts-base.js", 6757);
coords = this._getCoordsByOrderAndIndex(seriesCollection, currentIndex, oldOrder, direction);
                    _yuitest_coverline("/build/charts-base/charts-base.js", 6758);
closingXCoords.push(coords[0]);
                    _yuitest_coverline("/build/charts-base/charts-base.js", 6759);
closingYCoords.push(coords[1]);
                }
                else {_yuitest_coverline("/build/charts-base/charts-base.js", 6761);
if(highestValidOrder < oldOrder)
                {
                    _yuitest_coverline("/build/charts-base/charts-base.js", 6763);
coords = this._getCoordsByOrderAndIndex(seriesCollection, currentIndex - 1, highestValidOrder, direction);
                    _yuitest_coverline("/build/charts-base/charts-base.js", 6764);
closingXCoords.push(coords[0]);
                    _yuitest_coverline("/build/charts-base/charts-base.js", 6765);
closingYCoords.push(coords[1]);
                }}
            }
            _yuitest_coverline("/build/charts-base/charts-base.js", 6768);
coords = this._getCoordsByOrderAndIndex(seriesCollection, currentIndex, highestValidOrder, direction);
            _yuitest_coverline("/build/charts-base/charts-base.js", 6769);
closingXCoords.push(coords[0]);
            _yuitest_coverline("/build/charts-base/charts-base.js", 6770);
closingYCoords.push(coords[1]);
            _yuitest_coverline("/build/charts-base/charts-base.js", 6771);
currentIndex = currentIndex + 1;
        }

        _yuitest_coverline("/build/charts-base/charts-base.js", 6774);
closingXCoords.reverse();
        _yuitest_coverline("/build/charts-base/charts-base.js", 6775);
closingYCoords.reverse();
        _yuitest_coverline("/build/charts-base/charts-base.js", 6776);
return [xcoords.concat(closingXCoords), ycoords.concat(closingYCoords)];
    },

    /**
     * Returns default values for area styles.
     *
     * @method _getAreaDefaults
     * @return Object
     * @private
     */
    _getAreaDefaults: function()
    {
        _yuitest_coverfunc("/build/charts-base/charts-base.js", "_getAreaDefaults", 6786);
_yuitest_coverline("/build/charts-base/charts-base.js", 6788);
return {
        };
    }
};
_yuitest_coverline("/build/charts-base/charts-base.js", 6792);
Y.augment(Fills, Y.Attribute);
_yuitest_coverline("/build/charts-base/charts-base.js", 6793);
Y.Fills = Fills;
/**
 * Utility class used for drawing markers.
 *
 * @module charts
 * @submodule charts-base
 * @class Plots
 * @constructor
 */
_yuitest_coverline("/build/charts-base/charts-base.js", 6802);
function Plots(cfg)
{
    _yuitest_coverfunc("/build/charts-base/charts-base.js", "Plots", 6802);
_yuitest_coverline("/build/charts-base/charts-base.js", 6804);
var attrs = { 
        markers: {
            getter: function()
            {
                _yuitest_coverfunc("/build/charts-base/charts-base.js", "getter", 6806);
_yuitest_coverline("/build/charts-base/charts-base.js", 6808);
return this._markers;
            }
        }
    };
    _yuitest_coverline("/build/charts-base/charts-base.js", 6812);
this.addAttrs(attrs, cfg);
}

_yuitest_coverline("/build/charts-base/charts-base.js", 6815);
Plots.prototype = {
    /**
     * Storage for default marker styles.
     *
     * @property _plotDefaults
     * @type Object
     * @private
     */
    _plotDefaults: null,

    /**
     * Draws the markers
     *
     * @method drawPlots
     * @protected
     */
    drawPlots: function()
    {
        _yuitest_coverfunc("/build/charts-base/charts-base.js", "drawPlots", 6831);
_yuitest_coverline("/build/charts-base/charts-base.js", 6833);
if(!this.get("xcoords") || this.get("xcoords").length < 1) 
		{
			_yuitest_coverline("/build/charts-base/charts-base.js", 6835);
return;
		}
        _yuitest_coverline("/build/charts-base/charts-base.js", 6837);
var isNumber = Y_Lang.isNumber,
            style = Y.clone(this.get("styles").marker),
            w = style.width,
            h = style.height,
            xcoords = this.get("xcoords"),
            ycoords = this.get("ycoords"),
            i = 0,
            len = xcoords.length,
            top = ycoords[0],
            left,
            marker,
            offsetWidth = w/2,
            offsetHeight = h/2,
            xvalues,
            yvalues,
            fillColors = null,
            borderColors = null,
            graphOrder = this.get("graphOrder"),
            groupMarkers = this.get("groupMarkers");
        _yuitest_coverline("/build/charts-base/charts-base.js", 6856);
if(groupMarkers)
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 6858);
xvalues = [];
            _yuitest_coverline("/build/charts-base/charts-base.js", 6859);
yvalues = [];
            _yuitest_coverline("/build/charts-base/charts-base.js", 6860);
for(; i < len; ++i)
            {
                _yuitest_coverline("/build/charts-base/charts-base.js", 6862);
xvalues.push(parseFloat(xcoords[i] - offsetWidth));
                _yuitest_coverline("/build/charts-base/charts-base.js", 6863);
yvalues.push(parseFloat(ycoords[i] - offsetHeight));
            }
            _yuitest_coverline("/build/charts-base/charts-base.js", 6865);
this._createGroupMarker({
                xvalues: xvalues,
                yvalues: yvalues,
                fill: style.fill,
                border: style.border,
                dimensions: {
                    width: w,
                    height: h
                },
                graphOrder: graphOrder,
                shape: style.shape
            });
            _yuitest_coverline("/build/charts-base/charts-base.js", 6877);
return;
        }
        _yuitest_coverline("/build/charts-base/charts-base.js", 6879);
if(Y_Lang.isArray(style.fill.color))
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 6881);
fillColors = style.fill.color.concat(); 
        }
        _yuitest_coverline("/build/charts-base/charts-base.js", 6883);
if(Y_Lang.isArray(style.border.color))
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 6885);
borderColors = style.border.color.concat();
        }
        _yuitest_coverline("/build/charts-base/charts-base.js", 6887);
this._createMarkerCache();
        _yuitest_coverline("/build/charts-base/charts-base.js", 6888);
for(; i < len; ++i)
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 6890);
top = parseFloat(ycoords[i] - offsetHeight);
            _yuitest_coverline("/build/charts-base/charts-base.js", 6891);
left = parseFloat(xcoords[i] - offsetWidth);            
            _yuitest_coverline("/build/charts-base/charts-base.js", 6892);
if(!isNumber(left) || !isNumber(top))
            {
                _yuitest_coverline("/build/charts-base/charts-base.js", 6894);
this._markers.push(null);
                _yuitest_coverline("/build/charts-base/charts-base.js", 6895);
continue;
            }
            _yuitest_coverline("/build/charts-base/charts-base.js", 6897);
if(fillColors)
            {
                _yuitest_coverline("/build/charts-base/charts-base.js", 6899);
style.fill.color = fillColors[i % fillColors.length];
            }
            _yuitest_coverline("/build/charts-base/charts-base.js", 6901);
if(borderColors)
            {
                _yuitest_coverline("/build/charts-base/charts-base.js", 6903);
style.border.color = borderColors[i % borderColors.length];
            }

            _yuitest_coverline("/build/charts-base/charts-base.js", 6906);
style.x = left;
            _yuitest_coverline("/build/charts-base/charts-base.js", 6907);
style.y = top;
            _yuitest_coverline("/build/charts-base/charts-base.js", 6908);
marker = this.getMarker(style, graphOrder, i);
        }
        _yuitest_coverline("/build/charts-base/charts-base.js", 6910);
this._clearMarkerCache();
    },

    /**
     * Pre-defined group shapes.
     *
     * @property _groupShapes
     * @private
     */
    _groupShapes: {
        circle: Y.CircleGroup,
        rect: Y.RectGroup,
        ellipse: Y.EllipseGroup,
        diamond: Y.DiamondGroup
    },

    /**
     * Returns the correct group shape class.
     *
     * @method _getGroupShape
     * @param {Shape | String} shape Indicates which shape class. 
     * @return Function
     * @protected
     */
    _getGroupShape: function(shape)
    {
        _yuitest_coverfunc("/build/charts-base/charts-base.js", "_getGroupShape", 6934);
_yuitest_coverline("/build/charts-base/charts-base.js", 6936);
if(Y_Lang.isString(shape))
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 6938);
shape = this._groupShapes[shape];
        }
        _yuitest_coverline("/build/charts-base/charts-base.js", 6940);
return shape;
    },

    /**
     * Gets the default values for series that use the utility. This method is used by
     * the class' `styles` attribute's getter to get build default values.
     *
     * @method _getPlotDefaults
     * @return Object
     * @protected
     */
    _getPlotDefaults: function()
    {
        _yuitest_coverfunc("/build/charts-base/charts-base.js", "_getPlotDefaults", 6951);
_yuitest_coverline("/build/charts-base/charts-base.js", 6953);
var defs = {
            fill:{
                type: "solid",
                alpha: 1,
                colors:null,
                alphas: null,
                ratios: null
            },
            border:{
                weight: 1,
                alpha: 1
            },
            width: 10,
            height: 10,
            shape: "circle"
        };
        _yuitest_coverline("/build/charts-base/charts-base.js", 6969);
defs.fill.color = this._getDefaultColor(this.get("graphOrder"), "fill");
        _yuitest_coverline("/build/charts-base/charts-base.js", 6970);
defs.border.color = this._getDefaultColor(this.get("graphOrder"), "border");
        _yuitest_coverline("/build/charts-base/charts-base.js", 6971);
return defs;
    },

    /**
     * Collection of markers to be used in the series.
     *
     * @property _markers
     * @type Array
     * @private
     */
    _markers: null,

    /**
     * Collection of markers to be re-used on a series redraw.
     *
     * @property _markerCache
     * @type Array
     * @private
     */
    _markerCache: null,
   
    /**
     * Gets and styles a marker. If there is a marker in cache, it will use it. Otherwise
     * it will create one.
     *
     * @method getMarker
     * @param {Object} styles Hash of style properties.
     * @param {Number} order Order of the series.
     * @param {Number} index Index within the series associated with the marker.
     * @return Shape
     * @protected
     */
    getMarker: function(styles, order, index)
    {
        _yuitest_coverfunc("/build/charts-base/charts-base.js", "getMarker", 7003);
_yuitest_coverline("/build/charts-base/charts-base.js", 7005);
var marker,
            border = styles.border;
        _yuitest_coverline("/build/charts-base/charts-base.js", 7007);
styles.id = this.get("chart").get("id") + "_" + order + "_" + index;
        //fix name differences between graphic layer
        _yuitest_coverline("/build/charts-base/charts-base.js", 7009);
border.opacity = border.alpha;
        _yuitest_coverline("/build/charts-base/charts-base.js", 7010);
styles.stroke = border;
        _yuitest_coverline("/build/charts-base/charts-base.js", 7011);
styles.fill.opacity = styles.fill.alpha;
        _yuitest_coverline("/build/charts-base/charts-base.js", 7012);
if(this._markerCache.length > 0)
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 7014);
while(!marker)
            {
                _yuitest_coverline("/build/charts-base/charts-base.js", 7016);
if(this._markerCache.length < 1)
                {
                    _yuitest_coverline("/build/charts-base/charts-base.js", 7018);
marker = this._createMarker(styles, order, index);
                    _yuitest_coverline("/build/charts-base/charts-base.js", 7019);
break;
                }
                _yuitest_coverline("/build/charts-base/charts-base.js", 7021);
marker = this._markerCache.shift();

            }
            _yuitest_coverline("/build/charts-base/charts-base.js", 7024);
marker.set(styles);
        }
        else
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 7028);
marker = this._createMarker(styles, order, index);
        }
        _yuitest_coverline("/build/charts-base/charts-base.js", 7030);
this._markers.push(marker);
        _yuitest_coverline("/build/charts-base/charts-base.js", 7031);
return marker;
    },
    
    /**
     * Creates a shape to be used as a marker.
     *
     * @method _createMarker
     * @param {Object} styles Hash of style properties.
     * @param {Number} order Order of the series.
     * @param {Number} index Index within the series associated with the marker.
     * @return Shape
     * @private
     */
    _createMarker: function(styles, order, index)
    {
        _yuitest_coverfunc("/build/charts-base/charts-base.js", "_createMarker", 7044);
_yuitest_coverline("/build/charts-base/charts-base.js", 7046);
var graphic = this.get("graphic"),
            marker,
            cfg = Y.clone(styles);
        _yuitest_coverline("/build/charts-base/charts-base.js", 7049);
graphic.set("autoDraw", false);
        _yuitest_coverline("/build/charts-base/charts-base.js", 7050);
cfg.type = cfg.shape;
        _yuitest_coverline("/build/charts-base/charts-base.js", 7051);
marker = graphic.addShape(cfg); 
        _yuitest_coverline("/build/charts-base/charts-base.js", 7052);
marker.addClass(SERIES_MARKER);
        _yuitest_coverline("/build/charts-base/charts-base.js", 7053);
return marker;
    },
    
    /**
     * Creates a cache of markers for reuse.
     *
     * @method _createMarkerCache
     * @private
     */
    _createMarkerCache: function()
    {
        _yuitest_coverfunc("/build/charts-base/charts-base.js", "_createMarkerCache", 7062);
_yuitest_coverline("/build/charts-base/charts-base.js", 7064);
if(this._groupMarker)
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 7066);
this._groupMarker.destroy();
            _yuitest_coverline("/build/charts-base/charts-base.js", 7067);
this._groupMarker = null;
        }
        _yuitest_coverline("/build/charts-base/charts-base.js", 7069);
if(this._markers && this._markers.length > 0)
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 7071);
this._markerCache = this._markers.concat();
        }
        else
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 7075);
this._markerCache = [];
        }
        _yuitest_coverline("/build/charts-base/charts-base.js", 7077);
this._markers = [];
    },
  
    /**
     * Draws a series of markers in a single shape instance.
     *
     * @method _createGroupMarkers
     * @param {Object} styles Set of configuration properties used to create the markers.
     * @protected
     */
    _createGroupMarker: function(styles)
    {
        _yuitest_coverfunc("/build/charts-base/charts-base.js", "_createGroupMarker", 7087);
_yuitest_coverline("/build/charts-base/charts-base.js", 7089);
var marker,
            markers = this.get("markers"),
            border = styles.border,
            graphic,
            cfg,
            shape;
        _yuitest_coverline("/build/charts-base/charts-base.js", 7095);
if(markers && markers.length > 0)
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 7097);
while(markers.length > 0)
            {
                _yuitest_coverline("/build/charts-base/charts-base.js", 7099);
marker = markers.shift();
                _yuitest_coverline("/build/charts-base/charts-base.js", 7100);
marker.destroy();
            }
            _yuitest_coverline("/build/charts-base/charts-base.js", 7102);
this.set("markers", []);
        }
        //fix name differences between graphic layer
        _yuitest_coverline("/build/charts-base/charts-base.js", 7105);
border.opacity = border.alpha;
        _yuitest_coverline("/build/charts-base/charts-base.js", 7106);
cfg = {
            id: this.get("chart").get("id") + "_" + styles.graphOrder,
            stroke: border,
            fill: styles.fill,
            dimensions: styles.dimensions,
            xvalues: styles.xvalues,
            yvalues: styles.yvalues
        };
        _yuitest_coverline("/build/charts-base/charts-base.js", 7114);
cfg.fill.opacity = styles.fill.alpha;
        _yuitest_coverline("/build/charts-base/charts-base.js", 7115);
shape = this._getGroupShape(styles.shape);
        _yuitest_coverline("/build/charts-base/charts-base.js", 7116);
if(shape)
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 7118);
cfg.type = shape;
        }
        _yuitest_coverline("/build/charts-base/charts-base.js", 7120);
if(styles.hasOwnProperty("radius") && !isNaN(styles.radius))
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 7122);
cfg.dimensions.radius = styles.radius;
        }
        _yuitest_coverline("/build/charts-base/charts-base.js", 7124);
if(this._groupMarker)
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 7126);
this._groupMarker.destroy();
        }
        _yuitest_coverline("/build/charts-base/charts-base.js", 7128);
graphic = this.get("graphic");
        _yuitest_coverline("/build/charts-base/charts-base.js", 7129);
graphic.set("autoDraw", true);
        _yuitest_coverline("/build/charts-base/charts-base.js", 7130);
this._groupMarker = graphic.addShape(cfg);
    },

    /**
     * Toggles visibility
     *
     * @method _toggleVisible
     * @param {Boolean} visible indicates visibilitye
     * @private
     */
    _toggleVisible: function(visible)
    {
        _yuitest_coverfunc("/build/charts-base/charts-base.js", "_toggleVisible", 7140);
_yuitest_coverline("/build/charts-base/charts-base.js", 7142);
var marker,
            markers = this.get("markers"),
            i = 0,
            len;
        _yuitest_coverline("/build/charts-base/charts-base.js", 7146);
if(markers)
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 7148);
len = markers.length;
            _yuitest_coverline("/build/charts-base/charts-base.js", 7149);
for(; i < len; ++i)
            {
                _yuitest_coverline("/build/charts-base/charts-base.js", 7151);
marker = markers[i];
                _yuitest_coverline("/build/charts-base/charts-base.js", 7152);
if(marker)
                {
                    _yuitest_coverline("/build/charts-base/charts-base.js", 7154);
marker.set("visible", visible);
                }
            }
        }
    },

    /**
     * Removes unused markers from the marker cache
     *
     * @method _clearMarkerCache
     * @private
     */
    _clearMarkerCache: function()
    {
        _yuitest_coverfunc("/build/charts-base/charts-base.js", "_clearMarkerCache", 7166);
_yuitest_coverline("/build/charts-base/charts-base.js", 7168);
var marker;
        _yuitest_coverline("/build/charts-base/charts-base.js", 7169);
while(this._markerCache.length > 0)
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 7171);
marker = this._markerCache.shift();
            _yuitest_coverline("/build/charts-base/charts-base.js", 7172);
if(marker)
            {
                _yuitest_coverline("/build/charts-base/charts-base.js", 7174);
marker.destroy();
            }
        }
    },

    /**
     * Resizes and positions markers based on a mouse interaction.
     *
     * @method updateMarkerState
     * @param {String} type state of the marker
     * @param {Number} i index of the marker
     * @protected
     */
    updateMarkerState: function(type, i)
    {
        _yuitest_coverfunc("/build/charts-base/charts-base.js", "updateMarkerState", 7187);
_yuitest_coverline("/build/charts-base/charts-base.js", 7189);
if(this._markers && this._markers[i])
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 7191);
var w,
                h,
                styles = Y.clone(this.get("styles").marker),
                state = this._getState(type),
                xcoords = this.get("xcoords"),
                ycoords = this.get("ycoords"),
                marker = this._markers[i],
                markerStyles = state == "off" || !styles[state] ? styles : styles[state]; 
                _yuitest_coverline("/build/charts-base/charts-base.js", 7199);
markerStyles.fill.color = this._getItemColor(markerStyles.fill.color, i);
                _yuitest_coverline("/build/charts-base/charts-base.js", 7200);
markerStyles.border.color = this._getItemColor(markerStyles.border.color, i);
                _yuitest_coverline("/build/charts-base/charts-base.js", 7201);
markerStyles.stroke = markerStyles.border;
                _yuitest_coverline("/build/charts-base/charts-base.js", 7202);
marker.set(markerStyles);
                _yuitest_coverline("/build/charts-base/charts-base.js", 7203);
w = markerStyles.width;
                _yuitest_coverline("/build/charts-base/charts-base.js", 7204);
h = markerStyles.height;
                _yuitest_coverline("/build/charts-base/charts-base.js", 7205);
marker.set("x", (xcoords[i] - w/2));
                _yuitest_coverline("/build/charts-base/charts-base.js", 7206);
marker.set("y",  (ycoords[i] - h/2));
                _yuitest_coverline("/build/charts-base/charts-base.js", 7207);
marker.set("visible", this.get("visible"));
        }
    },

    /**
     * Parses a color from an array.
     *
     * @method _getItemColor
     * @param {Array} val collection of colors
     * @param {Number} i index of the item
     * @return String
     * @protected
     */
    _getItemColor: function(val, i)
    {
        _yuitest_coverfunc("/build/charts-base/charts-base.js", "_getItemColor", 7220);
_yuitest_coverline("/build/charts-base/charts-base.js", 7222);
if(Y_Lang.isArray(val))
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 7224);
return val[i % val.length];
        }
        _yuitest_coverline("/build/charts-base/charts-base.js", 7226);
return val;
    },

    /**
     * Method used by `styles` setter. Overrides base implementation.
     *
     * @method _setStyles
     * @param {Object} newStyles Hash of properties to update.
     * @return Object
     * @protected
     */
    _setStyles: function(val)
    {
        _yuitest_coverfunc("/build/charts-base/charts-base.js", "_setStyles", 7237);
_yuitest_coverline("/build/charts-base/charts-base.js", 7239);
val = this._parseMarkerStyles(val);
        _yuitest_coverline("/build/charts-base/charts-base.js", 7240);
return Y.Renderer.prototype._setStyles.apply(this, [val]);
    },

    /**
     * Combines new styles with existing styles.
     *
     * @method _parseMarkerStyles
     * @param {Object} Object containing style properties for the marker.
     * @return Object
     * @private
     */
    _parseMarkerStyles: function(val)
    {
        _yuitest_coverfunc("/build/charts-base/charts-base.js", "_parseMarkerStyles", 7251);
_yuitest_coverline("/build/charts-base/charts-base.js", 7253);
if(val.marker)
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 7255);
var defs = this._getPlotDefaults();
            _yuitest_coverline("/build/charts-base/charts-base.js", 7256);
val.marker = this._mergeStyles(val.marker, defs);
            _yuitest_coverline("/build/charts-base/charts-base.js", 7257);
if(val.marker.over)
            {
                _yuitest_coverline("/build/charts-base/charts-base.js", 7259);
val.marker.over = this._mergeStyles(val.marker.over, val.marker);
            }
            _yuitest_coverline("/build/charts-base/charts-base.js", 7261);
if(val.marker.down)
            {
                _yuitest_coverline("/build/charts-base/charts-base.js", 7263);
val.marker.down = this._mergeStyles(val.marker.down, val.marker);
            }
        }
        _yuitest_coverline("/build/charts-base/charts-base.js", 7266);
return val;
    },

    /**
     * Returns marker state based on event type
     *
     * @method _getState
     * @param {String} type event type
     * @return String
     * @protected
     */
    _getState: function(type)
    {
        _yuitest_coverfunc("/build/charts-base/charts-base.js", "_getState", 7277);
_yuitest_coverline("/build/charts-base/charts-base.js", 7279);
var state;
        _yuitest_coverline("/build/charts-base/charts-base.js", 7280);
switch(type)
        {
            case "mouseout" :
                _yuitest_coverline("/build/charts-base/charts-base.js", 7283);
state = "off";
            _yuitest_coverline("/build/charts-base/charts-base.js", 7284);
break;
            case "mouseover" :
                _yuitest_coverline("/build/charts-base/charts-base.js", 7286);
state = "over";
            _yuitest_coverline("/build/charts-base/charts-base.js", 7287);
break;
            case "mouseup" :
                _yuitest_coverline("/build/charts-base/charts-base.js", 7289);
state = "over";
            _yuitest_coverline("/build/charts-base/charts-base.js", 7290);
break;
            case "mousedown" :
                _yuitest_coverline("/build/charts-base/charts-base.js", 7292);
state = "down";
            _yuitest_coverline("/build/charts-base/charts-base.js", 7293);
break;
        }
        _yuitest_coverline("/build/charts-base/charts-base.js", 7295);
return state;
    },
    
    /**
     * @property _statSyles
     * @type Object
     * @private
     */
    _stateSyles: null
};

_yuitest_coverline("/build/charts-base/charts-base.js", 7306);
Y.augment(Plots, Y.Attribute);
_yuitest_coverline("/build/charts-base/charts-base.js", 7307);
Y.Plots = Plots;
/**
 * Histogram is the base class for Column and Bar series.
 *
 * @module charts
 * @submodule charts-base
 * @class Histogram
 * @constructor
 */
_yuitest_coverline("/build/charts-base/charts-base.js", 7316);
function Histogram(){}

_yuitest_coverline("/build/charts-base/charts-base.js", 7318);
Histogram.prototype = {
    /**
     * Draws the series.
     *
     * @method drawSeries
     * @protected
     */
    drawSeries: function()
    {
        _yuitest_coverfunc("/build/charts-base/charts-base.js", "drawSeries", 7325);
_yuitest_coverline("/build/charts-base/charts-base.js", 7327);
if(this.get("xcoords").length < 1) 
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 7329);
return;
        }
        _yuitest_coverline("/build/charts-base/charts-base.js", 7331);
var style = Y.clone(this.get("styles").marker),
            setSize,
            calculatedSize,
            xcoords = this.get("xcoords"),
            ycoords = this.get("ycoords"),
            i = 0,
            len = xcoords.length,
            top = ycoords[0],
            type = this.get("type"),
            graph = this.get("graph"),
            seriesCollection = graph.seriesTypes[type],
            seriesLen = seriesCollection.length,
            seriesSize = 0,
            totalSize = 0,
            offset = 0,
            ratio,
            renderer,
            order = this.get("order"),
            graphOrder = this.get("graphOrder"),
            left,
            marker,
            setSizeKey,
            calculatedSizeKey,
            config,
            fillColors = null,
            borderColors = null,
            xMarkerPlane = [],
            yMarkerPlane = [],
            xMarkerPlaneLeft,
            xMarkerPlaneRight,
            yMarkerPlaneTop,
            yMarkerPlaneBottom,
            dimensions = {
                width: [],
                height: []
            },
            xvalues = [],
            yvalues = [],
            groupMarkers = this.get("groupMarkers");
        _yuitest_coverline("/build/charts-base/charts-base.js", 7370);
if(Y_Lang.isArray(style.fill.color))
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 7372);
fillColors = style.fill.color.concat(); 
        }
        _yuitest_coverline("/build/charts-base/charts-base.js", 7374);
if(Y_Lang.isArray(style.border.color))
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 7376);
borderColors = style.border.color.concat();
        }
        _yuitest_coverline("/build/charts-base/charts-base.js", 7378);
if(this.get("direction") == "vertical")
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 7380);
setSizeKey = "height";
            _yuitest_coverline("/build/charts-base/charts-base.js", 7381);
calculatedSizeKey = "width";
        }
        else
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 7385);
setSizeKey = "width";
            _yuitest_coverline("/build/charts-base/charts-base.js", 7386);
calculatedSizeKey = "height";
        }
        _yuitest_coverline("/build/charts-base/charts-base.js", 7388);
setSize = style[setSizeKey];
        _yuitest_coverline("/build/charts-base/charts-base.js", 7389);
calculatedSize = style[calculatedSizeKey];
        _yuitest_coverline("/build/charts-base/charts-base.js", 7390);
this._createMarkerCache();
        _yuitest_coverline("/build/charts-base/charts-base.js", 7391);
for(; i < seriesLen; ++i)
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 7393);
renderer = seriesCollection[i];
            _yuitest_coverline("/build/charts-base/charts-base.js", 7394);
seriesSize += renderer.get("styles").marker[setSizeKey];
            _yuitest_coverline("/build/charts-base/charts-base.js", 7395);
if(order > i) 
            {
                _yuitest_coverline("/build/charts-base/charts-base.js", 7397);
offset = seriesSize;
            }
        }
        _yuitest_coverline("/build/charts-base/charts-base.js", 7400);
totalSize = len * seriesSize;
        _yuitest_coverline("/build/charts-base/charts-base.js", 7401);
this._maxSize = graph.get(setSizeKey);
        _yuitest_coverline("/build/charts-base/charts-base.js", 7402);
if(totalSize > this._maxSize)
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 7404);
ratio = graph.get(setSizeKey)/totalSize;
            _yuitest_coverline("/build/charts-base/charts-base.js", 7405);
seriesSize *= ratio;
            _yuitest_coverline("/build/charts-base/charts-base.js", 7406);
offset *= ratio;
            _yuitest_coverline("/build/charts-base/charts-base.js", 7407);
setSize *= ratio;
            _yuitest_coverline("/build/charts-base/charts-base.js", 7408);
setSize = Math.max(setSize, 1);
            _yuitest_coverline("/build/charts-base/charts-base.js", 7409);
this._maxSize = setSize;
        }
        _yuitest_coverline("/build/charts-base/charts-base.js", 7411);
offset -= seriesSize/2;
        _yuitest_coverline("/build/charts-base/charts-base.js", 7412);
for(i = 0; i < len; ++i)
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 7414);
xMarkerPlaneLeft = xcoords[i] - seriesSize/2;
            _yuitest_coverline("/build/charts-base/charts-base.js", 7415);
xMarkerPlaneRight = xMarkerPlaneLeft + seriesSize;
            _yuitest_coverline("/build/charts-base/charts-base.js", 7416);
yMarkerPlaneTop = ycoords[i] - seriesSize/2;
            _yuitest_coverline("/build/charts-base/charts-base.js", 7417);
yMarkerPlaneBottom = yMarkerPlaneTop + seriesSize;
            _yuitest_coverline("/build/charts-base/charts-base.js", 7418);
xMarkerPlane.push({start: xMarkerPlaneLeft, end: xMarkerPlaneRight});
            _yuitest_coverline("/build/charts-base/charts-base.js", 7419);
yMarkerPlane.push({start: yMarkerPlaneTop, end: yMarkerPlaneBottom});
            _yuitest_coverline("/build/charts-base/charts-base.js", 7420);
if(isNaN(xcoords[i]) || isNaN(ycoords[i]))
            {
                _yuitest_coverline("/build/charts-base/charts-base.js", 7422);
this._markers.push(null);
                _yuitest_coverline("/build/charts-base/charts-base.js", 7423);
continue;
            }
            _yuitest_coverline("/build/charts-base/charts-base.js", 7425);
config = this._getMarkerDimensions(xcoords[i], ycoords[i], calculatedSize, offset);
            _yuitest_coverline("/build/charts-base/charts-base.js", 7426);
if(!isNaN(config.calculatedSize) && config.calculatedSize > 0)
            {
                _yuitest_coverline("/build/charts-base/charts-base.js", 7428);
top = config.top;
                _yuitest_coverline("/build/charts-base/charts-base.js", 7429);
left = config.left;

                _yuitest_coverline("/build/charts-base/charts-base.js", 7431);
if(groupMarkers)
                {
                    _yuitest_coverline("/build/charts-base/charts-base.js", 7433);
dimensions[setSizeKey][i] = setSize;
                    _yuitest_coverline("/build/charts-base/charts-base.js", 7434);
dimensions[calculatedSizeKey][i] = config.calculatedSize;
                    _yuitest_coverline("/build/charts-base/charts-base.js", 7435);
xvalues.push(left);
                    _yuitest_coverline("/build/charts-base/charts-base.js", 7436);
yvalues.push(top);
                }
                else
                {
                    _yuitest_coverline("/build/charts-base/charts-base.js", 7440);
style[setSizeKey] = setSize;
                    _yuitest_coverline("/build/charts-base/charts-base.js", 7441);
style[calculatedSizeKey] = config.calculatedSize;
                    _yuitest_coverline("/build/charts-base/charts-base.js", 7442);
style.x = left;
                    _yuitest_coverline("/build/charts-base/charts-base.js", 7443);
style.y = top;
                    _yuitest_coverline("/build/charts-base/charts-base.js", 7444);
if(fillColors)
                    {
                        _yuitest_coverline("/build/charts-base/charts-base.js", 7446);
style.fill.color = fillColors[i % fillColors.length];
                    }
                    _yuitest_coverline("/build/charts-base/charts-base.js", 7448);
if(borderColors)
                    {
                        _yuitest_coverline("/build/charts-base/charts-base.js", 7450);
style.border.color = borderColors[i % borderColors.length];
                    }
                    _yuitest_coverline("/build/charts-base/charts-base.js", 7452);
marker = this.getMarker(style, graphOrder, i);
                }

            }
            else {_yuitest_coverline("/build/charts-base/charts-base.js", 7456);
if(!groupMarkers)
            {
                _yuitest_coverline("/build/charts-base/charts-base.js", 7458);
this._markers.push(null);
            }}
        }
        _yuitest_coverline("/build/charts-base/charts-base.js", 7461);
this.set("xMarkerPlane", xMarkerPlane);
        _yuitest_coverline("/build/charts-base/charts-base.js", 7462);
this.set("yMarkerPlane", yMarkerPlane);
        _yuitest_coverline("/build/charts-base/charts-base.js", 7463);
if(groupMarkers)
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 7465);
this._createGroupMarker({
                fill: style.fill,
                border: style.border,
                dimensions: dimensions,
                xvalues: xvalues,
                yvalues: yvalues,
                shape: style.shape
            });
        }
        else
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 7476);
this._clearMarkerCache();
        }
    },
    
    /**
     * Collection of default colors used for marker fills in a series when not specified by user.
     *
     * @property _defaultFillColors
     * @type Array
     * @protected
     */
    _defaultFillColors: ["#66007f", "#a86f41", "#295454", "#996ab2", "#e8cdb7", "#90bdbd","#000000","#c3b8ca", "#968373", "#678585"],
    
    /**
     * Gets the default style values for the markers.
     *
     * @method _getPlotDefaults
     * @return Object
     * @private
     */
    _getPlotDefaults: function()
    {
        _yuitest_coverfunc("/build/charts-base/charts-base.js", "_getPlotDefaults", 7496);
_yuitest_coverline("/build/charts-base/charts-base.js", 7498);
var defs = {
            fill:{
                type: "solid",
                alpha: 1,
                colors:null,
                alphas: null,
                ratios: null
            },
            border:{
                weight: 0,
                alpha: 1
            },
            width: 12,
            height: 12,
            shape: "rect",

            padding:{
                top: 0,
                left: 0,
                right: 0,
                bottom: 0
            }
        };
        _yuitest_coverline("/build/charts-base/charts-base.js", 7521);
defs.fill.color = this._getDefaultColor(this.get("graphOrder"), "fill");
        _yuitest_coverline("/build/charts-base/charts-base.js", 7522);
defs.border.color = this._getDefaultColor(this.get("graphOrder"), "border");
        _yuitest_coverline("/build/charts-base/charts-base.js", 7523);
return defs;
    }
};

_yuitest_coverline("/build/charts-base/charts-base.js", 7527);
Y.Histogram = Histogram;
/**
 * The CartesianSeries class creates a chart with horizontal and vertical axes.
 *
 * @module charts
 * @submodule charts-base
 * @class CartesianSeries
 * @extends Base
 * @uses Renderer
 * @constructor
 */
_yuitest_coverline("/build/charts-base/charts-base.js", 7538);
Y.CartesianSeries = Y.Base.create("cartesianSeries", Y.Base, [Y.Renderer], {
    /**
     * Storage for `xDisplayName` attribute.
     *
     * @property _xDisplayName
     * @type String
     * @private
     */
    _xDisplayName: null,

    /**
     * Storage for `yDisplayName` attribute.
     *
     * @property _yDisplayName
     * @type String
     * @private
     */
    _yDisplayName: null,
    
    /**
     * Th x-coordinate for the left edge of the series.
     *
     * @property _leftOrigin
     * @type String
     * @private
     */
    _leftOrigin: null,

    /**
     * The y-coordinate for the bottom edge of the series.
     * 
     * @property _bottomOrigin
     * @type String
     * @private
     */
    _bottomOrigin: null,

    /**
     * @method render
     * @private
     */
    render: function()
    {
        _yuitest_coverfunc("/build/charts-base/charts-base.js", "render", 7579);
_yuitest_coverline("/build/charts-base/charts-base.js", 7581);
this._setCanvas();
        _yuitest_coverline("/build/charts-base/charts-base.js", 7582);
this.addListeners();
        _yuitest_coverline("/build/charts-base/charts-base.js", 7583);
this.set("rendered", true);
        _yuitest_coverline("/build/charts-base/charts-base.js", 7584);
this.validate();
    },

    /**
     * Adds event listeners.
     *
     * @method addListeners
     * @private
     */
    addListeners: function()
    {
        _yuitest_coverfunc("/build/charts-base/charts-base.js", "addListeners", 7593);
_yuitest_coverline("/build/charts-base/charts-base.js", 7595);
var xAxis = this.get("xAxis"),
            yAxis = this.get("yAxis");
        _yuitest_coverline("/build/charts-base/charts-base.js", 7597);
if(xAxis)
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 7599);
this._xDataReadyHandle = xAxis.after("dataReady", Y.bind(this._xDataChangeHandler, this));
            _yuitest_coverline("/build/charts-base/charts-base.js", 7600);
this._xDataUpdateHandle = xAxis.after("dataUpdate", Y.bind(this._xDataChangeHandler, this));
        }
        _yuitest_coverline("/build/charts-base/charts-base.js", 7602);
if(yAxis)
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 7604);
this._yDataReadyHandle = yAxis.after("dataReady", Y.bind(this._yDataChangeHandler, this));
            _yuitest_coverline("/build/charts-base/charts-base.js", 7605);
this._yDataUpdateHandle = yAxis.after("dataUpdate", Y.bind(this._yDataChangeHandler, this));
        }
        _yuitest_coverline("/build/charts-base/charts-base.js", 7607);
this._xAxisChangeHandle = this.after("xAxisChange", this._xAxisChangeHandler);
        _yuitest_coverline("/build/charts-base/charts-base.js", 7608);
this._yAxisChangeHandle = this.after("yAxisChange", this._yAxisChangeHandler);
        _yuitest_coverline("/build/charts-base/charts-base.js", 7609);
this._stylesChangeHandle = this.after("stylesChange", function(e) {
            _yuitest_coverfunc("/build/charts-base/charts-base.js", "(anonymous 3)", 7609);
_yuitest_coverline("/build/charts-base/charts-base.js", 7610);
var axesReady = this._updateAxisData();
            _yuitest_coverline("/build/charts-base/charts-base.js", 7611);
if(axesReady)
            {
                _yuitest_coverline("/build/charts-base/charts-base.js", 7613);
this.draw();
            }
        });
        _yuitest_coverline("/build/charts-base/charts-base.js", 7616);
this._widthChangeHandle = this.after("widthChange", function(e) {
            _yuitest_coverfunc("/build/charts-base/charts-base.js", "(anonymous 4)", 7616);
_yuitest_coverline("/build/charts-base/charts-base.js", 7617);
var axesReady = this._updateAxisData();
            _yuitest_coverline("/build/charts-base/charts-base.js", 7618);
if(axesReady)
            {
                _yuitest_coverline("/build/charts-base/charts-base.js", 7620);
this.draw();
            }
        });
        _yuitest_coverline("/build/charts-base/charts-base.js", 7623);
this._heightChangeHandle = this.after("heightChange", function(e) {
            _yuitest_coverfunc("/build/charts-base/charts-base.js", "(anonymous 5)", 7623);
_yuitest_coverline("/build/charts-base/charts-base.js", 7624);
var axesReady = this._updateAxisData();
            _yuitest_coverline("/build/charts-base/charts-base.js", 7625);
if(axesReady)
            {
                _yuitest_coverline("/build/charts-base/charts-base.js", 7627);
this.draw();
            }
        });
        _yuitest_coverline("/build/charts-base/charts-base.js", 7630);
this._visibleChangeHandle = this.after("visibleChange", this._handleVisibleChange);
    },
  
    /**
     * Event handler for the xAxisChange event.
     *
     * @method _xAxisChangeHandler
     * @param {Object} e Event object.
     * @private
     */
    _xAxisChangeHandler: function(e)
    {
        _yuitest_coverfunc("/build/charts-base/charts-base.js", "_xAxisChangeHandler", 7640);
_yuitest_coverline("/build/charts-base/charts-base.js", 7642);
var xAxis = this.get("xAxis");
        _yuitest_coverline("/build/charts-base/charts-base.js", 7643);
xAxis.after("dataReady", Y.bind(this._xDataChangeHandler, this));
        _yuitest_coverline("/build/charts-base/charts-base.js", 7644);
xAxis.after("dataUpdate", Y.bind(this._xDataChangeHandler, this));
    },
    
    /**
     * Event handler the yAxisChange event.
     *
     * @method _yAxisChangeHandler
     * @param {Object} e Event object.
     * @private
     */
    _yAxisChangeHandler: function(e)
    {
        _yuitest_coverfunc("/build/charts-base/charts-base.js", "_yAxisChangeHandler", 7654);
_yuitest_coverline("/build/charts-base/charts-base.js", 7656);
var yAxis = this.get("yAxis");
        _yuitest_coverline("/build/charts-base/charts-base.js", 7657);
yAxis.after("dataReady", Y.bind(this._yDataChangeHandler, this));
        _yuitest_coverline("/build/charts-base/charts-base.js", 7658);
yAxis.after("dataUpdate", Y.bind(this._yDataChangeHandler, this));
    },

    /**
     * Constant used to generate unique id.
     *
     * @property GUID
     * @type String
     * @private
     */
    GUID: "yuicartesianseries",

    /**
     * Event handler for xDataChange event.
     *
     * @method _xDataChangeHandler
     * @param {Object} event Event object.
     * @private 
     */
    _xDataChangeHandler: function(event)
    {
        _yuitest_coverfunc("/build/charts-base/charts-base.js", "_xDataChangeHandler", 7677);
_yuitest_coverline("/build/charts-base/charts-base.js", 7679);
var axesReady = this._updateAxisData();
        _yuitest_coverline("/build/charts-base/charts-base.js", 7680);
if(axesReady)
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 7682);
this.draw();
        }
    },

    /**
     * Event handler for yDataChange event.
     *
     * @method _yDataChangeHandler
     * @param {Object} event Event object.
     * @private 
     */
    _yDataChangeHandler: function(event)
    {
        _yuitest_coverfunc("/build/charts-base/charts-base.js", "_yDataChangeHandler", 7693);
_yuitest_coverline("/build/charts-base/charts-base.js", 7695);
var axesReady = this._updateAxisData();
        _yuitest_coverline("/build/charts-base/charts-base.js", 7696);
if(axesReady)
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 7698);
this.draw();
        }
    },

    /**
     * Checks to ensure that both xAxis and yAxis data are available. If so, set the `xData` and `yData` attributes and return `true`. Otherwise, return `false`.
     *
     * @method _updateAxisData
     * @return Boolean
     * @private 
     */
    _updateAxisData: function()
    {
        _yuitest_coverfunc("/build/charts-base/charts-base.js", "_updateAxisData", 7709);
_yuitest_coverline("/build/charts-base/charts-base.js", 7711);
var xAxis = this.get("xAxis"),
            yAxis = this.get("yAxis"),
            xKey = this.get("xKey"),
            yKey = this.get("yKey"),
            yData,
            xData;
        _yuitest_coverline("/build/charts-base/charts-base.js", 7717);
if(!xAxis || !yAxis || !xKey || !yKey)
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 7719);
return false;
        }
        _yuitest_coverline("/build/charts-base/charts-base.js", 7721);
xData = xAxis.getDataByKey(xKey);
        _yuitest_coverline("/build/charts-base/charts-base.js", 7722);
yData = yAxis.getDataByKey(yKey);
        _yuitest_coverline("/build/charts-base/charts-base.js", 7723);
if(!xData || !yData)
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 7725);
return false;
        }
        _yuitest_coverline("/build/charts-base/charts-base.js", 7727);
this.set("xData", xData.concat());
        _yuitest_coverline("/build/charts-base/charts-base.js", 7728);
this.set("yData", yData.concat());
        _yuitest_coverline("/build/charts-base/charts-base.js", 7729);
return true;
    },

    /**
     * Draws the series is the xAxis and yAxis data are both available.
     *
     * @method validate
     * @private
     */
    validate: function()
    {
        _yuitest_coverfunc("/build/charts-base/charts-base.js", "validate", 7738);
_yuitest_coverline("/build/charts-base/charts-base.js", 7740);
if((this.get("xData") && this.get("yData")) || this._updateAxisData())
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 7742);
this.draw();
        }
        else
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 7746);
this.fire("drawingComplete");
        }
    },

    /**
     * Creates a `Graphic` instance.
     *
     * @method _setCanvas
     * @protected
     */
    _setCanvas: function()
    {
        _yuitest_coverfunc("/build/charts-base/charts-base.js", "_setCanvas", 7756);
_yuitest_coverline("/build/charts-base/charts-base.js", 7758);
var graph = this.get("graph"),
            graphic = graph.get("graphic");
        _yuitest_coverline("/build/charts-base/charts-base.js", 7760);
this.set("graphic", graphic);
    },

    /**
     * Calculates the coordinates for the series.
     *
     * @method setAreaData
     * @protected
     */
    setAreaData: function()
    {
        _yuitest_coverfunc("/build/charts-base/charts-base.js", "setAreaData", 7769);
_yuitest_coverline("/build/charts-base/charts-base.js", 7771);
var isNumber = Y_Lang.isNumber,
            nextX, nextY,
            graph = this.get("graph"),
            w = graph.get("width"),
            h = graph.get("height"),
            xAxis = this.get("xAxis"),
            yAxis = this.get("yAxis"),
            xData = this.get("xData").concat(),
            yData = this.get("yData").concat(),
            xValue,
            yValue,
            xOffset = xAxis.getEdgeOffset(xData.length, w),
            yOffset = yAxis.getEdgeOffset(yData.length, h),
            padding = this.get("styles").padding,
			leftPadding = padding.left,
			topPadding = padding.top,
			dataWidth = w - (leftPadding + padding.right + xOffset),
			dataHeight = h - (topPadding + padding.bottom + yOffset),
			xcoords = [],
			ycoords = [],
			xMax = xAxis.get("maximum"),
			xMin = xAxis.get("minimum"),
			yMax = yAxis.get("maximum"),
			yMin = yAxis.get("minimum"),
            xScaleFactor = dataWidth / (xMax - xMin),
			yScaleFactor = dataHeight / (yMax - yMin),
            dataLength,
            direction = this.get("direction"),
            i = 0,
            xMarkerPlane = [],
            yMarkerPlane = [],
            xMarkerPlaneOffset = this.get("xMarkerPlaneOffset"),
            yMarkerPlaneOffset = this.get("yMarkerPlaneOffset"),
            graphic = this.get("graphic");
        _yuitest_coverline("/build/charts-base/charts-base.js", 7805);
graphic.set("width", w);
        _yuitest_coverline("/build/charts-base/charts-base.js", 7806);
graphic.set("height", h);
        _yuitest_coverline("/build/charts-base/charts-base.js", 7807);
dataLength = xData.length;
        _yuitest_coverline("/build/charts-base/charts-base.js", 7808);
xOffset *= 0.5;
        _yuitest_coverline("/build/charts-base/charts-base.js", 7809);
yOffset *= 0.5;
        //Assuming a vertical graph has a range/category for its vertical axis.    
        _yuitest_coverline("/build/charts-base/charts-base.js", 7811);
if(direction === "vertical")
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 7813);
yData = yData.reverse();
        }
        _yuitest_coverline("/build/charts-base/charts-base.js", 7815);
this._leftOrigin = Math.round(((0 - xMin) * xScaleFactor) + leftPadding + xOffset);
        _yuitest_coverline("/build/charts-base/charts-base.js", 7816);
this._bottomOrigin = Math.round((dataHeight + topPadding + yOffset)); 
        _yuitest_coverline("/build/charts-base/charts-base.js", 7817);
if(yMin < 0)
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 7819);
this._bottomOrigin = this._bottomOrigin - ((0 - yMin) * yScaleFactor);
        }
        _yuitest_coverline("/build/charts-base/charts-base.js", 7821);
for (; i < dataLength; ++i) 
		{
            _yuitest_coverline("/build/charts-base/charts-base.js", 7823);
xValue = parseFloat(xData[i]);
            _yuitest_coverline("/build/charts-base/charts-base.js", 7824);
yValue = parseFloat(yData[i]);
            _yuitest_coverline("/build/charts-base/charts-base.js", 7825);
if(isNumber(xValue))
            {
                _yuitest_coverline("/build/charts-base/charts-base.js", 7827);
nextX = (((xValue - xMin) * xScaleFactor) + leftPadding + xOffset);
            }
            else
            {
                _yuitest_coverline("/build/charts-base/charts-base.js", 7831);
nextX = NaN;
            }
            _yuitest_coverline("/build/charts-base/charts-base.js", 7833);
if(isNumber(yValue))
            {
			    _yuitest_coverline("/build/charts-base/charts-base.js", 7835);
nextY = ((dataHeight + topPadding + yOffset) - (yValue - yMin) * yScaleFactor);
            }
            else
            {
                _yuitest_coverline("/build/charts-base/charts-base.js", 7839);
nextY = NaN;
            }
            _yuitest_coverline("/build/charts-base/charts-base.js", 7841);
xcoords.push(nextX);
            _yuitest_coverline("/build/charts-base/charts-base.js", 7842);
ycoords.push(nextY);
            _yuitest_coverline("/build/charts-base/charts-base.js", 7843);
xMarkerPlane.push({start:nextX - xMarkerPlaneOffset, end: nextX + xMarkerPlaneOffset});
            _yuitest_coverline("/build/charts-base/charts-base.js", 7844);
yMarkerPlane.push({start:nextY - yMarkerPlaneOffset, end: nextY + yMarkerPlaneOffset});
        }
        _yuitest_coverline("/build/charts-base/charts-base.js", 7846);
this.set("xcoords", xcoords);
		_yuitest_coverline("/build/charts-base/charts-base.js", 7847);
this.set("ycoords", ycoords);
        _yuitest_coverline("/build/charts-base/charts-base.js", 7848);
this.set("xMarkerPlane", xMarkerPlane);
        _yuitest_coverline("/build/charts-base/charts-base.js", 7849);
this.set("yMarkerPlane", yMarkerPlane);
        _yuitest_coverline("/build/charts-base/charts-base.js", 7850);
this._dataLength = dataLength;
    },

    /**
     * Finds the first valid index of an array coordinates.
     *
     * @method _getFirstValidIndex
     * @param {Array} coords An array of x or y coordinates.
     * @return Number
     * @private
     */
    _getFirstValidIndex: function(coords)
    {
        _yuitest_coverfunc("/build/charts-base/charts-base.js", "_getFirstValidIndex", 7861);
_yuitest_coverline("/build/charts-base/charts-base.js", 7863);
var coord,
            i = -1,
            limit = coords.length;
        _yuitest_coverline("/build/charts-base/charts-base.js", 7866);
while(!Y_Lang.isNumber(coord) && i < limit)
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 7868);
i += 1;
            _yuitest_coverline("/build/charts-base/charts-base.js", 7869);
coord = coords[i];
        }
        _yuitest_coverline("/build/charts-base/charts-base.js", 7871);
return i;
    },

    /**
     * Finds the last valid index of an array coordinates.
     *
     * @method _getLastValidIndex
     * @param {Array} coords An array of x or y coordinates.
     * @return Number
     * @private
     */
    _getLastValidIndex: function(coords)
    {
        _yuitest_coverfunc("/build/charts-base/charts-base.js", "_getLastValidIndex", 7882);
_yuitest_coverline("/build/charts-base/charts-base.js", 7884);
var coord,
            i = coords.length,
            limit = -1;
        _yuitest_coverline("/build/charts-base/charts-base.js", 7887);
while(!Y_Lang.isNumber(coord) && i > limit)
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 7889);
i -= 1;
            _yuitest_coverline("/build/charts-base/charts-base.js", 7890);
coord = coords[i];
        }
        _yuitest_coverline("/build/charts-base/charts-base.js", 7892);
return i;
    },

    /**
     * Draws the series.
     *
     * @method draw
     * @protected
     */
    draw: function()
    {
        _yuitest_coverfunc("/build/charts-base/charts-base.js", "draw", 7901);
_yuitest_coverline("/build/charts-base/charts-base.js", 7903);
var graph = this.get("graph"),
            w = graph.get("width"),
            h = graph.get("height");
        _yuitest_coverline("/build/charts-base/charts-base.js", 7906);
if(this.get("rendered"))
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 7908);
if((isFinite(w) && isFinite(h) && w > 0 && h > 0) && ((this.get("xData") && this.get("yData")) || this._updateAxisData()))
            {
                _yuitest_coverline("/build/charts-base/charts-base.js", 7910);
if(this._drawing)
                {
                    _yuitest_coverline("/build/charts-base/charts-base.js", 7912);
this._callLater = true;
                    _yuitest_coverline("/build/charts-base/charts-base.js", 7913);
return;
                }
                _yuitest_coverline("/build/charts-base/charts-base.js", 7915);
this._drawing = true;
                _yuitest_coverline("/build/charts-base/charts-base.js", 7916);
this._callLater = false;
                _yuitest_coverline("/build/charts-base/charts-base.js", 7917);
this.setAreaData();
                _yuitest_coverline("/build/charts-base/charts-base.js", 7918);
if(this.get("xcoords") && this.get("ycoords"))
                {
                    _yuitest_coverline("/build/charts-base/charts-base.js", 7920);
this.drawSeries();
                }
                _yuitest_coverline("/build/charts-base/charts-base.js", 7922);
this._drawing = false;
                _yuitest_coverline("/build/charts-base/charts-base.js", 7923);
if(this._callLater)
                {
                    _yuitest_coverline("/build/charts-base/charts-base.js", 7925);
this.draw();
                }
                else
                {
                    _yuitest_coverline("/build/charts-base/charts-base.js", 7929);
this._toggleVisible(this.get("visible"));
                    _yuitest_coverline("/build/charts-base/charts-base.js", 7930);
this.fire("drawingComplete");
                }
            }
        }
    },
    
    /**
     * Default value for plane offsets when the parent chart's `interactiveType` is `planar`. 
     *
     * @property _defaultPlaneOffset
     * @type Number
     * @private
     */
    _defaultPlaneOffset: 4,
    
    /**
     * Gets the default value for the `styles` attribute. Overrides
     * base implementation.
     *
     * @method _getDefaultStyles
     * @return Object
     * @protected
     */
    _getDefaultStyles: function()
    {
        _yuitest_coverfunc("/build/charts-base/charts-base.js", "_getDefaultStyles", 7953);
_yuitest_coverline("/build/charts-base/charts-base.js", 7955);
return {padding:{
                top: 0,
                left: 0,
                right: 0,
                bottom: 0
            }};
    },

    /**
     * Collection of default colors used for lines in a series when not specified by user.
     *
     * @property _defaultLineColors
     * @type Array
     * @protected
     */
    _defaultLineColors:["#426ab3", "#d09b2c", "#000000", "#b82837", "#b384b5", "#ff7200", "#779de3", "#cbc8ba", "#7ed7a6", "#007a6c"],

    /**
     * Collection of default colors used for marker fills in a series when not specified by user.
     *
     * @property _defaultFillColors
     * @type Array
     * @protected
     */
    _defaultFillColors:["#6084d0", "#eeb647", "#6c6b5f", "#d6484f", "#ce9ed1", "#ff9f3b", "#93b7ff", "#e0ddd0", "#94ecba", "#309687"],
    
    /**
     * Collection of default colors used for marker borders in a series when not specified by user.
     *
     * @property _defaultBorderColors
     * @type Array
     * @protected
     */
    _defaultBorderColors:["#205096", "#b38206", "#000000", "#94001e", "#9d6fa0", "#e55b00", "#5e85c9", "#adab9e", "#6ac291", "#006457"],
    
    /**
     * Collection of default colors used for area fills, histogram fills and pie fills in a series when not specified by user.
     *
     * @property _defaultSliceColors
     * @type Array
     * @protected
     */
    _defaultSliceColors: ["#66007f", "#a86f41", "#295454", "#996ab2", "#e8cdb7", "#90bdbd","#000000","#c3b8ca", "#968373", "#678585"],

    /**
     * Parses a color based on a series order and type.
     *
     * @method _getDefaultColor
     * @param {Number} index Index indicating the series order.
     * @param {String} type Indicates which type of object needs the color.
     * @return String
     * @protected
     */
    _getDefaultColor: function(index, type)
    {
        _yuitest_coverfunc("/build/charts-base/charts-base.js", "_getDefaultColor", 8008);
_yuitest_coverline("/build/charts-base/charts-base.js", 8010);
var colors = {
                line: this._defaultLineColors,
                fill: this._defaultFillColors,
                border: this._defaultBorderColors,
                slice: this._defaultSliceColors
            },
            col = colors[type],
            l = col.length;
        _yuitest_coverline("/build/charts-base/charts-base.js", 8018);
index = index || 0;
        _yuitest_coverline("/build/charts-base/charts-base.js", 8019);
if(index >= l)
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 8021);
index = index % l;
        }
        _yuitest_coverline("/build/charts-base/charts-base.js", 8023);
type = type || "fill";
        _yuitest_coverline("/build/charts-base/charts-base.js", 8024);
return colors[type][index];
    },
    
    /**
     * Shows/hides contents of the series.
     *
     * @method _handleVisibleChange
     * @param {Object} e Event object.
     * @protected
     */
    _handleVisibleChange: function(e) 
    {
        _yuitest_coverfunc("/build/charts-base/charts-base.js", "_handleVisibleChange", 8034);
_yuitest_coverline("/build/charts-base/charts-base.js", 8036);
this._toggleVisible(this.get("visible"));
    },

    /**
     * Returns the sum of all values for the series.
     *
     * @method getTotalValues
     * @return Number
     */
    getTotalValues: function()
    {
        _yuitest_coverfunc("/build/charts-base/charts-base.js", "getTotalValues", 8045);
_yuitest_coverline("/build/charts-base/charts-base.js", 8047);
var total = this.get("valueAxis").getTotalByKey(this.get("valueKey"));
        _yuitest_coverline("/build/charts-base/charts-base.js", 8048);
return total;
    },

    /**
     * Destructor implementation for the CartesianSeries class. Calls destroy on all Graphic instances.
     *
     * @method destructor
     * @protected
     */
    destructor: function()
    {
        _yuitest_coverfunc("/build/charts-base/charts-base.js", "destructor", 8057);
_yuitest_coverline("/build/charts-base/charts-base.js", 8059);
var marker,
            markers = this.get("markers");
        _yuitest_coverline("/build/charts-base/charts-base.js", 8061);
if(this.get("rendered"))
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 8063);
if(this._xDataReadyHandle)
            {
                _yuitest_coverline("/build/charts-base/charts-base.js", 8065);
this._xDataReadyHandle.detach();
            }
            _yuitest_coverline("/build/charts-base/charts-base.js", 8067);
if(this._xDataUpdateHandle)
            {
                _yuitest_coverline("/build/charts-base/charts-base.js", 8069);
this._xDataUpdateHandle.detach();
            }
            _yuitest_coverline("/build/charts-base/charts-base.js", 8071);
if(this._yDataReadyHandle)
            {
                _yuitest_coverline("/build/charts-base/charts-base.js", 8073);
this._yDataReadyHandle.detach();
            }
            _yuitest_coverline("/build/charts-base/charts-base.js", 8075);
if(this._yDataUpdateHandle)
            {
                _yuitest_coverline("/build/charts-base/charts-base.js", 8077);
this._yDataUpdateHandle.detach();
            }
            _yuitest_coverline("/build/charts-base/charts-base.js", 8079);
this._xAxisChangeHandle.detach();
            _yuitest_coverline("/build/charts-base/charts-base.js", 8080);
this._yAxisChangeHandle.detach();
            _yuitest_coverline("/build/charts-base/charts-base.js", 8081);
this._stylesChangeHandle.detach();
            _yuitest_coverline("/build/charts-base/charts-base.js", 8082);
this._widthChangeHandle.detach();
            _yuitest_coverline("/build/charts-base/charts-base.js", 8083);
this._heightChangeHandle.detach();
            _yuitest_coverline("/build/charts-base/charts-base.js", 8084);
this._visibleChangeHandle.detach();
        }
        _yuitest_coverline("/build/charts-base/charts-base.js", 8086);
while(markers && markers.length > 0)
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 8088);
marker = markers.shift();
            _yuitest_coverline("/build/charts-base/charts-base.js", 8089);
if(marker && marker instanceof Y.Shape)
            {
                _yuitest_coverline("/build/charts-base/charts-base.js", 8091);
marker.destroy();
            }
        }
        _yuitest_coverline("/build/charts-base/charts-base.js", 8094);
if(this._path)
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 8096);
this._path.destroy();
            _yuitest_coverline("/build/charts-base/charts-base.js", 8097);
this._path = null;
        }
        _yuitest_coverline("/build/charts-base/charts-base.js", 8099);
if(this._lineGraphic)
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 8101);
this._lineGraphic.destroy();
            _yuitest_coverline("/build/charts-base/charts-base.js", 8102);
this._lineGraphic = null;
        }
        _yuitest_coverline("/build/charts-base/charts-base.js", 8104);
if(this._groupMarker)
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 8106);
this._groupMarker.destroy();
            _yuitest_coverline("/build/charts-base/charts-base.js", 8107);
this._groupMarker = null;
        }
    }
        /**
         * Event handle for the x-axis' dataReady event.
         * 
         * @property _xDataReadyHandle
         * @type {EventHandle}
         * @private
         */
        
        /**
         * Event handle for the x-axis dataUpdate event.
         *
         * @property _xDataUpdateHandle
         * @type {EventHandle}
         * @private
         */
        
        /**
         * Event handle for the y-axis dataReady event.
         *
         * @property _yDataReadyHandle
         * @type {EventHandle}
         * @private
         */

        /**
         * Event handle for the y-axis dataUpdate event.
         * @property _yDataUpdateHandle
         * @type {EventHandle}
         * @private
         */

        /**
         * Event handle for the xAxisChange event.
         * @property _xAxisChangeHandle
         * @type {EventHandle}
         * @private
         */

        /**
         * Event handle for the yAxisChange event.
         * @property _yAxisChangeHandle
         * @type {EventHandle}
         * @private
         */

        /**
         * Event handle for the stylesChange event.
         * @property _stylesChangeHandle
         * @type {EventHandle}
         * @private
         */

        /**
         * Event handle for the widthChange event.
         * @property _widthChangeHandle
         * @type {EventHandle}
         * @private
         */

        /**
         * Event handle for the heightChange event.
         * @property _heightChangeHandle
         * @type {EventHandle}
         * @private
         */

        /**
         * Event handle for the visibleChange event.
         * @property _visibleChangeHandle
         * @type {EventHandle}
         * @private
         */
}, {
    ATTRS: {
        /**
         * Name used for for displaying data related to the x-coordinate.
         *
         * @attribute xDisplayName
         * @type String
         */
        xDisplayName: {
            getter: function()
            {
                _yuitest_coverfunc("/build/charts-base/charts-base.js", "getter", 8191);
_yuitest_coverline("/build/charts-base/charts-base.js", 8193);
return this._xDisplayName || this.get("xKey");
            },

            setter: function(val)
            {
                _yuitest_coverfunc("/build/charts-base/charts-base.js", "setter", 8196);
_yuitest_coverline("/build/charts-base/charts-base.js", 8198);
this._xDisplayName = val.toString();
                _yuitest_coverline("/build/charts-base/charts-base.js", 8199);
return val;
            }
        },

        /**
         * Name used for for displaying data related to the y-coordinate.
         *
         * @attribute yDisplayName
         * @type String
         */
        yDisplayName: {
            getter: function()
            {
                _yuitest_coverfunc("/build/charts-base/charts-base.js", "getter", 8210);
_yuitest_coverline("/build/charts-base/charts-base.js", 8212);
return this._yDisplayName || this.get("yKey");
            },

            setter: function(val)
            {
                _yuitest_coverfunc("/build/charts-base/charts-base.js", "setter", 8215);
_yuitest_coverline("/build/charts-base/charts-base.js", 8217);
this._yDisplayName = val.toString();
                _yuitest_coverline("/build/charts-base/charts-base.js", 8218);
return val;
            }
        },
        
        /**
         * Name used for for displaying category data
         *
         * @attribute categoryDisplayName
         * @type String
         * @readOnly
         */
        categoryDisplayName: {
            lazyAdd: false,

            getter: function()
            {
                _yuitest_coverfunc("/build/charts-base/charts-base.js", "getter", 8232);
_yuitest_coverline("/build/charts-base/charts-base.js", 8234);
return this.get("direction") == "vertical" ? this.get("yDisplayName") : this.get("xDisplayName");
           },

            setter: function(val)
            {
                _yuitest_coverfunc("/build/charts-base/charts-base.js", "setter", 8237);
_yuitest_coverline("/build/charts-base/charts-base.js", 8239);
if(this.get("direction") == "vertical")
                {
                    _yuitest_coverline("/build/charts-base/charts-base.js", 8241);
this._yDisplayName = val;
                }
                else
                {
                    _yuitest_coverline("/build/charts-base/charts-base.js", 8245);
this._xDisplayName = val;
                }
                _yuitest_coverline("/build/charts-base/charts-base.js", 8247);
return val;
            }
        },

        /**
         * Name used for for displaying value data
         *
         * @attribute valueDisplayName
         * @type String
         * @readOnly
         */
        valueDisplayName: {
            lazyAdd: false,

            getter: function()
            {
                _yuitest_coverfunc("/build/charts-base/charts-base.js", "getter", 8261);
_yuitest_coverline("/build/charts-base/charts-base.js", 8263);
return this.get("direction") == "vertical" ? this.get("xDisplayName") : this.get("yDisplayName");
            },

            setter: function(val)
            {
                _yuitest_coverfunc("/build/charts-base/charts-base.js", "setter", 8266);
_yuitest_coverline("/build/charts-base/charts-base.js", 8268);
if(this.get("direction") == "vertical")
                {
                    _yuitest_coverline("/build/charts-base/charts-base.js", 8270);
this._xDisplayName = val;
                }
                else
                {
                    _yuitest_coverline("/build/charts-base/charts-base.js", 8274);
this._yDisplayName = val;
                }
                _yuitest_coverline("/build/charts-base/charts-base.js", 8276);
return val;
            }
        },
        
        /**
         * Read-only attribute indicating the type of series.
         *
         * @attribute type
         * @type String
         * @default cartesian
         */
        type: {		
            value: "cartesian"
        },

        /**
         * Order of this instance of this `type`.
         *
         * @attribute order
         * @type Number
         */
        order: {},

        /**
         * Order of the instance
         *
         * @attribute graphOrder
         * @type Number
         */
        graphOrder: {},

        /**
         * x coordinates for the series.
         *
         * @attribute xcoords
         * @type Array
         */
        xcoords: {},
        
        /**
         * y coordinates for the series
         *
         * @attribute ycoords
         * @type Array
         */
        ycoords: {},

        /**
         * Reference to the `Chart` application.
         *
         * @attribute chart
         * @type ChartBase
         * @readOnly
         */
        chart: {
            readOnly: true,

            getter: function()
            {
                _yuitest_coverfunc("/build/charts-base/charts-base.js", "getter", 8333);
_yuitest_coverline("/build/charts-base/charts-base.js", 8335);
return this.get("graph").get("chart");
            }
        },
        
        /**
         * Reference to the `Graph` in which the series is drawn into.
         *
         * @attribute graph
         * @type Graph
         */
        graph: {},

        /**
         * Reference to the `Axis` instance used for assigning 
         * x-values to the graph.
         *
         * @attribute xAxis
         * @type Axis
         */
        xAxis: {},
        
        /**
         * Reference to the `Axis` instance used for assigning 
         * y-values to the graph.
         *
         * @attribute yAxis
         * @type Axis
         */
        yAxis: {},
        
        /**
         * Indicates which array to from the hash of value arrays in 
         * the x-axis `Axis` instance.
         *
         * @attribute xKey
         * @type String
         */
        xKey: {
            setter: function(val)
            {
                _yuitest_coverfunc("/build/charts-base/charts-base.js", "setter", 8373);
_yuitest_coverline("/build/charts-base/charts-base.js", 8375);
return val.toString();
            }
        },

        /**
         * Indicates which array to from the hash of value arrays in 
         * the y-axis `Axis` instance.
         *
         * @attribute yKey
         * @type String
         */
        yKey: {
            setter: function(val)
            {
                _yuitest_coverfunc("/build/charts-base/charts-base.js", "setter", 8387);
_yuitest_coverline("/build/charts-base/charts-base.js", 8389);
return val.toString();
            }
        },

        /**
         * Array of x values for the series.
         *
         * @attribute xData
         * @type Array
         */
        xData: {},

        /**
         * Array of y values for the series.
         *
         * @attribute yData
         * @type Array
         */
        yData: {},
       
        /**
         * Indicates whether the Series has been through its initial set up.
         *
         * @attribute rendered
         * @type Boolean
         */
        rendered: {
            value: false
        },

        /*
         * Returns the width of the parent graph
         *
         * @attribute width
         * @type Number
         */
        width: {
            readOnly: true,
            
            getter: function()
            {
                _yuitest_coverfunc("/build/charts-base/charts-base.js", "getter", 8428);
_yuitest_coverline("/build/charts-base/charts-base.js", 8430);
this.get("graph").get("width");
            }
        },

        /**
         * Returns the height of the parent graph
         *
         * @attribute height
         * @type Number
         */
        height: {
            readOnly: true,
            
            getter: function()
            {
                _yuitest_coverfunc("/build/charts-base/charts-base.js", "getter", 8443);
_yuitest_coverline("/build/charts-base/charts-base.js", 8445);
this.get("graph").get("height");
            }
        },

        /**
         * Indicates whether to show the series
         *
         * @attribute visible
         * @type Boolean
         * @default true
         */
        visible: {
            value: true
        },

        /**
         * Collection of area maps along the xAxis. Used to determine mouseover for multiple
         * series.
         *
         * @attribute xMarkerPlane
         * @type Array
         */
        xMarkerPlane: {},
        
        /**
         * Collection of area maps along the yAxis. Used to determine mouseover for multiple
         * series.
         *
         * @attribute yMarkerPlane
         * @type Array
         */
        yMarkerPlane: {},

        /**
         * Distance from a data coordinate to the left/right for setting a hotspot.
         *
         * @attribute xMarkerPlaneOffset
         * @type Number
         */
        xMarkerPlaneOffset: {
            getter: function() {
                _yuitest_coverfunc("/build/charts-base/charts-base.js", "getter", 8485);
_yuitest_coverline("/build/charts-base/charts-base.js", 8486);
var marker = this.get("styles").marker;
                _yuitest_coverline("/build/charts-base/charts-base.js", 8487);
if(marker && marker.width && isFinite(marker.width))
                {
                    _yuitest_coverline("/build/charts-base/charts-base.js", 8489);
return marker.width * 0.5;
                }
                _yuitest_coverline("/build/charts-base/charts-base.js", 8491);
return this._defaultPlaneOffset;
            }
        },

        /**
         * Distance from a data coordinate to the top/bottom for setting a hotspot.
         *
         * @attribute yMarkerPlaneOffset
         * @type Number
         */
        yMarkerPlaneOffset: {
            getter: function() {
                _yuitest_coverfunc("/build/charts-base/charts-base.js", "getter", 8502);
_yuitest_coverline("/build/charts-base/charts-base.js", 8503);
var marker = this.get("styles").marker;
                _yuitest_coverline("/build/charts-base/charts-base.js", 8504);
if(marker && marker.height && isFinite(marker.height))
                {
                    _yuitest_coverline("/build/charts-base/charts-base.js", 8506);
return marker.height * 0.5;
                }
                _yuitest_coverline("/build/charts-base/charts-base.js", 8508);
return this._defaultPlaneOffset;
            }
        },

        /**
         * Direction of the series
         *
         * @attribute direction
         * @type String
         */
        direction: {
            value: "horizontal"
        },

        /**
         * Indicates whether or not markers for a series will be grouped and rendered in a single complex shape instance.
         *
         * @attribute groupMarkers
         * @type Boolean
         */
        groupMarkers: {
            getter: function()
            {
                _yuitest_coverfunc("/build/charts-base/charts-base.js", "getter", 8529);
_yuitest_coverline("/build/charts-base/charts-base.js", 8531);
if(this._groupMarkers === undefined)
                {
                    _yuitest_coverline("/build/charts-base/charts-base.js", 8533);
return this.get("graph").get("groupMarkers");
                }
                else
                {
                    _yuitest_coverline("/build/charts-base/charts-base.js", 8537);
return this._groupMarkers;
                }
            },

            setter: function(val)
            {
                _yuitest_coverfunc("/build/charts-base/charts-base.js", "setter", 8541);
_yuitest_coverline("/build/charts-base/charts-base.js", 8543);
this._groupMarkers = val;
                _yuitest_coverline("/build/charts-base/charts-base.js", 8544);
return val;
            }
        }
    }
});
/**
 * The MarkerSeries class renders quantitative data by plotting relevant data points 
 * on a graph.
 *
 * @module charts
 * @submodule charts-base
 * @class MarkerSeries
 * @extends CartesianSeries
 * @uses Plots
 * @constructor
 */
_yuitest_coverline("/build/charts-base/charts-base.js", 8560);
Y.MarkerSeries = Y.Base.create("markerSeries", Y.CartesianSeries, [Y.Plots], {
    /**
     * @protected
     *
     * Draws the series.
     *
     * @method drawSeries
     */
    drawSeries: function()
    {
        _yuitest_coverfunc("/build/charts-base/charts-base.js", "drawSeries", 8568);
_yuitest_coverline("/build/charts-base/charts-base.js", 8570);
this.drawPlots();
    },
    
    /**
     * @protected
     *
     * Method used by `styles` setter. Overrides base implementation.
     *
     * @method _setStyles
     * @param {Object} newStyles Hash of properties to update.
     * @return Object
     */
    _setStyles: function(val)
    {
        _yuitest_coverfunc("/build/charts-base/charts-base.js", "_setStyles", 8582);
_yuitest_coverline("/build/charts-base/charts-base.js", 8584);
if(!val.marker)
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 8586);
val = {marker:val};
        }
        _yuitest_coverline("/build/charts-base/charts-base.js", 8588);
val = this._parseMarkerStyles(val);
        _yuitest_coverline("/build/charts-base/charts-base.js", 8589);
return Y.MarkerSeries.superclass._mergeStyles.apply(this, [val, this._getDefaultStyles()]);
    },
    
    /**
     * @protected
     *
     * Gets the default value for the `styles` attribute. Overrides
     * base implementation.
     *
     * @method _getDefaultStyles
     * @return Object
     */
    _getDefaultStyles: function()
    {
        _yuitest_coverfunc("/build/charts-base/charts-base.js", "_getDefaultStyles", 8601);
_yuitest_coverline("/build/charts-base/charts-base.js", 8603);
var styles = this._mergeStyles({marker:this._getPlotDefaults()}, Y.MarkerSeries.superclass._getDefaultStyles());
        _yuitest_coverline("/build/charts-base/charts-base.js", 8604);
return styles;
    }
},{
    ATTRS : {
        /**
         * Read-only attribute indicating the type of series.
         *
         * @attribute type
         * @type String
         * @default marker
         */
        type: {
            value:"marker"
        }
        
        /**
         * Style properties used for drawing markers. This attribute is inherited from `Renderer`. Below are the default values:
         *  <dl>
         *      <dt>fill</dt><dd>A hash containing the following values:
         *          <dl>
         *              <dt>color</dt><dd>Color of the fill. The default value is determined by the order of the series on the graph. The color
         *              will be retrieved from the below array:<br/>
         *              `["#6084d0", "#eeb647", "#6c6b5f", "#d6484f", "#ce9ed1", "#ff9f3b", "#93b7ff", "#e0ddd0", "#94ecba", "#309687"]`
         *              </dd>
         *              <dt>alpha</dt><dd>Number from 0 to 1 indicating the opacity of the marker fill. The default value is 1.</dd>
         *          </dl>
         *      </dd>
         *      <dt>border</dt><dd>A hash containing the following values:
         *          <dl>
         *              <dt>color</dt><dd>Color of the border. The default value is determined by the order of the series on the graph. The color
         *              will be retrieved from the below array:<br/>
         *              `["#205096", "#b38206", "#000000", "#94001e", "#9d6fa0", "#e55b00", "#5e85c9", "#adab9e", "#6ac291", "#006457"]`
         *              <dt>alpha</dt><dd>Number from 0 to 1 indicating the opacity of the marker border. The default value is 1.</dd>
         *              <dt>weight</dt><dd>Number indicating the width of the border. The default value is 1.</dd>
         *          </dl>
         *      </dd>
         *      <dt>width</dt><dd>indicates the width of the marker. The default value is 10.</dd>
         *      <dt>height</dt><dd>indicates the height of the marker The default value is 10.</dd>
         *      <dt>over</dt><dd>hash containing styles for markers when highlighted by a `mouseover` event. The default 
         *      values for each style is null. When an over style is not set, the non-over value will be used. For example,
         *      the default value for `marker.over.fill.color` is equivalent to `marker.fill.color`.</dd>
         *  </dl>
         *
         * @attribute styles
         * @type Object
         */
    }
});

/**
 * The LineSeries class renders quantitative data on a graph by connecting relevant data points.
 *
 * @module charts
 * @submodule charts-base
 * @class LineSeries
 * @extends CartesianSeries
 * @uses Lines
 * @constructor
 */
_yuitest_coverline("/build/charts-base/charts-base.js", 8663);
Y.LineSeries = Y.Base.create("lineSeries", Y.CartesianSeries, [Y.Lines], {
    /**
     * @protected
     *
     * @method drawSeries
     */
    drawSeries: function()
    {
        _yuitest_coverfunc("/build/charts-base/charts-base.js", "drawSeries", 8669);
_yuitest_coverline("/build/charts-base/charts-base.js", 8671);
this.drawLines();
    },

    /**
     * @protected
     *
     * Method used by `styles` setter. Overrides base implementation.
     *
     * @method _setStyles
     * @param {Object} newStyles Hash of properties to update.
     * @return Object
     */
    _setStyles: function(val)
    {
        _yuitest_coverfunc("/build/charts-base/charts-base.js", "_setStyles", 8683);
_yuitest_coverline("/build/charts-base/charts-base.js", 8685);
if(!val.line)
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 8687);
val = {line:val};
        }
        _yuitest_coverline("/build/charts-base/charts-base.js", 8689);
return Y.LineSeries.superclass._setStyles.apply(this, [val]);
    },

    /**
     * @protected
     *
     * Gets the default value for the `styles` attribute. Overrides
     * base implementation.
     *
     * @method _getDefaultStyles
     * @return Object
     */
    _getDefaultStyles: function()
    {
        _yuitest_coverfunc("/build/charts-base/charts-base.js", "_getDefaultStyles", 8701);
_yuitest_coverline("/build/charts-base/charts-base.js", 8703);
var styles = this._mergeStyles({line:this._getLineDefaults()}, Y.LineSeries.superclass._getDefaultStyles());
        _yuitest_coverline("/build/charts-base/charts-base.js", 8704);
return styles;
    }
},
{
    ATTRS: {
        /**
         * Read-only attribute indicating the type of series.
         *
         * @attribute type
         * @type String
         * @default line
         */
        type: {
            value:"line"
        }

        /**
         * Style properties used for drawing lines. This attribute is inherited from `Renderer`. Below are the default values:
         *  <dl>
         *      <dt>color</dt><dd>The color of the line. The default value is determined by the order of the series on the graph. The color will be
         *      retrieved from the following array: 
         *      `["#426ab3", "#d09b2c", "#000000", "#b82837", "#b384b5", "#ff7200", "#779de3", "#cbc8ba", "#7ed7a6", "#007a6c"]`
         *      <dt>weight</dt><dd>Number that indicates the width of the line. The default value is 6.</dd>
         *      <dt>alpha</dt><dd>Number between 0 and 1 that indicates the opacity of the line. The default value is 1.</dd>
         *      <dt>lineType</dt><dd>Indicates whether the line is solid or dashed. The default value is solid.</dd> 
         *      <dt>dashLength</dt><dd>When the `lineType` is dashed, indicates the length of the dash. The default value is 10.</dd>
         *      <dt>gapSpace</dt><dd>When the `lineType` is dashed, indicates the distance between dashes. The default value is 10.</dd>
         *      <dt>connectDiscontinuousPoints</dt><dd>Indicates whether or not to connect lines when there is a missing or null value between points. The default value is true.</dd> 
         *      <dt>discontinuousType</dt><dd>Indicates whether the line between discontinuous points is solid or dashed. The default value is solid.</dd>
         *      <dt>discontinuousDashLength</dt><dd>When the `discontinuousType` is dashed, indicates the length of the dash. The default value is 10.</dd>
         *      <dt>discontinuousGapSpace</dt><dd>When the `discontinuousType` is dashed, indicates the distance between dashes. The default value is 10.</dd>
         *  </dl>
         *
         * @attribute styles
         * @type Object
         */
    }
});



		

		
/**
 * SplineSeries renders a graph with data points connected by a curve.
 *
 * @module charts
 * @submodule charts-base
 * @class SplineSeries
 * @constructor
 * @extends CartesianSeries
 * @uses CurveUtil
 * @uses Lines
 */
_yuitest_coverline("/build/charts-base/charts-base.js", 8759);
Y.SplineSeries = Y.Base.create("splineSeries",  Y.LineSeries, [Y.CurveUtil, Y.Lines], {
    /**
     * @protected
     *
     * Draws the series.
     *
     * @method drawSeries
     */
    drawSeries: function()
    {
        _yuitest_coverfunc("/build/charts-base/charts-base.js", "drawSeries", 8767);
_yuitest_coverline("/build/charts-base/charts-base.js", 8769);
this.drawSpline();
    }
}, {
	ATTRS : {
        /**
         * Read-only attribute indicating the type of series.
         *
         * @attribute type
         * @type String
         * @default spline
         */
        type : {
            value:"spline"
        }

        /**
         * Style properties used for drawing lines. This attribute is inherited from `Renderer`. Below are the default values:
         *  <dl>
         *      <dt>color</dt><dd>The color of the line. The default value is determined by the order of the series on the graph. The color will be
         *      retrieved from the following array: 
         *      `["#426ab3", "#d09b2c", "#000000", "#b82837", "#b384b5", "#ff7200", "#779de3", "#cbc8ba", "#7ed7a6", "#007a6c"]`
         *      <dt>weight</dt><dd>Number that indicates the width of the line. The default value is 6.</dd>
         *      <dt>alpha</dt><dd>Number between 0 and 1 that indicates the opacity of the line. The default value is 1.</dd>
         *      <dt>lineType</dt><dd>Indicates whether the line is solid or dashed. The default value is solid.</dd> 
         *      <dt>dashLength</dt><dd>When the `lineType` is dashed, indicates the length of the dash. The default value is 10.</dd>
         *      <dt>gapSpace</dt><dd>When the `lineType` is dashed, indicates the distance between dashes. The default value is 10.</dd>
         *      <dt>connectDiscontinuousPoints</dt><dd>Indicates whether or not to connect lines when there is a missing or null value between points. The default value is true.</dd> 
         *      <dt>discontinuousType</dt><dd>Indicates whether the line between discontinuous points is solid or dashed. The default value is solid.</dd>
         *      <dt>discontinuousDashLength</dt><dd>When the `discontinuousType` is dashed, indicates the length of the dash. The default value is 10.</dd>
         *      <dt>discontinuousGapSpace</dt><dd>When the `discontinuousType` is dashed, indicates the distance between dashes. The default value is 10.</dd>
         *  </dl>
         *
         * @attribute styles
         * @type Object
         */
    }
});



		

		
/**
 * StackedSplineSeries creates spline graphs in which the different series are stacked along a value axis
 * to indicate their contribution to a cumulative total.
 *
 * @module charts
 * @submodule charts-base
 * @class StackedSplineSeries
 * @constructor
 * @extends SplineSeries
 * @extends StackingUtil
 */
_yuitest_coverline("/build/charts-base/charts-base.js", 8823);
Y.StackedSplineSeries = Y.Base.create("stackedSplineSeries", Y.SplineSeries, [Y.StackingUtil], {
    /**
     * @protected
     *
     * Calculates the coordinates for the series. Overrides base implementation.
     *
     * @method setAreaData
     */
    setAreaData: function()
    {   
        _yuitest_coverfunc("/build/charts-base/charts-base.js", "setAreaData", 8831);
_yuitest_coverline("/build/charts-base/charts-base.js", 8833);
Y.StackedSplineSeries.superclass.setAreaData.apply(this);
        _yuitest_coverline("/build/charts-base/charts-base.js", 8834);
this._stackCoordinates.apply(this);
    }
}, {
    ATTRS: {
        /**
         * Read-only attribute indicating the type of series.
         *
         * @attribute type
         * @type String
         * @default stackedSpline
         */
        type: {
            value:"stackedSpline"
        }
    }
});

/**
 * StackedMarkerSeries plots markers with different series stacked along the value axis to indicate each
 * series' contribution to a cumulative total.
 *
 * @module charts
 * @submodule charts-base
 * @class StackedMarkerSeries
 * @constructor
 * @extends MarkerSeries
 * @extends StackingUtil
 */
_yuitest_coverline("/build/charts-base/charts-base.js", 8862);
Y.StackedMarkerSeries = Y.Base.create("stackedMarkerSeries", Y.MarkerSeries, [Y.StackingUtil], {
    /**
     * @protected
     *
     * Calculates the coordinates for the series. Overrides base implementation.
     *
     * @method setAreaData
     */
    setAreaData: function()
    {   
        _yuitest_coverfunc("/build/charts-base/charts-base.js", "setAreaData", 8870);
_yuitest_coverline("/build/charts-base/charts-base.js", 8872);
Y.StackedMarkerSeries.superclass.setAreaData.apply(this);
        _yuitest_coverline("/build/charts-base/charts-base.js", 8873);
this._stackCoordinates.apply(this);
    }
}, {
    ATTRS: {
        /**
         * Read-only attribute indicating the type of series.
         *
         * @attribute type
         * @type String
         * @default stackedMarker
         */
        type: {
            value:"stackedMarker"
        }
    }
});

/**
 * The ColumnSeries class renders columns positioned horizontally along a category or time axis. The columns'
 * lengths are proportional to the values they represent along a vertical axis.
 * and the relevant data points.
 *
 * @module charts
 * @submodule charts-base
 * @class ColumnSeries
 * @extends MarkerSeries
 * @uses Histogram
 * @constructor
 */
_yuitest_coverline("/build/charts-base/charts-base.js", 8902);
Y.ColumnSeries = Y.Base.create("columnSeries", Y.MarkerSeries, [Y.Histogram], {
    /**
     * Helper method for calculating the size of markers. 
     *
     * @method _getMarkerDimensions
     * @param {Number} xcoord The x-coordinate representing the data point for the marker.
     * @param {Number} ycoord The y-coordinate representing the data point for the marker.
     * @param {Number} calculatedSize The calculated size for the marker. For a `BarSeries` is it the width. For a `ColumnSeries` it is the height.
     * @param {Number} offset Distance of position offset dictated by other marker series in the same graph.
     * @return Object
     * @private
     */
    _getMarkerDimensions: function(xcoord, ycoord, calculatedSize, offset)
    {
        _yuitest_coverfunc("/build/charts-base/charts-base.js", "_getMarkerDimensions", 8914);
_yuitest_coverline("/build/charts-base/charts-base.js", 8916);
var config = {
            left: xcoord + offset
        };
        _yuitest_coverline("/build/charts-base/charts-base.js", 8919);
if(this._bottomOrigin >= ycoord)
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 8921);
config.top = ycoord;
            _yuitest_coverline("/build/charts-base/charts-base.js", 8922);
config.calculatedSize = this._bottomOrigin - config.top;
        }
        else
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 8926);
config.top = this._bottomOrigin;
            _yuitest_coverline("/build/charts-base/charts-base.js", 8927);
config.calculatedSize = ycoord - this._bottomOrigin;
        }
        _yuitest_coverline("/build/charts-base/charts-base.js", 8929);
return config;
    },

    /**
     * Resizes and positions markers based on a mouse interaction.
     *
     * @method updateMarkerState
     * @param {String} type state of the marker
     * @param {Number} i index of the marker
     * @protected
     */
    updateMarkerState: function(type, i)
    {
        _yuitest_coverfunc("/build/charts-base/charts-base.js", "updateMarkerState", 8940);
_yuitest_coverline("/build/charts-base/charts-base.js", 8942);
if(this._markers && this._markers[i])
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 8944);
var styles = Y.clone(this.get("styles").marker),
                markerStyles,
                state = this._getState(type),
                xcoords = this.get("xcoords"),
                ycoords = this.get("ycoords"),
                marker = this._markers[i],
                markers,
                graph = this.get("graph"),
                seriesStyles,
                seriesCollection = graph.seriesTypes[this.get("type")],
                seriesLen = seriesCollection.length,
                seriesSize = 0,
                offset = 0,
                renderer,
                n = 0,
                xs = [],
                order = this.get("order"),
                config;
            _yuitest_coverline("/build/charts-base/charts-base.js", 8962);
markerStyles = state == "off" || !styles[state] ? Y.clone(styles) : Y.clone(styles[state]); 
            _yuitest_coverline("/build/charts-base/charts-base.js", 8963);
markerStyles.fill.color = this._getItemColor(markerStyles.fill.color, i);
            _yuitest_coverline("/build/charts-base/charts-base.js", 8964);
markerStyles.border.color = this._getItemColor(markerStyles.border.color, i);
            _yuitest_coverline("/build/charts-base/charts-base.js", 8965);
config = this._getMarkerDimensions(xcoords[i], ycoords[i], styles.width, offset);
            _yuitest_coverline("/build/charts-base/charts-base.js", 8966);
markerStyles.height = config.calculatedSize;
            _yuitest_coverline("/build/charts-base/charts-base.js", 8967);
markerStyles.width = Math.min(this._maxSize, markerStyles.width);
            _yuitest_coverline("/build/charts-base/charts-base.js", 8968);
marker.set(markerStyles);
            _yuitest_coverline("/build/charts-base/charts-base.js", 8969);
for(; n < seriesLen; ++n)
            {
                _yuitest_coverline("/build/charts-base/charts-base.js", 8971);
xs[n] = xcoords[i] + seriesSize;
                _yuitest_coverline("/build/charts-base/charts-base.js", 8972);
seriesStyles = seriesCollection[n].get("styles").marker;
                _yuitest_coverline("/build/charts-base/charts-base.js", 8973);
seriesSize += Math.min(this._maxSize, seriesStyles.width);
                _yuitest_coverline("/build/charts-base/charts-base.js", 8974);
if(order > n)
                {
                    _yuitest_coverline("/build/charts-base/charts-base.js", 8976);
offset = seriesSize;
                }
                _yuitest_coverline("/build/charts-base/charts-base.js", 8978);
offset -= seriesSize/2;
            }
            _yuitest_coverline("/build/charts-base/charts-base.js", 8980);
for(n = 0; n < seriesLen; ++n)
            {
                _yuitest_coverline("/build/charts-base/charts-base.js", 8982);
markers = seriesCollection[n].get("markers");
                _yuitest_coverline("/build/charts-base/charts-base.js", 8983);
if(markers)
                {
                    _yuitest_coverline("/build/charts-base/charts-base.js", 8985);
renderer = markers[i];
                    _yuitest_coverline("/build/charts-base/charts-base.js", 8986);
if(renderer && renderer !== undefined)
                    {
                        _yuitest_coverline("/build/charts-base/charts-base.js", 8988);
renderer.set("x", (xs[n] - seriesSize/2));
                    }
                }
            }
        }
    }
}, {
    ATTRS: {
        /**
         * Read-only attribute indicating the type of series.
         *
         * @attribute type
         * @type String
         * @readOnly
         * @default column
         */
        type: {
            value: "column"
        }
        
        /**
         * Style properties used for drawing markers. This attribute is inherited from `MarkerSeries`. Below are the default values:
         *  <dl>
         *      <dt>fill</dt><dd>A hash containing the following values:
         *          <dl>
         *              <dt>color</dt><dd>Color of the fill. The default value is determined by the order of the series on the graph. The color
         *              will be retrieved from the below array:<br/>
         *              `["#66007f", "#a86f41", "#295454", "#996ab2", "#e8cdb7", "#90bdbd","#000000","#c3b8ca", "#968373", "#678585"]`
         *              </dd>
         *              <dt>alpha</dt><dd>Number from 0 to 1 indicating the opacity of the marker fill. The default value is 1.</dd>
         *          </dl>
         *      </dd>
         *      <dt>border</dt><dd>A hash containing the following values:
         *          <dl>
         *              <dt>color</dt><dd>Color of the border. The default value is determined by the order of the series on the graph. The color
         *              will be retrieved from the below array:<br/>
         *              `["#205096", "#b38206", "#000000", "#94001e", "#9d6fa0", "#e55b00", "#5e85c9", "#adab9e", "#6ac291", "#006457"]`
         *              <dt>alpha</dt><dd>Number from 0 to 1 indicating the opacity of the marker border. The default value is 1.</dd>
         *              <dt>weight</dt><dd>Number indicating the width of the border. The default value is 1.</dd>
         *          </dl>
         *      </dd>
         *      <dt>width</dt><dd>indicates the width of the marker. The default value is 12.</dd>
         *      <dt>over</dt><dd>hash containing styles for markers when highlighted by a `mouseover` event. The default 
         *      values for each style is null. When an over style is not set, the non-over value will be used. For example,
         *      the default value for `marker.over.fill.color` is equivalent to `marker.fill.color`.</dd>
         *  </dl>
         *
         * @attribute styles
         * @type Object
         */
    }
});
/**
 * The BarSeries class renders bars positioned vertically along a category or time axis. The bars'
 * lengths are proportional to the values they represent along a horizontal axis.
 * and the relevant data points.
 *
 * @module charts
 * @submodule charts-base
 * @class BarSeries
 * @extends MarkerSeries
 * @uses Histogram
 * @constructor
 */
_yuitest_coverline("/build/charts-base/charts-base.js", 9052);
Y.BarSeries = Y.Base.create("barSeries", Y.MarkerSeries, [Y.Histogram], {
    /**
     * Helper method for calculating the size of markers. 
     *
     * @method _getMarkerDimensions
     * @param {Number} xcoord The x-coordinate representing the data point for the marker.
     * @param {Number} ycoord The y-coordinate representing the data point for the marker.
     * @param {Number} calculatedSize The calculated size for the marker. For a `BarSeries` is it the width. For a `ColumnSeries` it is the height.
     * @param {Number} offset Distance of position offset dictated by other marker series in the same graph.
     * @return Object
     * @private
     */
    _getMarkerDimensions: function(xcoord, ycoord, calculatedSize, offset)
    {
        _yuitest_coverfunc("/build/charts-base/charts-base.js", "_getMarkerDimensions", 9064);
_yuitest_coverline("/build/charts-base/charts-base.js", 9066);
var config = {
            top: ycoord + offset
        };
        _yuitest_coverline("/build/charts-base/charts-base.js", 9069);
if(xcoord >= this._leftOrigin)
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 9071);
config.left = this._leftOrigin;
            _yuitest_coverline("/build/charts-base/charts-base.js", 9072);
config.calculatedSize = xcoord - config.left;
        }
        else
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 9076);
config.left = xcoord;
            _yuitest_coverline("/build/charts-base/charts-base.js", 9077);
config.calculatedSize = this._leftOrigin - xcoord;
        }
        _yuitest_coverline("/build/charts-base/charts-base.js", 9079);
return config;
    },
    
    /**
     * Resizes and positions markers based on a mouse interaction.
     *
     * @method updateMarkerState
     * @param {String} type state of the marker
     * @param {Number} i index of the marker
     * @protected
     */
    updateMarkerState: function(type, i)
    {
        _yuitest_coverfunc("/build/charts-base/charts-base.js", "updateMarkerState", 9090);
_yuitest_coverline("/build/charts-base/charts-base.js", 9092);
if(this._markers && this._markers[i])
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 9094);
var styles = Y.clone(this.get("styles").marker),
                markerStyles,
                state = this._getState(type),
                xcoords = this.get("xcoords"),
                ycoords = this.get("ycoords"),
                marker = this._markers[i],
                markers,
                graph = this.get("graph"),
                seriesCollection = graph.seriesTypes[this.get("type")],
                seriesLen = seriesCollection.length,
                seriesStyles,
                seriesSize = 0,
                offset = 0,
                renderer,
                n = 0,
                ys = [],
                order = this.get("order"),
                config;
            _yuitest_coverline("/build/charts-base/charts-base.js", 9112);
markerStyles = state == "off" || !styles[state] ? styles : styles[state]; 
            _yuitest_coverline("/build/charts-base/charts-base.js", 9113);
markerStyles.fill.color = this._getItemColor(markerStyles.fill.color, i);
            _yuitest_coverline("/build/charts-base/charts-base.js", 9114);
markerStyles.border.color = this._getItemColor(markerStyles.border.color, i);
            _yuitest_coverline("/build/charts-base/charts-base.js", 9115);
config = this._getMarkerDimensions(xcoords[i], ycoords[i], styles.height, offset);
            _yuitest_coverline("/build/charts-base/charts-base.js", 9116);
markerStyles.width = config.calculatedSize;
            _yuitest_coverline("/build/charts-base/charts-base.js", 9117);
markerStyles.height = Math.min(this._maxSize, markerStyles.height);
            _yuitest_coverline("/build/charts-base/charts-base.js", 9118);
marker.set(markerStyles);
            _yuitest_coverline("/build/charts-base/charts-base.js", 9119);
for(; n < seriesLen; ++n)
            {
                _yuitest_coverline("/build/charts-base/charts-base.js", 9121);
ys[n] = ycoords[i] + seriesSize;
                _yuitest_coverline("/build/charts-base/charts-base.js", 9122);
seriesStyles = seriesCollection[n].get("styles").marker;
                _yuitest_coverline("/build/charts-base/charts-base.js", 9123);
seriesSize += Math.min(this._maxSize, seriesStyles.height); 
                _yuitest_coverline("/build/charts-base/charts-base.js", 9124);
if(order > n)
                {
                    _yuitest_coverline("/build/charts-base/charts-base.js", 9126);
offset = seriesSize;
                }
                _yuitest_coverline("/build/charts-base/charts-base.js", 9128);
offset -= seriesSize/2;
            }
            _yuitest_coverline("/build/charts-base/charts-base.js", 9130);
for(n = 0; n < seriesLen; ++n)
            {
                _yuitest_coverline("/build/charts-base/charts-base.js", 9132);
markers = seriesCollection[n].get("markers");
                _yuitest_coverline("/build/charts-base/charts-base.js", 9133);
if(markers)
                {
                    _yuitest_coverline("/build/charts-base/charts-base.js", 9135);
renderer = markers[i];
                    _yuitest_coverline("/build/charts-base/charts-base.js", 9136);
if(renderer && renderer !== undefined)
                    {
                        _yuitest_coverline("/build/charts-base/charts-base.js", 9138);
renderer.set("y", (ys[n] - seriesSize/2));
                    }
                }
            }
        }
    }
}, {
    ATTRS: {
        /**
         * Read-only attribute indicating the type of series.
         *
         * @attribute type
         * @type String
         * @default bar
         */
        type: {
            value: "bar"
        },

        /**
         * Indicates the direction of the category axis that the bars are plotted against.
         *
         * @attribute direction
         * @type String
         */
        direction: {
            value: "vertical"
        }
        
        /**
         * Style properties used for drawing markers. This attribute is inherited from `MarkerSeries`. Below are the default values:
         *  <dl>
         *      <dt>fill</dt><dd>A hash containing the following values:
         *          <dl>
         *              <dt>color</dt><dd>Color of the fill. The default value is determined by the order of the series on the graph. The color
         *              will be retrieved from the below array:<br/>
         *              `["#66007f", "#a86f41", "#295454", "#996ab2", "#e8cdb7", "#90bdbd","#000000","#c3b8ca", "#968373", "#678585"]`
         *              </dd>
         *              <dt>alpha</dt><dd>Number from 0 to 1 indicating the opacity of the marker fill. The default value is 1.</dd>
         *          </dl>
         *      </dd>
         *      <dt>border</dt><dd>A hash containing the following values:
         *          <dl>
         *              <dt>color</dt><dd>Color of the border. The default value is determined by the order of the series on the graph. The color
         *              will be retrieved from the below array:<br/>
         *              `["#205096", "#b38206", "#000000", "#94001e", "#9d6fa0", "#e55b00", "#5e85c9", "#adab9e", "#6ac291", "#006457"]`
         *              <dt>alpha</dt><dd>Number from 0 to 1 indicating the opacity of the marker border. The default value is 1.</dd>
         *              <dt>weight</dt><dd>Number indicating the width of the border. The default value is 1.</dd>
         *          </dl>
         *      </dd>
         *      <dt>height</dt><dd>indicates the width of the marker. The default value is 12.</dd>
         *      <dt>over</dt><dd>hash containing styles for markers when highlighted by a `mouseover` event. The default 
         *      values for each style is null. When an over style is not set, the non-over value will be used. For example,
         *      the default value for `marker.over.fill.color` is equivalent to `marker.fill.color`.</dd>
         *  </dl>
         *
         * @attribute styles
         * @type Object
         */
    }
});
/**
 * The AreaSeries class renders quantitative data on a graph by creating a fill between 0
 * and the relevant data points.
 *
 * @module charts
 * @submodule charts-base
 * @class AreaSeries
 * @extends CartesianSeries
 * @uses Fills
 * @constructor
 */
_yuitest_coverline("/build/charts-base/charts-base.js", 9210);
Y.AreaSeries = Y.Base.create("areaSeries", Y.CartesianSeries, [Y.Fills], {
    /**
     * @protected
     *
     * Renders the series. 
     *
     * @method drawSeries
     */
    drawSeries: function()
    {
        _yuitest_coverfunc("/build/charts-base/charts-base.js", "drawSeries", 9218);
_yuitest_coverline("/build/charts-base/charts-base.js", 9220);
this.drawFill.apply(this, this._getClosingPoints());
    },
    
    /**
     * @protected
     *
     * Method used by `styles` setter. Overrides base implementation.
     *
     * @method _setStyles
     * @param {Object} newStyles Hash of properties to update.
     * @return Object
     */
    _setStyles: function(val)
    {
        _yuitest_coverfunc("/build/charts-base/charts-base.js", "_setStyles", 9232);
_yuitest_coverline("/build/charts-base/charts-base.js", 9234);
if(!val.area)
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 9236);
val = {area:val};
        }
        _yuitest_coverline("/build/charts-base/charts-base.js", 9238);
return Y.AreaSeries.superclass._setStyles.apply(this, [val]);
    },

    /**
     * @protected
     *
     * Gets the default value for the `styles` attribute. Overrides
     * base implementation.
     *
     * @method _getDefaultStyles
     * @return Object
     */
    _getDefaultStyles: function()
    {
        _yuitest_coverfunc("/build/charts-base/charts-base.js", "_getDefaultStyles", 9250);
_yuitest_coverline("/build/charts-base/charts-base.js", 9252);
var styles = this._mergeStyles({area:this._getAreaDefaults()}, Y.AreaSeries.superclass._getDefaultStyles());
        _yuitest_coverline("/build/charts-base/charts-base.js", 9253);
return styles;
    }
},
{
    ATTRS: {
        /**
         * Read-only attribute indicating the type of series.
         *
         * @attribute type
         * @type String
         * @default area
         */
        type: {
            value:"area"
        }
        
        /**
         * Style properties used for drawing area fills. This attribute is inherited from `Renderer`. Below are the default values:
         *
         *  <dl>
         *      <dt>color</dt><dd>The color of the fill. The default value is determined by the order of the series on the graph. The color will be 
         *      retrieved from the following array:
         *      `["#66007f", "#a86f41", "#295454", "#996ab2", "#e8cdb7", "#90bdbd","#000000","#c3b8ca", "#968373", "#678585"]`
         *      </dd>
         *      <dt>alpha</dt><dd>Number between 0 and 1 that indicates the opacity of the fill. The default value is 1</dd>
         *  </dl>
         *
         * @attribute styles
         * @type Object
         */
    }
});



		

		
/**
 * AreaSplineSeries renders an area graph with data points connected by a curve.
 *
 * @module charts
 * @submodule charts-base
 * @class AreaSplineSeries
 * @constructor
 * @extends CartesianSeries
 * @uses Fills
 * @uses CurveUtil
 */
_yuitest_coverline("/build/charts-base/charts-base.js", 9302);
Y.AreaSplineSeries = Y.Base.create("areaSplineSeries", Y.AreaSeries, [Y.CurveUtil], {
    /**
     * @protected
     *
     * Draws the series.
     *
     * @method drawSeries
     */
    drawSeries: function()
    {
        _yuitest_coverfunc("/build/charts-base/charts-base.js", "drawSeries", 9310);
_yuitest_coverline("/build/charts-base/charts-base.js", 9312);
this.drawAreaSpline();
    }
}, {
	ATTRS : {
        /**
         * Read-only attribute indicating the type of series.
         *
         * @attribute type
         * @type String
         * @default areaSpline
         */
        type: {
            value:"areaSpline"
        }
        
        /**
         * Style properties used for drawing area fills. This attribute is inherited from `Renderer`. Below are the default values:
         *
         *  <dl>
         *      <dt>color</dt><dd>The color of the fill. The default value is determined by the order of the series on the graph. The color will be 
         *      retrieved from the following array:
         *      `["#66007f", "#a86f41", "#295454", "#996ab2", "#e8cdb7", "#90bdbd","#000000","#c3b8ca", "#968373", "#678585"]`
         *      </dd>
         *      <dt>alpha</dt><dd>Number between 0 and 1 that indicates the opacity of the fill. The default value is 1</dd>
         *  </dl>
         *
         * @attribute styles
         * @type Object
         */
    }
});

/**
 * StackedAreaSplineSeries creates a stacked area chart with points data points connected by a curve.
 *
 * @module charts
 * @submodule charts-base
 * @class StackedAreaSplineSeries
 * @constructor
 * @extends AreaSeries
 * @uses CurveUtil
 * @uses StackingUtil
 */
_yuitest_coverline("/build/charts-base/charts-base.js", 9355);
Y.StackedAreaSplineSeries = Y.Base.create("stackedAreaSplineSeries", Y.AreaSeries, [Y.CurveUtil, Y.StackingUtil], {
    /**
     * @protected
     *
     * Draws the series.
     *
     * @method drawSeries
     */
    drawSeries: function()
    {
        _yuitest_coverfunc("/build/charts-base/charts-base.js", "drawSeries", 9363);
_yuitest_coverline("/build/charts-base/charts-base.js", 9365);
this._stackCoordinates();
        _yuitest_coverline("/build/charts-base/charts-base.js", 9366);
this.drawStackedAreaSpline();
    }
}, {
    ATTRS : {
        /**
         * Read-only attribute indicating the type of series.
         *
         * @attribute type
         * @type String
         * @default stackedAreaSpline
         */
        type: {
            value:"stackedAreaSpline"
        }
    }
});

/**
 * The ComboSeries class renders a combination of lines, plots and area fills in a single series. Each
 * series type has a corresponding boolean attribute indicating if it is rendered. By default, lines and plots 
 * are rendered and area is not. 
 *
 * @module charts
 * @submodule charts-base
 * @class ComboSeries
 * @extends CartesianSeries 
 * @uses Fills
 * @uses Lines
 * @uses Plots
 * @constructor
 */
_yuitest_coverline("/build/charts-base/charts-base.js", 9397);
Y.ComboSeries = Y.Base.create("comboSeries", Y.CartesianSeries, [Y.Fills, Y.Lines, Y.Plots], {
	/**
     * @protected
     * 
     * Draws the series.
     *
     * @method drawSeries
     */
    drawSeries: function()
    {
        _yuitest_coverfunc("/build/charts-base/charts-base.js", "drawSeries", 9405);
_yuitest_coverline("/build/charts-base/charts-base.js", 9407);
if(this.get("showAreaFill"))
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 9409);
this.drawFill.apply(this, this._getClosingPoints());
        }
        _yuitest_coverline("/build/charts-base/charts-base.js", 9411);
if(this.get("showLines")) 
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 9413);
this.drawLines();
        }
        _yuitest_coverline("/build/charts-base/charts-base.js", 9415);
if(this.get("showMarkers"))
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 9417);
this.drawPlots();
        }   
    },
    
    /**
     * Toggles visibility
     *
     * @method _toggleVisible
     * @param {Boolean} visible indicates visibilitye
     * @private
     */
    _toggleVisible: function(visible)
    {
        _yuitest_coverfunc("/build/charts-base/charts-base.js", "_toggleVisible", 9428);
_yuitest_coverline("/build/charts-base/charts-base.js", 9430);
var markers,
            marker,
            len,
            i;
        _yuitest_coverline("/build/charts-base/charts-base.js", 9434);
if(this.get("showAreaFill") && this._path)
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 9436);
this._path.set("visible", visible);
        }
        _yuitest_coverline("/build/charts-base/charts-base.js", 9438);
if(this.get("showLines") && this._lineGraphic)
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 9440);
this._lineGraphic.set("visible", visible);
        }
        _yuitest_coverline("/build/charts-base/charts-base.js", 9442);
if(this.get("showMarkers"))
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 9444);
markers = this.get("markers");
            _yuitest_coverline("/build/charts-base/charts-base.js", 9445);
if(markers)
            {
                _yuitest_coverline("/build/charts-base/charts-base.js", 9447);
i = 0;
                _yuitest_coverline("/build/charts-base/charts-base.js", 9448);
len = markers.length;
                _yuitest_coverline("/build/charts-base/charts-base.js", 9449);
for(; i < len; ++i)
                {
                    _yuitest_coverline("/build/charts-base/charts-base.js", 9451);
marker = markers[i];
                    _yuitest_coverline("/build/charts-base/charts-base.js", 9452);
if(marker)
                    {
                        _yuitest_coverline("/build/charts-base/charts-base.js", 9454);
marker.set("visible", visible);
                    }
                }
            }
        }
    },

    /**
     * @protected
     *
     * Returns the default hash for the `styles` attribute.
     *
     * @method _getDefaultStyles
     * @return Object
     */
    _getDefaultStyles: function()
    {
        _yuitest_coverfunc("/build/charts-base/charts-base.js", "_getDefaultStyles", 9469);
_yuitest_coverline("/build/charts-base/charts-base.js", 9471);
var styles = Y.ComboSeries.superclass._getDefaultStyles();
        _yuitest_coverline("/build/charts-base/charts-base.js", 9472);
styles.line = this._getLineDefaults();
        _yuitest_coverline("/build/charts-base/charts-base.js", 9473);
styles.marker = this._getPlotDefaults();
        _yuitest_coverline("/build/charts-base/charts-base.js", 9474);
styles.area = this._getAreaDefaults();
        _yuitest_coverline("/build/charts-base/charts-base.js", 9475);
return styles;
    }
},
{
    ATTRS: {
        /**
         * Read-only attribute indicating the type of series.
         *
         * @attribute type
         * @type String
         * @default combo
         */
        type: {
            value:"combo"
        },

        /**
         * Indicates whether a fill is displayed.
         *
         * @attribute showAreaFill
         * @type Boolean
         * @default false
         */
        showAreaFill: {
            value: false
        },

        /**
         * Indicates whether lines are displayed.
         *
         * @attribute showLines
         * @type Boolean
         * @default true
         */
        showLines: {
            value: true
        },

        /**
         * Indicates whether markers are displayed.
         *
         * @attribute showMarkers
         * @type Boolean
         * @default true
         */
        showMarkers: {
            value: true
        },

        /**
         * Reference to the styles of the markers. These styles can also
         * be accessed through the `styles` attribute. Below are default
         * values:
         *  <dl>
         *      <dt>fill</dt><dd>A hash containing the following values:
         *          <dl>
         *              <dt>color</dt><dd>Color of the fill. The default value is determined by the order of the series on the graph. The color
         *              will be retrieved from the below array:<br/>
         *              `["#6084d0", "#eeb647", "#6c6b5f", "#d6484f", "#ce9ed1", "#ff9f3b", "#93b7ff", "#e0ddd0", "#94ecba", "#309687"]`
         *              </dd>
         *              <dt>alpha</dt><dd>Number from 0 to 1 indicating the opacity of the marker fill. The default value is 1.</dd>
         *          </dl>
         *      </dd>
         *      <dt>border</dt><dd>A hash containing the following values:
         *          <dl>
         *              <dt>color</dt><dd>Color of the border. The default value is determined by the order of the series on the graph. The color
         *              will be retrieved from the below array:<br/>
         *              `["#205096", "#b38206", "#000000", "#94001e", "#9d6fa0", "#e55b00", "#5e85c9", "#adab9e", "#6ac291", "#006457"]`
         *              <dt>alpha</dt><dd>Number from 0 to 1 indicating the opacity of the marker border. The default value is 1.</dd>
         *              <dt>weight</dt><dd>Number indicating the width of the border. The default value is 1.</dd>
         *          </dl>
         *      </dd>
         *      <dt>width</dt><dd>indicates the width of the marker. The default value is 10.</dd>
         *      <dt>height</dt><dd>indicates the height of the marker The default value is 10.</dd>
         *      <dt>over</dt><dd>hash containing styles for markers when highlighted by a `mouseover` event. The default 
         *      values for each style is null. When an over style is not set, the non-over value will be used. For example,
         *      the default value for `marker.over.fill.color` is equivalent to `marker.fill.color`.</dd>
         *  </dl>
         *
         * @attribute marker
         * @type Object
         */
        marker: {
            lazyAdd: false,
            getter: function()
            {
                _yuitest_coverfunc("/build/charts-base/charts-base.js", "getter", 9559);
_yuitest_coverline("/build/charts-base/charts-base.js", 9561);
return this.get("styles").marker;
            },
            setter: function(val)
            {
                _yuitest_coverfunc("/build/charts-base/charts-base.js", "setter", 9563);
_yuitest_coverline("/build/charts-base/charts-base.js", 9565);
this.set("styles", {marker:val});
            }
        },
        
        /**
         * Reference to the styles of the lines. These styles can also be accessed through the `styles` attribute.
         * Below are the default values:
         *  <dl>
         *      <dt>color</dt><dd>The color of the line. The default value is determined by the order of the series on the graph. The color will be
         *      retrieved from the following array: 
         *      `["#426ab3", "#d09b2c", "#000000", "#b82837", "#b384b5", "#ff7200", "#779de3", "#cbc8ba", "#7ed7a6", "#007a6c"]`
         *      <dt>weight</dt><dd>Number that indicates the width of the line. The default value is 6.</dd>
         *      <dt>alpha</dt><dd>Number between 0 and 1 that indicates the opacity of the line. The default value is 1.</dd>
         *      <dt>lineType</dt><dd>Indicates whether the line is solid or dashed. The default value is solid.</dd> 
         *      <dt>dashLength</dt><dd>When the `lineType` is dashed, indicates the length of the dash. The default value is 10.</dd>
         *      <dt>gapSpace</dt><dd>When the `lineType` is dashed, indicates the distance between dashes. The default value is 10.</dd>
         *      <dt>connectDiscontinuousPoints</dt><dd>Indicates whether or not to connect lines when there is a missing or null value between points. The default value is true.</dd> 
         *      <dt>discontinuousType</dt><dd>Indicates whether the line between discontinuous points is solid or dashed. The default value is solid.</dd>
         *      <dt>discontinuousDashLength</dt><dd>When the `discontinuousType` is dashed, indicates the length of the dash. The default value is 10.</dd>
         *      <dt>discontinuousGapSpace</dt><dd>When the `discontinuousType` is dashed, indicates the distance between dashes. The default value is 10.</dd>
         *  </dl>
         *
         * @attribute line
         * @type Object
         */
        line: {
            lazyAdd: false,
            getter: function()
            {
                _yuitest_coverfunc("/build/charts-base/charts-base.js", "getter", 9592);
_yuitest_coverline("/build/charts-base/charts-base.js", 9594);
return this.get("styles").line;
            },
            setter: function(val)
            {
                _yuitest_coverfunc("/build/charts-base/charts-base.js", "setter", 9596);
_yuitest_coverline("/build/charts-base/charts-base.js", 9598);
this.set("styles", {line:val});
            }
        },
        
        /**
         * Reference to the styles of the area fills. These styles can also be accessed through the `styles` attribute.
         * Below are the default values:
         *
         *  <dl>
         *      <dt>color</dt><dd>The color of the fill. The default value is determined by the order of the series on the graph. The color will be 
         *      retrieved from the following array:
         *      `["#66007f", "#a86f41", "#295454", "#996ab2", "#e8cdb7", "#90bdbd","#000000","#c3b8ca", "#968373", "#678585"]`
         *      </dd>
         *      <dt>alpha</dt><dd>Number between 0 and 1 that indicates the opacity of the fill. The default value is 1</dd>
         *  </dl>
         *
         * @attribute area
         * @type Object
         */
        area: {
            lazyAdd: false,
            getter: function()
            {
                _yuitest_coverfunc("/build/charts-base/charts-base.js", "getter", 9619);
_yuitest_coverline("/build/charts-base/charts-base.js", 9621);
return this.get("styles").area;
            },
            setter: function(val)
            {
                _yuitest_coverfunc("/build/charts-base/charts-base.js", "setter", 9623);
_yuitest_coverline("/build/charts-base/charts-base.js", 9625);
this.set("styles", {area:val});
            }
        }

        /**
         * Style properties for the series. Contains a key indexed hash of the following:
         *  <dl>
         *      <dt>marker</dt><dd>Style properties for the markers in the series. Specific style attributes are listed
         *      <a href="#attr_marker">here</a>.</dd>
         *      <dt>line</dt><dd>Style properties for the lines in the series. Specific
         *      style attributes are listed <a href="#attr_line">here</a>.</dd>
         *      <dt>area</dt><dd>Style properties for the area fills in the series. Specific style attributes are listed
         *      <a href="#attr_area">here</a>.</dd>
         *  </dl>
         *
         * @attribute styles
         * @type Object
         */
    }
});



		

		
/**
 * The StackedComboSeries class renders a combination of lines, plots and area fills in a single series. Series
 * are stacked along the value axis to indicate each series contribution to a cumulative total. Each
 * series type has a corresponding boolean attribute indicating if it is rendered. By default, all three types are
 * rendered.  
 *
 * @module charts
 * @submodule charts-base
 * @class StackedComboSeries
 * @extends ComboSeries
 * @uses StackingUtil
 * @constructor
 */
_yuitest_coverline("/build/charts-base/charts-base.js", 9664);
Y.StackedComboSeries = Y.Base.create("stackedComboSeries", Y.ComboSeries, [Y.StackingUtil], {
    /**
     * @protected
     *
     * Calculates the coordinates for the series. Overrides base implementation.
     *
     * @method setAreaData
     */
    setAreaData: function()
    {   
        _yuitest_coverfunc("/build/charts-base/charts-base.js", "setAreaData", 9672);
_yuitest_coverline("/build/charts-base/charts-base.js", 9674);
Y.StackedComboSeries.superclass.setAreaData.apply(this);
        _yuitest_coverline("/build/charts-base/charts-base.js", 9675);
this._stackCoordinates.apply(this);
    },
	
    /**
     * @protected
     *
     * Draws the series.
     *
     * @method drawSeries
     */
    drawSeries: function()
    {
        _yuitest_coverfunc("/build/charts-base/charts-base.js", "drawSeries", 9685);
_yuitest_coverline("/build/charts-base/charts-base.js", 9687);
if(this.get("showAreaFill"))
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 9689);
this.drawFill.apply(this, this._getStackedClosingPoints());
        }
        _yuitest_coverline("/build/charts-base/charts-base.js", 9691);
if(this.get("showLines")) 
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 9693);
this.drawLines();
        }
        _yuitest_coverline("/build/charts-base/charts-base.js", 9695);
if(this.get("showMarkers"))
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 9697);
this.drawPlots();
        }   
    }
    
}, {
    ATTRS : {
        /**
         * Read-only attribute indicating the type of series.
         *
         * @attribute type
         * @type String
         * @default stackedCombo
         */
        type: {
            value: "stackedCombo"
        },

        /**
         * Indicates whether a fill is displayed.
         *
         * @attribute showAreaFill
         * @type Boolean
         * @default true
         */
        showAreaFill: {
            value: true
        }
    }
});
/**
 * The ComboSplineSeries class renders a combination of splines, plots and areaspline fills in a single series. Each
 * series type has a corresponding boolean attribute indicating if it is rendered. By default, splines and plots 
 * are rendered and areaspline is not. 
 *
 * @module charts
 * @submodule charts-base
 * @class ComboSplineSeries
 * @extends ComboSeries
 * @extends CurveUtil
 * @constructor
 */
_yuitest_coverline("/build/charts-base/charts-base.js", 9738);
Y.ComboSplineSeries = Y.Base.create("comboSplineSeries", Y.ComboSeries, [Y.CurveUtil], {
    /**
     * @protected
     * 
     * Draws the series.
     *
     * @method drawSeries
     */
    drawSeries: function()
    {
        _yuitest_coverfunc("/build/charts-base/charts-base.js", "drawSeries", 9746);
_yuitest_coverline("/build/charts-base/charts-base.js", 9748);
if(this.get("showAreaFill"))
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 9750);
this.drawAreaSpline();
        }
        _yuitest_coverline("/build/charts-base/charts-base.js", 9752);
if(this.get("showLines")) 
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 9754);
this.drawSpline();
        }
        _yuitest_coverline("/build/charts-base/charts-base.js", 9756);
if(this.get("showMarkers"))
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 9758);
this.drawPlots();
        }   
    }
}, {
    ATTRS: {
        /**
         * Read-only attribute indicating the type of series.
         *
         * @attribute type
         * @type String
         * @default comboSpline
         */
        type: {
            value : "comboSpline"
        }
    }
});
/**
 * The StackedComboSplineSeries class renders a combination of splines, plots and areaspline fills in a single series. Series
 * are stacked along the value axis to indicate each series contribution to a cumulative total. Each
 * series type has a corresponding boolean attribute indicating if it is rendered. By default, all three types are
 * rendered.  
 *
 * @module charts
 * @submodule charts-base
 * @class StackedComboSplineSeries
 * @extends StackedComboSeries
 * @uses CurveUtil
 * @constructor
 */
_yuitest_coverline("/build/charts-base/charts-base.js", 9788);
Y.StackedComboSplineSeries = Y.Base.create("stackedComboSplineSeries", Y.StackedComboSeries, [Y.CurveUtil], {
    /**
	 * @protected
     *
     * Draws the series.
     *
     * @method drawSeries
	 */
	drawSeries: function()
    {
        _yuitest_coverfunc("/build/charts-base/charts-base.js", "drawSeries", 9796);
_yuitest_coverline("/build/charts-base/charts-base.js", 9798);
if(this.get("showAreaFill"))
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 9800);
this.drawStackedAreaSpline();
        }
        _yuitest_coverline("/build/charts-base/charts-base.js", 9802);
if(this.get("showLines")) 
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 9804);
this.drawSpline();
        }
        _yuitest_coverline("/build/charts-base/charts-base.js", 9806);
if(this.get("showMarkers"))
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 9808);
this.drawPlots();
        }   
    }
}, {
    ATTRS: {
        /**
         * Read-only attribute indicating the type of series.
         *
         * @attribute type
         * @type String
         * @default stackedComboSpline
         */
        type : {
            value : "stackedComboSpline"
        },

        /**
         * Indicates whether a fill is displayed.
         *
         * @attribute showAreaFill
         * @type Boolean
         * @default true
         */
        showAreaFill: {
            value: true
        }
    }
});
/**
 * StackedLineSeries creates line graphs in which the different series are stacked along a value axis
 * to indicate their contribution to a cumulative total.
 *
 * @module charts
 * @submodule charts-base
 * @class StackedLineSeries
 * @constructor
 * @extends  LineSeries
 * @uses StackingUtil
 */
_yuitest_coverline("/build/charts-base/charts-base.js", 9847);
Y.StackedLineSeries = Y.Base.create("stackedLineSeries", Y.LineSeries, [Y.StackingUtil], {
    /**
     * @protected
     *
     * Calculates the coordinates for the series. Overrides base implementation.
     *
     * @method setAreaData
     */
    setAreaData: function()
    {   
        _yuitest_coverfunc("/build/charts-base/charts-base.js", "setAreaData", 9855);
_yuitest_coverline("/build/charts-base/charts-base.js", 9857);
Y.StackedLineSeries.superclass.setAreaData.apply(this);
        _yuitest_coverline("/build/charts-base/charts-base.js", 9858);
this._stackCoordinates.apply(this);
    }
}, {
    ATTRS: {
        /**
         * Read-only attribute indicating the type of series.
         *
         * @attribute type
         * @type String
         * @default stackedLine
         */
        type: {
            value:"stackedLine"
        }
    }
});
/**
 * StackedAreaSeries area fills to display data showing its contribution to a whole.
 *
 * @module charts
 * @submodule charts-base
 * @class StackedAreaSeries
 * @constructor
 * @param {Object} config (optional) Configuration parameters for the Chart.
 * @extends AreaSeries
 * @uses StackingUtil
 */
_yuitest_coverline("/build/charts-base/charts-base.js", 9885);
Y.StackedAreaSeries = Y.Base.create("stackedAreaSeries", Y.AreaSeries, [Y.StackingUtil], {
    /**
     * @protected
     *
     * Calculates the coordinates for the series. Overrides base implementation.
     *
     * @method setAreaData
     */
    setAreaData: function()
    {   
        _yuitest_coverfunc("/build/charts-base/charts-base.js", "setAreaData", 9893);
_yuitest_coverline("/build/charts-base/charts-base.js", 9895);
Y.StackedAreaSeries.superclass.setAreaData.apply(this);
        _yuitest_coverline("/build/charts-base/charts-base.js", 9896);
this._stackCoordinates.apply(this);
    },

    /**
     * @protected
     *
     * Draws the series
     *
     * @method drawSeries
     */
	drawSeries: function()
    {
        _yuitest_coverfunc("/build/charts-base/charts-base.js", "drawSeries", 9906);
_yuitest_coverline("/build/charts-base/charts-base.js", 9908);
this.drawFill.apply(this, this._getStackedClosingPoints());
    }
}, {
    ATTRS: {
        /**
         * Read-only attribute indicating the type of series.
         *
         * @attribute type
         * @type String
         * @default stackedArea
         */
        type: {
            value:"stackedArea"
        }
    }
});
/**
 * The StackedColumnSeries renders column chart in which series are stacked vertically to show
 * their contribution to the cumulative total.
 *
 * @module charts
 * @submodule charts-base
 * @class StackedColumnSeries
 * @extends ColumnSeries
 * @uses StackingUtil
 * @constructor
 */
_yuitest_coverline("/build/charts-base/charts-base.js", 9935);
Y.StackedColumnSeries = Y.Base.create("stackedColumnSeries", Y.ColumnSeries, [Y.StackingUtil], {
    /**
     * Draws the series.
     *
     * @method drawSeries
	 * @protected
	 */
	drawSeries: function()
	{
        _yuitest_coverfunc("/build/charts-base/charts-base.js", "drawSeries", 9942);
_yuitest_coverline("/build/charts-base/charts-base.js", 9944);
if(this.get("xcoords").length < 1) 
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 9946);
return;
        }
        _yuitest_coverline("/build/charts-base/charts-base.js", 9948);
var isNumber = Y_Lang.isNumber,
            style = Y.clone(this.get("styles").marker), 
            w = style.width,
            h = style.height,
            xcoords = this.get("xcoords"),
            ycoords = this.get("ycoords"),
            i = 0,
            len = xcoords.length,
            top = ycoords[0],
            type = this.get("type"),
            graph = this.get("graph"),
            seriesCollection = graph.seriesTypes[type],
            ratio,
            order = this.get("order"),
            graphOrder = this.get("graphOrder"),
            left,
            marker,
            fillColors,
            borderColors,
            lastCollection,
            negativeBaseValues,
            positiveBaseValues,
            useOrigin = order === 0,
            totalWidth = len * w,
            dimensions = {
                width: [],
                height: []
            },
            xvalues = [],
            yvalues = [],
            groupMarkers = this.get("groupMarkers");
        _yuitest_coverline("/build/charts-base/charts-base.js", 9979);
if(Y_Lang.isArray(style.fill.color))
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 9981);
fillColors = style.fill.color.concat(); 
        }
        _yuitest_coverline("/build/charts-base/charts-base.js", 9983);
if(Y_Lang.isArray(style.border.color))
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 9985);
borderColors = style.border.color.concat();
        }
        _yuitest_coverline("/build/charts-base/charts-base.js", 9987);
this._createMarkerCache();
        _yuitest_coverline("/build/charts-base/charts-base.js", 9988);
if(totalWidth > this.get("width"))
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 9990);
ratio = this.width/totalWidth;
            _yuitest_coverline("/build/charts-base/charts-base.js", 9991);
w *= ratio;
            _yuitest_coverline("/build/charts-base/charts-base.js", 9992);
w = Math.max(w, 1);
        }
        _yuitest_coverline("/build/charts-base/charts-base.js", 9994);
if(!useOrigin)
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 9996);
lastCollection = seriesCollection[order - 1];
            _yuitest_coverline("/build/charts-base/charts-base.js", 9997);
negativeBaseValues = lastCollection.get("negativeBaseValues");
            _yuitest_coverline("/build/charts-base/charts-base.js", 9998);
positiveBaseValues = lastCollection.get("positiveBaseValues");
            _yuitest_coverline("/build/charts-base/charts-base.js", 9999);
if(!negativeBaseValues || !positiveBaseValues)
            {
                _yuitest_coverline("/build/charts-base/charts-base.js", 10001);
useOrigin = true;
                _yuitest_coverline("/build/charts-base/charts-base.js", 10002);
positiveBaseValues = [];
                _yuitest_coverline("/build/charts-base/charts-base.js", 10003);
negativeBaseValues = [];
            }
        }
        else
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 10008);
negativeBaseValues = [];
            _yuitest_coverline("/build/charts-base/charts-base.js", 10009);
positiveBaseValues = [];
        }
        _yuitest_coverline("/build/charts-base/charts-base.js", 10011);
this.set("negativeBaseValues", negativeBaseValues);
        _yuitest_coverline("/build/charts-base/charts-base.js", 10012);
this.set("positiveBaseValues", positiveBaseValues);
        _yuitest_coverline("/build/charts-base/charts-base.js", 10013);
for(i = 0; i < len; ++i)
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 10015);
left = xcoords[i];
            _yuitest_coverline("/build/charts-base/charts-base.js", 10016);
top = ycoords[i];
            
            _yuitest_coverline("/build/charts-base/charts-base.js", 10018);
if(!isNumber(top) || !isNumber(left))
            {
                _yuitest_coverline("/build/charts-base/charts-base.js", 10020);
if(useOrigin)
                {
                    _yuitest_coverline("/build/charts-base/charts-base.js", 10022);
negativeBaseValues[i] = this._bottomOrigin;
                    _yuitest_coverline("/build/charts-base/charts-base.js", 10023);
positiveBaseValues[i] = this._bottomOrigin;
                }
                _yuitest_coverline("/build/charts-base/charts-base.js", 10025);
this._markers.push(null); 
                _yuitest_coverline("/build/charts-base/charts-base.js", 10026);
continue;
            }
            _yuitest_coverline("/build/charts-base/charts-base.js", 10028);
if(useOrigin)
            {
                _yuitest_coverline("/build/charts-base/charts-base.js", 10030);
h = Math.abs(this._bottomOrigin - top);
                _yuitest_coverline("/build/charts-base/charts-base.js", 10031);
if(top < this._bottomOrigin)
                {
                    _yuitest_coverline("/build/charts-base/charts-base.js", 10033);
positiveBaseValues[i] = top;
                    _yuitest_coverline("/build/charts-base/charts-base.js", 10034);
negativeBaseValues[i] = this._bottomOrigin;
                }
                else {_yuitest_coverline("/build/charts-base/charts-base.js", 10036);
if(top > this._bottomOrigin)
                {
                    _yuitest_coverline("/build/charts-base/charts-base.js", 10038);
positiveBaseValues[i] = this._bottomOrigin;
                    _yuitest_coverline("/build/charts-base/charts-base.js", 10039);
negativeBaseValues[i] = top;
                    _yuitest_coverline("/build/charts-base/charts-base.js", 10040);
top -= h;
                }
                else
                {
                    _yuitest_coverline("/build/charts-base/charts-base.js", 10044);
positiveBaseValues[i] = top;
                    _yuitest_coverline("/build/charts-base/charts-base.js", 10045);
negativeBaseValues[i] = top;
                }}
            }
            else 
            {
                _yuitest_coverline("/build/charts-base/charts-base.js", 10050);
if(top > this._bottomOrigin)
                {
                    _yuitest_coverline("/build/charts-base/charts-base.js", 10052);
top += (negativeBaseValues[i] - this._bottomOrigin);
                    _yuitest_coverline("/build/charts-base/charts-base.js", 10053);
h = top - negativeBaseValues[i];
                    _yuitest_coverline("/build/charts-base/charts-base.js", 10054);
negativeBaseValues[i] = top;
                    _yuitest_coverline("/build/charts-base/charts-base.js", 10055);
top -= h;
                }
                else {_yuitest_coverline("/build/charts-base/charts-base.js", 10057);
if(top <= this._bottomOrigin)
                {
                    _yuitest_coverline("/build/charts-base/charts-base.js", 10059);
top = positiveBaseValues[i] - (this._bottomOrigin - top);
                    _yuitest_coverline("/build/charts-base/charts-base.js", 10060);
h = positiveBaseValues[i] - top;
                    _yuitest_coverline("/build/charts-base/charts-base.js", 10061);
positiveBaseValues[i] = top;
                }}
            }
            _yuitest_coverline("/build/charts-base/charts-base.js", 10064);
if(!isNaN(h) && h > 0)
            {
                _yuitest_coverline("/build/charts-base/charts-base.js", 10066);
left -= w/2;
                _yuitest_coverline("/build/charts-base/charts-base.js", 10067);
if(groupMarkers)
                {
                    _yuitest_coverline("/build/charts-base/charts-base.js", 10069);
dimensions.width[i] = w;
                    _yuitest_coverline("/build/charts-base/charts-base.js", 10070);
dimensions.height[i] = h;
                    _yuitest_coverline("/build/charts-base/charts-base.js", 10071);
xvalues.push(left);
                    _yuitest_coverline("/build/charts-base/charts-base.js", 10072);
yvalues.push(top);
                }
                else
                {
                    _yuitest_coverline("/build/charts-base/charts-base.js", 10076);
style.width = w;
                    _yuitest_coverline("/build/charts-base/charts-base.js", 10077);
style.height = h;
                    _yuitest_coverline("/build/charts-base/charts-base.js", 10078);
style.x = left;
                    _yuitest_coverline("/build/charts-base/charts-base.js", 10079);
style.y = top;
                    _yuitest_coverline("/build/charts-base/charts-base.js", 10080);
if(fillColors)
                    {
                        _yuitest_coverline("/build/charts-base/charts-base.js", 10082);
style.fill.color = fillColors[i % fillColors.length];
                    }
                    _yuitest_coverline("/build/charts-base/charts-base.js", 10084);
if(borderColors)
                    {
                        _yuitest_coverline("/build/charts-base/charts-base.js", 10086);
style.border.color = borderColors[i % borderColors.length];
                    }
                    _yuitest_coverline("/build/charts-base/charts-base.js", 10088);
marker = this.getMarker(style, graphOrder, i);
                }
            }
            else {_yuitest_coverline("/build/charts-base/charts-base.js", 10091);
if(!groupMarkers)
            {
               _yuitest_coverline("/build/charts-base/charts-base.js", 10093);
this._markers.push(null);
            }}
        }
        _yuitest_coverline("/build/charts-base/charts-base.js", 10096);
if(groupMarkers)
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 10098);
this._createGroupMarker({
                fill: style.fill,
                border: style.border,
                dimensions: dimensions,
                xvalues: xvalues,
                yvalues: yvalues,
                shape: style.shape
            });
        }
        else
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 10109);
this._clearMarkerCache();
        }
    },

    /**
     * Resizes and positions markers based on a mouse interaction.
     *
     * @method updateMarkerState
     * @param {String} type state of the marker
     * @param {Number} i index of the marker
     * @protected
     */
    updateMarkerState: function(type, i)
    {
        _yuitest_coverfunc("/build/charts-base/charts-base.js", "updateMarkerState", 10121);
_yuitest_coverline("/build/charts-base/charts-base.js", 10123);
if(this._markers && this._markers[i])
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 10125);
var styles,
                markerStyles,
                state = this._getState(type),
                xcoords = this.get("xcoords"),
                marker = this._markers[i],
                offset = 0,
                fillColor,
                borderColor;        
            _yuitest_coverline("/build/charts-base/charts-base.js", 10133);
styles = this.get("styles").marker;
            _yuitest_coverline("/build/charts-base/charts-base.js", 10134);
offset = styles.width * 0.5;
            _yuitest_coverline("/build/charts-base/charts-base.js", 10135);
markerStyles = state == "off" || !styles[state] ? Y.clone(styles) : Y.clone(styles[state]); 
            _yuitest_coverline("/build/charts-base/charts-base.js", 10136);
markerStyles.height = marker.get("height");
            _yuitest_coverline("/build/charts-base/charts-base.js", 10137);
markerStyles.x = (xcoords[i] - offset);
            _yuitest_coverline("/build/charts-base/charts-base.js", 10138);
markerStyles.y = marker.get("y");
            _yuitest_coverline("/build/charts-base/charts-base.js", 10139);
markerStyles.id = marker.get("id");
            _yuitest_coverline("/build/charts-base/charts-base.js", 10140);
fillColor = markerStyles.fill.color; 
            _yuitest_coverline("/build/charts-base/charts-base.js", 10141);
borderColor = markerStyles.border.color;
            _yuitest_coverline("/build/charts-base/charts-base.js", 10142);
if(Y_Lang.isArray(fillColor))
            {
                _yuitest_coverline("/build/charts-base/charts-base.js", 10144);
markerStyles.fill.color = fillColor[i % fillColor.length];
            }
            else
            {
                _yuitest_coverline("/build/charts-base/charts-base.js", 10148);
markerStyles.fill.color = this._getItemColor(markerStyles.fill.color, i);
            }
            _yuitest_coverline("/build/charts-base/charts-base.js", 10150);
if(Y_Lang.isArray(borderColor))
            {
                _yuitest_coverline("/build/charts-base/charts-base.js", 10152);
markerStyles.border.color = borderColor[i % borderColor.length];
            }
            else
            {
                _yuitest_coverline("/build/charts-base/charts-base.js", 10156);
markerStyles.border.color = this._getItemColor(markerStyles.border.color, i);
            }
            _yuitest_coverline("/build/charts-base/charts-base.js", 10158);
marker.set(markerStyles);
        }
    },
	
    /**
     * Gets the default values for the markers. 
     *
     * @method _getPlotDefaults
     * @return Object
     * @protected
     */
    _getPlotDefaults: function()
    {
        _yuitest_coverfunc("/build/charts-base/charts-base.js", "_getPlotDefaults", 10169);
_yuitest_coverline("/build/charts-base/charts-base.js", 10171);
var defs = {
            fill:{
                type: "solid",
                alpha: 1,
                colors:null,
                alphas: null,
                ratios: null
            },
            border:{
                weight: 0,
                alpha: 1
            },
            width: 24,
            height: 24,
            shape: "rect",

            padding:{
                top: 0,
                left: 0,
                right: 0,
                bottom: 0
            }
        };
        _yuitest_coverline("/build/charts-base/charts-base.js", 10194);
defs.fill.color = this._getDefaultColor(this.get("graphOrder"), "fill");
        _yuitest_coverline("/build/charts-base/charts-base.js", 10195);
defs.border.color = this._getDefaultColor(this.get("graphOrder"), "border");
        _yuitest_coverline("/build/charts-base/charts-base.js", 10196);
return defs;
    }
}, {
    ATTRS: {
        /**
         * Read-only attribute indicating the type of series.
         *
         * @attribute type
         * @type String
         * @default stackedColumn
         */
        type: {
            value: "stackedColumn"
        },

        /**
         * @attribute negativeBaseValues
         * @type Array
         * @default null
         * @private
         */
        negativeBaseValues: {
            value: null
        },

        /**
         * @attribute positiveBaseValues
         * @type Array
         * @default null
         * @private
         */
        positiveBaseValues: {
            value: null
        }
        
        /**
         * Style properties used for drawing markers. This attribute is inherited from `ColumnSeries`. Below are the default values:
         *  <dl>
         *      <dt>fill</dt><dd>A hash containing the following values:
         *          <dl>
         *              <dt>color</dt><dd>Color of the fill. The default value is determined by the order of the series on the graph. The color
         *              will be retrieved from the below array:<br/>
         *              `["#66007f", "#a86f41", "#295454", "#996ab2", "#e8cdb7", "#90bdbd","#000000","#c3b8ca", "#968373", "#678585"]`
         *              </dd>
         *              <dt>alpha</dt><dd>Number from 0 to 1 indicating the opacity of the marker fill. The default value is 1.</dd>
         *          </dl>
         *      </dd>
         *      <dt>border</dt><dd>A hash containing the following values:
         *          <dl>
         *              <dt>color</dt><dd>Color of the border. The default value is determined by the order of the series on the graph. The color
         *              will be retrieved from the below array:<br/>
         *              `["#205096", "#b38206", "#000000", "#94001e", "#9d6fa0", "#e55b00", "#5e85c9", "#adab9e", "#6ac291", "#006457"]`
         *              <dt>alpha</dt><dd>Number from 0 to 1 indicating the opacity of the marker border. The default value is 1.</dd>
         *              <dt>weight</dt><dd>Number indicating the width of the border. The default value is 1.</dd>
         *          </dl>
         *      </dd>
         *      <dt>width</dt><dd>indicates the width of the marker. The default value is 24.</dd>
         *      <dt>over</dt><dd>hash containing styles for markers when highlighted by a `mouseover` event. The default 
         *      values for each style is null. When an over style is not set, the non-over value will be used. For example,
         *      the default value for `marker.over.fill.color` is equivalent to `marker.fill.color`.</dd>
         *  </dl>
         *
         * @attribute styles
         * @type Object
         */
    }
});

/**
 * The StackedBarSeries renders bar chart in which series are stacked horizontally to show
 * their contribution to the cumulative total.
 *
 * @module charts
 * @submodule charts-base
 * @class StackedBarSeries
 * @extends BarSeries
 * @uses StackingUtil
 * @constructor
 */
_yuitest_coverline("/build/charts-base/charts-base.js", 10275);
Y.StackedBarSeries = Y.Base.create("stackedBarSeries", Y.BarSeries, [Y.StackingUtil], {
    /**
     * @protected
     *
     * Draws the series.
     *
     * @method drawSeries
     */
    drawSeries: function()
	{
        _yuitest_coverfunc("/build/charts-base/charts-base.js", "drawSeries", 10283);
_yuitest_coverline("/build/charts-base/charts-base.js", 10285);
if(this.get("xcoords").length < 1) 
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 10287);
return;
        }

        _yuitest_coverline("/build/charts-base/charts-base.js", 10290);
var isNumber = Y_Lang.isNumber,
            style = Y.clone(this.get("styles").marker),
            w = style.width,
            h = style.height,
            xcoords = this.get("xcoords"),
            ycoords = this.get("ycoords"),
            i = 0,
            len = xcoords.length,
            top = ycoords[0],
            type = this.get("type"),
            graph = this.get("graph"),
            seriesCollection = graph.seriesTypes[type],
            ratio,
            order = this.get("order"),
            graphOrder = this.get("graphOrder"),
            left,
            marker,
            lastCollection,
            negativeBaseValues,
            positiveBaseValues,
            fillColors,
            borderColors,
            useOrigin = order === 0,
            totalHeight = len * h,
            dimensions = {
                width: [],
                height: []
            },
            xvalues = [],
            yvalues = [],
            groupMarkers = this.get("groupMarkers");
        _yuitest_coverline("/build/charts-base/charts-base.js", 10321);
if(Y_Lang.isArray(style.fill.color))
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 10323);
fillColors = style.fill.color.concat(); 
        }
        _yuitest_coverline("/build/charts-base/charts-base.js", 10325);
if(Y_Lang.isArray(style.border.color))
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 10327);
borderColors = style.border.color.concat();
        }
        _yuitest_coverline("/build/charts-base/charts-base.js", 10329);
this._createMarkerCache();
        _yuitest_coverline("/build/charts-base/charts-base.js", 10330);
if(totalHeight > this.get("height"))
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 10332);
ratio = this.height/totalHeight;
            _yuitest_coverline("/build/charts-base/charts-base.js", 10333);
h *= ratio;
            _yuitest_coverline("/build/charts-base/charts-base.js", 10334);
h = Math.max(h, 1);
        }
        _yuitest_coverline("/build/charts-base/charts-base.js", 10336);
if(!useOrigin)
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 10338);
lastCollection = seriesCollection[order - 1];
            _yuitest_coverline("/build/charts-base/charts-base.js", 10339);
negativeBaseValues = lastCollection.get("negativeBaseValues");
            _yuitest_coverline("/build/charts-base/charts-base.js", 10340);
positiveBaseValues = lastCollection.get("positiveBaseValues");
            _yuitest_coverline("/build/charts-base/charts-base.js", 10341);
if(!negativeBaseValues || !positiveBaseValues)
            {
                _yuitest_coverline("/build/charts-base/charts-base.js", 10343);
useOrigin = true;
                _yuitest_coverline("/build/charts-base/charts-base.js", 10344);
positiveBaseValues = [];
                _yuitest_coverline("/build/charts-base/charts-base.js", 10345);
negativeBaseValues = [];
            }
        }
        else
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 10350);
negativeBaseValues = [];
            _yuitest_coverline("/build/charts-base/charts-base.js", 10351);
positiveBaseValues = [];
        }
        _yuitest_coverline("/build/charts-base/charts-base.js", 10353);
this.set("negativeBaseValues", negativeBaseValues);
        _yuitest_coverline("/build/charts-base/charts-base.js", 10354);
this.set("positiveBaseValues", positiveBaseValues);
        _yuitest_coverline("/build/charts-base/charts-base.js", 10355);
for(i = 0; i < len; ++i)
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 10357);
top = ycoords[i];
            _yuitest_coverline("/build/charts-base/charts-base.js", 10358);
left = xcoords[i];
            _yuitest_coverline("/build/charts-base/charts-base.js", 10359);
if(!isNumber(top) || !isNumber(left))
            {
                _yuitest_coverline("/build/charts-base/charts-base.js", 10361);
if(useOrigin)
                {
                    _yuitest_coverline("/build/charts-base/charts-base.js", 10363);
positiveBaseValues[i] = this._leftOrigin;
                    _yuitest_coverline("/build/charts-base/charts-base.js", 10364);
negativeBaseValues[i] = this._leftOrigin;
                }
                _yuitest_coverline("/build/charts-base/charts-base.js", 10366);
this._markers.push(null);
                _yuitest_coverline("/build/charts-base/charts-base.js", 10367);
continue;
            }
            _yuitest_coverline("/build/charts-base/charts-base.js", 10369);
if(useOrigin)
            {
                _yuitest_coverline("/build/charts-base/charts-base.js", 10371);
w = Math.abs(left - this._leftOrigin);
                _yuitest_coverline("/build/charts-base/charts-base.js", 10372);
if(left > this._leftOrigin)
                {
                    _yuitest_coverline("/build/charts-base/charts-base.js", 10374);
positiveBaseValues[i] = left;
                    _yuitest_coverline("/build/charts-base/charts-base.js", 10375);
negativeBaseValues[i] = this._leftOrigin;
                    _yuitest_coverline("/build/charts-base/charts-base.js", 10376);
left -= w;
                }
                else {_yuitest_coverline("/build/charts-base/charts-base.js", 10378);
if(left < this._leftOrigin)
                {   
                    _yuitest_coverline("/build/charts-base/charts-base.js", 10380);
positiveBaseValues[i] = this._leftOrigin;
                    _yuitest_coverline("/build/charts-base/charts-base.js", 10381);
negativeBaseValues[i] = left;
                }
                else
                {
                    _yuitest_coverline("/build/charts-base/charts-base.js", 10385);
positiveBaseValues[i] = left;
                    _yuitest_coverline("/build/charts-base/charts-base.js", 10386);
negativeBaseValues[i] = this._leftOrigin;
                }}
            }
            else
            {
                _yuitest_coverline("/build/charts-base/charts-base.js", 10391);
if(left < this._leftOrigin)
                {
                    _yuitest_coverline("/build/charts-base/charts-base.js", 10393);
left = negativeBaseValues[i] - (this._leftOrigin - xcoords[i]);
                    _yuitest_coverline("/build/charts-base/charts-base.js", 10394);
w = negativeBaseValues[i] - left;
                    _yuitest_coverline("/build/charts-base/charts-base.js", 10395);
negativeBaseValues[i] = left;
                }
                else {_yuitest_coverline("/build/charts-base/charts-base.js", 10397);
if(left >= this._leftOrigin)
                {
                    _yuitest_coverline("/build/charts-base/charts-base.js", 10399);
left += (positiveBaseValues[i] - this._leftOrigin);
                    _yuitest_coverline("/build/charts-base/charts-base.js", 10400);
w = left - positiveBaseValues[i];
                    _yuitest_coverline("/build/charts-base/charts-base.js", 10401);
positiveBaseValues[i] = left;
                    _yuitest_coverline("/build/charts-base/charts-base.js", 10402);
left -= w;
                }}
            }
            _yuitest_coverline("/build/charts-base/charts-base.js", 10405);
if(!isNaN(w) && w > 0)
            {
                _yuitest_coverline("/build/charts-base/charts-base.js", 10407);
top -= h/2;
                _yuitest_coverline("/build/charts-base/charts-base.js", 10408);
if(groupMarkers)
                {
                    _yuitest_coverline("/build/charts-base/charts-base.js", 10410);
dimensions.width[i] = w;
                    _yuitest_coverline("/build/charts-base/charts-base.js", 10411);
dimensions.height[i] = h;
                    _yuitest_coverline("/build/charts-base/charts-base.js", 10412);
xvalues.push(left);
                    _yuitest_coverline("/build/charts-base/charts-base.js", 10413);
yvalues.push(top);
                }
                else
                {
                    _yuitest_coverline("/build/charts-base/charts-base.js", 10417);
style.width = w;
                    _yuitest_coverline("/build/charts-base/charts-base.js", 10418);
style.height = h;
                    _yuitest_coverline("/build/charts-base/charts-base.js", 10419);
style.x = left;
                    _yuitest_coverline("/build/charts-base/charts-base.js", 10420);
style.y = top;
                    _yuitest_coverline("/build/charts-base/charts-base.js", 10421);
if(fillColors)
                    {
                        _yuitest_coverline("/build/charts-base/charts-base.js", 10423);
style.fill.color = fillColors[i % fillColors.length];
                    }
                    _yuitest_coverline("/build/charts-base/charts-base.js", 10425);
if(borderColors)
                    {
                        _yuitest_coverline("/build/charts-base/charts-base.js", 10427);
style.border.color = borderColors[i % borderColors.length];
                    }
                    _yuitest_coverline("/build/charts-base/charts-base.js", 10429);
marker = this.getMarker(style, graphOrder, i);
                }
            }
            else {_yuitest_coverline("/build/charts-base/charts-base.js", 10432);
if(!groupMarkers)
            {
                _yuitest_coverline("/build/charts-base/charts-base.js", 10434);
this._markers.push(null);
            }}
        }
        _yuitest_coverline("/build/charts-base/charts-base.js", 10437);
if(groupMarkers)
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 10439);
this._createGroupMarker({
                fill: style.fill,
                border: style.border,
                dimensions: dimensions,
                xvalues: xvalues,
                yvalues: yvalues,
                shape: style.shape
            });
        }
        else
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 10450);
this._clearMarkerCache();
        }
    },

    /**
     * @protected
     *
     * Resizes and positions markers based on a mouse interaction.
     *
     * @method updateMarkerState
     * @param {String} type state of the marker
     * @param {Number} i index of the marker
     */
    updateMarkerState: function(type, i)
    {
        _yuitest_coverfunc("/build/charts-base/charts-base.js", "updateMarkerState", 10463);
_yuitest_coverline("/build/charts-base/charts-base.js", 10465);
if(this._markers[i])
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 10467);
var state = this._getState(type),
                ycoords = this.get("ycoords"),
                marker = this._markers[i],
                styles = this.get("styles").marker,
                h = styles.height,
                markerStyles = state == "off" || !styles[state] ? Y.clone(styles) : Y.clone(styles[state]), 
                fillColor,
                borderColor;        
            _yuitest_coverline("/build/charts-base/charts-base.js", 10475);
markerStyles.y = (ycoords[i] - h/2);
            _yuitest_coverline("/build/charts-base/charts-base.js", 10476);
markerStyles.x = marker.get("x");
            _yuitest_coverline("/build/charts-base/charts-base.js", 10477);
markerStyles.width = marker.get("width");
            _yuitest_coverline("/build/charts-base/charts-base.js", 10478);
markerStyles.id = marker.get("id");
            _yuitest_coverline("/build/charts-base/charts-base.js", 10479);
fillColor = markerStyles.fill.color; 
            _yuitest_coverline("/build/charts-base/charts-base.js", 10480);
borderColor = markerStyles.border.color;
            _yuitest_coverline("/build/charts-base/charts-base.js", 10481);
if(Y_Lang.isArray(fillColor))
            {
                _yuitest_coverline("/build/charts-base/charts-base.js", 10483);
markerStyles.fill.color = fillColor[i % fillColor.length];
            }
            else
            {
                _yuitest_coverline("/build/charts-base/charts-base.js", 10487);
markerStyles.fill.color = this._getItemColor(markerStyles.fill.color, i);
            }
            _yuitest_coverline("/build/charts-base/charts-base.js", 10489);
if(Y_Lang.isArray(borderColor))
            {
                _yuitest_coverline("/build/charts-base/charts-base.js", 10491);
markerStyles.border.color = borderColor[i % borderColor.length];
            }
            else
            {
                _yuitest_coverline("/build/charts-base/charts-base.js", 10495);
markerStyles.border.color = this._getItemColor(markerStyles.border.color, i);
            }
            _yuitest_coverline("/build/charts-base/charts-base.js", 10497);
marker.set(markerStyles);
        }
    },
	
    /**
     * @protected
     *
     * Returns default values for the `styles` attribute.
     * 
     * @method _getPlotDefaults
     * @return Object
     */
    _getPlotDefaults: function()
    {
        _yuitest_coverfunc("/build/charts-base/charts-base.js", "_getPlotDefaults", 10509);
_yuitest_coverline("/build/charts-base/charts-base.js", 10511);
var defs = {
            fill:{
                type: "solid",
                alpha: 1,
                colors:null,
                alphas: null,
                ratios: null
            },
            border:{
                weight: 0,
                alpha: 1
            },
            width: 24,
            height: 24,
            shape: "rect",

            padding:{
                top: 0,
                left: 0,
                right: 0,
                bottom: 0
            }
        };
        _yuitest_coverline("/build/charts-base/charts-base.js", 10534);
defs.fill.color = this._getDefaultColor(this.get("graphOrder"), "fill");
        _yuitest_coverline("/build/charts-base/charts-base.js", 10535);
defs.border.color = this._getDefaultColor(this.get("graphOrder"), "border");
        _yuitest_coverline("/build/charts-base/charts-base.js", 10536);
return defs;
    }
}, {
    ATTRS: {
        /**
         * Read-only attribute indicating the type of series.
         *
         * @attribute type
         * @type String
         * @default stackedBar
         */
        type: {
            value: "stackedBar"
        },

        /**
         * Direction of the series
         *
         * @attribute direction
         * @type String
         * @default vertical
         */
        direction: {
            value: "vertical"
        },

        /**
         * @private
         *
         * @attribute negativeBaseValues
         * @type Array
         * @default null
         */
        negativeBaseValues: {
            value: null
        },

        /**
         * @private
         *
         * @attribute positiveBaseValues
         * @type Array
         * @default null
         */
        positiveBaseValues: {
            value: null
        }
        
        /**
         * Style properties used for drawing markers. This attribute is inherited from `BarSeries`. Below are the default values:
         *  <dl>
         *      <dt>fill</dt><dd>A hash containing the following values:
         *          <dl>
         *              <dt>color</dt><dd>Color of the fill. The default value is determined by the order of the series on the graph. The color
         *              will be retrieved from the below array:<br/>
         *              `["#66007f", "#a86f41", "#295454", "#996ab2", "#e8cdb7", "#90bdbd","#000000","#c3b8ca", "#968373", "#678585"]`
         *              </dd>
         *              <dt>alpha</dt><dd>Number from 0 to 1 indicating the opacity of the marker fill. The default value is 1.</dd>
         *          </dl>
         *      </dd>
         *      <dt>border</dt><dd>A hash containing the following values:
         *          <dl>
         *              <dt>color</dt><dd>Color of the border. The default value is determined by the order of the series on the graph. The color
         *              will be retrieved from the below array:<br/>
         *              `["#205096", "#b38206", "#000000", "#94001e", "#9d6fa0", "#e55b00", "#5e85c9", "#adab9e", "#6ac291", "#006457"]`
         *              <dt>alpha</dt><dd>Number from 0 to 1 indicating the opacity of the marker border. The default value is 1.</dd>
         *              <dt>weight</dt><dd>Number indicating the width of the border. The default value is 1.</dd>
         *          </dl>
         *      </dd>
         *      <dt>height</dt><dd>indicates the width of the marker. The default value is 24.</dd>
         *      <dt>over</dt><dd>hash containing styles for markers when highlighted by a `mouseover` event. The default 
         *      values for each style is null. When an over style is not set, the non-over value will be used. For example,
         *      the default value for `marker.over.fill.color` is equivalent to `marker.fill.color`.</dd>
         *  </dl>
         *
         * @attribute styles
         * @type Object
         */
    }
});

/**
 * PieSeries visualizes data as a circular chart divided into wedges which represent data as a 
 * percentage of a whole.
 *
 * @module charts
 * @submodule charts-base
 * @class PieSeries
 * @constructor
 * @extends MarkerSeries
 */
_yuitest_coverline("/build/charts-base/charts-base.js", 10627);
Y.PieSeries = Y.Base.create("pieSeries", Y.MarkerSeries, [], { 
    /**
     * Image map used for interactivity when rendered with canvas.
     *
     * @property _map
     * @type HTMLElement
     * @private
     */
    _map: null,

    /**
     * Image used for image map when rendered with canvas.
     *
     * @property _image
     * @type HTMLElement
     * @private
     */
    _image: null,

    /**
     * Creates or updates the image map when rendered with canvas.
     *
     * @method _setMap
     * @private
     */
    _setMap: function()
    {
        _yuitest_coverfunc("/build/charts-base/charts-base.js", "_setMap", 10652);
_yuitest_coverline("/build/charts-base/charts-base.js", 10654);
var id = "pieHotSpotMapi_" + Math.round(100000 * Math.random()),
            cb = this.get("graph").get("contentBox"),
            areaNode;
        _yuitest_coverline("/build/charts-base/charts-base.js", 10657);
if(this._image)
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 10659);
cb.removeChild(this._image);
            _yuitest_coverline("/build/charts-base/charts-base.js", 10660);
while(this._areaNodes && this._areaNodes.length > 0)
            {
                _yuitest_coverline("/build/charts-base/charts-base.js", 10662);
areaNode = this._areaNodes.shift();
                _yuitest_coverline("/build/charts-base/charts-base.js", 10663);
this._map.removeChild(areaNode);
            }
            _yuitest_coverline("/build/charts-base/charts-base.js", 10665);
cb.removeChild(this._map);
        }
        _yuitest_coverline("/build/charts-base/charts-base.js", 10667);
this._image = DOCUMENT.createElement("img"); 
        _yuitest_coverline("/build/charts-base/charts-base.js", 10668);
this._image.src = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAYAAAABCAYAAAD9yd/wAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAABJJREFUeNpiZGBgSGPAAgACDAAIkABoFyloZQAAAABJRU5ErkJggg==";
        _yuitest_coverline("/build/charts-base/charts-base.js", 10669);
cb.appendChild(this._image);
        _yuitest_coverline("/build/charts-base/charts-base.js", 10670);
this._image.setAttribute("usemap", "#" + id);
        _yuitest_coverline("/build/charts-base/charts-base.js", 10671);
this._image.style.zIndex = 3;
        _yuitest_coverline("/build/charts-base/charts-base.js", 10672);
this._image.style.opacity = 0;
        _yuitest_coverline("/build/charts-base/charts-base.js", 10673);
this._image.setAttribute("alt", "imagemap");
        _yuitest_coverline("/build/charts-base/charts-base.js", 10674);
this._map = DOCUMENT.createElement("map");
        _yuitest_coverline("/build/charts-base/charts-base.js", 10675);
this._map.style.zIndex = 5;
        _yuitest_coverline("/build/charts-base/charts-base.js", 10676);
cb.appendChild(this._map);
        _yuitest_coverline("/build/charts-base/charts-base.js", 10677);
this._map.setAttribute("name", id);
        _yuitest_coverline("/build/charts-base/charts-base.js", 10678);
this._map.setAttribute("id", id);
        _yuitest_coverline("/build/charts-base/charts-base.js", 10679);
this._areaNodes = [];
    },

    /**
     * Storage for `categoryDisplayName` attribute.
     *
     * @property _categoryDisplayName
     * @private
     */
    _categoryDisplayName: null,
    
    /**
     * Storage for `valueDisplayName` attribute.
     *
     * @property _valueDisplayName
     * @private
     */
    _valueDisplayName: null,

    /**
     * Adds event listeners.
     *
     * @method addListeners
     * @private
     */
    addListeners: function()
    {
        _yuitest_coverfunc("/build/charts-base/charts-base.js", "addListeners", 10704);
_yuitest_coverline("/build/charts-base/charts-base.js", 10706);
var categoryAxis = this.get("categoryAxis"),
            valueAxis = this.get("valueAxis");
        _yuitest_coverline("/build/charts-base/charts-base.js", 10708);
if(categoryAxis)
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 10710);
categoryAxis.after("dataReady", Y.bind(this._categoryDataChangeHandler, this));
            _yuitest_coverline("/build/charts-base/charts-base.js", 10711);
categoryAxis.after("dataUpdate", Y.bind(this._categoryDataChangeHandler, this));
        }
        _yuitest_coverline("/build/charts-base/charts-base.js", 10713);
if(valueAxis)
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 10715);
valueAxis.after("dataReady", Y.bind(this._valueDataChangeHandler, this));
            _yuitest_coverline("/build/charts-base/charts-base.js", 10716);
valueAxis.after("dataUpdate", Y.bind(this._valueDataChangeHandler, this));
        }
        _yuitest_coverline("/build/charts-base/charts-base.js", 10718);
this.after("categoryAxisChange", this.categoryAxisChangeHandler);
        _yuitest_coverline("/build/charts-base/charts-base.js", 10719);
this.after("valueAxisChange", this.valueAxisChangeHandler);
        _yuitest_coverline("/build/charts-base/charts-base.js", 10720);
this.after("stylesChange", this._updateHandler);
    },
    
    /**
     * Draws the series.
     *
     * @method validate
     * @private
     */
    validate: function()
    {
        _yuitest_coverfunc("/build/charts-base/charts-base.js", "validate", 10729);
_yuitest_coverline("/build/charts-base/charts-base.js", 10731);
this.draw();
        _yuitest_coverline("/build/charts-base/charts-base.js", 10732);
this._renderered = true;
    },

    /**
     * Event handler for the categoryAxisChange event.
     *
     * @method _categoryAxisChangeHandler
     * @param {Object} e Event object.
     * @private
     */
    _categoryAxisChangeHandler: function(e)
    {
        _yuitest_coverfunc("/build/charts-base/charts-base.js", "_categoryAxisChangeHandler", 10742);
_yuitest_coverline("/build/charts-base/charts-base.js", 10744);
var categoryAxis = this.get("categoryAxis");
        _yuitest_coverline("/build/charts-base/charts-base.js", 10745);
categoryAxis.after("dataReady", Y.bind(this._categoryDataChangeHandler, this));
        _yuitest_coverline("/build/charts-base/charts-base.js", 10746);
categoryAxis.after("dataUpdate", Y.bind(this._categoryDataChangeHandler, this));
    },
    
    /**
     * Event handler for the valueAxisChange event.
     *
     * @method _valueAxisChangeHandler
     * @param {Object} e Event object.
     * @private
     */
    _valueAxisChangeHandler: function(e)
    {
        _yuitest_coverfunc("/build/charts-base/charts-base.js", "_valueAxisChangeHandler", 10756);
_yuitest_coverline("/build/charts-base/charts-base.js", 10758);
var valueAxis = this.get("valueAxis");
        _yuitest_coverline("/build/charts-base/charts-base.js", 10759);
valueAxis.after("dataReady", Y.bind(this._valueDataChangeHandler, this));
        _yuitest_coverline("/build/charts-base/charts-base.js", 10760);
valueAxis.after("dataUpdate", Y.bind(this._valueDataChangeHandler, this));
    },
	
    /**
     * Constant used to generate unique id.
     *
     * @property GUID
     * @type String
     * @private
     */
    GUID: "pieseries",
	
    /**
     * Event handler for categoryDataChange event.
     *
     * @method _categoryDataChangeHandler
     * @param {Object} event Event object.
     * @private 
     */
    _categoryDataChangeHandler: function(event)
    {
       _yuitest_coverfunc("/build/charts-base/charts-base.js", "_categoryDataChangeHandler", 10779);
_yuitest_coverline("/build/charts-base/charts-base.js", 10781);
if(this._rendered && this.get("categoryKey") && this.get("valueKey"))
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 10783);
this.draw();
        }
    },

    /**
     * Event handler for valueDataChange event.
     *
     * @method _valueDataChangeHandler
     * @param {Object} event Event object.
     * @private 
     */
    _valueDataChangeHandler: function(event)
    {
        _yuitest_coverfunc("/build/charts-base/charts-base.js", "_valueDataChangeHandler", 10794);
_yuitest_coverline("/build/charts-base/charts-base.js", 10796);
if(this._rendered && this.get("categoryKey") && this.get("valueKey"))
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 10798);
this.draw();
        }
    },
   
    /**
     * Draws the series. Overrides the base implementation.
     *
     * @method draw
     * @protected
     */
    draw: function()
    {
        _yuitest_coverfunc("/build/charts-base/charts-base.js", "draw", 10808);
_yuitest_coverline("/build/charts-base/charts-base.js", 10810);
var graph = this.get("graph"),
            w = graph.get("width"),
            h = graph.get("height");
        _yuitest_coverline("/build/charts-base/charts-base.js", 10813);
if(isFinite(w) && isFinite(h) && w > 0 && h > 0)
        {   
            _yuitest_coverline("/build/charts-base/charts-base.js", 10815);
this._rendered = true;
            _yuitest_coverline("/build/charts-base/charts-base.js", 10816);
if(this._drawing)
            {
                _yuitest_coverline("/build/charts-base/charts-base.js", 10818);
this._callLater = true;
                _yuitest_coverline("/build/charts-base/charts-base.js", 10819);
return;
            }
            _yuitest_coverline("/build/charts-base/charts-base.js", 10821);
this._drawing = true;
            _yuitest_coverline("/build/charts-base/charts-base.js", 10822);
this._callLater = false;
            _yuitest_coverline("/build/charts-base/charts-base.js", 10823);
this.drawSeries();
            _yuitest_coverline("/build/charts-base/charts-base.js", 10824);
this._drawing = false;
            _yuitest_coverline("/build/charts-base/charts-base.js", 10825);
if(this._callLater)
            {
                _yuitest_coverline("/build/charts-base/charts-base.js", 10827);
this.draw();
            }
            else
            {
                _yuitest_coverline("/build/charts-base/charts-base.js", 10831);
this.fire("drawingComplete");
            }
        }
    },

    /**
     * Draws the markers
     *
     * @method drawPlots
     * @protected
     */
    drawPlots: function()
    {
        _yuitest_coverfunc("/build/charts-base/charts-base.js", "drawPlots", 10842);
_yuitest_coverline("/build/charts-base/charts-base.js", 10844);
var values = this.get("valueAxis").getDataByKey(this.get("valueKey")).concat(),
            catValues = this.get("categoryAxis").getDataByKey(this.get("categoryKey")).concat(),
            totalValue = 0,
            itemCount = values.length,
            styles = this.get("styles").marker,
            fillColors = styles.fill.colors,
            fillAlphas = styles.fill.alphas || ["1"],
            borderColors = styles.border.colors,
            borderWeights = [styles.border.weight],
            borderAlphas = [styles.border.alpha],
            tbw = borderWeights.concat(),
            tbc = borderColors.concat(),
            tba = borderAlphas.concat(),
            tfc,
            tfa,
            padding = styles.padding,
            graph = this.get("graph"),
            minDimension = Math.min(graph.get("width"), graph.get("height")),
            w = minDimension - (padding.left + padding.right),
            h = minDimension - (padding.top + padding.bottom),
            startAngle = -90,
            halfWidth = w / 2,
            halfHeight = h / 2,
            radius = Math.min(halfWidth, halfHeight),
            i = 0,
            value,
            angle = 0,
            lc,
            la,
            lw,
            wedgeStyle,
            marker,
            graphOrder = this.get("graphOrder"),
            isCanvas = Y.Graphic.NAME == "canvasGraphic";
        _yuitest_coverline("/build/charts-base/charts-base.js", 10878);
for(; i < itemCount; ++i)
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 10880);
value = parseFloat(values[i]);
            
            _yuitest_coverline("/build/charts-base/charts-base.js", 10882);
values.push(value);
            _yuitest_coverline("/build/charts-base/charts-base.js", 10883);
if(!isNaN(value))
            {
                _yuitest_coverline("/build/charts-base/charts-base.js", 10885);
totalValue += value;
            }
        }
        
        _yuitest_coverline("/build/charts-base/charts-base.js", 10889);
tfc = fillColors ? fillColors.concat() : null;
        _yuitest_coverline("/build/charts-base/charts-base.js", 10890);
tfa = fillAlphas ? fillAlphas.concat() : null;
        _yuitest_coverline("/build/charts-base/charts-base.js", 10891);
this._createMarkerCache();
        _yuitest_coverline("/build/charts-base/charts-base.js", 10892);
if(isCanvas)
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 10894);
this._setMap();
            _yuitest_coverline("/build/charts-base/charts-base.js", 10895);
this._image.width = w;
            _yuitest_coverline("/build/charts-base/charts-base.js", 10896);
this._image.height = h;
        }
        _yuitest_coverline("/build/charts-base/charts-base.js", 10898);
for(i = 0; i < itemCount; i++)
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 10900);
value = values[i];
            _yuitest_coverline("/build/charts-base/charts-base.js", 10901);
if(totalValue === 0)
            {
                _yuitest_coverline("/build/charts-base/charts-base.js", 10903);
angle = 360 / values.length;
            }
            else
            {
                _yuitest_coverline("/build/charts-base/charts-base.js", 10907);
angle = 360 * (value / totalValue);
            }
            _yuitest_coverline("/build/charts-base/charts-base.js", 10909);
if(tfc && tfc.length < 1)
            {
                _yuitest_coverline("/build/charts-base/charts-base.js", 10911);
tfc = fillColors.concat();
            }
            _yuitest_coverline("/build/charts-base/charts-base.js", 10913);
if(tfa && tfa.length < 1)
            {
                _yuitest_coverline("/build/charts-base/charts-base.js", 10915);
tfa = fillAlphas.concat();
            }
            _yuitest_coverline("/build/charts-base/charts-base.js", 10917);
if(tbw && tbw.length < 1)
            {
                _yuitest_coverline("/build/charts-base/charts-base.js", 10919);
tbw = borderWeights.concat();
            }
            _yuitest_coverline("/build/charts-base/charts-base.js", 10921);
if(tbw && tbc.length < 1)
            {
                _yuitest_coverline("/build/charts-base/charts-base.js", 10923);
tbc = borderColors.concat();
            }
            _yuitest_coverline("/build/charts-base/charts-base.js", 10925);
if(tba && tba.length < 1)
            {
                _yuitest_coverline("/build/charts-base/charts-base.js", 10927);
tba = borderAlphas.concat();
            }
            _yuitest_coverline("/build/charts-base/charts-base.js", 10929);
lw = tbw ? tbw.shift() : null;
            _yuitest_coverline("/build/charts-base/charts-base.js", 10930);
lc = tbc ? tbc.shift() : null;
            _yuitest_coverline("/build/charts-base/charts-base.js", 10931);
la = tba ? tba.shift() : null;
            _yuitest_coverline("/build/charts-base/charts-base.js", 10932);
startAngle += angle;
            _yuitest_coverline("/build/charts-base/charts-base.js", 10933);
wedgeStyle = {
                border: {
                    color:lc,
                    weight:lw,
                    alpha:la
                },
                fill: {
                    color:tfc ? tfc.shift() : this._getDefaultColor(i, "slice"),
                    alpha:tfa ? tfa.shift() : null
                },
                type: "pieslice",
                arc: angle,
                radius: radius,
                startAngle: startAngle,
                cx: halfWidth,
                cy: halfHeight,
                width: w,
                height: h
            };
            _yuitest_coverline("/build/charts-base/charts-base.js", 10952);
marker = this.getMarker(wedgeStyle, graphOrder, i);
            _yuitest_coverline("/build/charts-base/charts-base.js", 10953);
if(isCanvas)
            {
                _yuitest_coverline("/build/charts-base/charts-base.js", 10955);
this._addHotspot(wedgeStyle, graphOrder, i);
            }
        }
        _yuitest_coverline("/build/charts-base/charts-base.js", 10958);
this._clearMarkerCache();
    },

    /**
     *  Adds an interactive map when rendering in canvas.
     *
     *  @method _addHotspot
     *  @param {Object} cfg Object containing data used to draw the hotspot
     *  @param {Number} seriesIndex Index of series in the `seriesCollection`.
     *  @param {Number} index Index of the marker using the hotspot.
     *  @private
     */
    _addHotspot: function(cfg, seriesIndex, index)
    {
        _yuitest_coverfunc("/build/charts-base/charts-base.js", "_addHotspot", 10970);
_yuitest_coverline("/build/charts-base/charts-base.js", 10972);
var areaNode = DOCUMENT.createElement("area"),
            i = 1,
            x = cfg.cx,
            y = cfg.cy, 
            arc = cfg.arc,
            startAngle = cfg.startAngle - arc, 
            endAngle = cfg.startAngle,
            radius = cfg.radius, 
            ax = x + Math.cos(startAngle / 180 * Math.PI) * radius,
            ay = y + Math.sin(startAngle / 180 * Math.PI) * radius,
            bx = x + Math.cos(endAngle / 180 * Math.PI) * radius,
            by = y + Math.sin(endAngle / 180 * Math.PI) * radius,
            numPoints = Math.floor(arc/10) - 1,
            divAngle = (arc/(Math.floor(arc/10)) / 180) * Math.PI,
            angleCoord = Math.atan((ay - y)/(ax - x)),
            pts = x + ", " + y + ", " + ax + ", " + ay,
            cosAng,
            sinAng,
            multDivAng;
        _yuitest_coverline("/build/charts-base/charts-base.js", 10991);
for(i = 1; i <= numPoints; ++i)
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 10993);
multDivAng = divAngle * i;
            _yuitest_coverline("/build/charts-base/charts-base.js", 10994);
cosAng = Math.cos(angleCoord + multDivAng);
            _yuitest_coverline("/build/charts-base/charts-base.js", 10995);
sinAng = Math.sin(angleCoord + multDivAng);
            _yuitest_coverline("/build/charts-base/charts-base.js", 10996);
if(startAngle <= 90)
            {
                _yuitest_coverline("/build/charts-base/charts-base.js", 10998);
pts += ", " + (x + (radius * Math.cos(angleCoord + (divAngle * i))));
                _yuitest_coverline("/build/charts-base/charts-base.js", 10999);
pts += ", " + (y + (radius * Math.sin(angleCoord + (divAngle * i))));
            }
            else
            {
                _yuitest_coverline("/build/charts-base/charts-base.js", 11003);
pts += ", " + (x - (radius * Math.cos(angleCoord + (divAngle * i))));
                _yuitest_coverline("/build/charts-base/charts-base.js", 11004);
pts += ", " + (y - (radius * Math.sin(angleCoord + (divAngle * i))));
            }
        }
        _yuitest_coverline("/build/charts-base/charts-base.js", 11007);
pts += ", " + bx + ", " + by;
        _yuitest_coverline("/build/charts-base/charts-base.js", 11008);
pts += ", " + x + ", " + y;
        _yuitest_coverline("/build/charts-base/charts-base.js", 11009);
this._map.appendChild(areaNode);
        _yuitest_coverline("/build/charts-base/charts-base.js", 11010);
areaNode.setAttribute("class", SERIES_MARKER);
        _yuitest_coverline("/build/charts-base/charts-base.js", 11011);
areaNode.setAttribute("id", "hotSpot_" + seriesIndex + "_" + index);
        _yuitest_coverline("/build/charts-base/charts-base.js", 11012);
areaNode.setAttribute("shape", "polygon");
        _yuitest_coverline("/build/charts-base/charts-base.js", 11013);
areaNode.setAttribute("coords", pts);
        _yuitest_coverline("/build/charts-base/charts-base.js", 11014);
this._areaNodes.push(areaNode);

    },

    /**
     * Resizes and positions markers based on a mouse interaction.
     *
     * @method updateMarkerState
     * @param {String} type state of the marker
     * @param {Number} i index of the marker
     * @protected
     */
    updateMarkerState: function(type, i)
    {
        _yuitest_coverfunc("/build/charts-base/charts-base.js", "updateMarkerState", 11026);
_yuitest_coverline("/build/charts-base/charts-base.js", 11028);
if(this._markers[i])
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 11030);
var state = this._getState(type),
                markerStyles,
                indexStyles,
                marker = this._markers[i],
                styles = this.get("styles").marker; 
            _yuitest_coverline("/build/charts-base/charts-base.js", 11035);
markerStyles = state == "off" || !styles[state] ? styles : styles[state]; 
            _yuitest_coverline("/build/charts-base/charts-base.js", 11036);
indexStyles = this._mergeStyles(markerStyles, {});
            _yuitest_coverline("/build/charts-base/charts-base.js", 11037);
indexStyles.fill.color = indexStyles.fill.colors[i % indexStyles.fill.colors.length];
            _yuitest_coverline("/build/charts-base/charts-base.js", 11038);
indexStyles.fill.alpha = indexStyles.fill.alphas[i % indexStyles.fill.alphas.length];
            _yuitest_coverline("/build/charts-base/charts-base.js", 11039);
marker.set(indexStyles);
        }
    },
    
    /**
     * Creates a shape to be used as a marker.
     *
     * @method _createMarker
     * @param {Object} styles Hash of style properties.
     * @param {Number} order Order of the series.
     * @param {Number} index Index within the series associated with the marker.
     * @return Shape
     * @private
     */
    _createMarker: function(styles, order, index)
    {
        _yuitest_coverfunc("/build/charts-base/charts-base.js", "_createMarker", 11053);
_yuitest_coverline("/build/charts-base/charts-base.js", 11055);
var graphic = this.get("graphic"),
            marker,
            cfg = Y.clone(styles);
        _yuitest_coverline("/build/charts-base/charts-base.js", 11058);
graphic.set("autoDraw", false);
        _yuitest_coverline("/build/charts-base/charts-base.js", 11059);
marker = graphic.addShape(cfg); 
        _yuitest_coverline("/build/charts-base/charts-base.js", 11060);
marker.addClass(SERIES_MARKER);
        _yuitest_coverline("/build/charts-base/charts-base.js", 11061);
return marker;
    },
    
    /**
     * Creates a cache of markers for reuse.
     *
     * @method _createMarkerCache
     * @private
     */
    _clearMarkerCache: function()
    {
        _yuitest_coverfunc("/build/charts-base/charts-base.js", "_clearMarkerCache", 11070);
_yuitest_coverline("/build/charts-base/charts-base.js", 11072);
var len = this._markerCache.length,
            i = 0,
            marker;
        _yuitest_coverline("/build/charts-base/charts-base.js", 11075);
for(; i < len; ++i)
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 11077);
marker = this._markerCache[i];
            _yuitest_coverline("/build/charts-base/charts-base.js", 11078);
if(marker)
            {
                _yuitest_coverline("/build/charts-base/charts-base.js", 11080);
marker.destroy();
            }
        }
        _yuitest_coverline("/build/charts-base/charts-base.js", 11083);
this._markerCache = [];
    },

    /**
     * Gets the default style values for the markers.
     *
     * @method _getPlotDefaults
     * @return Object
     * @private
     */
    _getPlotDefaults: function()
    {
         _yuitest_coverfunc("/build/charts-base/charts-base.js", "_getPlotDefaults", 11093);
_yuitest_coverline("/build/charts-base/charts-base.js", 11095);
var defs = {
            padding:{
                top: 0,
                left: 0,
                right: 0,
                bottom: 0
            },
            fill:{
                alphas:["1"]
            },
            border: {
                weight: 0,
                alpha: 1
            }
        };
        _yuitest_coverline("/build/charts-base/charts-base.js", 11110);
defs.fill.colors = this._defaultSliceColors;
        _yuitest_coverline("/build/charts-base/charts-base.js", 11111);
defs.border.colors = this._defaultBorderColors;
        _yuitest_coverline("/build/charts-base/charts-base.js", 11112);
return defs;
    },

    /**
     * Collection of default colors used for lines in a series when not specified by user.
     *
     * @property _defaultLineColors
     * @type Array
     * @protected
     */
    _defaultLineColors:["#426ab3", "#d09b2c", "#000000", "#b82837", "#b384b5", "#ff7200", "#779de3", "#cbc8ba", "#7ed7a6", "#007a6c"],

    /**
     * Collection of default colors used for marker fills in a series when not specified by user.
     *
     * @property _defaultFillColors
     * @type Array
     * @protected
     */
    _defaultFillColors:["#6084d0", "#eeb647", "#6c6b5f", "#d6484f", "#ce9ed1", "#ff9f3b", "#93b7ff", "#e0ddd0", "#94ecba", "#309687"],
    
    /**
     * Collection of default colors used for marker borders in a series when not specified by user.
     *
     * @property _defaultBorderColors
     * @type Array
     * @protected
     */
    _defaultBorderColors:["#205096", "#b38206", "#000000", "#94001e", "#9d6fa0", "#e55b00", "#5e85c9", "#adab9e", "#6ac291", "#006457"],
    
    /**
     * Collection of default colors used for area fills, histogram fills and pie fills in a series when not specified by user.
     *
     * @property _defaultSliceColors
     * @type Array
     * @protected
     */
    _defaultSliceColors: ["#66007f", "#a86f41", "#295454", "#996ab2", "#e8cdb7", "#90bdbd","#000000","#c3b8ca", "#968373", "#678585"],

    /**
     * Colors used if style colors are not specified
     *
     * @method _getDefaultColor
     * @param {Number} index Index indicating the series order.
     * @param {String} type Indicates which type of object needs the color.
     * @return String
     * @protected
     */
    _getDefaultColor: function(index, type)
    {
        _yuitest_coverfunc("/build/charts-base/charts-base.js", "_getDefaultColor", 11160);
_yuitest_coverline("/build/charts-base/charts-base.js", 11162);
var colors = {
                line: this._defaultLineColors,
                fill: this._defaultFillColors,
                border: this._defaultBorderColors,
                slice: this._defaultSliceColors
            },
            col = colors[type],
            l = col.length;
        _yuitest_coverline("/build/charts-base/charts-base.js", 11170);
index = index || 0;
        _yuitest_coverline("/build/charts-base/charts-base.js", 11171);
if(index >= l)
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 11173);
index = index % l;
        }
        _yuitest_coverline("/build/charts-base/charts-base.js", 11175);
type = type || "fill";
        _yuitest_coverline("/build/charts-base/charts-base.js", 11176);
return colors[type][index];
    }
}, {
    ATTRS: {
        /**
         * Read-only attribute indicating the type of series.
         *
         * @attribute type
         * @type String
         * @default pie
         */
        type: {		
            value: "pie"
        },
        
        /**
         * Order of this instance of this `type`.
         *
         * @attribute order
         * @type Number
         */
        order: {},

        /**
         * Reference to the `Graph` in which the series is drawn into.
         *
         * @attribute graph
         * @type Graph
         */
        graph: {},
        
        /**
         * Reference to the `Axis` instance used for assigning 
         * category values to the graph.
         *
         * @attribute categoryAxis
         * @type Axis
         */
        categoryAxis: {
            value: null,

            validator: function(value)
            {
                _yuitest_coverfunc("/build/charts-base/charts-base.js", "validator", 11217);
_yuitest_coverline("/build/charts-base/charts-base.js", 11219);
return value !== this.get("categoryAxis");
            }
        },
        
        /**
         * Reference to the `Axis` instance used for assigning 
         * series values to the graph.
         *
         * @attribute categoryAxis
         * @type Axis
         */
        valueAxis: {
            value: null,

            validator: function(value)
            {
                _yuitest_coverfunc("/build/charts-base/charts-base.js", "validator", 11233);
_yuitest_coverline("/build/charts-base/charts-base.js", 11235);
return value !== this.get("valueAxis");
            }
        },

        /**
         * Indicates which array to from the hash of value arrays in 
         * the category `Axis` instance.
         *
         * @attribute categoryKey
         * @type String
         */
        categoryKey: {
            value: null,

            validator: function(value)
            {
                _yuitest_coverfunc("/build/charts-base/charts-base.js", "validator", 11249);
_yuitest_coverline("/build/charts-base/charts-base.js", 11251);
return value !== this.get("categoryKey");
            }
        },
        /**
         * Indicates which array to from the hash of value arrays in 
         * the value `Axis` instance.
         *
         * @attribute valueKey
         * @type String
         */
        valueKey: {
            value: null,

            validator: function(value)
            {
                _yuitest_coverfunc("/build/charts-base/charts-base.js", "validator", 11264);
_yuitest_coverline("/build/charts-base/charts-base.js", 11266);
return value !== this.get("valueKey");
            }
        },

        /**
         * Name used for for displaying category data
         *
         * @attribute categoryDisplayName
         * @type String
         */
        categoryDisplayName: {
            setter: function(val)
            {
                _yuitest_coverfunc("/build/charts-base/charts-base.js", "setter", 11277);
_yuitest_coverline("/build/charts-base/charts-base.js", 11279);
this._categoryDisplayName = val;
                _yuitest_coverline("/build/charts-base/charts-base.js", 11280);
return val;
            },

            getter: function()
            {
                _yuitest_coverfunc("/build/charts-base/charts-base.js", "getter", 11283);
_yuitest_coverline("/build/charts-base/charts-base.js", 11285);
return this._categoryDisplayName || this.get("categoryKey");
            }
        },

        /**
         * Name used for for displaying value data
         *
         * @attribute valueDisplayName
         * @type String
         */
        valueDisplayName: {
            setter: function(val)
            {
                _yuitest_coverfunc("/build/charts-base/charts-base.js", "setter", 11296);
_yuitest_coverline("/build/charts-base/charts-base.js", 11298);
this._valueDisplayName = val;
                _yuitest_coverline("/build/charts-base/charts-base.js", 11299);
return val;
            },

            getter: function()
            {
                _yuitest_coverfunc("/build/charts-base/charts-base.js", "getter", 11302);
_yuitest_coverline("/build/charts-base/charts-base.js", 11304);
return this._valueDisplayName || this.get("valueKey");
            }
        },
        
        /**
         * @attribute slices
         * @type Array
         * @private
         */
        slices: null
        
        /**
         * Style properties used for drawing markers. This attribute is inherited from `MarkerSeries`. Below are the default values:
         *  <dl>
         *      <dt>fill</dt><dd>A hash containing the following values:
         *          <dl>
         *              <dt>colors</dt><dd>An array of colors to be used for the marker fills. The color for each marker is retrieved from the 
         *              array below:<br/>
         *              `["#66007f", "#a86f41", "#295454", "#996ab2", "#e8cdb7", "#90bdbd","#000000","#c3b8ca", "#968373", "#678585"]`
         *              </dd>
         *              <dt>alphas</dt><dd>An array of alpha references (Number from 0 to 1) indicating the opacity of each marker fill. The default value is [1].</dd>
         *          </dl>
         *      </dd>
         *      <dt>border</dt><dd>A hash containing the following values:
         *          <dl>
         *              <dt>color</dt><dd>An array of colors to be used for the marker borders. The color for each marker is retrieved from the
         *              array below:<br/>
         *              `["#205096", "#b38206", "#000000", "#94001e", "#9d6fa0", "#e55b00", "#5e85c9", "#adab9e", "#6ac291", "#006457"]`
         *              <dt>alpha</dt><dd>Number from 0 to 1 indicating the opacity of the marker border. The default value is 1.</dd>
         *              <dt>weight</dt><dd>Number indicating the width of the border. The default value is 1.</dd>
         *          </dl>
         *      </dd>
         *      <dt>over</dt><dd>hash containing styles for markers when highlighted by a `mouseover` event. The default 
         *      values for each style is null. When an over style is not set, the non-over value will be used. For example,
         *      the default value for `marker.over.fill.color` is equivalent to `marker.fill.color`.</dd>
         *  </dl>
         *
         * @attribute styles
         * @type Object
         */
    }
});
/**
 * Gridlines draws gridlines on a Graph.
 *
 * @module charts
 * @submodule charts-base
 * @class Gridlines
 * @constructor
 * @extends Base
 * @uses Renderer
 */
_yuitest_coverline("/build/charts-base/charts-base.js", 11356);
Y.Gridlines = Y.Base.create("gridlines", Y.Base, [Y.Renderer], {
    /**
     * Reference to the `Path` element used for drawing Gridlines.
     *
     * @property _path
     * @type Path
     * @private
     */
    _path: null,

    /**
     * Removes the Gridlines.
     *
     * @method remove
     * @private
     */
    remove: function()
    {
        _yuitest_coverfunc("/build/charts-base/charts-base.js", "remove", 11372);
_yuitest_coverline("/build/charts-base/charts-base.js", 11374);
var path = this._path;
        _yuitest_coverline("/build/charts-base/charts-base.js", 11375);
if(path)
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 11377);
path.destroy();
        }
    },

    /**
     * Draws the gridlines
     *
     * @method draw
     * @protected
     */
    draw: function()
    {
        _yuitest_coverfunc("/build/charts-base/charts-base.js", "draw", 11387);
_yuitest_coverline("/build/charts-base/charts-base.js", 11389);
if(this.get("axis") && this.get("graph"))
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 11391);
this._drawGridlines();
        }
    },

    /**
     * Algorithm for drawing gridlines
     *
     * @method _drawGridlines
     * @private
     */
    _drawGridlines: function()
    {
        _yuitest_coverfunc("/build/charts-base/charts-base.js", "_drawGridlines", 11401);
_yuitest_coverline("/build/charts-base/charts-base.js", 11403);
var path,
            axis = this.get("axis"),
            axisPosition = axis.get("position"),
            points,
            i = 0,
            l,
            direction = this.get("direction"),
            graph = this.get("graph"),
            w = graph.get("width"),
            h = graph.get("height"),
            line = this.get("styles").line,
            color = line.color,
            weight = line.weight,
            alpha = line.alpha,
            lineFunction = direction == "vertical" ? this._verticalLine : this._horizontalLine;
        _yuitest_coverline("/build/charts-base/charts-base.js", 11418);
if(isFinite(w) && isFinite(h) && w > 0 && h > 0)
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 11420);
if(axisPosition != "none" && axis && axis.get("tickPoints"))
            {
                _yuitest_coverline("/build/charts-base/charts-base.js", 11422);
points = axis.get("tickPoints");
                _yuitest_coverline("/build/charts-base/charts-base.js", 11423);
l = points.length;
            }
            else
            {
                _yuitest_coverline("/build/charts-base/charts-base.js", 11427);
points = [];
                _yuitest_coverline("/build/charts-base/charts-base.js", 11428);
l = axis.get("styles").majorUnit.count;
                _yuitest_coverline("/build/charts-base/charts-base.js", 11429);
for(; i < l; ++i)
                {
                    _yuitest_coverline("/build/charts-base/charts-base.js", 11431);
points[i] = {
                        x: w * (i/(l-1)),
                        y: h * (i/(l-1))
                    };
                }
                _yuitest_coverline("/build/charts-base/charts-base.js", 11436);
i = 0;
            }
            _yuitest_coverline("/build/charts-base/charts-base.js", 11438);
path = graph.get("gridlines");
            _yuitest_coverline("/build/charts-base/charts-base.js", 11439);
path.set("width", w);
            _yuitest_coverline("/build/charts-base/charts-base.js", 11440);
path.set("height", h);
            _yuitest_coverline("/build/charts-base/charts-base.js", 11441);
path.set("stroke", {
                weight: weight,
                color: color,
                opacity: alpha
            });
            _yuitest_coverline("/build/charts-base/charts-base.js", 11446);
for(; i < l; ++i)
            {
                _yuitest_coverline("/build/charts-base/charts-base.js", 11448);
lineFunction(path, points[i], w, h);
            }
            _yuitest_coverline("/build/charts-base/charts-base.js", 11450);
path.end();
        }
    },

    /**
     * Algorithm for horizontal lines.
     *
     * @method _horizontalLine
     * @param {Path} path Reference to path element
     * @param {Object} pt Coordinates corresponding to a major unit of an axis.
     * @param {Number} w Width of the Graph
     * @param {Number} h Height of the Graph
     * @private
     */
    _horizontalLine: function(path, pt, w, h)
    {
        _yuitest_coverfunc("/build/charts-base/charts-base.js", "_horizontalLine", 11464);
_yuitest_coverline("/build/charts-base/charts-base.js", 11466);
path.moveTo(0, pt.y);
        _yuitest_coverline("/build/charts-base/charts-base.js", 11467);
path.lineTo(w, pt.y);
    },

    /**
     * Algorithm for vertical lines.
     *
     * @method _verticalLine
     * @param {Path} path Reference to path element
     * @param {Object} pt Coordinates corresponding to a major unit of an axis.
     * @param {Number} w Width of the Graph
     * @param {Number} h Height of the Graph
     * @private
     */
    _verticalLine: function(path, pt, w, h)
    {
        _yuitest_coverfunc("/build/charts-base/charts-base.js", "_verticalLine", 11480);
_yuitest_coverline("/build/charts-base/charts-base.js", 11482);
path.moveTo(pt.x, 0);
        _yuitest_coverline("/build/charts-base/charts-base.js", 11483);
path.lineTo(pt.x, h);
    },
    
    /**
     * Gets the default value for the `styles` attribute. Overrides
     * base implementation.
     *
     * @method _getDefaultStyles
     * @return Object
     * @protected
     */
    _getDefaultStyles: function()
    {
        _yuitest_coverfunc("/build/charts-base/charts-base.js", "_getDefaultStyles", 11494);
_yuitest_coverline("/build/charts-base/charts-base.js", 11496);
var defs = {
            line: {
                color:"#f0efe9",
                weight: 1,
                alpha: 1
            }
        };
        _yuitest_coverline("/build/charts-base/charts-base.js", 11503);
return defs;
    }

},
{
    ATTRS: {
        /**
         * Indicates the direction of the gridline.
         *
         * @attribute direction
         * @type String
         */
        direction: {},
        
        /**
         * Indicate the `Axis` in which to bind
         * the gridlines.
         *
         * @attribute axis
         * @type Axis
         */
        axis: {},
        
        /**
         * Indicates the `Graph` in which the gridlines 
         * are drawn.
         *
         * @attribute graph
         * @type Graph
         */
        graph: {}
    }
});
/**
 * Graph manages and contains series instances for a `CartesianChart`
 * instance.
 *
 * @module charts
 * @submodule charts-base
 * @class Graph
 * @constructor
 * @extends Widget
 * @uses Renderer
 */
_yuitest_coverline("/build/charts-base/charts-base.js", 11547);
Y.Graph = Y.Base.create("graph", Y.Widget, [Y.Renderer], {
    /**
     * @method bindUI
     * @private
     */
    bindUI: function()
    {
        _yuitest_coverfunc("/build/charts-base/charts-base.js", "bindUI", 11552);
_yuitest_coverline("/build/charts-base/charts-base.js", 11554);
var bb = this.get("boundingBox");
        _yuitest_coverline("/build/charts-base/charts-base.js", 11555);
bb.setStyle("position", "absolute");
        _yuitest_coverline("/build/charts-base/charts-base.js", 11556);
this.after("widthChange", this._sizeChangeHandler);
        _yuitest_coverline("/build/charts-base/charts-base.js", 11557);
this.after("heightChange", this._sizeChangeHandler);
        _yuitest_coverline("/build/charts-base/charts-base.js", 11558);
this.after("stylesChange", this._updateStyles);
        _yuitest_coverline("/build/charts-base/charts-base.js", 11559);
this.after("groupMarkersChange", this._drawSeries);
    },

    /**
     * @method syncUI
     * @private
     */
    syncUI: function()
    {
        _yuitest_coverfunc("/build/charts-base/charts-base.js", "syncUI", 11566);
_yuitest_coverline("/build/charts-base/charts-base.js", 11568);
var background,
            cb,
            bg,
            sc = this.get("seriesCollection"),
            series,
            i = 0,
            len = sc ? sc.length : 0,
            hgl = this.get("horizontalGridlines"),
            vgl = this.get("verticalGridlines");
        _yuitest_coverline("/build/charts-base/charts-base.js", 11577);
if(this.get("showBackground"))
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 11579);
background = this.get("background");
            _yuitest_coverline("/build/charts-base/charts-base.js", 11580);
cb = this.get("contentBox");
            _yuitest_coverline("/build/charts-base/charts-base.js", 11581);
bg = this.get("styles").background;
            _yuitest_coverline("/build/charts-base/charts-base.js", 11582);
bg.stroke = bg.border;
            _yuitest_coverline("/build/charts-base/charts-base.js", 11583);
bg.stroke.opacity = bg.stroke.alpha;
            _yuitest_coverline("/build/charts-base/charts-base.js", 11584);
bg.fill.opacity = bg.fill.alpha;
            _yuitest_coverline("/build/charts-base/charts-base.js", 11585);
bg.width = this.get("width");
            _yuitest_coverline("/build/charts-base/charts-base.js", 11586);
bg.height = this.get("height");
            _yuitest_coverline("/build/charts-base/charts-base.js", 11587);
bg.type = bg.shape;
            _yuitest_coverline("/build/charts-base/charts-base.js", 11588);
background.set(bg);
        }
        _yuitest_coverline("/build/charts-base/charts-base.js", 11590);
for(; i < len; ++i)
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 11592);
series = sc[i];
            _yuitest_coverline("/build/charts-base/charts-base.js", 11593);
if(series instanceof Y.CartesianSeries)
            {
                _yuitest_coverline("/build/charts-base/charts-base.js", 11595);
series.render();
            }
        }
        _yuitest_coverline("/build/charts-base/charts-base.js", 11598);
if(hgl && hgl instanceof Y.Gridlines)
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 11600);
hgl.draw();
        }
        _yuitest_coverline("/build/charts-base/charts-base.js", 11602);
if(vgl && vgl instanceof Y.Gridlines)
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 11604);
vgl.draw();
        }
    },
   
    /**
     * Object of arrays containing series mapped to a series type.
     *
     * @property seriesTypes
     * @type Object
     * @private
     */
    seriesTypes: null,

    /**
     * Returns a series instance based on an index.
     * 
     * @method getSeriesByIndex
     * @param {Number} val index of the series
     * @return CartesianSeries
     */
    getSeriesByIndex: function(val)
    {
        _yuitest_coverfunc("/build/charts-base/charts-base.js", "getSeriesByIndex", 11624);
_yuitest_coverline("/build/charts-base/charts-base.js", 11626);
var col = this.get("seriesCollection"),
            series;
        _yuitest_coverline("/build/charts-base/charts-base.js", 11628);
if(col && col.length > val)
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 11630);
series = col[val];
        }
        _yuitest_coverline("/build/charts-base/charts-base.js", 11632);
return series;
    },

    /**
     * Returns a series instance based on a key value.
     * 
     * @method getSeriesByKey
     * @param {String} val key value of the series
     * @return CartesianSeries
     */
    getSeriesByKey: function(val)
    {
        _yuitest_coverfunc("/build/charts-base/charts-base.js", "getSeriesByKey", 11642);
_yuitest_coverline("/build/charts-base/charts-base.js", 11644);
var obj = this._seriesDictionary,
            series;
        _yuitest_coverline("/build/charts-base/charts-base.js", 11646);
if(obj && obj.hasOwnProperty(val))
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 11648);
series = obj[val];
        }
        _yuitest_coverline("/build/charts-base/charts-base.js", 11650);
return series;
    },

    /**
     * Adds dispatcher to a `_dispatcher` used to
     * to ensure all series have redrawn before for firing event.
     *
     * @method addDispatcher
     * @param {CartesianSeries} val series instance to add
     * @protected
     */
    addDispatcher: function(val)
    {
        _yuitest_coverfunc("/build/charts-base/charts-base.js", "addDispatcher", 11661);
_yuitest_coverline("/build/charts-base/charts-base.js", 11663);
if(!this._dispatchers)
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 11665);
this._dispatchers = [];
        }
        _yuitest_coverline("/build/charts-base/charts-base.js", 11667);
this._dispatchers.push(val);
    },

    /**
     * Collection of series to be displayed in the graph.
     *
     * @property _seriesCollection
     * @type Array
     * @private 
     */
    _seriesCollection: null,
    
    /**
     * Object containing key value pairs of `CartesianSeries` instances.
     *
     * @property _seriesDictionary
     * @type Object
     * @private
     */
    _seriesDictionary: null,

    /**
     * Parses series instances to be displayed in the graph.
     *
     * @method _parseSeriesCollection
     * @param {Array} Collection of `CartesianSeries` instances or objects container `CartesianSeries` attributes values.
     * @private
     */
    _parseSeriesCollection: function(val)
    {
        _yuitest_coverfunc("/build/charts-base/charts-base.js", "_parseSeriesCollection", 11695);
_yuitest_coverline("/build/charts-base/charts-base.js", 11697);
if(!val)
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 11699);
return;
        }	
        _yuitest_coverline("/build/charts-base/charts-base.js", 11701);
var len = val.length,
            i = 0,
            series,
            seriesKey;
        _yuitest_coverline("/build/charts-base/charts-base.js", 11705);
this._seriesCollection = [];
        _yuitest_coverline("/build/charts-base/charts-base.js", 11706);
this._seriesDictionary = {};
        _yuitest_coverline("/build/charts-base/charts-base.js", 11707);
this.seriesTypes = [];
        _yuitest_coverline("/build/charts-base/charts-base.js", 11708);
for(; i < len; ++i)
        {	
            _yuitest_coverline("/build/charts-base/charts-base.js", 11710);
series = val[i];
            _yuitest_coverline("/build/charts-base/charts-base.js", 11711);
if(!(series instanceof Y.CartesianSeries) && !(series instanceof Y.PieSeries))
            {
                _yuitest_coverline("/build/charts-base/charts-base.js", 11713);
this._createSeries(series);
                _yuitest_coverline("/build/charts-base/charts-base.js", 11714);
continue;
            }
            _yuitest_coverline("/build/charts-base/charts-base.js", 11716);
this._addSeries(series);
        }
        _yuitest_coverline("/build/charts-base/charts-base.js", 11718);
len = this._seriesCollection.length;
        _yuitest_coverline("/build/charts-base/charts-base.js", 11719);
for(i = 0; i < len; ++i)
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 11721);
series = this.get("seriesCollection")[i];
            _yuitest_coverline("/build/charts-base/charts-base.js", 11722);
seriesKey = series.get("direction") == "horizontal" ? "yKey" : "xKey";
            _yuitest_coverline("/build/charts-base/charts-base.js", 11723);
this._seriesDictionary[series.get(seriesKey)] = series;
        }
    },

    /**
     * Adds a series to the graph.
     *
     * @method _addSeries
     * @param {CartesianSeries} series Series to add to the graph.
     * @private
     */
    _addSeries: function(series)
    {
        _yuitest_coverfunc("/build/charts-base/charts-base.js", "_addSeries", 11734);
_yuitest_coverline("/build/charts-base/charts-base.js", 11736);
var type = series.get("type"),
            seriesCollection = this.get("seriesCollection"),
            graphSeriesLength = seriesCollection.length,
            seriesTypes = this.seriesTypes,
            typeSeriesCollection;	
        _yuitest_coverline("/build/charts-base/charts-base.js", 11741);
if(!series.get("graph")) 
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 11743);
series.set("graph", this);
        }
        _yuitest_coverline("/build/charts-base/charts-base.js", 11745);
seriesCollection.push(series);
        _yuitest_coverline("/build/charts-base/charts-base.js", 11746);
if(!seriesTypes.hasOwnProperty(type))
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 11748);
this.seriesTypes[type] = [];
        }
        _yuitest_coverline("/build/charts-base/charts-base.js", 11750);
typeSeriesCollection = this.seriesTypes[type];
        _yuitest_coverline("/build/charts-base/charts-base.js", 11751);
series.set("graphOrder", graphSeriesLength);
        _yuitest_coverline("/build/charts-base/charts-base.js", 11752);
series.set("order", typeSeriesCollection.length);
        _yuitest_coverline("/build/charts-base/charts-base.js", 11753);
typeSeriesCollection.push(series);
        _yuitest_coverline("/build/charts-base/charts-base.js", 11754);
this.addDispatcher(series);
        _yuitest_coverline("/build/charts-base/charts-base.js", 11755);
series.after("drawingComplete", Y.bind(this._drawingCompleteHandler, this));
        _yuitest_coverline("/build/charts-base/charts-base.js", 11756);
this.fire("seriesAdded", series);
    },

    /**
     * Creates a `CartesianSeries` instance from an object containing attribute key value pairs. The key value pairs include attributes for the specific series and a type value which defines the type of
     * series to be used. 
     *
     * @method createSeries
     * @param {Object} seriesData Series attribute key value pairs.
     * @private
     */
    _createSeries: function(seriesData)
    {
        _yuitest_coverfunc("/build/charts-base/charts-base.js", "_createSeries", 11767);
_yuitest_coverline("/build/charts-base/charts-base.js", 11769);
var type = seriesData.type,
            seriesCollection = this.get("seriesCollection"),
            seriesTypes = this.seriesTypes,
            typeSeriesCollection,
            seriesType,
            series;
            _yuitest_coverline("/build/charts-base/charts-base.js", 11775);
seriesData.graph = this;
        _yuitest_coverline("/build/charts-base/charts-base.js", 11776);
if(!seriesTypes.hasOwnProperty(type))
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 11778);
seriesTypes[type] = [];
        }
        _yuitest_coverline("/build/charts-base/charts-base.js", 11780);
typeSeriesCollection = seriesTypes[type];
        _yuitest_coverline("/build/charts-base/charts-base.js", 11781);
seriesData.graph = this;
        _yuitest_coverline("/build/charts-base/charts-base.js", 11782);
seriesData.order = typeSeriesCollection.length;
        _yuitest_coverline("/build/charts-base/charts-base.js", 11783);
seriesData.graphOrder = seriesCollection.length;
        _yuitest_coverline("/build/charts-base/charts-base.js", 11784);
seriesType = this._getSeries(seriesData.type);
        _yuitest_coverline("/build/charts-base/charts-base.js", 11785);
series = new seriesType(seriesData);
        _yuitest_coverline("/build/charts-base/charts-base.js", 11786);
this.addDispatcher(series);
        _yuitest_coverline("/build/charts-base/charts-base.js", 11787);
series.after("drawingComplete", Y.bind(this._drawingCompleteHandler, this));
        _yuitest_coverline("/build/charts-base/charts-base.js", 11788);
typeSeriesCollection.push(series);
        _yuitest_coverline("/build/charts-base/charts-base.js", 11789);
seriesCollection.push(series);
        _yuitest_coverline("/build/charts-base/charts-base.js", 11790);
if(this.get("rendered"))
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 11792);
series.render();
        }
    },
    
    /**
     * String reference for pre-defined `Series` classes.
     *
     * @property _seriesMap
     * @type Object
     * @private
     */
    _seriesMap: {
        line : Y.LineSeries,
        column : Y.ColumnSeries,
        bar : Y.BarSeries,
        area :  Y.AreaSeries,
        candlestick : Y.CandlestickSeries,
        ohlc : Y.OHLCSeries,
        stackedarea : Y.StackedAreaSeries,
        stackedline : Y.StackedLineSeries,
        stackedcolumn : Y.StackedColumnSeries,
        stackedbar : Y.StackedBarSeries,
        markerseries : Y.MarkerSeries,
        spline : Y.SplineSeries,
        areaspline : Y.AreaSplineSeries,
        stackedspline : Y.StackedSplineSeries,
        stackedareaspline : Y.StackedAreaSplineSeries,
        stackedmarkerseries : Y.StackedMarkerSeries,
        pie : Y.PieSeries,
        combo : Y.ComboSeries,
        stackedcombo : Y.StackedComboSeries,
        combospline : Y.ComboSplineSeries,
        stackedcombospline : Y.StackedComboSplineSeries
    },

    /**
     * Returns a specific `CartesianSeries` class based on key value from a look up table of a direct reference to a class. When specifying a key value, the following options
     * are available:
     *
     *  <table>
     *      <tr><th>Key Value</th><th>Class</th></tr>
     *      <tr><td>line</td><td>Y.LineSeries</td></tr>    
     *      <tr><td>column</td><td>Y.ColumnSeries</td></tr>    
     *      <tr><td>bar</td><td>Y.BarSeries</td></tr>    
     *      <tr><td>area</td><td>Y.AreaSeries</td></tr>    
     *      <tr><td>stackedarea</td><td>Y.StackedAreaSeries</td></tr>    
     *      <tr><td>stackedline</td><td>Y.StackedLineSeries</td></tr>    
     *      <tr><td>stackedcolumn</td><td>Y.StackedColumnSeries</td></tr>    
     *      <tr><td>stackedbar</td><td>Y.StackedBarSeries</td></tr>    
     *      <tr><td>markerseries</td><td>Y.MarkerSeries</td></tr>    
     *      <tr><td>spline</td><td>Y.SplineSeries</td></tr>    
     *      <tr><td>areaspline</td><td>Y.AreaSplineSeries</td></tr>    
     *      <tr><td>stackedspline</td><td>Y.StackedSplineSeries</td></tr>
     *      <tr><td>stackedareaspline</td><td>Y.StackedAreaSplineSeries</td></tr>
     *      <tr><td>stackedmarkerseries</td><td>Y.StackedMarkerSeries</td></tr>
     *      <tr><td>pie</td><td>Y.PieSeries</td></tr>
     *      <tr><td>combo</td><td>Y.ComboSeries</td></tr>
     *      <tr><td>stackedcombo</td><td>Y.StackedComboSeries</td></tr>
     *      <tr><td>combospline</td><td>Y.ComboSplineSeries</td></tr>
     *      <tr><td>stackedcombospline</td><td>Y.StackedComboSplineSeries</td></tr>
     *  </table>
     * 
     * When referencing a class directly, you can specify any of the above classes or any custom class that extends `CartesianSeries` or `PieSeries`.
     *
     * @method _getSeries
     * @param {String | Object} type Series type.
     * @return CartesianSeries
     * @private
     */
    _getSeries: function(type)
    {
        _yuitest_coverfunc("/build/charts-base/charts-base.js", "_getSeries", 11861);
_yuitest_coverline("/build/charts-base/charts-base.js", 11863);
var seriesClass;
        _yuitest_coverline("/build/charts-base/charts-base.js", 11864);
if(Y_Lang.isString(type))
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 11866);
seriesClass = this._seriesMap[type];
        }
        else 
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 11870);
seriesClass = type;
        }
        _yuitest_coverline("/build/charts-base/charts-base.js", 11872);
return seriesClass;
    },

    /**
     * Event handler for marker events.
     *
     * @method _markerEventHandler
     * @param {Object} e Event object.
     * @private
     */
    _markerEventHandler: function(e)
    {
        _yuitest_coverfunc("/build/charts-base/charts-base.js", "_markerEventHandler", 11882);
_yuitest_coverline("/build/charts-base/charts-base.js", 11884);
var type = e.type,
            markerNode = e.currentTarget,
            strArr = markerNode.getAttribute("id").split("_"),
            series = this.getSeriesByIndex(strArr[1]),
            index = strArr[2];
        _yuitest_coverline("/build/charts-base/charts-base.js", 11889);
series.updateMarkerState(type, index);
    },

    /**
     * Collection of `CartesianSeries` instances to be redrawn.
     *
     * @property _dispatchers
     * @type Array
     * @private
     */
    _dispatchers: null,

    /**
     * Updates the `Graph` styles.
     *
     * @method _updateStyles
     * @private
     */
    _updateStyles: function()
    {
        _yuitest_coverfunc("/build/charts-base/charts-base.js", "_updateStyles", 11907);
_yuitest_coverline("/build/charts-base/charts-base.js", 11909);
var styles = this.get("styles").background,
            border = styles.border;
            _yuitest_coverline("/build/charts-base/charts-base.js", 11911);
border.opacity = border.alpha;
            _yuitest_coverline("/build/charts-base/charts-base.js", 11912);
styles.stroke = border;
            _yuitest_coverline("/build/charts-base/charts-base.js", 11913);
styles.fill.opacity = styles.fill.alpha;
        _yuitest_coverline("/build/charts-base/charts-base.js", 11914);
this.get("background").set(styles);
        _yuitest_coverline("/build/charts-base/charts-base.js", 11915);
this._sizeChangeHandler();
    },

    /**
     * Event handler for size changes.
     *
     * @method _sizeChangeHandler
     * @param {Object} e Event object.
     * @private
     */
    _sizeChangeHandler: function(e)
    {
        _yuitest_coverfunc("/build/charts-base/charts-base.js", "_sizeChangeHandler", 11925);
_yuitest_coverline("/build/charts-base/charts-base.js", 11927);
var hgl = this.get("horizontalGridlines"),
            vgl = this.get("verticalGridlines"),
            w = this.get("width"),
            h = this.get("height"),
            bg = this.get("styles").background,
            weight,
            background;
        _yuitest_coverline("/build/charts-base/charts-base.js", 11934);
if(bg && bg.border)
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 11936);
weight = bg.border.weight || 0;
        }
        _yuitest_coverline("/build/charts-base/charts-base.js", 11938);
if(this.get("showBackground"))
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 11940);
background = this.get("background");
            _yuitest_coverline("/build/charts-base/charts-base.js", 11941);
if(w && h)
            {
                _yuitest_coverline("/build/charts-base/charts-base.js", 11943);
background.set("width", w);
                _yuitest_coverline("/build/charts-base/charts-base.js", 11944);
background.set("height", h);
            }
        }
        _yuitest_coverline("/build/charts-base/charts-base.js", 11947);
if(this._gridlines)
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 11949);
this._gridlines.clear();
        }
        _yuitest_coverline("/build/charts-base/charts-base.js", 11951);
if(hgl && hgl instanceof Y.Gridlines)
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 11953);
hgl.draw();
        }
        _yuitest_coverline("/build/charts-base/charts-base.js", 11955);
if(vgl && vgl instanceof Y.Gridlines)
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 11957);
vgl.draw();
        }
        _yuitest_coverline("/build/charts-base/charts-base.js", 11959);
this._drawSeries();
    },

    /**
     * Draws each series.
     *
     * @method _drawSeries
     * @private
     */
    _drawSeries: function()
    {
        _yuitest_coverfunc("/build/charts-base/charts-base.js", "_drawSeries", 11968);
_yuitest_coverline("/build/charts-base/charts-base.js", 11970);
if(this._drawing)
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 11972);
this._callLater = true;
            _yuitest_coverline("/build/charts-base/charts-base.js", 11973);
return;
        }
        _yuitest_coverline("/build/charts-base/charts-base.js", 11975);
var sc,
            i,
            len,
            graphic = this.get("graphic");
        _yuitest_coverline("/build/charts-base/charts-base.js", 11979);
graphic.set("autoDraw", false);
        _yuitest_coverline("/build/charts-base/charts-base.js", 11980);
this._callLater = false;
        _yuitest_coverline("/build/charts-base/charts-base.js", 11981);
this._drawing = true;
        _yuitest_coverline("/build/charts-base/charts-base.js", 11982);
sc = this.get("seriesCollection");
        _yuitest_coverline("/build/charts-base/charts-base.js", 11983);
i = 0;
        _yuitest_coverline("/build/charts-base/charts-base.js", 11984);
len = sc ? sc.length : 0;
        _yuitest_coverline("/build/charts-base/charts-base.js", 11985);
for(; i < len; ++i)
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 11987);
sc[i].draw();
            _yuitest_coverline("/build/charts-base/charts-base.js", 11988);
if((!sc[i].get("xcoords") || !sc[i].get("ycoords")) && !sc[i] instanceof Y.PieSeries)
            {
                _yuitest_coverline("/build/charts-base/charts-base.js", 11990);
this._callLater = true;
                _yuitest_coverline("/build/charts-base/charts-base.js", 11991);
break;
            }
        }
        _yuitest_coverline("/build/charts-base/charts-base.js", 11994);
this._drawing = false;
        _yuitest_coverline("/build/charts-base/charts-base.js", 11995);
if(this._callLater)
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 11997);
this._drawSeries();
        }
    },  

    /**
     * Event handler for series drawingComplete event.
     *
     * @method _drawingCompleteHandler
     * @param {Object} e Event object.
     * @private
     */
    _drawingCompleteHandler: function(e)
    {
        _yuitest_coverfunc("/build/charts-base/charts-base.js", "_drawingCompleteHandler", 12008);
_yuitest_coverline("/build/charts-base/charts-base.js", 12010);
var series = e.currentTarget,
            graphic,
            index = Y.Array.indexOf(this._dispatchers, series);
        _yuitest_coverline("/build/charts-base/charts-base.js", 12013);
if(index > -1)
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 12015);
this._dispatchers.splice(index, 1);
        }
        _yuitest_coverline("/build/charts-base/charts-base.js", 12017);
if(this._dispatchers.length < 1)
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 12019);
graphic = this.get("graphic");
            _yuitest_coverline("/build/charts-base/charts-base.js", 12020);
if(!graphic.get("autoDraw"))
            {
                _yuitest_coverline("/build/charts-base/charts-base.js", 12022);
graphic._redraw();
            }
            _yuitest_coverline("/build/charts-base/charts-base.js", 12024);
this.fire("chartRendered");
        }
    },

    /**
     * Gets the default value for the `styles` attribute. Overrides
     * base implementation.
     *
     * @method _getDefaultStyles
     * @return Object
     * @protected
     */
    _getDefaultStyles: function()
    {
        _yuitest_coverfunc("/build/charts-base/charts-base.js", "_getDefaultStyles", 12036);
_yuitest_coverline("/build/charts-base/charts-base.js", 12038);
var defs = {
            background: {
                shape: "rect",
                fill:{
                    color:"#faf9f2"
                },
                border: {
                    color:"#dad8c9",
                    weight: 1
                }
            }
        };
        _yuitest_coverline("/build/charts-base/charts-base.js", 12050);
return defs;
    },

    /**
     * Destructor implementation Graph class. Removes all Graphic instances from the widget.
     *
     * @method destructor
     * @protected
     */
    destructor: function()
    {
        _yuitest_coverfunc("/build/charts-base/charts-base.js", "destructor", 12059);
_yuitest_coverline("/build/charts-base/charts-base.js", 12061);
if(this._graphic)
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 12063);
this._graphic.destroy();
            _yuitest_coverline("/build/charts-base/charts-base.js", 12064);
this._graphic = null;
        }
        _yuitest_coverline("/build/charts-base/charts-base.js", 12066);
if(this._background)
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 12068);
this._background.get("graphic").destroy();
            _yuitest_coverline("/build/charts-base/charts-base.js", 12069);
this._background = null;
        }
        _yuitest_coverline("/build/charts-base/charts-base.js", 12071);
if(this._gridlines)
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 12073);
this._gridlines.get("graphic").destroy();
            _yuitest_coverline("/build/charts-base/charts-base.js", 12074);
this._gridlines = null;
        }
    }
}, {
    ATTRS: {
        /**
         * The x-coordinate for the graph.
         *
         * @attribute x
         * @type Number
         * @protected
         */
        x: {
            setter: function(val)
            {
                _yuitest_coverfunc("/build/charts-base/charts-base.js", "setter", 12087);
_yuitest_coverline("/build/charts-base/charts-base.js", 12089);
this.get("boundingBox").setStyle("left", val + "px");
                _yuitest_coverline("/build/charts-base/charts-base.js", 12090);
return val;
            }
        },

        /**
         * The y-coordinate for the graph.
         *
         * @attribute y
         * @type Number
         * @protected
         */
        y: {
            setter: function(val)
            {
                _yuitest_coverfunc("/build/charts-base/charts-base.js", "setter", 12102);
_yuitest_coverline("/build/charts-base/charts-base.js", 12104);
this.get("boundingBox").setStyle("top", val + "px");
                _yuitest_coverline("/build/charts-base/charts-base.js", 12105);
return val;
            }
        },

        /**
         * Reference to the chart instance using the graph.
         *
         * @attribute chart
         * @type ChartBase
         * @readOnly
         */
        chart: {},

        /**
         * Collection of series. When setting the `seriesCollection` the array can contain a combination of either
         * `CartesianSeries` instances or object literals with properties that will define a series.
         *
         * @attribute seriesCollection
         * @type CartesianSeries
         */
        seriesCollection: {
            getter: function()
            {
                _yuitest_coverfunc("/build/charts-base/charts-base.js", "getter", 12126);
_yuitest_coverline("/build/charts-base/charts-base.js", 12128);
return this._seriesCollection;
            },

            setter: function(val)
            {
                _yuitest_coverfunc("/build/charts-base/charts-base.js", "setter", 12131);
_yuitest_coverline("/build/charts-base/charts-base.js", 12133);
this._parseSeriesCollection(val);
                _yuitest_coverline("/build/charts-base/charts-base.js", 12134);
return this._seriesCollection;
            }
        },
       
        /**
         * Indicates whether the `Graph` has a background.
         *
         * @attribute showBackground
         * @type Boolean
         * @default true
         */
        showBackground: {
            value: true
        },

        /**
         * Read-only hash lookup for all series on in the `Graph`.
         *
         * @attribute seriesDictionary
         * @type Object
         * @readOnly
         */
        seriesDictionary: {
            readOnly: true,

            getter: function()
            {
                _yuitest_coverfunc("/build/charts-base/charts-base.js", "getter", 12159);
_yuitest_coverline("/build/charts-base/charts-base.js", 12161);
return this._seriesDictionary;
            }
        },

        /**
         * Reference to the horizontal `Gridlines` instance.
         *
         * @attribute horizontalGridlines
         * @type Gridlines
         * @default null
         */
        horizontalGridlines: {
            value: null,

            setter: function(val)
            {
                _yuitest_coverfunc("/build/charts-base/charts-base.js", "setter", 12175);
_yuitest_coverline("/build/charts-base/charts-base.js", 12177);
var gl = this.get("horizontalGridlines");
                _yuitest_coverline("/build/charts-base/charts-base.js", 12178);
if(gl && gl instanceof Y.Gridlines)
                {
                    _yuitest_coverline("/build/charts-base/charts-base.js", 12180);
gl.remove();
                }
                _yuitest_coverline("/build/charts-base/charts-base.js", 12182);
if(val instanceof Y.Gridlines)
                {
                    _yuitest_coverline("/build/charts-base/charts-base.js", 12184);
gl = val;
                    _yuitest_coverline("/build/charts-base/charts-base.js", 12185);
val.set("graph", this);
                    _yuitest_coverline("/build/charts-base/charts-base.js", 12186);
return val;
                }
                else {_yuitest_coverline("/build/charts-base/charts-base.js", 12188);
if(val && val.axis)
                {
                    _yuitest_coverline("/build/charts-base/charts-base.js", 12190);
gl = new Y.Gridlines({direction:"horizontal", axis:val.axis, graph:this, styles:val.styles});
                    _yuitest_coverline("/build/charts-base/charts-base.js", 12191);
return gl;
                }}
            }
        },
        
        /**
         * Reference to the vertical `Gridlines` instance.
         *
         * @attribute verticalGridlines
         * @type Gridlines
         * @default null
         */
        verticalGridlines: {
            value: null,

            setter: function(val)
            {
                _yuitest_coverfunc("/build/charts-base/charts-base.js", "setter", 12206);
_yuitest_coverline("/build/charts-base/charts-base.js", 12208);
var gl = this.get("verticalGridlines");
                _yuitest_coverline("/build/charts-base/charts-base.js", 12209);
if(gl && gl instanceof Y.Gridlines)
                {
                    _yuitest_coverline("/build/charts-base/charts-base.js", 12211);
gl.remove();
                }
                _yuitest_coverline("/build/charts-base/charts-base.js", 12213);
if(val instanceof Y.Gridlines)
                {
                    _yuitest_coverline("/build/charts-base/charts-base.js", 12215);
gl = val;
                    _yuitest_coverline("/build/charts-base/charts-base.js", 12216);
val.set("graph", this);
                    _yuitest_coverline("/build/charts-base/charts-base.js", 12217);
return val;
                }
                else {_yuitest_coverline("/build/charts-base/charts-base.js", 12219);
if(val && val.axis)
                {
                    _yuitest_coverline("/build/charts-base/charts-base.js", 12221);
gl = new Y.Gridlines({direction:"vertical", axis:val.axis, graph:this, styles:val.styles});
                    _yuitest_coverline("/build/charts-base/charts-base.js", 12222);
return gl;
                }}
            }
        },

        /**
         * Reference to graphic instance used for the background.
         *
         * @attribute background
         * @type Graphic
         * @readOnly
         */
        background: {
            getter: function()
            {
                _yuitest_coverfunc("/build/charts-base/charts-base.js", "getter", 12235);
_yuitest_coverline("/build/charts-base/charts-base.js", 12237);
if(!this._background)
                {
                    _yuitest_coverline("/build/charts-base/charts-base.js", 12239);
this._backgroundGraphic = new Y.Graphic({render:this.get("contentBox")});
                    _yuitest_coverline("/build/charts-base/charts-base.js", 12240);
this._backgroundGraphic.get("node").style.zIndex = 0; 
                    _yuitest_coverline("/build/charts-base/charts-base.js", 12241);
this._background = this._backgroundGraphic.addShape({type: "rect"});
                }
                _yuitest_coverline("/build/charts-base/charts-base.js", 12243);
return this._background;
            }
        },

        /**
         * Reference to graphic instance used for gridlines.
         *
         * @attribute gridlines
         * @type Graphic
         * @readOnly
         */
        gridlines: {
            readOnly: true,

            getter: function()
            {
                _yuitest_coverfunc("/build/charts-base/charts-base.js", "getter", 12257);
_yuitest_coverline("/build/charts-base/charts-base.js", 12259);
if(!this._gridlines)
                {
                    _yuitest_coverline("/build/charts-base/charts-base.js", 12261);
this._gridlinesGraphic = new Y.Graphic({render:this.get("contentBox")});
                    _yuitest_coverline("/build/charts-base/charts-base.js", 12262);
this._gridlinesGraphic.get("node").style.zIndex = 1; 
                    _yuitest_coverline("/build/charts-base/charts-base.js", 12263);
this._gridlines = this._gridlinesGraphic.addShape({type: "path"});
                }
                _yuitest_coverline("/build/charts-base/charts-base.js", 12265);
return this._gridlines;
            }
        },
        
        /**
         * Reference to graphic instance used for series.
         *
         * @attribute graphic
         * @type Graphic
         * @readOnly
         */
        graphic: {
            readOnly: true,

            getter: function() 
            {
                _yuitest_coverfunc("/build/charts-base/charts-base.js", "getter", 12279);
_yuitest_coverline("/build/charts-base/charts-base.js", 12281);
if(!this._graphic)
                {
                    _yuitest_coverline("/build/charts-base/charts-base.js", 12283);
this._graphic = new Y.Graphic({render:this.get("contentBox")});
                    _yuitest_coverline("/build/charts-base/charts-base.js", 12284);
this._graphic.get("node").style.zIndex = 2; 
                    _yuitest_coverline("/build/charts-base/charts-base.js", 12285);
this._graphic.set("autoDraw", false);
                }
                _yuitest_coverline("/build/charts-base/charts-base.js", 12287);
return this._graphic;
            }
        },

        /**
         * Indicates whether or not markers for a series will be grouped and rendered in a single complex shape instance.
         *
         * @attribute groupMarkers
         * @type Boolean
         */
        groupMarkers: {
            value: false
        }

        /**
         * Style properties used for drawing a background. Below are the default values:
         *  <dl>
         *      <dt>background</dt><dd>An object containing the following values:
         *          <dl>
         *              <dt>fill</dt><dd>Defines the style properties for the fill. Contains the following values:
         *                  <dl>
         *                      <dt>color</dt><dd>Color of the fill. The default value is #faf9f2.</dd>
         *                      <dt>alpha</dt><dd>Number from 0 to 1 indicating the opacity of the background fill. The default value is 1.</dd>
         *                  </dl>
         *              </dd>
         *              <dt>border</dt><dd>Defines the style properties for the border. Contains the following values:
         *                  <dl>
         *                      <dt>color</dt><dd>Color of the border. The default value is #dad8c9.</dd>
         *                      <dt>alpha</dt><dd>Number from 0 to 1 indicating the opacity of the background border. The default value is 1.</dd>
         *                      <dt>weight</dt><dd>Number indicating the width of the border. The default value is 1.</dd>
         *                  </dl>
         *              </dd>
         *          </dl>
         *      </dd>
         *  </dl>
         *
         * @attribute styles
         * @type Object
         */
    }
});
/**
 * The ChartBase class is an abstract class used to create charts.
 *
 * @module charts
 * @submodule charts-base
 * @class ChartBase
 * @constructor
 */
_yuitest_coverline("/build/charts-base/charts-base.js", 12336);
function ChartBase() {}

_yuitest_coverline("/build/charts-base/charts-base.js", 12338);
ChartBase.ATTRS = {
    /**
     * Data used to generate the chart.
     * 
     * @attribute dataProvider
     * @type Array
     */
    dataProvider: {
        lazyAdd: false,

        valueFn: function()
        {
            _yuitest_coverfunc("/build/charts-base/charts-base.js", "valueFn", 12348);
_yuitest_coverline("/build/charts-base/charts-base.js", 12350);
var defDataProvider = [];
            _yuitest_coverline("/build/charts-base/charts-base.js", 12351);
if(!this._seriesKeysExplicitlySet)
            {
                _yuitest_coverline("/build/charts-base/charts-base.js", 12353);
this._seriesKeys = this._buildSeriesKeys(defDataProvider);
            }
            _yuitest_coverline("/build/charts-base/charts-base.js", 12355);
return defDataProvider;
        },

        setter: function(val)
        {
            _yuitest_coverfunc("/build/charts-base/charts-base.js", "setter", 12358);
_yuitest_coverline("/build/charts-base/charts-base.js", 12360);
var dataProvider = this._setDataValues(val);
            _yuitest_coverline("/build/charts-base/charts-base.js", 12361);
if(!this._seriesKeysExplicitlySet)
            {
                _yuitest_coverline("/build/charts-base/charts-base.js", 12363);
this._seriesKeys = this._buildSeriesKeys(dataProvider);
            }
            _yuitest_coverline("/build/charts-base/charts-base.js", 12365);
return dataProvider;
        }
    },

    /**
     * A collection of keys that map to the series axes. If no keys are set,
     * they will be generated automatically depending on the data structure passed into 
     * the chart.
     *
     * @attribute seriesKeys
     * @type Array
     */
    seriesKeys: {
        getter: function()
        {
            _yuitest_coverfunc("/build/charts-base/charts-base.js", "getter", 12378);
_yuitest_coverline("/build/charts-base/charts-base.js", 12380);
return this._seriesKeys;
        },

        setter: function(val)
        {
            _yuitest_coverfunc("/build/charts-base/charts-base.js", "setter", 12383);
_yuitest_coverline("/build/charts-base/charts-base.js", 12385);
this._seriesKeysExplicitlySet = true;
            _yuitest_coverline("/build/charts-base/charts-base.js", 12386);
this._seriesKeys = val;
            _yuitest_coverline("/build/charts-base/charts-base.js", 12387);
return val;
        }
    },

    /**
     * Sets the `aria-label` for the chart.
     *
     * @attribute ariaLabel
     * @type String
     */
    ariaLabel: {
        value: "Chart Application",

        setter: function(val)
        {
            _yuitest_coverfunc("/build/charts-base/charts-base.js", "setter", 12400);
_yuitest_coverline("/build/charts-base/charts-base.js", 12402);
var cb = this.get("contentBox");
            _yuitest_coverline("/build/charts-base/charts-base.js", 12403);
if(cb)
            {
                _yuitest_coverline("/build/charts-base/charts-base.js", 12405);
cb.setAttribute("aria-label", val);
            }
            _yuitest_coverline("/build/charts-base/charts-base.js", 12407);
return val;
        }
    },
    
    /**
     * Sets the aria description for the chart.
     *
     * @attribute ariaDescription
     * @type String
     */
    ariaDescription: {
        value: "Use the up and down keys to navigate between series. Use the left and right keys to navigate through items in a series.",

        setter: function(val)
        {
            _yuitest_coverfunc("/build/charts-base/charts-base.js", "setter", 12420);
_yuitest_coverline("/build/charts-base/charts-base.js", 12422);
if(this._description)
            {
                _yuitest_coverline("/build/charts-base/charts-base.js", 12424);
this._description.setContent("");
                _yuitest_coverline("/build/charts-base/charts-base.js", 12425);
this._description.appendChild(DOCUMENT.createTextNode(val));
            }
            _yuitest_coverline("/build/charts-base/charts-base.js", 12427);
return val;
        }
    },
    
    /**
     * Reference to the default tooltip available for the chart.
     * <p>Contains the following properties:</p>
     *  <dl>
     *      <dt>node</dt><dd>Reference to the actual dom node</dd>
     *      <dt>showEvent</dt><dd>Event that should trigger the tooltip</dd>
     *      <dt>hideEvent</dt><dd>Event that should trigger the removal of a tooltip (can be an event or an array of events)</dd>
     *      <dt>styles</dt><dd>A hash of style properties that will be applied to the tooltip node</dd>
     *      <dt>show</dt><dd>Indicates whether or not to show the tooltip</dd>
     *      <dt>markerEventHandler</dt><dd>Displays and hides tooltip based on marker events</dd>
     *      <dt>planarEventHandler</dt><dd>Displays and hides tooltip based on planar events</dd>
     *      <dt>markerLabelFunction</dt><dd>Reference to the function used to format a marker event triggered tooltip's text. The method contains 
     *      the following arguments:
     *  <dl>
     *      <dt>categoryItem</dt><dd>An object containing the following:
     *  <dl>
     *      <dt>axis</dt><dd>The axis to which the category is bound.</dd>
     *      <dt>displayName</dt><dd>The display name set to the category (defaults to key if not provided).</dd>
     *      <dt>key</dt><dd>The key of the category.</dd>
     *      <dt>value</dt><dd>The value of the category.</dd>
     *  </dl>
     *  </dd>
     *  <dt>valueItem</dt><dd>An object containing the following:
     *      <dl>
     *          <dt>axis</dt><dd>The axis to which the item's series is bound.</dd>
     *          <dt>displayName</dt><dd>The display name of the series. (defaults to key if not provided)</dd>
     *          <dt>key</dt><dd>The key for the series.</dd>
     *          <dt>value</dt><dd>The value for the series item.</dd> 
     *      </dl>
     *  </dd>
     *  <dt>itemIndex</dt><dd>The index of the item within the series.</dd>
     *  <dt>series</dt><dd> The `CartesianSeries` instance of the item.</dd>
     *  <dt>seriesIndex</dt><dd>The index of the series in the `seriesCollection`.</dd>
     *  </dl>
     *  The method returns an `HTMLElement` which is written into the DOM using `appendChild`. If you override this method and choose to return an html string, you
     *  will also need to override the tooltip's `setTextFunction` method to accept an html string.
     *  </dd>
     *  <dt>planarLabelFunction</dt><dd>Reference to the function used to format a planar event triggered tooltip's text
     *  <dl>
     *      <dt>categoryAxis</dt><dd> `CategoryAxis` Reference to the categoryAxis of the chart.
     *      <dt>valueItems</dt><dd>Array of objects for each series that has a data point in the coordinate plane of the event. Each object contains the following data:
     *  <dl>
     *      <dt>axis</dt><dd>The value axis of the series.</dd>
     *      <dt>key</dt><dd>The key for the series.</dd>
     *      <dt>value</dt><dd>The value for the series item.</dd>
     *      <dt>displayName</dt><dd>The display name of the series. (defaults to key if not provided)</dd>
     *  </dl> 
     *  </dd>
     *      <dt>index</dt><dd>The index of the item within its series.</dd>
     *      <dt>seriesArray</dt><dd>Array of series instances for each value item.</dd>
     *      <dt>seriesIndex</dt><dd>The index of the series in the `seriesCollection`.</dd>
     *  </dl>
     *  </dd>
     *  </dl>
     *  The method returns an `HTMLElement` which is written into the DOM using `appendChild`. If you override this method and choose to return an html string, you
     *  will also need to override the tooltip's `setTextFunction` method to accept an html string.
     *  </dd>
     *  <dt>setTextFunction</dt><dd>Method that writes content returned from `planarLabelFunction` or `markerLabelFunction` into the the tooltip node.
     *  has the following signature:
     *  <dl>
     *      <dt>label</dt><dd>The `HTMLElement` that the content is to be added.</dd>
     *      <dt>val</dt><dd>The content to be rendered into tooltip. This can be a `String` or `HTMLElement`. If an HTML string is used, it will be rendered as a
     *      string.</dd>
     *  </dl>
     *  </dd>
     *  </dl>
     * @attribute tooltip
     * @type Object
     */ 
    tooltip: {
        valueFn: "_getTooltip",

        setter: function(val)
        {
            _yuitest_coverfunc("/build/charts-base/charts-base.js", "setter", 12503);
_yuitest_coverline("/build/charts-base/charts-base.js", 12505);
return this._updateTooltip(val);
        }
    },

    /** 
     * The key value used for the chart's category axis. 
     *
     * @attribute categoryKey
     * @type String
     * @default category
     */
    categoryKey: {
        value: "category"
    },
        
    /**
     * Indicates the type of axis to use for the category axis.
     *
     *  <dl>
     *      <dt>category</dt><dd>Specifies a `CategoryAxis`.</dd>
     *      <dt>time</dt><dd>Specifies a `TimeAxis</dd>
     *  </dl>
     *
     * @attribute categoryType
     * @type String
     * @default category
     */
    categoryType:{
        value:"category"
    },

    /**
     * Indicates the the type of interactions that will fire events.
     *
     *  <dl>
     *      <dt>marker</dt><dd>Events will be broadcasted when the mouse interacts with individual markers.</dd>
     *      <dt>planar</dt><dd>Events will be broadcasted when the mouse intersects the plane of any markers on the chart.</dd>
     *      <dt>none</dt><dd>No events will be broadcasted.</dd>
     *  </dl>
     *
     * @attribute interactionType
     * @type String
     * @default marker
     */
    interactionType: {
        value: "marker"
    },

    /**
     * Reference to all the axes in the chart.
     *
     * @attribute axesCollection
     * @type Array
     */
    axesCollection: {},

    /**
     * Reference to graph instance.
     * 
     * @attribute graph
     * @type Graph 
     */
    graph: {
        valueFn: "_getGraph"
    },

    /**
     * Indicates whether or not markers for a series will be grouped and rendered in a single complex shape instance.
     *
     * @attribute groupMarkers
     * @type Boolean
     */
    groupMarkers: {
        value: false
    }
};

_yuitest_coverline("/build/charts-base/charts-base.js", 12582);
ChartBase.prototype = {
    /**
     * Handles groupMarkers change event.
     *
     * @method _groupMarkersChangeHandler
     * @param {Object} e Event object.
     * @private
     */
    _groupMarkersChangeHandler: function(e)
    {
        _yuitest_coverfunc("/build/charts-base/charts-base.js", "_groupMarkersChangeHandler", 12590);
_yuitest_coverline("/build/charts-base/charts-base.js", 12592);
var graph = this.get("graph"),
            useGroupMarkers = e.newVal;
        _yuitest_coverline("/build/charts-base/charts-base.js", 12594);
if(graph)
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 12596);
graph.set("groupMarkers", useGroupMarkers);
        }
    },

    /**
     * Handler for itemRendered event.
     *
     * @method _itemRendered
     * @param {Object} e Event object.
     * @private
     */
    _itemRendered: function(e)
    {
        _yuitest_coverfunc("/build/charts-base/charts-base.js", "_itemRendered", 12607);
_yuitest_coverline("/build/charts-base/charts-base.js", 12609);
this._itemRenderQueue = this._itemRenderQueue.splice(1 + Y.Array.indexOf(this._itemRenderQueue, e.currentTarget), 1);
        _yuitest_coverline("/build/charts-base/charts-base.js", 12610);
if(this._itemRenderQueue.length < 1)
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 12612);
this._redraw();
        }
    },

    /**
     * Default value function for the `Graph` attribute.
     *
     * @method _getGraph
     * @return Graph
     * @private
     */
    _getGraph: function()
    {
        _yuitest_coverfunc("/build/charts-base/charts-base.js", "_getGraph", 12623);
_yuitest_coverline("/build/charts-base/charts-base.js", 12625);
var graph = new Y.Graph({
            chart:this,
            groupMarkers: this.get("groupMarkers")    
        });
        _yuitest_coverline("/build/charts-base/charts-base.js", 12629);
graph.after("chartRendered", Y.bind(function(e) {
            _yuitest_coverfunc("/build/charts-base/charts-base.js", "(anonymous 6)", 12629);
_yuitest_coverline("/build/charts-base/charts-base.js", 12630);
this.fire("chartRendered");
        }, this));
        _yuitest_coverline("/build/charts-base/charts-base.js", 12632);
return graph; 
    },

    /**
     * Returns a series instance by index or key value.
     *
     * @method getSeries
     * @param val
     * @return CartesianSeries
     */
    getSeries: function(val)
    {
        _yuitest_coverfunc("/build/charts-base/charts-base.js", "getSeries", 12642);
_yuitest_coverline("/build/charts-base/charts-base.js", 12644);
var series = null, 
            graph = this.get("graph");
        _yuitest_coverline("/build/charts-base/charts-base.js", 12646);
if(graph)
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 12648);
if(Y_Lang.isNumber(val))
            {
                _yuitest_coverline("/build/charts-base/charts-base.js", 12650);
series = graph.getSeriesByIndex(val);
            }
            else
            {
                _yuitest_coverline("/build/charts-base/charts-base.js", 12654);
series = graph.getSeriesByKey(val);
            }
        }
        _yuitest_coverline("/build/charts-base/charts-base.js", 12657);
return series;
    },

    /**
     * Returns an `Axis` instance by key reference. If the axis was explicitly set through the `axes` attribute,
     * the key will be the same as the key used in the `axes` object. For default axes, the key for
     * the category axis is the value of the `categoryKey` (`category`). For the value axis, the default 
     * key is `values`.
     *
     * @method getAxisByKey
     * @param {String} val Key reference used to look up the axis.
     * @return Axis
     */
    getAxisByKey: function(val)
    {
        _yuitest_coverfunc("/build/charts-base/charts-base.js", "getAxisByKey", 12670);
_yuitest_coverline("/build/charts-base/charts-base.js", 12672);
var axis,
            axes = this.get("axes");
        _yuitest_coverline("/build/charts-base/charts-base.js", 12674);
if(axes && axes.hasOwnProperty(val))
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 12676);
axis = axes[val];
        }
        _yuitest_coverline("/build/charts-base/charts-base.js", 12678);
return axis;
    },

    /**
     * Returns the category axis for the chart.
     *
     * @method getCategoryAxis
     * @return Axis
     */
    getCategoryAxis: function()
    {
        _yuitest_coverfunc("/build/charts-base/charts-base.js", "getCategoryAxis", 12687);
_yuitest_coverline("/build/charts-base/charts-base.js", 12689);
var axis,
            key = this.get("categoryKey"),
            axes = this.get("axes");
        _yuitest_coverline("/build/charts-base/charts-base.js", 12692);
if(axes.hasOwnProperty(key))
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 12694);
axis = axes[key];
        }
        _yuitest_coverline("/build/charts-base/charts-base.js", 12696);
return axis;
    },

    /**
     * Default direction of the chart.
     *
     * @property _direction
     * @type String
     * @default horizontal
     * @private
     */
    _direction: "horizontal",
    
    /**
     * Storage for the `dataProvider` attribute.
     *
     * @property _dataProvider
     * @type Array
     * @private
     */
    _dataProvider: null,

    /**
     * Setter method for `dataProvider` attribute.
     *
     * @method _setDataValues
     * @param {Array} val Array to be set as `dataProvider`.
     * @return Array
     * @private
     */
    _setDataValues: function(val)
    {
        _yuitest_coverfunc("/build/charts-base/charts-base.js", "_setDataValues", 12726);
_yuitest_coverline("/build/charts-base/charts-base.js", 12728);
if(Y_Lang.isArray(val[0]))
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 12730);
var hash, 
                dp = [], 
                cats = val[0], 
                i = 0, 
                l = cats.length, 
                n, 
                sl = val.length;
            _yuitest_coverline("/build/charts-base/charts-base.js", 12737);
for(; i < l; ++i)
            {
                _yuitest_coverline("/build/charts-base/charts-base.js", 12739);
hash = {category:cats[i]};
                _yuitest_coverline("/build/charts-base/charts-base.js", 12740);
for(n = 1; n < sl; ++n)
                {
                    _yuitest_coverline("/build/charts-base/charts-base.js", 12742);
hash["series" + n] = val[n][i];
                }
                _yuitest_coverline("/build/charts-base/charts-base.js", 12744);
dp[i] = hash; 
            }
            _yuitest_coverline("/build/charts-base/charts-base.js", 12746);
return dp;
        }
        _yuitest_coverline("/build/charts-base/charts-base.js", 12748);
return val;
    },

    /**
     * Storage for `seriesCollection` attribute.
     *
     * @property _seriesCollection
     * @type Array
     * @private 
     */
    _seriesCollection: null,

    /**
     * Setter method for `seriesCollection` attribute.
     *
     * @property _setSeriesCollection
     * @param {Array} val Array of either `CartesianSeries` instances or objects containing series attribute key value pairs.
     * @private
     */
    _setSeriesCollection: function(val)
    {
        _yuitest_coverfunc("/build/charts-base/charts-base.js", "_setSeriesCollection", 12767);
_yuitest_coverline("/build/charts-base/charts-base.js", 12769);
this._seriesCollection = val;
    },
    /**
     * Helper method that returns the axis class that a key references.
     *
     * @method _getAxisClass
     * @param {String} t The type of axis.
     * @return Axis
     * @private
     */
    _getAxisClass: function(t)
    {
        _yuitest_coverfunc("/build/charts-base/charts-base.js", "_getAxisClass", 12779);
_yuitest_coverline("/build/charts-base/charts-base.js", 12781);
return this._axisClass[t];
    },
  
    /**
     * Key value pairs of axis types. 
     *
     * @property _axisClass
     * @type Object
     * @private
     */
    _axisClass: {
        stacked: Y.StackedAxis,
        numeric: Y.NumericAxis,
        category: Y.CategoryAxis,
        time: Y.TimeAxis
    },

    /**
     * Collection of axes.
     *
     * @property _axes
     * @type Array
     * @private
     */
    _axes: null,

    /**
     * @method initializer
     * @private
     */
    initializer: function()
    {
        _yuitest_coverfunc("/build/charts-base/charts-base.js", "initializer", 12811);
_yuitest_coverline("/build/charts-base/charts-base.js", 12813);
this._itemRenderQueue = [];
        _yuitest_coverline("/build/charts-base/charts-base.js", 12814);
this._seriesIndex = -1;
        _yuitest_coverline("/build/charts-base/charts-base.js", 12815);
this._itemIndex = -1;
        _yuitest_coverline("/build/charts-base/charts-base.js", 12816);
this.after("dataProviderChange", this._dataProviderChangeHandler);
    },

    /**
     * @method renderUI
     * @private
     */
    renderUI: function()
    {
        _yuitest_coverfunc("/build/charts-base/charts-base.js", "renderUI", 12823);
_yuitest_coverline("/build/charts-base/charts-base.js", 12825);
var tt = this.get("tooltip"),
            bb = this.get("boundingBox"),
            cb = this.get("contentBox");
        //move the position = absolute logic to a class file
        _yuitest_coverline("/build/charts-base/charts-base.js", 12829);
bb.setStyle("position", "absolute");
        _yuitest_coverline("/build/charts-base/charts-base.js", 12830);
cb.setStyle("position", "absolute");
        _yuitest_coverline("/build/charts-base/charts-base.js", 12831);
this._addAxes();
        _yuitest_coverline("/build/charts-base/charts-base.js", 12832);
this._addSeries();
        _yuitest_coverline("/build/charts-base/charts-base.js", 12833);
if(tt && tt.show)
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 12835);
this._addTooltip();
        }
        _yuitest_coverline("/build/charts-base/charts-base.js", 12837);
this._setAriaElements(bb, cb);
    },
   
    /**
     * Creates an aria `live-region`, `aria-label` and `aria-describedby` for the Chart.
     *
     * @method _setAriaElements
     * @param {Node} cb Reference to the Chart's `contentBox` attribute.
     * @private
     */
    _setAriaElements: function(bb, cb)
    {
        _yuitest_coverfunc("/build/charts-base/charts-base.js", "_setAriaElements", 12847);
_yuitest_coverline("/build/charts-base/charts-base.js", 12849);
var description = this._getAriaOffscreenNode(),
            id = this.get("id") + "_description",
            liveRegion = this._getAriaOffscreenNode();
        _yuitest_coverline("/build/charts-base/charts-base.js", 12852);
cb.set("tabIndex", 0);
        _yuitest_coverline("/build/charts-base/charts-base.js", 12853);
cb.set("role", "img");
        _yuitest_coverline("/build/charts-base/charts-base.js", 12854);
cb.setAttribute("aria-label", this.get("ariaLabel"));
        _yuitest_coverline("/build/charts-base/charts-base.js", 12855);
cb.setAttribute("aria-describedby", id);
        _yuitest_coverline("/build/charts-base/charts-base.js", 12856);
description.set("id", id);
        _yuitest_coverline("/build/charts-base/charts-base.js", 12857);
description.set("tabIndex", -1);
        _yuitest_coverline("/build/charts-base/charts-base.js", 12858);
description.appendChild(DOCUMENT.createTextNode(this.get("ariaDescription")));
        _yuitest_coverline("/build/charts-base/charts-base.js", 12859);
liveRegion.set("id", "live-region");
        _yuitest_coverline("/build/charts-base/charts-base.js", 12860);
liveRegion.set("aria-live", "polite");
        _yuitest_coverline("/build/charts-base/charts-base.js", 12861);
liveRegion.set("aria-atomic", "true");
        _yuitest_coverline("/build/charts-base/charts-base.js", 12862);
liveRegion.set("role", "status");
        _yuitest_coverline("/build/charts-base/charts-base.js", 12863);
bb.setAttribute("role", "application");
        _yuitest_coverline("/build/charts-base/charts-base.js", 12864);
bb.appendChild(description);
        _yuitest_coverline("/build/charts-base/charts-base.js", 12865);
bb.appendChild(liveRegion);
        _yuitest_coverline("/build/charts-base/charts-base.js", 12866);
this._description = description;
        _yuitest_coverline("/build/charts-base/charts-base.js", 12867);
this._liveRegion = liveRegion;
    },

    /**
     * Sets a node offscreen for use as aria-description or aria-live-regin.
     *
     * @method _setOffscreen
     * @return Node 
     * @private
     */
    _getAriaOffscreenNode: function()  
    {
        _yuitest_coverfunc("/build/charts-base/charts-base.js", "_getAriaOffscreenNode", 12877);
_yuitest_coverline("/build/charts-base/charts-base.js", 12879);
var node = Y.Node.create("<div></div>"),
            ie = Y.UA.ie,
            clipRect = (ie && ie < 8) ? "rect(1px 1px 1px 1px)" : "rect(1px, 1px, 1px, 1px)";
        _yuitest_coverline("/build/charts-base/charts-base.js", 12882);
node.setStyle("position", "absolute");
        _yuitest_coverline("/build/charts-base/charts-base.js", 12883);
node.setStyle("height", "1px"); 
        _yuitest_coverline("/build/charts-base/charts-base.js", 12884);
node.setStyle("width", "1px"); 
        _yuitest_coverline("/build/charts-base/charts-base.js", 12885);
node.setStyle("overflow", "hidden");
        _yuitest_coverline("/build/charts-base/charts-base.js", 12886);
node.setStyle("clip", clipRect); 
        _yuitest_coverline("/build/charts-base/charts-base.js", 12887);
return node;
    },
  
    /**
     * @method syncUI
     * @private
     */
    syncUI: function()
    {
        _yuitest_coverfunc("/build/charts-base/charts-base.js", "syncUI", 12894);
_yuitest_coverline("/build/charts-base/charts-base.js", 12896);
this._redraw();
    },

    /**
     * @method bindUI
     * @private
     */
    bindUI: function()
    {
        _yuitest_coverfunc("/build/charts-base/charts-base.js", "bindUI", 12903);
_yuitest_coverline("/build/charts-base/charts-base.js", 12905);
this.after("tooltipChange", Y.bind(this._tooltipChangeHandler, this));
        _yuitest_coverline("/build/charts-base/charts-base.js", 12906);
this.after("widthChange", this._sizeChanged);
        _yuitest_coverline("/build/charts-base/charts-base.js", 12907);
this.after("heightChange", this._sizeChanged);
        _yuitest_coverline("/build/charts-base/charts-base.js", 12908);
this.after("groupMarkersChange", this._groupMarkersChangeHandler);
        _yuitest_coverline("/build/charts-base/charts-base.js", 12909);
var tt = this.get("tooltip"),
            hideEvent = "mouseout",
            showEvent = "mouseover",
            cb = this.get("contentBox"),
            interactionType = this.get("interactionType"),
            i = 0,
            len,
            markerClassName = "." + SERIES_MARKER,
            isTouch = ((WINDOW && ("ontouchstart" in WINDOW)) && !(Y.UA.chrome && Y.UA.chrome < 6));
        _yuitest_coverline("/build/charts-base/charts-base.js", 12918);
Y.on("keydown", Y.bind(function(e) {
            _yuitest_coverfunc("/build/charts-base/charts-base.js", "(anonymous 7)", 12918);
_yuitest_coverline("/build/charts-base/charts-base.js", 12919);
var key = e.keyCode,
                numKey = parseFloat(key),
                msg;
            _yuitest_coverline("/build/charts-base/charts-base.js", 12922);
if(numKey > 36 && numKey < 41)
            {
                _yuitest_coverline("/build/charts-base/charts-base.js", 12924);
e.halt();
                _yuitest_coverline("/build/charts-base/charts-base.js", 12925);
msg = this._getAriaMessage(numKey);
                _yuitest_coverline("/build/charts-base/charts-base.js", 12926);
this._liveRegion.setContent("");
                _yuitest_coverline("/build/charts-base/charts-base.js", 12927);
this._liveRegion.appendChild(DOCUMENT.createTextNode(msg));
            }
        }, this), this.get("contentBox"));
        _yuitest_coverline("/build/charts-base/charts-base.js", 12930);
if(interactionType == "marker")
        {
            //if touch capabilities, toggle tooltip on touchend. otherwise, the tooltip attribute's hideEvent/showEvent types.
            _yuitest_coverline("/build/charts-base/charts-base.js", 12933);
hideEvent = tt.hideEvent;
            _yuitest_coverline("/build/charts-base/charts-base.js", 12934);
showEvent = tt.showEvent;
            _yuitest_coverline("/build/charts-base/charts-base.js", 12935);
if(isTouch)
            {
                _yuitest_coverline("/build/charts-base/charts-base.js", 12937);
Y.delegate("touchend", Y.bind(this._markerEventDispatcher, this), cb, markerClassName);
                //hide active tooltip if the chart is touched
                _yuitest_coverline("/build/charts-base/charts-base.js", 12939);
Y.on("touchend", Y.bind(function(e) {
                    _yuitest_coverfunc("/build/charts-base/charts-base.js", "(anonymous 8)", 12939);
_yuitest_coverline("/build/charts-base/charts-base.js", 12940);
e.halt(true);
                    _yuitest_coverline("/build/charts-base/charts-base.js", 12941);
if(this._activeMarker)
                    {
                        _yuitest_coverline("/build/charts-base/charts-base.js", 12943);
this._activeMarker = null;
                        _yuitest_coverline("/build/charts-base/charts-base.js", 12944);
this.hideTooltip(e);
                    }
                }, this));
            }
            else
            {
                _yuitest_coverline("/build/charts-base/charts-base.js", 12950);
Y.delegate("mouseenter", Y.bind(this._markerEventDispatcher, this), cb, markerClassName);
                _yuitest_coverline("/build/charts-base/charts-base.js", 12951);
Y.delegate("mousedown", Y.bind(this._markerEventDispatcher, this), cb, markerClassName);
                _yuitest_coverline("/build/charts-base/charts-base.js", 12952);
Y.delegate("mouseup", Y.bind(this._markerEventDispatcher, this), cb, markerClassName);
                _yuitest_coverline("/build/charts-base/charts-base.js", 12953);
Y.delegate("mouseleave", Y.bind(this._markerEventDispatcher, this), cb, markerClassName);
                _yuitest_coverline("/build/charts-base/charts-base.js", 12954);
Y.delegate("click", Y.bind(this._markerEventDispatcher, this), cb, markerClassName);
                _yuitest_coverline("/build/charts-base/charts-base.js", 12955);
Y.delegate("mousemove", Y.bind(this._positionTooltip, this), cb, markerClassName);
            }
        }
        else {_yuitest_coverline("/build/charts-base/charts-base.js", 12958);
if(interactionType == "planar")
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 12960);
if(isTouch)
            {
                _yuitest_coverline("/build/charts-base/charts-base.js", 12962);
this._overlay.on("touchend", Y.bind(this._planarEventDispatcher, this));
            }
            else
            {
                _yuitest_coverline("/build/charts-base/charts-base.js", 12966);
this._overlay.on("mousemove", Y.bind(this._planarEventDispatcher, this));
                _yuitest_coverline("/build/charts-base/charts-base.js", 12967);
this.on("mouseout", this.hideTooltip);
            }
        }}
        _yuitest_coverline("/build/charts-base/charts-base.js", 12970);
if(tt)
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 12972);
this.on("markerEvent:touchend", Y.bind(function(e) {
                _yuitest_coverfunc("/build/charts-base/charts-base.js", "(anonymous 9)", 12972);
_yuitest_coverline("/build/charts-base/charts-base.js", 12973);
var marker = e.series.get("markers")[e.index];
                _yuitest_coverline("/build/charts-base/charts-base.js", 12974);
if(this._activeMarker && marker === this._activeMarker)
                {
                    _yuitest_coverline("/build/charts-base/charts-base.js", 12976);
this._activeMarker = null;
                    _yuitest_coverline("/build/charts-base/charts-base.js", 12977);
this.hideTooltip(e);
                }
                else
                {

                    _yuitest_coverline("/build/charts-base/charts-base.js", 12982);
this._activeMarker = marker;
                    _yuitest_coverline("/build/charts-base/charts-base.js", 12983);
tt.markerEventHandler.apply(this, [e]);
                }
            }, this));
            _yuitest_coverline("/build/charts-base/charts-base.js", 12986);
if(hideEvent && showEvent && hideEvent == showEvent)
            {
                _yuitest_coverline("/build/charts-base/charts-base.js", 12988);
this.on(interactionType + "Event:" + hideEvent, this.toggleTooltip);
            }
            else
            {
                _yuitest_coverline("/build/charts-base/charts-base.js", 12992);
if(showEvent)
                {
                    _yuitest_coverline("/build/charts-base/charts-base.js", 12994);
this.on(interactionType + "Event:" + showEvent, tt[interactionType + "EventHandler"]);
                }
                _yuitest_coverline("/build/charts-base/charts-base.js", 12996);
if(hideEvent)
                {
                    _yuitest_coverline("/build/charts-base/charts-base.js", 12998);
if(Y_Lang.isArray(hideEvent))
                    {
                        _yuitest_coverline("/build/charts-base/charts-base.js", 13000);
len = hideEvent.length;
                        _yuitest_coverline("/build/charts-base/charts-base.js", 13001);
for(; i < len; ++i)
                        {
                            _yuitest_coverline("/build/charts-base/charts-base.js", 13003);
this.on(interactionType + "Event:" + hideEvent[i], this.hideTooltip);
                        }
                    }
                    _yuitest_coverline("/build/charts-base/charts-base.js", 13006);
this.on(interactionType + "Event:" + hideEvent, this.hideTooltip);
                }
            }
        }
    },
    
    /**
     * Event handler for marker events.
     *
     * @method _markerEventDispatcher
     * @param {Object} e Event object.
     * @private
     */
    _markerEventDispatcher: function(e)
    {
        _yuitest_coverfunc("/build/charts-base/charts-base.js", "_markerEventDispatcher", 13019);
_yuitest_coverline("/build/charts-base/charts-base.js", 13021);
var type = e.type,
            cb = this.get("contentBox"),
            markerNode = e.currentTarget,
            strArr = markerNode.getAttribute("id").split("_"),
            index = strArr.pop(),
            seriesIndex = strArr.pop(),
            series = this.getSeries(parseInt(seriesIndex, 10)),
            items = this.getSeriesItems(series, index),
            isTouch = e && e.hasOwnProperty("changedTouches"),
            pageX = isTouch ? e.changedTouches[0].pageX : e.pageX,
            pageY = isTouch ? e.changedTouches[0].pageY : e.pageY,
            x = pageX - cb.getX(),
            y = pageY - cb.getY();
        _yuitest_coverline("/build/charts-base/charts-base.js", 13034);
if(type == "mouseenter")
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 13036);
type = "mouseover";
        }
        else {_yuitest_coverline("/build/charts-base/charts-base.js", 13038);
if(type == "mouseleave")
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 13040);
type = "mouseout";
        }}
        _yuitest_coverline("/build/charts-base/charts-base.js", 13042);
series.updateMarkerState(type, index);
        _yuitest_coverline("/build/charts-base/charts-base.js", 13043);
e.halt();
        /**
         * Broadcasts when `interactionType` is set to `marker` and a series marker has received a mouseover event.
         * 
         *
         * @event markerEvent:mouseover
         * @preventable false
         * @param {EventFacade} e Event facade with the following additional
         *   properties:
         *  <dl>
         *      <dt>categoryItem</dt><dd>Hash containing information about the category `Axis`.</dd>
         *      <dt>valueItem</dt><dd>Hash containing information about the value `Axis`.</dd>
         *      <dt>node</dt><dd>The dom node of the marker.</dd>
         *      <dt>x</dt><dd>The x-coordinate of the mouse in relation to the Chart.</dd>
         *      <dt>y</dt><dd>The y-coordinate of the mouse in relation to the Chart.</dd>
         *      <dt>series</dt><dd>Reference to the series of the marker.</dd>
         *      <dt>index</dt><dd>Index of the marker in the series.</dd>
         *      <dt>seriesIndex</dt><dd>The `order` of the marker's series.</dd>
         *  </dl>
         */
        /**
         * Broadcasts when `interactionType` is set to `marker` and a series marker has received a mouseout event.
         *
         * @event markerEvent:mouseout
         * @preventable false
         * @param {EventFacade} e Event facade with the following additional
         *   properties:
         *  <dl>
         *      <dt>categoryItem</dt><dd>Hash containing information about the category `Axis`.</dd>
         *      <dt>valueItem</dt><dd>Hash containing information about the value `Axis`.</dd>
         *      <dt>node</dt><dd>The dom node of the marker.</dd>
         *      <dt>x</dt><dd>The x-coordinate of the mouse in relation to the Chart.</dd>
         *      <dt>y</dt><dd>The y-coordinate of the mouse in relation to the Chart.</dd>
         *      <dt>series</dt><dd>Reference to the series of the marker.</dd>
         *      <dt>index</dt><dd>Index of the marker in the series.</dd>
         *      <dt>seriesIndex</dt><dd>The `order` of the marker's series.</dd>
         *  </dl>
         */
        /**
         * Broadcasts when `interactionType` is set to `marker` and a series marker has received a mousedown event.
         *
         * @event markerEvent:mousedown
         * @preventable false
         * @param {EventFacade} e Event facade with the following additional
         *   properties:
         *  <dl>
         *      <dt>categoryItem</dt><dd>Hash containing information about the category `Axis`.</dd>
         *      <dt>valueItem</dt><dd>Hash containing information about the value `Axis`.</dd>
         *      <dt>node</dt><dd>The dom node of the marker.</dd>
         *      <dt>x</dt><dd>The x-coordinate of the mouse in relation to the Chart.</dd>
         *      <dt>y</dt><dd>The y-coordinate of the mouse in relation to the Chart.</dd>
         *      <dt>series</dt><dd>Reference to the series of the marker.</dd>
         *      <dt>index</dt><dd>Index of the marker in the series.</dd>
         *      <dt>seriesIndex</dt><dd>The `order` of the marker's series.</dd>
         *  </dl>
         */
        /**
         * Broadcasts when `interactionType` is set to `marker` and a series marker has received a mouseup event.
         *
         * @event markerEvent:mouseup
         * @preventable false
         * @param {EventFacade} e Event facade with the following additional
         *   properties:
         *  <dl>
         *      <dt>categoryItem</dt><dd>Hash containing information about the category `Axis`.</dd>
         *      <dt>valueItem</dt><dd>Hash containing information about the value `Axis`.</dd>
         *      <dt>node</dt><dd>The dom node of the marker.</dd>
         *      <dt>x</dt><dd>The x-coordinate of the mouse in relation to the Chart.</dd>
         *      <dt>y</dt><dd>The y-coordinate of the mouse in relation to the Chart.</dd>
         *      <dt>series</dt><dd>Reference to the series of the marker.</dd>
         *      <dt>index</dt><dd>Index of the marker in the series.</dd>
         *      <dt>seriesIndex</dt><dd>The `order` of the marker's series.</dd>
         *  </dl>
         */
        /**
         * Broadcasts when `interactionType` is set to `marker` and a series marker has received a click event.
         *
         * @event markerEvent:click
         * @preventable false
         * @param {EventFacade} e Event facade with the following additional
         *   properties:
         *  <dl>
         *      <dt>categoryItem</dt><dd>Hash containing information about the category `Axis`.</dd>
         *      <dt>valueItem</dt><dd>Hash containing information about the value `Axis`.</dd>
         *      <dt>node</dt><dd>The dom node of the marker.</dd>
         *      <dt>x</dt><dd>The x-coordinate of the mouse in relation to the Chart.</dd>
         *      <dt>y</dt><dd>The y-coordinate of the mouse in relation to the Chart.</dd>
         *      <dt>pageX</dt><dd>The x location of the event on the page (including scroll)</dd>
         *      <dt>pageY</dt><dd>The y location of the event on the page (including scroll)</dd>
         *      <dt>series</dt><dd>Reference to the series of the marker.</dd>
         *      <dt>index</dt><dd>Index of the marker in the series.</dd>
         *      <dt>seriesIndex</dt><dd>The `order` of the marker's series.</dd>
         *      <dt>originEvent</dt><dd>Underlying dom event.</dd>
         *  </dl>
         */
        _yuitest_coverline("/build/charts-base/charts-base.js", 13138);
this.fire("markerEvent:" + type, {
            originEvent: e,
            pageX:pageX, 
            pageY:pageY, 
            categoryItem:items.category, 
            valueItem:items.value, 
            node:markerNode, 
            x:x, 
            y:y, 
            series:series, 
            index:index, 
            seriesIndex:seriesIndex
        });
    },

    /**
     * Event handler for dataProviderChange.
     *
     * @method _dataProviderChangeHandler
     * @param {Object} e Event object.
     * @private
     */
    _dataProviderChangeHandler: function(e)
    {
        _yuitest_coverfunc("/build/charts-base/charts-base.js", "_dataProviderChangeHandler", 13160);
_yuitest_coverline("/build/charts-base/charts-base.js", 13162);
var dataProvider = e.newVal,
            axes,
            i,
            axis;
        _yuitest_coverline("/build/charts-base/charts-base.js", 13166);
this._seriesIndex = -1;
        _yuitest_coverline("/build/charts-base/charts-base.js", 13167);
this._itemIndex = -1;
        _yuitest_coverline("/build/charts-base/charts-base.js", 13168);
if(this instanceof Y.CartesianChart)
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 13170);
this.set("axes", this.get("axes"));
            _yuitest_coverline("/build/charts-base/charts-base.js", 13171);
this.set("seriesCollection", this.get("seriesCollection"));
        }
        _yuitest_coverline("/build/charts-base/charts-base.js", 13173);
axes = this.get("axes");
        _yuitest_coverline("/build/charts-base/charts-base.js", 13174);
if(axes)
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 13176);
for(i in axes)
            {
                _yuitest_coverline("/build/charts-base/charts-base.js", 13178);
if(axes.hasOwnProperty(i))
                {
                    _yuitest_coverline("/build/charts-base/charts-base.js", 13180);
axis = axes[i];
                    _yuitest_coverline("/build/charts-base/charts-base.js", 13181);
if(axis instanceof Y.Axis)
                    {
                        _yuitest_coverline("/build/charts-base/charts-base.js", 13183);
if(axis.get("position") != "none")
                        {
                            _yuitest_coverline("/build/charts-base/charts-base.js", 13185);
this._addToAxesRenderQueue(axis);
                        }
                        _yuitest_coverline("/build/charts-base/charts-base.js", 13187);
axis.set("dataProvider", dataProvider);
                    }
                }
            }
        }
    },
    
    /**
     * Event listener for toggling the tooltip. If a tooltip is visible, hide it. If not, it 
     * will create and show a tooltip based on the event object.
     * 
     * @method toggleTooltip
     * @param {Object} e Event object.
     */
    toggleTooltip: function(e)
    {
        _yuitest_coverfunc("/build/charts-base/charts-base.js", "toggleTooltip", 13201);
_yuitest_coverline("/build/charts-base/charts-base.js", 13203);
var tt = this.get("tooltip");
        _yuitest_coverline("/build/charts-base/charts-base.js", 13204);
if(tt.visible)
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 13206);
this.hideTooltip();
        }
        else
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 13210);
tt.markerEventHandler.apply(this, [e]);
        }
    },

    /**
     * Shows a tooltip
     *
     * @method _showTooltip
     * @param {String} msg Message to dispaly in the tooltip.
     * @param {Number} x x-coordinate 
     * @param {Number} y y-coordinate
     * @private
     */
    _showTooltip: function(msg, x, y)
    {
        _yuitest_coverfunc("/build/charts-base/charts-base.js", "_showTooltip", 13223);
_yuitest_coverline("/build/charts-base/charts-base.js", 13225);
var tt = this.get("tooltip"),
            node = tt.node;
        _yuitest_coverline("/build/charts-base/charts-base.js", 13227);
if(msg)
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 13229);
tt.visible = true;
            _yuitest_coverline("/build/charts-base/charts-base.js", 13230);
tt.setTextFunction(node, msg);
            _yuitest_coverline("/build/charts-base/charts-base.js", 13231);
node.setStyle("top", y + "px");
            _yuitest_coverline("/build/charts-base/charts-base.js", 13232);
node.setStyle("left", x + "px");
            _yuitest_coverline("/build/charts-base/charts-base.js", 13233);
node.setStyle("visibility", "visible");
        }
    },

    /**
     * Positions the tooltip
     *
     * @method _positionTooltip
     * @param {Object} e Event object.
     * @private
     */
    _positionTooltip: function(e)
    {
        _yuitest_coverfunc("/build/charts-base/charts-base.js", "_positionTooltip", 13244);
_yuitest_coverline("/build/charts-base/charts-base.js", 13246);
var tt = this.get("tooltip"),
            node = tt.node,
            cb = this.get("contentBox"),
            x = (e.pageX + 10) - cb.getX(),
            y = (e.pageY + 10) - cb.getY();
        _yuitest_coverline("/build/charts-base/charts-base.js", 13251);
if(node)
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 13253);
node.setStyle("left", x + "px");
            _yuitest_coverline("/build/charts-base/charts-base.js", 13254);
node.setStyle("top", y + "px");
        }
    },

    /**
     * Hides the default tooltip
     *
     * @method hideTooltip
     */
    hideTooltip: function()
    {
        _yuitest_coverfunc("/build/charts-base/charts-base.js", "hideTooltip", 13263);
_yuitest_coverline("/build/charts-base/charts-base.js", 13265);
var tt = this.get("tooltip"),
            node = tt.node;
        _yuitest_coverline("/build/charts-base/charts-base.js", 13267);
tt.visible = false;
        _yuitest_coverline("/build/charts-base/charts-base.js", 13268);
node.set("innerHTML", "");
        _yuitest_coverline("/build/charts-base/charts-base.js", 13269);
node.setStyle("left", -10000);
        _yuitest_coverline("/build/charts-base/charts-base.js", 13270);
node.setStyle("top", -10000);
        _yuitest_coverline("/build/charts-base/charts-base.js", 13271);
node.setStyle("visibility", "hidden");
    },

    /**
     * Adds a tooltip to the dom.
     *
     * @method _addTooltip
     * @private
     */
    _addTooltip: function()
    {
        _yuitest_coverfunc("/build/charts-base/charts-base.js", "_addTooltip", 13280);
_yuitest_coverline("/build/charts-base/charts-base.js", 13282);
var tt = this.get("tooltip"),
            id = this.get("id") + "_tooltip",
            cb = this.get("contentBox"),
            oldNode = DOCUMENT.getElementById(id);
        _yuitest_coverline("/build/charts-base/charts-base.js", 13286);
if(oldNode)
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 13288);
cb.removeChild(oldNode);
        }
        _yuitest_coverline("/build/charts-base/charts-base.js", 13290);
tt.node.set("id", id);
        _yuitest_coverline("/build/charts-base/charts-base.js", 13291);
tt.node.setStyle("visibility", "hidden");
        _yuitest_coverline("/build/charts-base/charts-base.js", 13292);
cb.appendChild(tt.node);
    },

    /**
     * Updates the tooltip attribute.
     *
     * @method _updateTooltip
     * @param {Object} val Object containing properties for the tooltip.
     * @return Object
     * @private
     */
    _updateTooltip: function(val)
    {
        _yuitest_coverfunc("/build/charts-base/charts-base.js", "_updateTooltip", 13303);
_yuitest_coverline("/build/charts-base/charts-base.js", 13305);
var tt = this.get("tooltip") || this._getTooltip(),
            i,
            styles,
            node,
            props = {
                markerLabelFunction:"markerLabelFunction",
                planarLabelFunction:"planarLabelFunction",
                setTextFunction:"setTextFunction",
                showEvent:"showEvent",
                hideEvent:"hideEvent",
                markerEventHandler:"markerEventHandler",
                planarEventHandler:"planarEventHandler",
                show:"show"
            };
        _yuitest_coverline("/build/charts-base/charts-base.js", 13319);
if(Y_Lang.isObject(val))
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 13321);
styles = val.styles;
            _yuitest_coverline("/build/charts-base/charts-base.js", 13322);
node = Y.one(val.node) || tt.node;
            _yuitest_coverline("/build/charts-base/charts-base.js", 13323);
if(styles)
            {
                _yuitest_coverline("/build/charts-base/charts-base.js", 13325);
for(i in styles)
                {
                    _yuitest_coverline("/build/charts-base/charts-base.js", 13327);
if(styles.hasOwnProperty(i))
                    {
                        _yuitest_coverline("/build/charts-base/charts-base.js", 13329);
node.setStyle(i, styles[i]);
                    }
                }
            }
            _yuitest_coverline("/build/charts-base/charts-base.js", 13333);
for(i in props)
            {
                _yuitest_coverline("/build/charts-base/charts-base.js", 13335);
if(val.hasOwnProperty(i))
                {
                    _yuitest_coverline("/build/charts-base/charts-base.js", 13337);
tt[i] = val[i];
                }
            }
            _yuitest_coverline("/build/charts-base/charts-base.js", 13340);
tt.node = node;
        }
        _yuitest_coverline("/build/charts-base/charts-base.js", 13342);
return tt;
    },

    /**
     * Default getter for `tooltip` attribute.
     *
     * @method _getTooltip
     * @return Object
     * @private
     */
    _getTooltip: function()
    {
        _yuitest_coverfunc("/build/charts-base/charts-base.js", "_getTooltip", 13352);
_yuitest_coverline("/build/charts-base/charts-base.js", 13354);
var node = DOCUMENT.createElement("div"),
            tooltipClass = _getClassName("chart-tooltip"),
            tt = {
                setTextFunction: this._setText,
                markerLabelFunction: this._tooltipLabelFunction,
                planarLabelFunction: this._planarLabelFunction,
                show: true,
                hideEvent: "mouseout",
                showEvent: "mouseover",
                markerEventHandler: function(e)
                {
                    _yuitest_coverfunc("/build/charts-base/charts-base.js", "markerEventHandler", 13363);
_yuitest_coverline("/build/charts-base/charts-base.js", 13365);
var tt = this.get("tooltip"),
                    msg = tt.markerLabelFunction.apply(this, [e.categoryItem, e.valueItem, e.index, e.series, e.seriesIndex]);
                    _yuitest_coverline("/build/charts-base/charts-base.js", 13367);
this._showTooltip(msg, e.x + 10, e.y + 10);
                },
                planarEventHandler: function(e)
                {
                    _yuitest_coverfunc("/build/charts-base/charts-base.js", "planarEventHandler", 13369);
_yuitest_coverline("/build/charts-base/charts-base.js", 13371);
var tt = this.get("tooltip"),
                        msg ,
                        categoryAxis = this.get("categoryAxis");
                    _yuitest_coverline("/build/charts-base/charts-base.js", 13374);
msg = tt.planarLabelFunction.apply(this, [categoryAxis, e.valueItem, e.index, e.items, e.seriesIndex]);
                    _yuitest_coverline("/build/charts-base/charts-base.js", 13375);
this._showTooltip(msg, e.x + 10, e.y + 10);
                }
            };
        _yuitest_coverline("/build/charts-base/charts-base.js", 13378);
node = Y.one(node);
        _yuitest_coverline("/build/charts-base/charts-base.js", 13379);
node.set("id", this.get("id") + "_tooltip");
        _yuitest_coverline("/build/charts-base/charts-base.js", 13380);
node.setStyle("fontSize", "85%");
        _yuitest_coverline("/build/charts-base/charts-base.js", 13381);
node.setStyle("opacity", "0.83");
        _yuitest_coverline("/build/charts-base/charts-base.js", 13382);
node.setStyle("position", "absolute");
        _yuitest_coverline("/build/charts-base/charts-base.js", 13383);
node.setStyle("paddingTop", "2px");
        _yuitest_coverline("/build/charts-base/charts-base.js", 13384);
node.setStyle("paddingRight", "5px");
        _yuitest_coverline("/build/charts-base/charts-base.js", 13385);
node.setStyle("paddingBottom", "4px");
        _yuitest_coverline("/build/charts-base/charts-base.js", 13386);
node.setStyle("paddingLeft", "2px");
        _yuitest_coverline("/build/charts-base/charts-base.js", 13387);
node.setStyle("backgroundColor", "#fff");
        _yuitest_coverline("/build/charts-base/charts-base.js", 13388);
node.setStyle("border", "1px solid #dbdccc");
        _yuitest_coverline("/build/charts-base/charts-base.js", 13389);
node.setStyle("pointerEvents", "none");
        _yuitest_coverline("/build/charts-base/charts-base.js", 13390);
node.setStyle("zIndex", 3);
        _yuitest_coverline("/build/charts-base/charts-base.js", 13391);
node.setStyle("whiteSpace", "noWrap");
        _yuitest_coverline("/build/charts-base/charts-base.js", 13392);
node.setStyle("visibility", "hidden");
        _yuitest_coverline("/build/charts-base/charts-base.js", 13393);
node.addClass(tooltipClass);
        _yuitest_coverline("/build/charts-base/charts-base.js", 13394);
tt.node = Y.one(node);
        _yuitest_coverline("/build/charts-base/charts-base.js", 13395);
return tt;
    },

    /**
     * Formats tooltip text when `interactionType` is `planar`.
     *
     * @method _planarLabelFunction
     * @param {Axis} categoryAxis Reference to the categoryAxis of the chart.
     * @param {Array} valueItems Array of objects for each series that has a data point in the coordinate plane of the event. Each object contains the following data:
     *  <dl>
     *      <dt>axis</dt><dd>The value axis of the series.</dd>
     *      <dt>key</dt><dd>The key for the series.</dd>
     *      <dt>value</dt><dd>The value for the series item.</dd>
     *      <dt>displayName</dt><dd>The display name of the series. (defaults to key if not provided)</dd>
     *  </dl> 
     *  @param {Number} index The index of the item within its series.
     *  @param {Array} seriesArray Array of series instances for each value item.
     *  @param {Number} seriesIndex The index of the series in the `seriesCollection`.
     *  @return {String | HTML} 
     * @private
     */
    _planarLabelFunction: function(categoryAxis, valueItems, index, seriesArray, seriesIndex)
    {
        _yuitest_coverfunc("/build/charts-base/charts-base.js", "_planarLabelFunction", 13416);
_yuitest_coverline("/build/charts-base/charts-base.js", 13418);
var msg = DOCUMENT.createElement("div"),
            valueItem,
            i = 0,
            len = seriesArray.length,
            axis,
            categoryValue,
            seriesValue,
            series;
        _yuitest_coverline("/build/charts-base/charts-base.js", 13426);
if(categoryAxis)
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 13428);
categoryValue = categoryAxis.get("labelFunction").apply(this, [categoryAxis.getKeyValueAt(this.get("categoryKey"), index), categoryAxis.get("labelFormat")]);
            _yuitest_coverline("/build/charts-base/charts-base.js", 13429);
if(!Y_Lang.isObject(categoryValue))
            {
                _yuitest_coverline("/build/charts-base/charts-base.js", 13431);
categoryValue = DOCUMENT.createTextNode(categoryValue);
            }
            _yuitest_coverline("/build/charts-base/charts-base.js", 13433);
msg.appendChild(categoryValue);
        }

        _yuitest_coverline("/build/charts-base/charts-base.js", 13436);
for(; i < len; ++i)
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 13438);
series = seriesArray[i];
            _yuitest_coverline("/build/charts-base/charts-base.js", 13439);
if(series.get("visible"))
            {
                _yuitest_coverline("/build/charts-base/charts-base.js", 13441);
valueItem = valueItems[i];
                _yuitest_coverline("/build/charts-base/charts-base.js", 13442);
axis = valueItem.axis;
                _yuitest_coverline("/build/charts-base/charts-base.js", 13443);
seriesValue =  axis.get("labelFunction").apply(this, [axis.getKeyValueAt(valueItem.key, index), axis.get("labelFormat")]);
                _yuitest_coverline("/build/charts-base/charts-base.js", 13444);
msg.appendChild(DOCUMENT.createElement("br"));
                _yuitest_coverline("/build/charts-base/charts-base.js", 13445);
msg.appendChild(DOCUMENT.createTextNode(valueItem.displayName));
                _yuitest_coverline("/build/charts-base/charts-base.js", 13446);
msg.appendChild(DOCUMENT.createTextNode(": "));
                _yuitest_coverline("/build/charts-base/charts-base.js", 13447);
if(!Y_Lang.isObject(seriesValue))
                {
                    _yuitest_coverline("/build/charts-base/charts-base.js", 13449);
seriesValue = DOCUMENT.createTextNode(seriesValue);
                }
                _yuitest_coverline("/build/charts-base/charts-base.js", 13451);
msg.appendChild(seriesValue);
            }
        }
        _yuitest_coverline("/build/charts-base/charts-base.js", 13454);
return msg;
    },

    /**
     * Formats tooltip text when `interactionType` is `marker`.
     *
     * @method _tooltipLabelFunction
     * @param {Object} categoryItem An object containing the following:
     *  <dl>
     *      <dt>axis</dt><dd>The axis to which the category is bound.</dd>
     *      <dt>displayName</dt><dd>The display name set to the category (defaults to key if not provided)</dd>
     *      <dt>key</dt><dd>The key of the category.</dd>
     *      <dt>value</dt><dd>The value of the category</dd>
     *  </dl>
     * @param {Object} valueItem An object containing the following:
     *  <dl>
     *      <dt>axis</dt><dd>The axis to which the item's series is bound.</dd>
     *      <dt>displayName</dt><dd>The display name of the series. (defaults to key if not provided)</dd>
     *      <dt>key</dt><dd>The key for the series.</dd>
     *      <dt>value</dt><dd>The value for the series item.</dd> 
     *  </dl>
     * @param {Number} itemIndex The index of the item within the series.
     * @param {CartesianSeries} series The `CartesianSeries` instance of the item.
     * @param {Number} seriesIndex The index of the series in the `seriesCollection`.
     * @return {String | HTML}
     * @private
     */
    _tooltipLabelFunction: function(categoryItem, valueItem, itemIndex, series, seriesIndex)
    {
        _yuitest_coverfunc("/build/charts-base/charts-base.js", "_tooltipLabelFunction", 13481);
_yuitest_coverline("/build/charts-base/charts-base.js", 13483);
var msg = DOCUMENT.createElement("div"),
            categoryValue = categoryItem.axis.get("labelFunction").apply(this, [categoryItem.value, categoryItem.axis.get("labelFormat")]),
            seriesValue = valueItem.axis.get("labelFunction").apply(this, [valueItem.value, valueItem.axis.get("labelFormat")]);
        _yuitest_coverline("/build/charts-base/charts-base.js", 13486);
msg.appendChild(DOCUMENT.createTextNode(categoryItem.displayName)); 
        _yuitest_coverline("/build/charts-base/charts-base.js", 13487);
msg.appendChild(DOCUMENT.createTextNode(": ")); 
        _yuitest_coverline("/build/charts-base/charts-base.js", 13488);
if(!Y_Lang.isObject(categoryValue))
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 13490);
categoryValue = DOCUMENT.createTextNode(categoryValue);
        }
        _yuitest_coverline("/build/charts-base/charts-base.js", 13492);
msg.appendChild(categoryValue);
        _yuitest_coverline("/build/charts-base/charts-base.js", 13493);
msg.appendChild(DOCUMENT.createElement("br"));
        _yuitest_coverline("/build/charts-base/charts-base.js", 13494);
msg.appendChild(DOCUMENT.createTextNode(valueItem.displayName)); 
        _yuitest_coverline("/build/charts-base/charts-base.js", 13495);
msg.appendChild(DOCUMENT.createTextNode(": ")); 
        _yuitest_coverline("/build/charts-base/charts-base.js", 13496);
if(!Y_Lang.isObject(seriesValue))
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 13498);
seriesValue = DOCUMENT.createTextNode(seriesValue);
        }
        _yuitest_coverline("/build/charts-base/charts-base.js", 13500);
msg.appendChild(seriesValue);
        _yuitest_coverline("/build/charts-base/charts-base.js", 13501);
return msg; 
    },

    /**
     * Event handler for the tooltipChange.
     *
     * @method _tooltipChangeHandler
     * @param {Object} e Event object.
     * @private
     */
    _tooltipChangeHandler: function(e)
    {
        _yuitest_coverfunc("/build/charts-base/charts-base.js", "_tooltipChangeHandler", 13511);
_yuitest_coverline("/build/charts-base/charts-base.js", 13513);
if(this.get("tooltip"))
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 13515);
var tt = this.get("tooltip"),
                node = tt.node,
                show = tt.show,
                cb = this.get("contentBox");
            _yuitest_coverline("/build/charts-base/charts-base.js", 13519);
if(node && show)
            {
                _yuitest_coverline("/build/charts-base/charts-base.js", 13521);
if(!cb.contains(node))
                {
                    _yuitest_coverline("/build/charts-base/charts-base.js", 13523);
this._addTooltip();
                }
            }
        }
    },
    
    /**
     * Updates the content of text field. This method writes a value into a text field using 
     * `appendChild`. If the value is a `String`, it is converted to a `TextNode` first. 
     *
     * @method _setText
     * @param label {HTMLElement} label to be updated
     * @param val {String} value with which to update the label
     * @private
     */
    _setText: function(textField, val)
    { 
        _yuitest_coverfunc("/build/charts-base/charts-base.js", "_setText", 13538);
_yuitest_coverline("/build/charts-base/charts-base.js", 13540);
textField.setContent("");
        _yuitest_coverline("/build/charts-base/charts-base.js", 13541);
if(Y_Lang.isNumber(val))
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 13543);
val = val + "";
        }
        else {_yuitest_coverline("/build/charts-base/charts-base.js", 13545);
if(!val)
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 13547);
val = "";
        }}
        _yuitest_coverline("/build/charts-base/charts-base.js", 13549);
if(IS_STRING(val))
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 13551);
val = DOCUMENT.createTextNode(val);
        }
        _yuitest_coverline("/build/charts-base/charts-base.js", 13553);
textField.appendChild(val);
    },

    /**
     * Returns all the keys contained in a  `dataProvider`.
     *
     * @method _getAllKeys
     * @param {Array} dp Collection of objects to be parsed.
     * @return Object
     */
    _getAllKeys: function(dp)
    {
        _yuitest_coverfunc("/build/charts-base/charts-base.js", "_getAllKeys", 13563);
_yuitest_coverline("/build/charts-base/charts-base.js", 13565);
var i = 0,
            len = dp.length,
            item,
            key,
            keys = {};
        _yuitest_coverline("/build/charts-base/charts-base.js", 13570);
for(; i < len; ++i)
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 13572);
item = dp[i];
            _yuitest_coverline("/build/charts-base/charts-base.js", 13573);
for(key in item)
            {
                _yuitest_coverline("/build/charts-base/charts-base.js", 13575);
if(item.hasOwnProperty(key))
                {
                    _yuitest_coverline("/build/charts-base/charts-base.js", 13577);
keys[key] = true;
                }
            }
        }
        _yuitest_coverline("/build/charts-base/charts-base.js", 13581);
return keys;
    },
    
    /**
     * Constructs seriesKeys if not explicitly specified.
     *
     * @method _buildSeriesKeys
     * @param {Array} dataProvider The dataProvider for the chart.
     * @return Array
     * @private
     */
    _buildSeriesKeys: function(dataProvider)
    {
        _yuitest_coverfunc("/build/charts-base/charts-base.js", "_buildSeriesKeys", 13592);
_yuitest_coverline("/build/charts-base/charts-base.js", 13594);
var allKeys,
            catKey = this.get("categoryKey"),
            keys = [],
            i;
        _yuitest_coverline("/build/charts-base/charts-base.js", 13598);
if(this._seriesKeysExplicitlySet)
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 13600);
return this._seriesKeys;
        }
        _yuitest_coverline("/build/charts-base/charts-base.js", 13602);
allKeys = this._getAllKeys(dataProvider);
        _yuitest_coverline("/build/charts-base/charts-base.js", 13603);
for(i in allKeys)
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 13605);
if(allKeys.hasOwnProperty(i) && i != catKey)
            {
                _yuitest_coverline("/build/charts-base/charts-base.js", 13607);
keys.push(i);
            }
        }
        _yuitest_coverline("/build/charts-base/charts-base.js", 13610);
return keys;
    }
};
_yuitest_coverline("/build/charts-base/charts-base.js", 13613);
Y.ChartBase = ChartBase;
/**
 * The CartesianChart class creates a chart with horizontal and vertical axes.
 *
 * @module charts
 * @submodule charts-base
 * @class CartesianChart
 * @extends ChartBase
 * @constructor
 */
_yuitest_coverline("/build/charts-base/charts-base.js", 13623);
Y.CartesianChart = Y.Base.create("cartesianChart", Y.Widget, [Y.ChartBase], {
    /**
     * @method renderUI
     * @private
     */
    renderUI: function()
    {
        _yuitest_coverfunc("/build/charts-base/charts-base.js", "renderUI", 13628);
_yuitest_coverline("/build/charts-base/charts-base.js", 13630);
var bb = this.get("boundingBox"),
            cb = this.get("contentBox"),
            tt = this.get("tooltip"),
            overlay,
            overlayClass = _getClassName("overlay");
        //move the position = absolute logic to a class file
        _yuitest_coverline("/build/charts-base/charts-base.js", 13636);
bb.setStyle("position", "absolute");
        _yuitest_coverline("/build/charts-base/charts-base.js", 13637);
cb.setStyle("position", "absolute");
        _yuitest_coverline("/build/charts-base/charts-base.js", 13638);
this._addAxes();
        _yuitest_coverline("/build/charts-base/charts-base.js", 13639);
this._addGridlines();
        _yuitest_coverline("/build/charts-base/charts-base.js", 13640);
this._addSeries();
        _yuitest_coverline("/build/charts-base/charts-base.js", 13641);
if(tt && tt.show)
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 13643);
this._addTooltip();
        }
        //If there is a style definition. Force them to set.
        _yuitest_coverline("/build/charts-base/charts-base.js", 13646);
this.get("styles");
        _yuitest_coverline("/build/charts-base/charts-base.js", 13647);
if(this.get("interactionType") == "planar")
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 13649);
overlay = DOCUMENT.createElement("div");
            _yuitest_coverline("/build/charts-base/charts-base.js", 13650);
this.get("contentBox").appendChild(overlay);
            _yuitest_coverline("/build/charts-base/charts-base.js", 13651);
this._overlay = Y.one(overlay); 
            _yuitest_coverline("/build/charts-base/charts-base.js", 13652);
this._overlay.set("id", this.get("id") + "_overlay");
            _yuitest_coverline("/build/charts-base/charts-base.js", 13653);
this._overlay.setStyle("position", "absolute");
            _yuitest_coverline("/build/charts-base/charts-base.js", 13654);
this._overlay.setStyle("background", "#fff");
            _yuitest_coverline("/build/charts-base/charts-base.js", 13655);
this._overlay.setStyle("opacity", 0);
            _yuitest_coverline("/build/charts-base/charts-base.js", 13656);
this._overlay.addClass(overlayClass);
            _yuitest_coverline("/build/charts-base/charts-base.js", 13657);
this._overlay.setStyle("zIndex", 4);
        }
        _yuitest_coverline("/build/charts-base/charts-base.js", 13659);
this._setAriaElements(bb, cb);
        _yuitest_coverline("/build/charts-base/charts-base.js", 13660);
this._redraw();
    },

    /**
     * When `interactionType` is set to `planar`, listens for mouse move events and fires `planarEvent:mouseover` or `planarEvent:mouseout` depending on the position of the mouse in relation to 
     * data points on the `Chart`.
     *
     * @method _planarEventDispatcher
     * @param {Object} e Event object.
     * @private
     */
    _planarEventDispatcher: function(e)
    {
        _yuitest_coverfunc("/build/charts-base/charts-base.js", "_planarEventDispatcher", 13671);
_yuitest_coverline("/build/charts-base/charts-base.js", 13673);
var graph = this.get("graph"),
            bb = this.get("boundingBox"),
            cb = graph.get("contentBox"),
            isTouch = e && e.hasOwnProperty("changedTouches"),
            pageX = isTouch ? e.changedTouches[0].pageX : e.pageX,
            pageY = isTouch ? e.changedTouches[0].pageY : e.pageY,
            posX = pageX - bb.getX(),
            posY = pageY - bb.getY(),
            offset = {
                x: pageX - cb.getX(),
                y: pageY - cb.getY()
            },
            sc = graph.get("seriesCollection"),
            series,
            i = 0,
            index,
            oldIndex = this._selectedIndex,
            item,
            items = [],
            categoryItems = [],
            valueItems = [],
            direction = this.get("direction"),
            hasMarkers,
            catAxis,
            valAxis,
            coord,
            //data columns and area data could be created on a graph level
            markerPlane,
            len,
            coords;
        _yuitest_coverline("/build/charts-base/charts-base.js", 13703);
e.halt(true);
        _yuitest_coverline("/build/charts-base/charts-base.js", 13704);
if(direction == "horizontal")
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 13706);
catAxis = "x";
            _yuitest_coverline("/build/charts-base/charts-base.js", 13707);
valAxis = "y";
        }
        else
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 13711);
valAxis = "x";
            _yuitest_coverline("/build/charts-base/charts-base.js", 13712);
catAxis = "y";
        }
        _yuitest_coverline("/build/charts-base/charts-base.js", 13714);
coord = offset[catAxis];
        _yuitest_coverline("/build/charts-base/charts-base.js", 13715);
if(sc)
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 13717);
len = sc.length;
            _yuitest_coverline("/build/charts-base/charts-base.js", 13718);
while(i < len && !markerPlane)
            {
                _yuitest_coverline("/build/charts-base/charts-base.js", 13720);
if(sc[i])
                {
                    _yuitest_coverline("/build/charts-base/charts-base.js", 13722);
markerPlane = sc[i].get(catAxis + "MarkerPlane");
                }
                _yuitest_coverline("/build/charts-base/charts-base.js", 13724);
i++;
            }
        }
        _yuitest_coverline("/build/charts-base/charts-base.js", 13727);
if(markerPlane)
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 13729);
len = markerPlane.length;
            _yuitest_coverline("/build/charts-base/charts-base.js", 13730);
for(i = 0; i < len; ++i)
            {
                _yuitest_coverline("/build/charts-base/charts-base.js", 13732);
if(coord <= markerPlane[i].end && coord >= markerPlane[i].start)
                {
                    _yuitest_coverline("/build/charts-base/charts-base.js", 13734);
index = i;
                    _yuitest_coverline("/build/charts-base/charts-base.js", 13735);
break;
                }
            }
            _yuitest_coverline("/build/charts-base/charts-base.js", 13738);
len = sc.length;
            _yuitest_coverline("/build/charts-base/charts-base.js", 13739);
for(i = 0; i < len; ++i)
            {
                _yuitest_coverline("/build/charts-base/charts-base.js", 13741);
series = sc[i];
                _yuitest_coverline("/build/charts-base/charts-base.js", 13742);
coords = series.get(valAxis + "coords");
                _yuitest_coverline("/build/charts-base/charts-base.js", 13743);
hasMarkers = series.get("markers");
                _yuitest_coverline("/build/charts-base/charts-base.js", 13744);
if(hasMarkers && !isNaN(oldIndex) && oldIndex > -1)
                {
                    _yuitest_coverline("/build/charts-base/charts-base.js", 13746);
series.updateMarkerState("mouseout", oldIndex);
                }
                _yuitest_coverline("/build/charts-base/charts-base.js", 13748);
if(coords && coords[index] > -1)
                {
                    _yuitest_coverline("/build/charts-base/charts-base.js", 13750);
if(hasMarkers && !isNaN(index) && index > -1)
                    {
                        _yuitest_coverline("/build/charts-base/charts-base.js", 13752);
series.updateMarkerState("mouseover", index);
                    }
                    _yuitest_coverline("/build/charts-base/charts-base.js", 13754);
item = this.getSeriesItems(series, index);
                    _yuitest_coverline("/build/charts-base/charts-base.js", 13755);
categoryItems.push(item.category);
                    _yuitest_coverline("/build/charts-base/charts-base.js", 13756);
valueItems.push(item.value);
                    _yuitest_coverline("/build/charts-base/charts-base.js", 13757);
items.push(series);
                }
                    
            }
            _yuitest_coverline("/build/charts-base/charts-base.js", 13761);
this._selectedIndex = index;

            /**
             * Broadcasts when `interactionType` is set to `planar` and a series' marker plane has received a mouseover event.
             * 
             *
             * @event planarEvent:mouseover
             * @preventable false
             * @param {EventFacade} e Event facade with the following additional
             *   properties:
             *  <dl>
             *      <dt>categoryItem</dt><dd>An array of hashes, each containing information about the category `Axis` of each marker whose plane has been intersected.</dd>
             *      <dt>valueItem</dt><dd>An array of hashes, each containing information about the value `Axis` of each marker whose plane has been intersected.</dd>
             *      <dt>x</dt><dd>The x-coordinate of the mouse in relation to the Chart.</dd>
             *      <dt>y</dt><dd>The y-coordinate of the mouse in relation to the Chart.</dd>
             *      <dt>pageX</dt><dd>The x location of the event on the page (including scroll)</dd>
             *      <dt>pageY</dt><dd>The y location of the event on the page (including scroll)</dd>
             *      <dt>items</dt><dd>An array including all the series which contain a marker whose plane has been intersected.</dd>
             *      <dt>index</dt><dd>Index of the markers in their respective series.</dd>
             *      <dt>originEvent</dt><dd>Underlying dom event.</dd>
             *  </dl>
             */
            /**
             * Broadcasts when `interactionType` is set to `planar` and a series' marker plane has received a mouseout event.
             *
             * @event planarEvent:mouseout
             * @preventable false
             * @param {EventFacade} e 
             */
            _yuitest_coverline("/build/charts-base/charts-base.js", 13790);
if(index > -1)
            {
                _yuitest_coverline("/build/charts-base/charts-base.js", 13792);
this.fire("planarEvent:mouseover", {
                    categoryItem:categoryItems, 
                    valueItem:valueItems, 
                    x:posX, 
                    y:posY, 
                    pageX:pageX,
                    pageY:pageY,
                    items:items, 
                    index:index,
                    originEvent:e
                });
            }
            else
            {
                _yuitest_coverline("/build/charts-base/charts-base.js", 13806);
this.fire("planarEvent:mouseout");
            }
        }
    },

    /**
     * Indicates the default series type for the chart.
     *
     * @property _type
     * @type {String}
     * @private
     */
    _type: "combo",

    /**
     * Queue of axes instances that will be updated. This method is used internally to determine when all axes have been updated.
     *
     * @property _itemRenderQueue
     * @type Array
     * @private
     */
    _itemRenderQueue: null,

    /**
     * Adds an `Axis` instance to the `_itemRenderQueue`.
     *
     * @method _addToAxesRenderQueue
     * @param {Axis} axis An `Axis` instance.
     * @private 
     */
    _addToAxesRenderQueue: function(axis)
    {
        _yuitest_coverfunc("/build/charts-base/charts-base.js", "_addToAxesRenderQueue", 13836);
_yuitest_coverline("/build/charts-base/charts-base.js", 13838);
if(!this._itemRenderQueue)
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 13840);
this._itemRenderQueue = [];
        }
        _yuitest_coverline("/build/charts-base/charts-base.js", 13842);
if(Y.Array.indexOf(this._itemRenderQueue, axis) < 0)
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 13844);
this._itemRenderQueue.push(axis);
        }
    },

    /**
     * Adds axis instance to the appropriate array based on position
     *
     * @method _addToAxesCollection
     * @param {String} position The position of the axis
     * @param {Axis} axis The `Axis` instance
     */
    _addToAxesCollection: function(position, axis)
    {
        _yuitest_coverfunc("/build/charts-base/charts-base.js", "_addToAxesCollection", 13855);
_yuitest_coverline("/build/charts-base/charts-base.js", 13857);
var axesCollection = this.get(position + "AxesCollection");
        _yuitest_coverline("/build/charts-base/charts-base.js", 13858);
if(!axesCollection)
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 13860);
axesCollection = [];
            _yuitest_coverline("/build/charts-base/charts-base.js", 13861);
this.set(position + "AxesCollection", axesCollection);
        }
        _yuitest_coverline("/build/charts-base/charts-base.js", 13863);
axesCollection.push(axis);
    },

    /**
     * Returns the default value for the `seriesCollection` attribute.
     *
     * @method _getDefaultSeriesCollection
     * @param {Array} val Array containing either `CartesianSeries` instances or objects containing data to construct series instances.
     * @return Array
     * @private
     */
    _getDefaultSeriesCollection: function()
    {
        _yuitest_coverfunc("/build/charts-base/charts-base.js", "_getDefaultSeriesCollection", 13874);
_yuitest_coverline("/build/charts-base/charts-base.js", 13876);
var seriesCollection,
            dataProvider = this.get("dataProvider");
        _yuitest_coverline("/build/charts-base/charts-base.js", 13878);
if(dataProvider)
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 13880);
seriesCollection = this._parseSeriesCollection();
        }
        _yuitest_coverline("/build/charts-base/charts-base.js", 13882);
return seriesCollection;
    },

    /**
     * Parses and returns a series collection from an object and default properties.
     *
     * @method _parseSeriesCollection
     * @param {Object} val Object contain properties for series being set.
     * @return Object
     * @private
     */
    _parseSeriesCollection: function(val)
    {
        _yuitest_coverfunc("/build/charts-base/charts-base.js", "_parseSeriesCollection", 13893);
_yuitest_coverline("/build/charts-base/charts-base.js", 13895);
var dir = this.get("direction"), 
            sc = [], 
            catAxis,
            valAxis,
            tempKeys = [],
            series,
            seriesKeys = this.get("seriesKeys").concat(),
            i,
            index,
            l,
            type = this.get("type"),
            key,
            catKey,
            seriesKey,
            graph,
            orphans = [],
            categoryKey = this.get("categoryKey"),
            showMarkers = this.get("showMarkers"),
            showAreaFill = this.get("showAreaFill"),
            showLines = this.get("showLines");
        _yuitest_coverline("/build/charts-base/charts-base.js", 13915);
val = val || []; 
        _yuitest_coverline("/build/charts-base/charts-base.js", 13916);
if(dir == "vertical")
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 13918);
catAxis = "yAxis";
            _yuitest_coverline("/build/charts-base/charts-base.js", 13919);
catKey = "yKey";
            _yuitest_coverline("/build/charts-base/charts-base.js", 13920);
valAxis = "xAxis";
            _yuitest_coverline("/build/charts-base/charts-base.js", 13921);
seriesKey = "xKey";
        }
        else
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 13925);
catAxis = "xAxis";
            _yuitest_coverline("/build/charts-base/charts-base.js", 13926);
catKey = "xKey";
            _yuitest_coverline("/build/charts-base/charts-base.js", 13927);
valAxis = "yAxis";
            _yuitest_coverline("/build/charts-base/charts-base.js", 13928);
seriesKey = "yKey";
        }
        _yuitest_coverline("/build/charts-base/charts-base.js", 13930);
l = val.length;
        _yuitest_coverline("/build/charts-base/charts-base.js", 13931);
while(val && val.length > 0)
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 13933);
series = val.shift();
            _yuitest_coverline("/build/charts-base/charts-base.js", 13934);
key = this._getBaseAttribute(series, seriesKey);
            _yuitest_coverline("/build/charts-base/charts-base.js", 13935);
if(key)
            {
                _yuitest_coverline("/build/charts-base/charts-base.js", 13937);
index = Y.Array.indexOf(seriesKeys, key);
                _yuitest_coverline("/build/charts-base/charts-base.js", 13938);
if(index > -1)
                {
                    _yuitest_coverline("/build/charts-base/charts-base.js", 13940);
seriesKeys.splice(index, 1);
                    _yuitest_coverline("/build/charts-base/charts-base.js", 13941);
tempKeys.push(key);
                    _yuitest_coverline("/build/charts-base/charts-base.js", 13942);
sc.push(series);
                }
                else
                {
                    _yuitest_coverline("/build/charts-base/charts-base.js", 13946);
orphans.push(series);
                }
            }
            else
            {
                _yuitest_coverline("/build/charts-base/charts-base.js", 13951);
orphans.push(series);
            }
        }
        _yuitest_coverline("/build/charts-base/charts-base.js", 13954);
while(orphans.length > 0)
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 13956);
series = orphans.shift();
            _yuitest_coverline("/build/charts-base/charts-base.js", 13957);
if(seriesKeys.length > 0)
            {
                _yuitest_coverline("/build/charts-base/charts-base.js", 13959);
key = seriesKeys.shift();
                _yuitest_coverline("/build/charts-base/charts-base.js", 13960);
this._setBaseAttribute(series, seriesKey, key);
                _yuitest_coverline("/build/charts-base/charts-base.js", 13961);
tempKeys.push(key);
                _yuitest_coverline("/build/charts-base/charts-base.js", 13962);
sc.push(series);
            }
            else {_yuitest_coverline("/build/charts-base/charts-base.js", 13964);
if(series instanceof Y.CartesianSeries)
            {
                _yuitest_coverline("/build/charts-base/charts-base.js", 13966);
series.destroy(true);
            }}
        }
        _yuitest_coverline("/build/charts-base/charts-base.js", 13969);
if(seriesKeys.length > 0)
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 13971);
tempKeys = tempKeys.concat(seriesKeys);
        }
        _yuitest_coverline("/build/charts-base/charts-base.js", 13973);
l = tempKeys.length;
        _yuitest_coverline("/build/charts-base/charts-base.js", 13974);
for(i = 0; i < l; ++i)
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 13976);
series = sc[i] || {type:type};
            _yuitest_coverline("/build/charts-base/charts-base.js", 13977);
if(series instanceof Y.CartesianSeries)
            {
                _yuitest_coverline("/build/charts-base/charts-base.js", 13979);
this._parseSeriesAxes(series);
                _yuitest_coverline("/build/charts-base/charts-base.js", 13980);
continue;
            }

            _yuitest_coverline("/build/charts-base/charts-base.js", 13983);
series[catKey] = series[catKey] || categoryKey;
            _yuitest_coverline("/build/charts-base/charts-base.js", 13984);
series[seriesKey] = series[seriesKey] || seriesKeys.shift();
            _yuitest_coverline("/build/charts-base/charts-base.js", 13985);
series[catAxis] = this._getCategoryAxis();
            _yuitest_coverline("/build/charts-base/charts-base.js", 13986);
series[valAxis] = this._getSeriesAxis(series[seriesKey]);
                
            _yuitest_coverline("/build/charts-base/charts-base.js", 13988);
series.type = series.type || type;
            _yuitest_coverline("/build/charts-base/charts-base.js", 13989);
series.direction = series.direction || dir;
            
            _yuitest_coverline("/build/charts-base/charts-base.js", 13991);
if((series.type == "combo" || series.type == "stackedcombo" || series.type == "combospline" || series.type == "stackedcombospline"))
            {
                _yuitest_coverline("/build/charts-base/charts-base.js", 13993);
if(showAreaFill !== null)
                {
                    _yuitest_coverline("/build/charts-base/charts-base.js", 13995);
series.showAreaFill = (series.showAreaFill !== null && series.showAreaFill !== undefined) ? series.showAreaFill : showAreaFill;
                }
                _yuitest_coverline("/build/charts-base/charts-base.js", 13997);
if(showMarkers !== null)
                {
                    _yuitest_coverline("/build/charts-base/charts-base.js", 13999);
series.showMarkers = (series.showMarkers !== null && series.showMarkers !== undefined) ? series.showMarkers : showMarkers;
                }
                _yuitest_coverline("/build/charts-base/charts-base.js", 14001);
if(showLines !== null)
                {
                    _yuitest_coverline("/build/charts-base/charts-base.js", 14003);
series.showLines = (series.showLines !== null && series.showLines !== undefined) ? series.showLines : showLines;
                }
            }
            _yuitest_coverline("/build/charts-base/charts-base.js", 14006);
sc[i] = series;
        }
        _yuitest_coverline("/build/charts-base/charts-base.js", 14008);
if(sc)
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 14010);
graph = this.get("graph");
            _yuitest_coverline("/build/charts-base/charts-base.js", 14011);
graph.set("seriesCollection", sc);
            _yuitest_coverline("/build/charts-base/charts-base.js", 14012);
sc = graph.get("seriesCollection");
        }
        _yuitest_coverline("/build/charts-base/charts-base.js", 14014);
return sc;
    },

    /**
     * Parse and sets the axes for a series instance.
     *
     * @method _parseSeriesAxes
     * @param {CartesianSeries} series A `CartesianSeries` instance.
     * @private
     */
    _parseSeriesAxes: function(series)
    {
        _yuitest_coverfunc("/build/charts-base/charts-base.js", "_parseSeriesAxes", 14024);
_yuitest_coverline("/build/charts-base/charts-base.js", 14026);
var axes = this.get("axes"),
            xAxis = series.get("xAxis"),
            yAxis = series.get("yAxis"),
            YAxis = Y.Axis,
            axis;
        _yuitest_coverline("/build/charts-base/charts-base.js", 14031);
if(xAxis && !(xAxis instanceof YAxis) && Y_Lang.isString(xAxis) && axes.hasOwnProperty(xAxis))
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 14033);
axis = axes[xAxis];
            _yuitest_coverline("/build/charts-base/charts-base.js", 14034);
if(axis instanceof YAxis)
            {
                _yuitest_coverline("/build/charts-base/charts-base.js", 14036);
series.set("xAxis", axis);
            }
        }
        _yuitest_coverline("/build/charts-base/charts-base.js", 14039);
if(yAxis && !(yAxis instanceof YAxis) && Y_Lang.isString(yAxis) && axes.hasOwnProperty(yAxis))
        {   
            _yuitest_coverline("/build/charts-base/charts-base.js", 14041);
axis = axes[yAxis];
            _yuitest_coverline("/build/charts-base/charts-base.js", 14042);
if(axis instanceof YAxis)
            {
                _yuitest_coverline("/build/charts-base/charts-base.js", 14044);
series.set("yAxis", axis);
            }
        }

    },

    /**
     * Returns the category axis instance for the chart.
     *
     * @method _getCategoryAxis
     * @return Axis
     * @private
     */
    _getCategoryAxis: function()
    {
        _yuitest_coverfunc("/build/charts-base/charts-base.js", "_getCategoryAxis", 14057);
_yuitest_coverline("/build/charts-base/charts-base.js", 14059);
var axis,
            axes = this.get("axes"),
            categoryAxisName = this.get("categoryAxisName") || this.get("categoryKey");
        _yuitest_coverline("/build/charts-base/charts-base.js", 14062);
axis = axes[categoryAxisName];
        _yuitest_coverline("/build/charts-base/charts-base.js", 14063);
return axis;
    },

    /**
     * Returns the value axis for a series.
     *
     * @method _getSeriesAxis
     * @param {String} key The key value used to determine the axis instance.
     * @return Axis
     * @private
     */
    _getSeriesAxis:function(key, axisName)
    {
        _yuitest_coverfunc("/build/charts-base/charts-base.js", "_getSeriesAxis", 14074);
_yuitest_coverline("/build/charts-base/charts-base.js", 14076);
var axes = this.get("axes"),
            i,
            keys,
            axis;
        _yuitest_coverline("/build/charts-base/charts-base.js", 14080);
if(axes)
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 14082);
if(axisName && axes.hasOwnProperty(axisName))
            {
                _yuitest_coverline("/build/charts-base/charts-base.js", 14084);
axis = axes[axisName];
            }
            else
            {
                _yuitest_coverline("/build/charts-base/charts-base.js", 14088);
for(i in axes)
                {
                    _yuitest_coverline("/build/charts-base/charts-base.js", 14090);
if(axes.hasOwnProperty(i))
                    {
                        _yuitest_coverline("/build/charts-base/charts-base.js", 14092);
keys = axes[i].get("keys");
                        _yuitest_coverline("/build/charts-base/charts-base.js", 14093);
if(keys && keys.hasOwnProperty(key))
                        {
                            _yuitest_coverline("/build/charts-base/charts-base.js", 14095);
axis = axes[i];
                            _yuitest_coverline("/build/charts-base/charts-base.js", 14096);
break;
                        }
                    }
                }
            }
        }
        _yuitest_coverline("/build/charts-base/charts-base.js", 14102);
return axis;
    },

    /**
     * Gets an attribute from an object, using a getter for Base objects and a property for object
     * literals. Used for determining attributes from series/axis references which can be an actual class instance
     * or a hash of properties that will be used to create a class instance.
     *
     * @method _getBaseAttribute
     * @param {Object} item Object or instance in which the attribute resides.
     * @param {String} key Attribute whose value will be returned.
     * @return Object
     * @private
     */
    _getBaseAttribute: function(item, key)
    {
        _yuitest_coverfunc("/build/charts-base/charts-base.js", "_getBaseAttribute", 14116);
_yuitest_coverline("/build/charts-base/charts-base.js", 14118);
if(item instanceof Y.Base)
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 14120);
return item.get(key);
        }
        _yuitest_coverline("/build/charts-base/charts-base.js", 14122);
if(item.hasOwnProperty(key))
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 14124);
return item[key];
        }
        _yuitest_coverline("/build/charts-base/charts-base.js", 14126);
return null;
    },

    /**
     * Sets an attribute on an object, using a setter of Base objects and a property for object
     * literals. Used for setting attributes on a Base class, either directly or to be stored in an object literal
     * for use at instantiation.
     *
     * @method _setBaseAttribute
     * @param {Object} item Object or instance in which the attribute resides.
     * @param {String} key Attribute whose value will be assigned.
     * @param {Object} value Value to be assigned to the attribute.
     * @private
     */
    _setBaseAttribute: function(item, key, value)
    {
        _yuitest_coverfunc("/build/charts-base/charts-base.js", "_setBaseAttribute", 14140);
_yuitest_coverline("/build/charts-base/charts-base.js", 14142);
if(item instanceof Y.Base)
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 14144);
item.set(key, value);
        }
        else
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 14148);
item[key] = value;
        }
    },

    /**
     * Creates `Axis` instances.
     *
     * @method _setAxes
     * @param {Object} val Object containing `Axis` instances or objects in which to construct `Axis` instances.
     * @return Object
     * @private
     */
    _setAxes: function(val)
    {
        _yuitest_coverfunc("/build/charts-base/charts-base.js", "_setAxes", 14160);
_yuitest_coverline("/build/charts-base/charts-base.js", 14162);
var hash = this._parseAxes(val),
            axes = {},
            axesAttrs = {
                edgeOffset: "edgeOffset", 
                position: "position",
                overlapGraph:"overlapGraph",
                labelFunction:"labelFunction",
                labelFunctionScope:"labelFunctionScope",
                labelFormat:"labelFormat",
                appendLabelFunction: "appendLabelFunction",
                appendTitleFunction: "appendTitleFunction",
                maximum:"maximum",
                minimum:"minimum", 
                roundingMethod:"roundingMethod",
                alwaysShowZero:"alwaysShowZero",
                title:"title",
                width:"width",
                height:"height"
            },
            dp = this.get("dataProvider"),
            ai,
            i, 
            pos, 
            axis,
            axisPosition,
            dh, 
            axisClass, 
            config,
            axesCollection;
        _yuitest_coverline("/build/charts-base/charts-base.js", 14191);
for(i in hash)
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 14193);
if(hash.hasOwnProperty(i))
            {
                _yuitest_coverline("/build/charts-base/charts-base.js", 14195);
dh = hash[i];
                _yuitest_coverline("/build/charts-base/charts-base.js", 14196);
if(dh instanceof Y.Axis)
                {
                    _yuitest_coverline("/build/charts-base/charts-base.js", 14198);
axis = dh;
                }
                else
                {
                    _yuitest_coverline("/build/charts-base/charts-base.js", 14202);
axis = null;
                    _yuitest_coverline("/build/charts-base/charts-base.js", 14203);
config = {};
                    _yuitest_coverline("/build/charts-base/charts-base.js", 14204);
config.dataProvider = dh.dataProvider || dp;
                    _yuitest_coverline("/build/charts-base/charts-base.js", 14205);
config.keys = dh.keys;
                    
                    _yuitest_coverline("/build/charts-base/charts-base.js", 14207);
if(dh.hasOwnProperty("roundingUnit"))
                    {
                        _yuitest_coverline("/build/charts-base/charts-base.js", 14209);
config.roundingUnit = dh.roundingUnit;
                    }
                    _yuitest_coverline("/build/charts-base/charts-base.js", 14211);
pos = dh.position;
                    _yuitest_coverline("/build/charts-base/charts-base.js", 14212);
if(dh.styles)
                    {
                        _yuitest_coverline("/build/charts-base/charts-base.js", 14214);
config.styles = dh.styles;
                    }
                    _yuitest_coverline("/build/charts-base/charts-base.js", 14216);
config.position = dh.position;
                    _yuitest_coverline("/build/charts-base/charts-base.js", 14217);
for(ai in axesAttrs)
                    {
                        _yuitest_coverline("/build/charts-base/charts-base.js", 14219);
if(axesAttrs.hasOwnProperty(ai) && dh.hasOwnProperty(ai))
                        {
                            _yuitest_coverline("/build/charts-base/charts-base.js", 14221);
config[ai] = dh[ai];
                        }
                    }
                   
                    //only check for existing axis if we constructed the default axes already
                    _yuitest_coverline("/build/charts-base/charts-base.js", 14226);
if(val)
                    {
                        _yuitest_coverline("/build/charts-base/charts-base.js", 14228);
axis = this.getAxisByKey(i);
                    }
                    
                    _yuitest_coverline("/build/charts-base/charts-base.js", 14231);
if(axis && axis instanceof Y.Axis)
                    {
                        _yuitest_coverline("/build/charts-base/charts-base.js", 14233);
axisPosition = axis.get("position");
                        _yuitest_coverline("/build/charts-base/charts-base.js", 14234);
if(pos != axisPosition)
                        {
                            _yuitest_coverline("/build/charts-base/charts-base.js", 14236);
if(axisPosition != "none")
                            {
                                _yuitest_coverline("/build/charts-base/charts-base.js", 14238);
axesCollection = this.get(axisPosition + "AxesCollection");
                                _yuitest_coverline("/build/charts-base/charts-base.js", 14239);
axesCollection.splice(Y.Array.indexOf(axesCollection, axis), 1);
                            }
                            _yuitest_coverline("/build/charts-base/charts-base.js", 14241);
if(pos != "none")
                            {
                                _yuitest_coverline("/build/charts-base/charts-base.js", 14243);
this._addToAxesCollection(pos, axis);
                            }
                        }
                        _yuitest_coverline("/build/charts-base/charts-base.js", 14246);
axis.setAttrs(config);
                    }
                    else
                    {
                        _yuitest_coverline("/build/charts-base/charts-base.js", 14250);
axisClass = this._getAxisClass(dh.type);
                        _yuitest_coverline("/build/charts-base/charts-base.js", 14251);
axis = new axisClass(config);
                        _yuitest_coverline("/build/charts-base/charts-base.js", 14252);
axis.after("axisRendered", Y.bind(this._itemRendered, this));
                    }
                }

                _yuitest_coverline("/build/charts-base/charts-base.js", 14256);
if(axis)
                {
                    _yuitest_coverline("/build/charts-base/charts-base.js", 14258);
axesCollection = this.get(pos + "AxesCollection");
                    _yuitest_coverline("/build/charts-base/charts-base.js", 14259);
if(axesCollection && Y.Array.indexOf(axesCollection, axis) > 0)
                    {
                        _yuitest_coverline("/build/charts-base/charts-base.js", 14261);
axis.set("overlapGraph", false);
                    }
                    _yuitest_coverline("/build/charts-base/charts-base.js", 14263);
axes[i] = axis;
                }
            }
        }
        _yuitest_coverline("/build/charts-base/charts-base.js", 14267);
return axes;
    },
    
    /**
     * Adds axes to the chart.
     *
     * @method _addAxes
     * @private
     */
    _addAxes: function()
    {
        _yuitest_coverfunc("/build/charts-base/charts-base.js", "_addAxes", 14276);
_yuitest_coverline("/build/charts-base/charts-base.js", 14278);
var axes = this.get("axes"),
            i, 
            axis, 
            pos,
            w = this.get("width"),
            h = this.get("height"),
            node = Y.Node.one(this._parentNode);
        _yuitest_coverline("/build/charts-base/charts-base.js", 14285);
if(!this._axesCollection)
        {   
            _yuitest_coverline("/build/charts-base/charts-base.js", 14287);
this._axesCollection = [];
        }
        _yuitest_coverline("/build/charts-base/charts-base.js", 14289);
for(i in axes)
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 14291);
if(axes.hasOwnProperty(i))
            {
                _yuitest_coverline("/build/charts-base/charts-base.js", 14293);
axis = axes[i];
                _yuitest_coverline("/build/charts-base/charts-base.js", 14294);
if(axis instanceof Y.Axis)
                {
                    _yuitest_coverline("/build/charts-base/charts-base.js", 14296);
if(!w)
                    {
                        _yuitest_coverline("/build/charts-base/charts-base.js", 14298);
this.set("width", node.get("offsetWidth"));
                        _yuitest_coverline("/build/charts-base/charts-base.js", 14299);
w = this.get("width");
                    }
                    _yuitest_coverline("/build/charts-base/charts-base.js", 14301);
if(!h)
                    {
                        _yuitest_coverline("/build/charts-base/charts-base.js", 14303);
this.set("height", node.get("offsetHeight"));
                        _yuitest_coverline("/build/charts-base/charts-base.js", 14304);
h = this.get("height");
                    }
                    _yuitest_coverline("/build/charts-base/charts-base.js", 14306);
this._addToAxesRenderQueue(axis);
                    _yuitest_coverline("/build/charts-base/charts-base.js", 14307);
pos = axis.get("position");
                    _yuitest_coverline("/build/charts-base/charts-base.js", 14308);
if(!this.get(pos + "AxesCollection"))
                    {
                        _yuitest_coverline("/build/charts-base/charts-base.js", 14310);
this.set(pos + "AxesCollection", [axis]);
                    }
                    else
                    {
                        _yuitest_coverline("/build/charts-base/charts-base.js", 14314);
this.get(pos + "AxesCollection").push(axis);
                    }
                    _yuitest_coverline("/build/charts-base/charts-base.js", 14316);
this._axesCollection.push(axis);
                    _yuitest_coverline("/build/charts-base/charts-base.js", 14317);
if(axis.get("keys").hasOwnProperty(this.get("categoryKey")))
                    {
                        _yuitest_coverline("/build/charts-base/charts-base.js", 14319);
this.set("categoryAxis", axis);
                    }
                    _yuitest_coverline("/build/charts-base/charts-base.js", 14321);
axis.render(this.get("contentBox"));
                }
            }
        }
    },

    /**
     * Renders the Graph.
     *
     * @method _addSeries
     * @private
     */
    _addSeries: function()
    {
        _yuitest_coverfunc("/build/charts-base/charts-base.js", "_addSeries", 14333);
_yuitest_coverline("/build/charts-base/charts-base.js", 14335);
var graph = this.get("graph"),
            sc = this.get("seriesCollection");
        _yuitest_coverline("/build/charts-base/charts-base.js", 14337);
graph.render(this.get("contentBox"));

    },

    /**
     * Adds gridlines to the chart.
     *
     * @method _addGridlines
     * @private
     */
    _addGridlines: function()
    {
        _yuitest_coverfunc("/build/charts-base/charts-base.js", "_addGridlines", 14347);
_yuitest_coverline("/build/charts-base/charts-base.js", 14349);
var graph = this.get("graph"),
            hgl = this.get("horizontalGridlines"),
            vgl = this.get("verticalGridlines"),
            direction = this.get("direction"),
            leftAxesCollection = this.get("leftAxesCollection"),
            rightAxesCollection = this.get("rightAxesCollection"),
            bottomAxesCollection = this.get("bottomAxesCollection"),
            topAxesCollection = this.get("topAxesCollection"),
            seriesAxesCollection,
            catAxis = this.get("categoryAxis"),
            hAxis,
            vAxis;
        _yuitest_coverline("/build/charts-base/charts-base.js", 14361);
if(this._axesCollection)
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 14363);
seriesAxesCollection = this._axesCollection.concat();
            _yuitest_coverline("/build/charts-base/charts-base.js", 14364);
seriesAxesCollection.splice(Y.Array.indexOf(seriesAxesCollection, catAxis), 1);
        }
        _yuitest_coverline("/build/charts-base/charts-base.js", 14366);
if(hgl)
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 14368);
if(leftAxesCollection && leftAxesCollection[0])
            {
                _yuitest_coverline("/build/charts-base/charts-base.js", 14370);
hAxis = leftAxesCollection[0];
            }
            else {_yuitest_coverline("/build/charts-base/charts-base.js", 14372);
if(rightAxesCollection && rightAxesCollection[0])
            {
                _yuitest_coverline("/build/charts-base/charts-base.js", 14374);
hAxis = rightAxesCollection[0];
            }
            else 
            {
                _yuitest_coverline("/build/charts-base/charts-base.js", 14378);
hAxis = direction == "horizontal" ? catAxis : seriesAxesCollection[0];
            }}
            _yuitest_coverline("/build/charts-base/charts-base.js", 14380);
if(!this._getBaseAttribute(hgl, "axis") && hAxis)
            {
                _yuitest_coverline("/build/charts-base/charts-base.js", 14382);
this._setBaseAttribute(hgl, "axis", hAxis);
            }
            _yuitest_coverline("/build/charts-base/charts-base.js", 14384);
if(this._getBaseAttribute(hgl, "axis"))
            {
                _yuitest_coverline("/build/charts-base/charts-base.js", 14386);
graph.set("horizontalGridlines", hgl);
            }
        }
        _yuitest_coverline("/build/charts-base/charts-base.js", 14389);
if(vgl)
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 14391);
if(bottomAxesCollection && bottomAxesCollection[0])
            {
                _yuitest_coverline("/build/charts-base/charts-base.js", 14393);
vAxis = bottomAxesCollection[0];
            }
            else {_yuitest_coverline("/build/charts-base/charts-base.js", 14395);
if (topAxesCollection && topAxesCollection[0])
            {
                _yuitest_coverline("/build/charts-base/charts-base.js", 14397);
vAxis = topAxesCollection[0];
            }
            else 
            {
                _yuitest_coverline("/build/charts-base/charts-base.js", 14401);
vAxis = direction == "vertical" ? catAxis : seriesAxesCollection[0];
            }}
            _yuitest_coverline("/build/charts-base/charts-base.js", 14403);
if(!this._getBaseAttribute(vgl, "axis") && vAxis)
            {
                _yuitest_coverline("/build/charts-base/charts-base.js", 14405);
this._setBaseAttribute(vgl, "axis", vAxis);
            }
            _yuitest_coverline("/build/charts-base/charts-base.js", 14407);
if(this._getBaseAttribute(vgl, "axis"))
            {
                _yuitest_coverline("/build/charts-base/charts-base.js", 14409);
graph.set("verticalGridlines", vgl);
            }
        }
    },
    
    /**
     * Default Function for the axes attribute.
     *
     * @method _getDefaultAxes
     * @return Object
     * @private
     */
    _getDefaultAxes: function()
    {
        _yuitest_coverfunc("/build/charts-base/charts-base.js", "_getDefaultAxes", 14421);
_yuitest_coverline("/build/charts-base/charts-base.js", 14423);
var axes;
        _yuitest_coverline("/build/charts-base/charts-base.js", 14424);
if(this.get("dataProvider"))
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 14426);
axes = this._parseAxes();
        }
        _yuitest_coverline("/build/charts-base/charts-base.js", 14428);
return axes;
    },

    /**
     * Generates and returns a key-indexed object containing `Axis` instances or objects used to create `Axis` instances.
     *
     * @method _parseAxes
     * @param {Object} axes Object containing `Axis` instances or `Axis` attributes.
     * @return Object
     * @private
     */
    _parseAxes: function(axes)
    {
        _yuitest_coverfunc("/build/charts-base/charts-base.js", "_parseAxes", 14439);
_yuitest_coverline("/build/charts-base/charts-base.js", 14441);
var catKey = this.get("categoryKey"),
            axis,
            attr,
            keys,
            newAxes = {},
            claimedKeys = [],
            categoryAxisName = this.get("categoryAxisName") || this.get("categoryKey"),
            valueAxisName = this.get("valueAxisName"),
            seriesKeys = this.get("seriesKeys").concat(),
            i, 
            l,
            ii,
            ll,
            cIndex,
            direction = this.get("direction"),
            seriesPosition,
            categoryPosition,
            valueAxes = [],
            seriesAxis = this.get("stacked") ? "stacked" : "numeric";
        _yuitest_coverline("/build/charts-base/charts-base.js", 14460);
if(direction == "vertical")
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 14462);
seriesPosition = "bottom";
            _yuitest_coverline("/build/charts-base/charts-base.js", 14463);
categoryPosition = "left";
        }
        else
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 14467);
seriesPosition = "left";
            _yuitest_coverline("/build/charts-base/charts-base.js", 14468);
categoryPosition = "bottom";
        }
        _yuitest_coverline("/build/charts-base/charts-base.js", 14470);
if(axes)
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 14472);
for(i in axes)
            {
                _yuitest_coverline("/build/charts-base/charts-base.js", 14474);
if(axes.hasOwnProperty(i))
                {
                    _yuitest_coverline("/build/charts-base/charts-base.js", 14476);
axis = axes[i];
                    _yuitest_coverline("/build/charts-base/charts-base.js", 14477);
keys = this._getBaseAttribute(axis, "keys");
                    _yuitest_coverline("/build/charts-base/charts-base.js", 14478);
attr = this._getBaseAttribute(axis, "type");
                    _yuitest_coverline("/build/charts-base/charts-base.js", 14479);
if(attr == "time" || attr == "category")
                    {
                        _yuitest_coverline("/build/charts-base/charts-base.js", 14481);
categoryAxisName = i;
                        _yuitest_coverline("/build/charts-base/charts-base.js", 14482);
this.set("categoryAxisName", i);
                        _yuitest_coverline("/build/charts-base/charts-base.js", 14483);
if(Y_Lang.isArray(keys) && keys.length > 0)
                        {
                            _yuitest_coverline("/build/charts-base/charts-base.js", 14485);
catKey = keys[0];
                            _yuitest_coverline("/build/charts-base/charts-base.js", 14486);
this.set("categoryKey", catKey);
                        }
                        _yuitest_coverline("/build/charts-base/charts-base.js", 14488);
newAxes[i] = axis;
                    }
                    else {_yuitest_coverline("/build/charts-base/charts-base.js", 14490);
if(i == categoryAxisName)
                    {
                        _yuitest_coverline("/build/charts-base/charts-base.js", 14492);
newAxes[i] = axis;
                    }
                    else 
                    {
                        _yuitest_coverline("/build/charts-base/charts-base.js", 14496);
newAxes[i] = axis;
                        _yuitest_coverline("/build/charts-base/charts-base.js", 14497);
if(i != valueAxisName && keys && Y_Lang.isArray(keys))
                        {
                            _yuitest_coverline("/build/charts-base/charts-base.js", 14499);
ll = keys.length;
                            _yuitest_coverline("/build/charts-base/charts-base.js", 14500);
for(ii = 0; ii < ll; ++ii)
                            {
                                _yuitest_coverline("/build/charts-base/charts-base.js", 14502);
claimedKeys.push(keys[ii]);
                            }
                            _yuitest_coverline("/build/charts-base/charts-base.js", 14504);
valueAxes.push(newAxes[i]);
                        }
                        _yuitest_coverline("/build/charts-base/charts-base.js", 14506);
if(!(this._getBaseAttribute(newAxes[i], "type")))
                        {
                            _yuitest_coverline("/build/charts-base/charts-base.js", 14508);
this._setBaseAttribute(newAxes[i], "type", seriesAxis);
                        }
                        _yuitest_coverline("/build/charts-base/charts-base.js", 14510);
if(!(this._getBaseAttribute(newAxes[i], "position")))
                        {
                            _yuitest_coverline("/build/charts-base/charts-base.js", 14512);
this._setBaseAttribute(newAxes[i], "position", this._getDefaultAxisPosition(newAxes[i], valueAxes, seriesPosition));
                        }
                    }}
                }
            }
        }
        _yuitest_coverline("/build/charts-base/charts-base.js", 14518);
cIndex = Y.Array.indexOf(seriesKeys, catKey);
        _yuitest_coverline("/build/charts-base/charts-base.js", 14519);
if(cIndex > -1)
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 14521);
seriesKeys.splice(cIndex, 1);
        }
        _yuitest_coverline("/build/charts-base/charts-base.js", 14523);
l = claimedKeys.length;
        _yuitest_coverline("/build/charts-base/charts-base.js", 14524);
for(i = 0; i < l; ++i)
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 14526);
cIndex = Y.Array.indexOf(seriesKeys, claimedKeys[i]); 
            _yuitest_coverline("/build/charts-base/charts-base.js", 14527);
if(cIndex > -1)
            {
                _yuitest_coverline("/build/charts-base/charts-base.js", 14529);
seriesKeys.splice(cIndex, 1);
            }
        }
        _yuitest_coverline("/build/charts-base/charts-base.js", 14532);
if(!newAxes.hasOwnProperty(categoryAxisName))
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 14534);
newAxes[categoryAxisName] = {};
        }
        _yuitest_coverline("/build/charts-base/charts-base.js", 14536);
if(!(this._getBaseAttribute(newAxes[categoryAxisName], "keys")))
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 14538);
this._setBaseAttribute(newAxes[categoryAxisName], "keys", [catKey]);
        }
        
        _yuitest_coverline("/build/charts-base/charts-base.js", 14541);
if(!(this._getBaseAttribute(newAxes[categoryAxisName], "position")))
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 14543);
this._setBaseAttribute(newAxes[categoryAxisName], "position", categoryPosition);
        }
         
        _yuitest_coverline("/build/charts-base/charts-base.js", 14546);
if(!(this._getBaseAttribute(newAxes[categoryAxisName], "type")))
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 14548);
this._setBaseAttribute(newAxes[categoryAxisName], "type", this.get("categoryType"));
        }
        _yuitest_coverline("/build/charts-base/charts-base.js", 14550);
if(!newAxes.hasOwnProperty(valueAxisName) && seriesKeys && seriesKeys.length > 0)
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 14552);
newAxes[valueAxisName] = {keys:seriesKeys};
            _yuitest_coverline("/build/charts-base/charts-base.js", 14553);
valueAxes.push(newAxes[valueAxisName]);
        }
        _yuitest_coverline("/build/charts-base/charts-base.js", 14555);
if(claimedKeys.length > 0)
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 14557);
if(seriesKeys.length > 0)
            {
                _yuitest_coverline("/build/charts-base/charts-base.js", 14559);
seriesKeys = claimedKeys.concat(seriesKeys);
            }
            else
            {
                _yuitest_coverline("/build/charts-base/charts-base.js", 14563);
seriesKeys = claimedKeys;
            }
        }
        _yuitest_coverline("/build/charts-base/charts-base.js", 14566);
if(newAxes.hasOwnProperty(valueAxisName))
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 14568);
if(!(this._getBaseAttribute(newAxes[valueAxisName], "position")))
            {
                _yuitest_coverline("/build/charts-base/charts-base.js", 14570);
this._setBaseAttribute(newAxes[valueAxisName], "position", this._getDefaultAxisPosition(newAxes[valueAxisName], valueAxes, seriesPosition));
            }
            _yuitest_coverline("/build/charts-base/charts-base.js", 14572);
this._setBaseAttribute(newAxes[valueAxisName], "type", seriesAxis);
            _yuitest_coverline("/build/charts-base/charts-base.js", 14573);
this._setBaseAttribute(newAxes[valueAxisName], "keys", seriesKeys);
        } 
        _yuitest_coverline("/build/charts-base/charts-base.js", 14575);
if(!this._seriesKeysExplicitlySet)
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 14577);
this._seriesKeys = seriesKeys;
        }
        _yuitest_coverline("/build/charts-base/charts-base.js", 14579);
return newAxes;
    },

    /**
     * Determines the position of an axis when one is not specified.
     *
     * @method _getDefaultAxisPosition
     * @param {Axis} axis `Axis` instance.
     * @param {Array} valueAxes Array of `Axis` instances.
     * @param {String} position Default position depending on the direction of the chart and type of axis.
     * @return String
     * @private
     */
    _getDefaultAxisPosition: function(axis, valueAxes, position)
    {
        _yuitest_coverfunc("/build/charts-base/charts-base.js", "_getDefaultAxisPosition", 14592);
_yuitest_coverline("/build/charts-base/charts-base.js", 14594);
var direction = this.get("direction"),
            i = Y.Array.indexOf(valueAxes, axis);
        
        _yuitest_coverline("/build/charts-base/charts-base.js", 14597);
if(valueAxes[i - 1] && valueAxes[i - 1].position)
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 14599);
if(direction == "horizontal")
            {
                _yuitest_coverline("/build/charts-base/charts-base.js", 14601);
if(valueAxes[i - 1].position == "left")
                {
                    _yuitest_coverline("/build/charts-base/charts-base.js", 14603);
position = "right";
                }
                else {_yuitest_coverline("/build/charts-base/charts-base.js", 14605);
if(valueAxes[i - 1].position == "right")
                {
                    _yuitest_coverline("/build/charts-base/charts-base.js", 14607);
position = "left";
                }}
            }
            else
            {
                _yuitest_coverline("/build/charts-base/charts-base.js", 14612);
if (valueAxes[i -1].position == "bottom")
                {
                    _yuitest_coverline("/build/charts-base/charts-base.js", 14614);
position = "top";
                }       
                else
                {
                    _yuitest_coverline("/build/charts-base/charts-base.js", 14618);
position = "bottom";
                }
            }
        }
        _yuitest_coverline("/build/charts-base/charts-base.js", 14622);
return position;
    },

   
    /**
     * Returns an object literal containing a categoryItem and a valueItem for a given series index. Below is the structure of each:
     * 
     * @method getSeriesItems
     * @param {CartesianSeries} series Reference to a series.
     * @param {Number} index Index of the specified item within a series.
     * @return Object An object literal containing the following:
     *
     *  <dl>
     *      <dt>categoryItem</dt><dd>Object containing the following data related to the category axis of the series.
     *  <dl>
     *      <dt>axis</dt><dd>Reference to the category axis of the series.</dd>
     *      <dt>key</dt><dd>Category key for the series.</dd>
     *      <dt>value</dt><dd>Value on the axis corresponding to the series index.</dd>
     *  </dl>
     *      </dd>
     *      <dt>valueItem</dt><dd>Object containing the following data related to the category axis of the series.
     *  <dl>
     *      <dt>axis</dt><dd>Reference to the value axis of the series.</dd>
     *      <dt>key</dt><dd>Value key for the series.</dd>
     *      <dt>value</dt><dd>Value on the axis corresponding to the series index.</dd>
     *  </dl>
     *      </dd>
     *  </dl>
     */
    getSeriesItems: function(series, index)
    {
        _yuitest_coverfunc("/build/charts-base/charts-base.js", "getSeriesItems", 14651);
_yuitest_coverline("/build/charts-base/charts-base.js", 14653);
var xAxis = series.get("xAxis"),
            yAxis = series.get("yAxis"),
            xKey = series.get("xKey"),
            yKey = series.get("yKey"),
            categoryItem,
            valueItem;
        _yuitest_coverline("/build/charts-base/charts-base.js", 14659);
if(this.get("direction") == "vertical")
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 14661);
categoryItem = {
                axis:yAxis,
                key:yKey,
                value:yAxis.getKeyValueAt(yKey, index)
            };
            _yuitest_coverline("/build/charts-base/charts-base.js", 14666);
valueItem = {
                axis:xAxis,
                key:xKey,
                value: xAxis.getKeyValueAt(xKey, index)
            };
        }
        else
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 14674);
valueItem = {
                axis:yAxis,
                key:yKey,
                value:yAxis.getKeyValueAt(yKey, index)
            };
            _yuitest_coverline("/build/charts-base/charts-base.js", 14679);
categoryItem = {
                axis:xAxis,
                key:xKey,
                value: xAxis.getKeyValueAt(xKey, index)
            };
        }
        _yuitest_coverline("/build/charts-base/charts-base.js", 14685);
categoryItem.displayName = series.get("categoryDisplayName");
        _yuitest_coverline("/build/charts-base/charts-base.js", 14686);
valueItem.displayName = series.get("valueDisplayName");
        _yuitest_coverline("/build/charts-base/charts-base.js", 14687);
categoryItem.value = categoryItem.axis.getKeyValueAt(categoryItem.key, index);
        _yuitest_coverline("/build/charts-base/charts-base.js", 14688);
valueItem.value = valueItem.axis.getKeyValueAt(valueItem.key, index);
        _yuitest_coverline("/build/charts-base/charts-base.js", 14689);
return {category:categoryItem, value:valueItem};
    },

    /**
     * Handler for sizeChanged event.
     *
     * @method _sizeChanged
     * @param {Object} e Event object.
     * @private
     */
    _sizeChanged: function(e)
    {
        _yuitest_coverfunc("/build/charts-base/charts-base.js", "_sizeChanged", 14699);
_yuitest_coverline("/build/charts-base/charts-base.js", 14701);
if(this._axesCollection)
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 14703);
var ac = this._axesCollection,
                i = 0,
                l = ac.length;
            _yuitest_coverline("/build/charts-base/charts-base.js", 14706);
for(; i < l; ++i)
            {
                _yuitest_coverline("/build/charts-base/charts-base.js", 14708);
this._addToAxesRenderQueue(ac[i]);
            }
            _yuitest_coverline("/build/charts-base/charts-base.js", 14710);
this._redraw();
        }
    },
    
    /**
     * Returns the maximum distance in pixels that the extends outside the top bounds of all vertical axes.
     *
     * @method _getTopOverflow
     * @param {Array} set1 Collection of axes to check.
     * @param {Array} set2 Seconf collection of axes to check.
     * @param {Number} width Width of the axes
     * @return Number
     * @private
     */
    _getTopOverflow: function(set1, set2, height)
    {
        _yuitest_coverfunc("/build/charts-base/charts-base.js", "_getTopOverflow", 14724);
_yuitest_coverline("/build/charts-base/charts-base.js", 14726);
var i = 0,
            len,
            overflow = 0,
            axis;
        _yuitest_coverline("/build/charts-base/charts-base.js", 14730);
if(set1)
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 14732);
len = set1.length;
            _yuitest_coverline("/build/charts-base/charts-base.js", 14733);
for(; i < len; ++i)
            {
                _yuitest_coverline("/build/charts-base/charts-base.js", 14735);
axis = set1[i];
                _yuitest_coverline("/build/charts-base/charts-base.js", 14736);
overflow = Math.max(overflow, Math.abs(axis.getMaxLabelBounds().top) - (axis.getEdgeOffset(axis.get("styles").majorTicks.count, height) * 0.5));
            }
        }
        _yuitest_coverline("/build/charts-base/charts-base.js", 14739);
if(set2)
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 14741);
i = 0;
            _yuitest_coverline("/build/charts-base/charts-base.js", 14742);
len = set2.length;
            _yuitest_coverline("/build/charts-base/charts-base.js", 14743);
for(; i < len; ++i)
            {
                _yuitest_coverline("/build/charts-base/charts-base.js", 14745);
axis = set2[i];
                _yuitest_coverline("/build/charts-base/charts-base.js", 14746);
overflow = Math.max(overflow, Math.abs(axis.getMaxLabelBounds().top) - (axis.getEdgeOffset(axis.get("styles").majorTicks.count, height) * 0.5));
            }
        }
        _yuitest_coverline("/build/charts-base/charts-base.js", 14749);
return overflow;
    },
    
    /**
     * Returns the maximum distance in pixels that the extends outside the right bounds of all horizontal axes.
     *
     * @method _getRightOverflow
     * @param {Array} set1 Collection of axes to check.
     * @param {Array} set2 Seconf collection of axes to check.
     * @param {Number} width Width of the axes
     * @return Number
     * @private
     */
    _getRightOverflow: function(set1, set2, width)
    {
        _yuitest_coverfunc("/build/charts-base/charts-base.js", "_getRightOverflow", 14762);
_yuitest_coverline("/build/charts-base/charts-base.js", 14764);
var i = 0,
            len,
            overflow = 0,
            axis;
        _yuitest_coverline("/build/charts-base/charts-base.js", 14768);
if(set1)
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 14770);
len = set1.length;
            _yuitest_coverline("/build/charts-base/charts-base.js", 14771);
for(; i < len; ++i)
            {
                _yuitest_coverline("/build/charts-base/charts-base.js", 14773);
axis = set1[i];
                _yuitest_coverline("/build/charts-base/charts-base.js", 14774);
overflow = Math.max(overflow, axis.getMaxLabelBounds().right - (axis.getEdgeOffset(axis.get("styles").majorTicks.count, width) * 0.5));
            }
        }
        _yuitest_coverline("/build/charts-base/charts-base.js", 14777);
if(set2)
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 14779);
i = 0;
            _yuitest_coverline("/build/charts-base/charts-base.js", 14780);
len = set2.length;
            _yuitest_coverline("/build/charts-base/charts-base.js", 14781);
for(; i < len; ++i)
            {
                _yuitest_coverline("/build/charts-base/charts-base.js", 14783);
axis = set2[i];
                _yuitest_coverline("/build/charts-base/charts-base.js", 14784);
overflow = Math.max(overflow, axis.getMaxLabelBounds().right - (axis.getEdgeOffset(axis.get("styles").majorTicks.count, width) * 0.5));
            }
        }
        _yuitest_coverline("/build/charts-base/charts-base.js", 14787);
return overflow;
    },
    
    /**
     * Returns the maximum distance in pixels that the extends outside the left bounds of all horizontal axes.
     *
     * @method _getLeftOverflow
     * @param {Array} set1 Collection of axes to check.
     * @param {Array} set2 Seconf collection of axes to check.
     * @param {Number} width Width of the axes
     * @return Number
     * @private
     */
    _getLeftOverflow: function(set1, set2, width)
    {
        _yuitest_coverfunc("/build/charts-base/charts-base.js", "_getLeftOverflow", 14800);
_yuitest_coverline("/build/charts-base/charts-base.js", 14802);
var i = 0,
            len,
            overflow = 0,
            axis;
        _yuitest_coverline("/build/charts-base/charts-base.js", 14806);
if(set1)
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 14808);
len = set1.length;
            _yuitest_coverline("/build/charts-base/charts-base.js", 14809);
for(; i < len; ++i)
            {
                _yuitest_coverline("/build/charts-base/charts-base.js", 14811);
axis = set1[i];
                _yuitest_coverline("/build/charts-base/charts-base.js", 14812);
overflow = Math.max(overflow, Math.abs(axis.getMinLabelBounds().left) - (axis.getEdgeOffset(axis.get("styles").majorTicks.count, width) * 0.5));
            }
        }
        _yuitest_coverline("/build/charts-base/charts-base.js", 14815);
if(set2)
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 14817);
i = 0;
            _yuitest_coverline("/build/charts-base/charts-base.js", 14818);
len = set2.length;
            _yuitest_coverline("/build/charts-base/charts-base.js", 14819);
for(; i < len; ++i)
            {
                _yuitest_coverline("/build/charts-base/charts-base.js", 14821);
axis = set2[i];
                _yuitest_coverline("/build/charts-base/charts-base.js", 14822);
overflow = Math.max(overflow, Math.abs(axis.getMinLabelBounds().left) - (axis.getEdgeOffset(axis.get("styles").majorTicks.count, width) * 0.5));
            }
        }
        _yuitest_coverline("/build/charts-base/charts-base.js", 14825);
return overflow;
    },
    
    /**
     * Returns the maximum distance in pixels that the extends outside the bottom bounds of all vertical axes.
     *
     * @method _getBottomOverflow
     * @param {Array} set1 Collection of axes to check.
     * @param {Array} set2 Seconf collection of axes to check.
     * @param {Number} height Height of the axes
     * @return Number
     * @private
     */
    _getBottomOverflow: function(set1, set2, height)
    {
        _yuitest_coverfunc("/build/charts-base/charts-base.js", "_getBottomOverflow", 14838);
_yuitest_coverline("/build/charts-base/charts-base.js", 14840);
var i = 0,
            len,
            overflow = 0,
            axis;
        _yuitest_coverline("/build/charts-base/charts-base.js", 14844);
if(set1)
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 14846);
len = set1.length;
            _yuitest_coverline("/build/charts-base/charts-base.js", 14847);
for(; i < len; ++i)
            {
                _yuitest_coverline("/build/charts-base/charts-base.js", 14849);
axis = set1[i];
                _yuitest_coverline("/build/charts-base/charts-base.js", 14850);
overflow = Math.max(overflow, axis.getMinLabelBounds().bottom - (axis.getEdgeOffset(axis.get("styles").majorTicks.count, height) * 0.5));
            }
        }
        _yuitest_coverline("/build/charts-base/charts-base.js", 14853);
if(set2)
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 14855);
i = 0;
            _yuitest_coverline("/build/charts-base/charts-base.js", 14856);
len = set2.length;
            _yuitest_coverline("/build/charts-base/charts-base.js", 14857);
for(; i < len; ++i)
            {
                _yuitest_coverline("/build/charts-base/charts-base.js", 14859);
axis = set2[i];
                _yuitest_coverline("/build/charts-base/charts-base.js", 14860);
overflow = Math.max(overflow, axis.getMinLabelBounds().bottom - (axis.getEdgeOffset(axis.get("styles").majorTicks.count, height) * 0.5));
            }
        }
        _yuitest_coverline("/build/charts-base/charts-base.js", 14863);
return overflow;
    },

    /**
     * Redraws and position all the components of the chart instance.
     *
     * @method _redraw
     * @private
     */
    _redraw: function()
    {
        _yuitest_coverfunc("/build/charts-base/charts-base.js", "_redraw", 14872);
_yuitest_coverline("/build/charts-base/charts-base.js", 14874);
if(this._drawing)
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 14876);
this._callLater = true;
            _yuitest_coverline("/build/charts-base/charts-base.js", 14877);
return;
        }
        _yuitest_coverline("/build/charts-base/charts-base.js", 14879);
this._drawing = true;
        _yuitest_coverline("/build/charts-base/charts-base.js", 14880);
this._callLater = false;
        _yuitest_coverline("/build/charts-base/charts-base.js", 14881);
var w = this.get("width"),
            h = this.get("height"),
            leftPaneWidth = 0,
            rightPaneWidth = 0,
            topPaneHeight = 0,
            bottomPaneHeight = 0,
            leftAxesCollection = this.get("leftAxesCollection"),
            rightAxesCollection = this.get("rightAxesCollection"),
            topAxesCollection = this.get("topAxesCollection"),
            bottomAxesCollection = this.get("bottomAxesCollection"),
            i = 0,
            l,
            axis,
            graphOverflow = "visible",
            graph = this.get("graph"),
            topOverflow,
            bottomOverflow,
            leftOverflow,
            rightOverflow,
            graphWidth,
            graphHeight,
            graphX,
            graphY,
            allowContentOverflow = this.get("allowContentOverflow"),
            diff,
            rightAxesXCoords,
            leftAxesXCoords,
            topAxesYCoords,
            bottomAxesYCoords,
            graphRect = {};
        _yuitest_coverline("/build/charts-base/charts-base.js", 14911);
if(leftAxesCollection)
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 14913);
leftAxesXCoords = [];
            _yuitest_coverline("/build/charts-base/charts-base.js", 14914);
l = leftAxesCollection.length;
            _yuitest_coverline("/build/charts-base/charts-base.js", 14915);
for(i = l - 1; i > -1; --i)
            {
                _yuitest_coverline("/build/charts-base/charts-base.js", 14917);
leftAxesXCoords.unshift(leftPaneWidth);
                _yuitest_coverline("/build/charts-base/charts-base.js", 14918);
leftPaneWidth += leftAxesCollection[i].get("width");
            }
        }
        _yuitest_coverline("/build/charts-base/charts-base.js", 14921);
if(rightAxesCollection)
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 14923);
rightAxesXCoords = [];
            _yuitest_coverline("/build/charts-base/charts-base.js", 14924);
l = rightAxesCollection.length;
            _yuitest_coverline("/build/charts-base/charts-base.js", 14925);
i = 0;
            _yuitest_coverline("/build/charts-base/charts-base.js", 14926);
for(i = l - 1; i > -1; --i)
            {
                _yuitest_coverline("/build/charts-base/charts-base.js", 14928);
rightPaneWidth += rightAxesCollection[i].get("width");
                _yuitest_coverline("/build/charts-base/charts-base.js", 14929);
rightAxesXCoords.unshift(w - rightPaneWidth);
            }
        }
        _yuitest_coverline("/build/charts-base/charts-base.js", 14932);
if(topAxesCollection)
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 14934);
topAxesYCoords = [];
            _yuitest_coverline("/build/charts-base/charts-base.js", 14935);
l = topAxesCollection.length;
            _yuitest_coverline("/build/charts-base/charts-base.js", 14936);
for(i = l - 1; i > -1; --i)
            {
                _yuitest_coverline("/build/charts-base/charts-base.js", 14938);
topAxesYCoords.unshift(topPaneHeight);
                _yuitest_coverline("/build/charts-base/charts-base.js", 14939);
topPaneHeight += topAxesCollection[i].get("height");
            }
        }
        _yuitest_coverline("/build/charts-base/charts-base.js", 14942);
if(bottomAxesCollection)
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 14944);
bottomAxesYCoords = [];
            _yuitest_coverline("/build/charts-base/charts-base.js", 14945);
l = bottomAxesCollection.length;
            _yuitest_coverline("/build/charts-base/charts-base.js", 14946);
for(i = l - 1; i > -1; --i)
            {
                _yuitest_coverline("/build/charts-base/charts-base.js", 14948);
bottomPaneHeight += bottomAxesCollection[i].get("height");
                _yuitest_coverline("/build/charts-base/charts-base.js", 14949);
bottomAxesYCoords.unshift(h - bottomPaneHeight);
            }
        }
        
        _yuitest_coverline("/build/charts-base/charts-base.js", 14953);
graphWidth = w - (leftPaneWidth + rightPaneWidth);
        _yuitest_coverline("/build/charts-base/charts-base.js", 14954);
graphHeight = h - (bottomPaneHeight + topPaneHeight);
        _yuitest_coverline("/build/charts-base/charts-base.js", 14955);
graphRect.left = leftPaneWidth;
        _yuitest_coverline("/build/charts-base/charts-base.js", 14956);
graphRect.top = topPaneHeight;
        _yuitest_coverline("/build/charts-base/charts-base.js", 14957);
graphRect.bottom = h - bottomPaneHeight;
        _yuitest_coverline("/build/charts-base/charts-base.js", 14958);
graphRect.right = w - rightPaneWidth;
        _yuitest_coverline("/build/charts-base/charts-base.js", 14959);
if(!allowContentOverflow)
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 14961);
topOverflow = this._getTopOverflow(leftAxesCollection, rightAxesCollection);
            _yuitest_coverline("/build/charts-base/charts-base.js", 14962);
bottomOverflow = this._getBottomOverflow(leftAxesCollection, rightAxesCollection);
            _yuitest_coverline("/build/charts-base/charts-base.js", 14963);
leftOverflow = this._getLeftOverflow(bottomAxesCollection, topAxesCollection);
            _yuitest_coverline("/build/charts-base/charts-base.js", 14964);
rightOverflow = this._getRightOverflow(bottomAxesCollection, topAxesCollection);
            
            _yuitest_coverline("/build/charts-base/charts-base.js", 14966);
diff = topOverflow - topPaneHeight;
            _yuitest_coverline("/build/charts-base/charts-base.js", 14967);
if(diff > 0)
            {
                _yuitest_coverline("/build/charts-base/charts-base.js", 14969);
graphRect.top = topOverflow;
                _yuitest_coverline("/build/charts-base/charts-base.js", 14970);
if(topAxesYCoords)
                {
                    _yuitest_coverline("/build/charts-base/charts-base.js", 14972);
i = 0;
                    _yuitest_coverline("/build/charts-base/charts-base.js", 14973);
l = topAxesYCoords.length;
                    _yuitest_coverline("/build/charts-base/charts-base.js", 14974);
for(; i < l; ++i)
                    {
                        _yuitest_coverline("/build/charts-base/charts-base.js", 14976);
topAxesYCoords[i] += diff;
                    }
                }
            }

            _yuitest_coverline("/build/charts-base/charts-base.js", 14981);
diff = bottomOverflow - bottomPaneHeight;
            _yuitest_coverline("/build/charts-base/charts-base.js", 14982);
if(diff > 0)
            {
                _yuitest_coverline("/build/charts-base/charts-base.js", 14984);
graphRect.bottom = h - bottomOverflow;
                _yuitest_coverline("/build/charts-base/charts-base.js", 14985);
if(bottomAxesYCoords)
                {
                    _yuitest_coverline("/build/charts-base/charts-base.js", 14987);
i = 0;
                    _yuitest_coverline("/build/charts-base/charts-base.js", 14988);
l = bottomAxesYCoords.length;
                    _yuitest_coverline("/build/charts-base/charts-base.js", 14989);
for(; i < l; ++i)
                    {
                        _yuitest_coverline("/build/charts-base/charts-base.js", 14991);
bottomAxesYCoords[i] -= diff;
                    }
                }
            }

            _yuitest_coverline("/build/charts-base/charts-base.js", 14996);
diff = leftOverflow - leftPaneWidth;
            _yuitest_coverline("/build/charts-base/charts-base.js", 14997);
if(diff > 0)
            {
                _yuitest_coverline("/build/charts-base/charts-base.js", 14999);
graphRect.left = leftOverflow;
                _yuitest_coverline("/build/charts-base/charts-base.js", 15000);
if(leftAxesXCoords)
                {
                    _yuitest_coverline("/build/charts-base/charts-base.js", 15002);
i = 0;
                    _yuitest_coverline("/build/charts-base/charts-base.js", 15003);
l = leftAxesXCoords.length;
                    _yuitest_coverline("/build/charts-base/charts-base.js", 15004);
for(; i < l; ++i)
                    {
                        _yuitest_coverline("/build/charts-base/charts-base.js", 15006);
leftAxesXCoords[i] += diff;
                    }
                }
            }

            _yuitest_coverline("/build/charts-base/charts-base.js", 15011);
diff = rightOverflow - rightPaneWidth;
            _yuitest_coverline("/build/charts-base/charts-base.js", 15012);
if(diff > 0)
            {
                _yuitest_coverline("/build/charts-base/charts-base.js", 15014);
graphRect.right = w - rightOverflow;
                _yuitest_coverline("/build/charts-base/charts-base.js", 15015);
if(rightAxesXCoords)
                {
                    _yuitest_coverline("/build/charts-base/charts-base.js", 15017);
i = 0;
                    _yuitest_coverline("/build/charts-base/charts-base.js", 15018);
l = rightAxesXCoords.length;
                    _yuitest_coverline("/build/charts-base/charts-base.js", 15019);
for(; i < l; ++i)
                    {
                        _yuitest_coverline("/build/charts-base/charts-base.js", 15021);
rightAxesXCoords[i] -= diff;
                    }
                }
            }
        }
        _yuitest_coverline("/build/charts-base/charts-base.js", 15026);
graphWidth = graphRect.right - graphRect.left;
        _yuitest_coverline("/build/charts-base/charts-base.js", 15027);
graphHeight = graphRect.bottom - graphRect.top;
        _yuitest_coverline("/build/charts-base/charts-base.js", 15028);
graphX = graphRect.left;
        _yuitest_coverline("/build/charts-base/charts-base.js", 15029);
graphY = graphRect.top;
        _yuitest_coverline("/build/charts-base/charts-base.js", 15030);
if(topAxesCollection)
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 15032);
l = topAxesCollection.length;
            _yuitest_coverline("/build/charts-base/charts-base.js", 15033);
i = 0;
            _yuitest_coverline("/build/charts-base/charts-base.js", 15034);
for(; i < l; i++)
            {
                _yuitest_coverline("/build/charts-base/charts-base.js", 15036);
axis = topAxesCollection[i];
                _yuitest_coverline("/build/charts-base/charts-base.js", 15037);
if(axis.get("width") !== graphWidth)
                {
                    _yuitest_coverline("/build/charts-base/charts-base.js", 15039);
axis.set("width", graphWidth);
                }
                _yuitest_coverline("/build/charts-base/charts-base.js", 15041);
axis.get("boundingBox").setStyle("left", graphX + "px");
                _yuitest_coverline("/build/charts-base/charts-base.js", 15042);
axis.get("boundingBox").setStyle("top", topAxesYCoords[i] + "px");
            }
            _yuitest_coverline("/build/charts-base/charts-base.js", 15044);
if(axis._hasDataOverflow())
            {
                _yuitest_coverline("/build/charts-base/charts-base.js", 15046);
graphOverflow = "hidden";
            }
        }
        _yuitest_coverline("/build/charts-base/charts-base.js", 15049);
if(bottomAxesCollection)
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 15051);
l = bottomAxesCollection.length;
            _yuitest_coverline("/build/charts-base/charts-base.js", 15052);
i = 0;
            _yuitest_coverline("/build/charts-base/charts-base.js", 15053);
for(; i < l; i++)
            {
                _yuitest_coverline("/build/charts-base/charts-base.js", 15055);
axis = bottomAxesCollection[i];
                _yuitest_coverline("/build/charts-base/charts-base.js", 15056);
if(axis.get("width") !== graphWidth)
                {
                    _yuitest_coverline("/build/charts-base/charts-base.js", 15058);
axis.set("width", graphWidth);
                }
                _yuitest_coverline("/build/charts-base/charts-base.js", 15060);
axis.get("boundingBox").setStyle("left", graphX + "px");
                _yuitest_coverline("/build/charts-base/charts-base.js", 15061);
axis.get("boundingBox").setStyle("top", bottomAxesYCoords[i] + "px");
            }
            _yuitest_coverline("/build/charts-base/charts-base.js", 15063);
if(axis._hasDataOverflow())
            {
                _yuitest_coverline("/build/charts-base/charts-base.js", 15065);
graphOverflow = "hidden";
            }
        }
        _yuitest_coverline("/build/charts-base/charts-base.js", 15068);
if(leftAxesCollection)
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 15070);
l = leftAxesCollection.length;
            _yuitest_coverline("/build/charts-base/charts-base.js", 15071);
i = 0;
            _yuitest_coverline("/build/charts-base/charts-base.js", 15072);
for(; i < l; ++i)
            {
                _yuitest_coverline("/build/charts-base/charts-base.js", 15074);
axis = leftAxesCollection[i];
                _yuitest_coverline("/build/charts-base/charts-base.js", 15075);
axis.get("boundingBox").setStyle("top", graphY + "px");
                _yuitest_coverline("/build/charts-base/charts-base.js", 15076);
axis.get("boundingBox").setStyle("left", leftAxesXCoords[i] + "px");
                _yuitest_coverline("/build/charts-base/charts-base.js", 15077);
if(axis.get("height") !== graphHeight)
                {
                    _yuitest_coverline("/build/charts-base/charts-base.js", 15079);
axis.set("height", graphHeight);
                }
            }
            _yuitest_coverline("/build/charts-base/charts-base.js", 15082);
if(axis._hasDataOverflow())
            {
                _yuitest_coverline("/build/charts-base/charts-base.js", 15084);
graphOverflow = "hidden";
            }
        }
        _yuitest_coverline("/build/charts-base/charts-base.js", 15087);
if(rightAxesCollection)
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 15089);
l = rightAxesCollection.length;
            _yuitest_coverline("/build/charts-base/charts-base.js", 15090);
i = 0;
            _yuitest_coverline("/build/charts-base/charts-base.js", 15091);
for(; i < l; ++i)
            {
                _yuitest_coverline("/build/charts-base/charts-base.js", 15093);
axis = rightAxesCollection[i];
                _yuitest_coverline("/build/charts-base/charts-base.js", 15094);
axis.get("boundingBox").setStyle("top", graphY + "px");
                _yuitest_coverline("/build/charts-base/charts-base.js", 15095);
axis.get("boundingBox").setStyle("left", rightAxesXCoords[i] + "px");
                _yuitest_coverline("/build/charts-base/charts-base.js", 15096);
if(axis.get("height") !== graphHeight)
                {
                    _yuitest_coverline("/build/charts-base/charts-base.js", 15098);
axis.set("height", graphHeight);
                }
            }
            _yuitest_coverline("/build/charts-base/charts-base.js", 15101);
if(axis._hasDataOverflow())
            {
                _yuitest_coverline("/build/charts-base/charts-base.js", 15103);
graphOverflow = "hidden";
            }
        }
        _yuitest_coverline("/build/charts-base/charts-base.js", 15106);
this._drawing = false;
        _yuitest_coverline("/build/charts-base/charts-base.js", 15107);
if(this._callLater)
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 15109);
this._redraw();
            _yuitest_coverline("/build/charts-base/charts-base.js", 15110);
return;
        }
        _yuitest_coverline("/build/charts-base/charts-base.js", 15112);
if(graph)
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 15114);
graph.get("boundingBox").setStyle("left", graphX + "px");
            _yuitest_coverline("/build/charts-base/charts-base.js", 15115);
graph.get("boundingBox").setStyle("top", graphY + "px");
            _yuitest_coverline("/build/charts-base/charts-base.js", 15116);
graph.set("width", graphWidth);
            _yuitest_coverline("/build/charts-base/charts-base.js", 15117);
graph.set("height", graphHeight);
            _yuitest_coverline("/build/charts-base/charts-base.js", 15118);
graph.get("boundingBox").setStyle("overflow", graphOverflow);
        }

        _yuitest_coverline("/build/charts-base/charts-base.js", 15121);
if(this._overlay)
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 15123);
this._overlay.setStyle("left", graphX + "px");
            _yuitest_coverline("/build/charts-base/charts-base.js", 15124);
this._overlay.setStyle("top", graphY + "px");
            _yuitest_coverline("/build/charts-base/charts-base.js", 15125);
this._overlay.setStyle("width", graphWidth + "px");
            _yuitest_coverline("/build/charts-base/charts-base.js", 15126);
this._overlay.setStyle("height", graphHeight + "px");
        }
    },

    /**
     * Destructor implementation for the CartesianChart class. Calls destroy on all axes, series and the Graph instance.
     * Removes the tooltip and overlay HTML elements.
     *
     * @method destructor
     * @protected
     */
    destructor: function()
    {
        _yuitest_coverfunc("/build/charts-base/charts-base.js", "destructor", 15137);
_yuitest_coverline("/build/charts-base/charts-base.js", 15139);
var graph = this.get("graph"),
            i = 0,
            len,
            seriesCollection = this.get("seriesCollection"),
            axesCollection = this._axesCollection,
            tooltip = this.get("tooltip").node;
        _yuitest_coverline("/build/charts-base/charts-base.js", 15145);
if(this._description)
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 15147);
this._description.empty();
            _yuitest_coverline("/build/charts-base/charts-base.js", 15148);
this._description.remove(true);
        }
        _yuitest_coverline("/build/charts-base/charts-base.js", 15150);
if(this._liveRegion)
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 15152);
this._liveRegion.empty();
            _yuitest_coverline("/build/charts-base/charts-base.js", 15153);
this._liveRegion.remove(true);
        }
        _yuitest_coverline("/build/charts-base/charts-base.js", 15155);
len = seriesCollection ? seriesCollection.length : 0;
        _yuitest_coverline("/build/charts-base/charts-base.js", 15156);
for(; i < len; ++i)
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 15158);
if(seriesCollection[i] instanceof Y.CartesianSeries)
            {
                _yuitest_coverline("/build/charts-base/charts-base.js", 15160);
seriesCollection[i].destroy(true);
            }
        }
        _yuitest_coverline("/build/charts-base/charts-base.js", 15163);
len = axesCollection ? axesCollection.length : 0;
        _yuitest_coverline("/build/charts-base/charts-base.js", 15164);
for(i = 0; i < len; ++i)
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 15166);
if(axesCollection[i] instanceof Y.Axis)
            {
                _yuitest_coverline("/build/charts-base/charts-base.js", 15168);
axesCollection[i].destroy(true);
            }
        }
        _yuitest_coverline("/build/charts-base/charts-base.js", 15171);
if(graph)
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 15173);
graph.destroy(true);
        }
        _yuitest_coverline("/build/charts-base/charts-base.js", 15175);
if(tooltip)
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 15177);
tooltip.empty();
            _yuitest_coverline("/build/charts-base/charts-base.js", 15178);
tooltip.remove(true);
        }
        _yuitest_coverline("/build/charts-base/charts-base.js", 15180);
if(this._overlay)
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 15182);
this._overlay.empty();
            _yuitest_coverline("/build/charts-base/charts-base.js", 15183);
this._overlay.remove(true);
        }
    },

    /**
     * Returns the appropriate message based on the key press.
     *
     * @method _getAriaMessage
     * @param {Number} key The keycode that was pressed.
     * @return String
     */
    _getAriaMessage: function(key)
    {
        _yuitest_coverfunc("/build/charts-base/charts-base.js", "_getAriaMessage", 15194);
_yuitest_coverline("/build/charts-base/charts-base.js", 15196);
var msg = "",
            series,
            items,
            categoryItem,
            valueItem,
            seriesIndex = this._seriesIndex,
            itemIndex = this._itemIndex,
            seriesCollection = this.get("seriesCollection"),
            len = seriesCollection.length,
            dataLength;
        _yuitest_coverline("/build/charts-base/charts-base.js", 15206);
if(key % 2 === 0)
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 15208);
if(len > 1)
            {
                _yuitest_coverline("/build/charts-base/charts-base.js", 15210);
if(key === 38)
                {
                    _yuitest_coverline("/build/charts-base/charts-base.js", 15212);
seriesIndex = seriesIndex < 1 ? len - 1 : seriesIndex - 1;
                }
                else {_yuitest_coverline("/build/charts-base/charts-base.js", 15214);
if(key === 40)
                {
                    _yuitest_coverline("/build/charts-base/charts-base.js", 15216);
seriesIndex = seriesIndex >= len - 1 ? 0 : seriesIndex + 1;
                }}
                _yuitest_coverline("/build/charts-base/charts-base.js", 15218);
this._itemIndex = -1;
            }
            else
            {
                _yuitest_coverline("/build/charts-base/charts-base.js", 15222);
seriesIndex = 0;
            }
            _yuitest_coverline("/build/charts-base/charts-base.js", 15224);
this._seriesIndex = seriesIndex;
            _yuitest_coverline("/build/charts-base/charts-base.js", 15225);
series = this.getSeries(parseInt(seriesIndex, 10));
            _yuitest_coverline("/build/charts-base/charts-base.js", 15226);
msg = series.get("valueDisplayName") + " series.";
        }
        else
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 15230);
if(seriesIndex > -1)
            {
                _yuitest_coverline("/build/charts-base/charts-base.js", 15232);
msg = "";
                _yuitest_coverline("/build/charts-base/charts-base.js", 15233);
series = this.getSeries(parseInt(seriesIndex, 10));
            }
            else
            {
                _yuitest_coverline("/build/charts-base/charts-base.js", 15237);
seriesIndex = 0;
                _yuitest_coverline("/build/charts-base/charts-base.js", 15238);
this._seriesIndex = seriesIndex;
                _yuitest_coverline("/build/charts-base/charts-base.js", 15239);
series = this.getSeries(parseInt(seriesIndex, 10));
                _yuitest_coverline("/build/charts-base/charts-base.js", 15240);
msg = series.get("valueDisplayName") + " series.";
            }
            _yuitest_coverline("/build/charts-base/charts-base.js", 15242);
dataLength = series._dataLength ? series._dataLength : 0;
            _yuitest_coverline("/build/charts-base/charts-base.js", 15243);
if(key === 37)
            {
                _yuitest_coverline("/build/charts-base/charts-base.js", 15245);
itemIndex = itemIndex > 0 ? itemIndex - 1 : dataLength - 1;
            }
            else {_yuitest_coverline("/build/charts-base/charts-base.js", 15247);
if(key === 39)
            {
                _yuitest_coverline("/build/charts-base/charts-base.js", 15249);
itemIndex = itemIndex >= dataLength - 1 ? 0 : itemIndex + 1;
            }}
            _yuitest_coverline("/build/charts-base/charts-base.js", 15251);
this._itemIndex = itemIndex;
            _yuitest_coverline("/build/charts-base/charts-base.js", 15252);
items = this.getSeriesItems(series, itemIndex);
            _yuitest_coverline("/build/charts-base/charts-base.js", 15253);
categoryItem = items.category;
            _yuitest_coverline("/build/charts-base/charts-base.js", 15254);
valueItem = items.value;
            _yuitest_coverline("/build/charts-base/charts-base.js", 15255);
if(categoryItem && valueItem && categoryItem.value && valueItem.value)
            {
                _yuitest_coverline("/build/charts-base/charts-base.js", 15257);
msg += categoryItem.displayName + ": " + categoryItem.axis.formatLabel.apply(this, [categoryItem.value, categoryItem.axis.get("labelFormat")]) + ", ";
                _yuitest_coverline("/build/charts-base/charts-base.js", 15258);
msg += valueItem.displayName + ": " + valueItem.axis.formatLabel.apply(this, [valueItem.value, valueItem.axis.get("labelFormat")]) + ", "; 
            }
           else
            {
                _yuitest_coverline("/build/charts-base/charts-base.js", 15262);
msg += "No data available.";
            }
            _yuitest_coverline("/build/charts-base/charts-base.js", 15264);
msg += (itemIndex + 1) + " of " + dataLength + ". ";
        }
        _yuitest_coverline("/build/charts-base/charts-base.js", 15266);
return msg;
    }
}, {
    ATTRS: {
        /**
         * Indicates whether axis labels are allowed to overflow beyond the bounds of the chart's content box.
         *
         * @attribute allowContentOverflow
         * @type Boolean
         */
        allowContentOverflow: {
            value: false
        },

        /**
         * Style object for the axes.
         *
         * @attribute axesStyles
         * @type Object
         * @private
         */
        axesStyles: {
            getter: function()
            {
                _yuitest_coverfunc("/build/charts-base/charts-base.js", "getter", 15288);
_yuitest_coverline("/build/charts-base/charts-base.js", 15290);
var axes = this.get("axes"),
                    i,
                    styles = this._axesStyles;
                _yuitest_coverline("/build/charts-base/charts-base.js", 15293);
if(axes)
                {
                    _yuitest_coverline("/build/charts-base/charts-base.js", 15295);
for(i in axes)
                    {
                        _yuitest_coverline("/build/charts-base/charts-base.js", 15297);
if(axes.hasOwnProperty(i) && axes[i] instanceof Y.Axis)
                        {
                            _yuitest_coverline("/build/charts-base/charts-base.js", 15299);
if(!styles)
                            {
                                _yuitest_coverline("/build/charts-base/charts-base.js", 15301);
styles = {};
                            }
                            _yuitest_coverline("/build/charts-base/charts-base.js", 15303);
styles[i] = axes[i].get("styles");
                        }
                    }
                }
                _yuitest_coverline("/build/charts-base/charts-base.js", 15307);
return styles;
            },
            
            setter: function(val)
            {
                _yuitest_coverfunc("/build/charts-base/charts-base.js", "setter", 15310);
_yuitest_coverline("/build/charts-base/charts-base.js", 15312);
var axes = this.get("axes"),
                    i;
                _yuitest_coverline("/build/charts-base/charts-base.js", 15314);
for(i in val)
                {
                    _yuitest_coverline("/build/charts-base/charts-base.js", 15316);
if(val.hasOwnProperty(i) && axes.hasOwnProperty(i))
                    {
                        _yuitest_coverline("/build/charts-base/charts-base.js", 15318);
this._setBaseAttribute(axes[i], "styles", val[i]);
                    }
                }
            }
        },

        /**
         * Style object for the series
         *
         * @attribute seriesStyles
         * @type Object
         * @private
         */
        seriesStyles: {
            getter: function()
            {
                _yuitest_coverfunc("/build/charts-base/charts-base.js", "getter", 15332);
_yuitest_coverline("/build/charts-base/charts-base.js", 15334);
var styles = this._seriesStyles,
                    graph = this.get("graph"),
                    dict,
                    i;
                _yuitest_coverline("/build/charts-base/charts-base.js", 15338);
if(graph)
                {
                    _yuitest_coverline("/build/charts-base/charts-base.js", 15340);
dict = graph.get("seriesDictionary");
                    _yuitest_coverline("/build/charts-base/charts-base.js", 15341);
if(dict)
                    {
                        _yuitest_coverline("/build/charts-base/charts-base.js", 15343);
styles = {};
                        _yuitest_coverline("/build/charts-base/charts-base.js", 15344);
for(i in dict)
                        {
                            _yuitest_coverline("/build/charts-base/charts-base.js", 15346);
if(dict.hasOwnProperty(i))
                            {
                                _yuitest_coverline("/build/charts-base/charts-base.js", 15348);
styles[i] = dict[i].get("styles");
                            }
                        }
                    }
                }
                _yuitest_coverline("/build/charts-base/charts-base.js", 15353);
return styles;
            },
            
            setter: function(val)
            {
                _yuitest_coverfunc("/build/charts-base/charts-base.js", "setter", 15356);
_yuitest_coverline("/build/charts-base/charts-base.js", 15358);
var i,
                    l,
                    s;
    
                _yuitest_coverline("/build/charts-base/charts-base.js", 15362);
if(Y_Lang.isArray(val))
                {
                    _yuitest_coverline("/build/charts-base/charts-base.js", 15364);
s = this.get("seriesCollection");
                    _yuitest_coverline("/build/charts-base/charts-base.js", 15365);
i = 0;
                    _yuitest_coverline("/build/charts-base/charts-base.js", 15366);
l = val.length;

                    _yuitest_coverline("/build/charts-base/charts-base.js", 15368);
for(; i < l; ++i)
                    {
                        _yuitest_coverline("/build/charts-base/charts-base.js", 15370);
this._setBaseAttribute(s[i], "styles", val[i]);
                    }
                }
                else
                {
                    _yuitest_coverline("/build/charts-base/charts-base.js", 15375);
for(i in val)
                    {
                        _yuitest_coverline("/build/charts-base/charts-base.js", 15377);
if(val.hasOwnProperty(i))
                        {
                            _yuitest_coverline("/build/charts-base/charts-base.js", 15379);
s = this.getSeries(i);
                            _yuitest_coverline("/build/charts-base/charts-base.js", 15380);
this._setBaseAttribute(s, "styles", val[i]);
                        }
                    }
                }
            }
        },

        /**
         * Styles for the graph.
         *
         * @attribute graphStyles
         * @type Object
         * @private
         */
        graphStyles: {
            getter: function()
            {
                _yuitest_coverfunc("/build/charts-base/charts-base.js", "getter", 15395);
_yuitest_coverline("/build/charts-base/charts-base.js", 15397);
var graph = this.get("graph");
                _yuitest_coverline("/build/charts-base/charts-base.js", 15398);
if(graph)
                {
                    _yuitest_coverline("/build/charts-base/charts-base.js", 15400);
return(graph.get("styles"));
                }
                _yuitest_coverline("/build/charts-base/charts-base.js", 15402);
return this._graphStyles;
            },

            setter: function(val)
            {
                _yuitest_coverfunc("/build/charts-base/charts-base.js", "setter", 15405);
_yuitest_coverline("/build/charts-base/charts-base.js", 15407);
var graph = this.get("graph");
                _yuitest_coverline("/build/charts-base/charts-base.js", 15408);
this._setBaseAttribute(graph, "styles", val);
            }

        },

        /**
         * Style properties for the chart. Contains a key indexed hash of the following:
         *  <dl>
         *      <dt>series</dt><dd>A key indexed hash containing references to the `styles` attribute for each series in the chart.
         *      Specific style attributes vary depending on the series:
         *      <ul>
         *          <li><a href="AreaSeries.html#attr_styles">AreaSeries</a></li>
         *          <li><a href="BarSeries.html#attr_styles">BarSeries</a></li>
         *          <li><a href="ColumnSeries.html#attr_styles">ColumnSeries</a></li>
         *          <li><a href="ComboSeries.html#attr_styles">ComboSeries</a></li>
         *          <li><a href="LineSeries.html#attr_styles">LineSeries</a></li>
         *          <li><a href="MarkerSeries.html#attr_styles">MarkerSeries</a></li>
         *          <li><a href="SplineSeries.html#attr_styles">SplineSeries</a></li>
         *      </ul>
         *      </dd>
         *      <dt>axes</dt><dd>A key indexed hash containing references to the `styles` attribute for each axes in the chart. Specific
         *      style attributes can be found in the <a href="Axis.html#attr_styles">Axis</a> class.</dd>
         *      <dt>graph</dt><dd>A reference to the `styles` attribute in the chart. Specific style attributes can be found in the
         *      <a href="Graph.html#attr_styles">Graph</a> class.</dd>
         *  </dl>
         *
         * @attribute styles
         * @type Object
         */
        styles: {
            getter: function()
            {
                _yuitest_coverfunc("/build/charts-base/charts-base.js", "getter", 15438);
_yuitest_coverline("/build/charts-base/charts-base.js", 15440);
var styles = { 
                    axes: this.get("axesStyles"),
                    series: this.get("seriesStyles"),
                    graph: this.get("graphStyles")
                };
                _yuitest_coverline("/build/charts-base/charts-base.js", 15445);
return styles;
            },
            setter: function(val)
            {
                _yuitest_coverfunc("/build/charts-base/charts-base.js", "setter", 15447);
_yuitest_coverline("/build/charts-base/charts-base.js", 15449);
if(val.hasOwnProperty("axes"))
                {
                    _yuitest_coverline("/build/charts-base/charts-base.js", 15451);
if(this.get("axesStyles"))
                    {
                        _yuitest_coverline("/build/charts-base/charts-base.js", 15453);
this.set("axesStyles", val.axes);
                    }
                    else
                    {
                        _yuitest_coverline("/build/charts-base/charts-base.js", 15457);
this._axesStyles = val.axes;
                    }
                }
                _yuitest_coverline("/build/charts-base/charts-base.js", 15460);
if(val.hasOwnProperty("series"))
                {
                    _yuitest_coverline("/build/charts-base/charts-base.js", 15462);
if(this.get("seriesStyles"))
                    {
                        _yuitest_coverline("/build/charts-base/charts-base.js", 15464);
this.set("seriesStyles", val.series);
                    }
                    else
                    {
                        _yuitest_coverline("/build/charts-base/charts-base.js", 15468);
this._seriesStyles = val.series;
                    }
                }
                _yuitest_coverline("/build/charts-base/charts-base.js", 15471);
if(val.hasOwnProperty("graph"))
                {
                    _yuitest_coverline("/build/charts-base/charts-base.js", 15473);
this.set("graphStyles", val.graph);
                }
            }
        },

        /**
         * Axes to appear in the chart. This can be a key indexed hash of axis instances or object literals
         * used to construct the appropriate axes.
         *
         * @attribute axes
         * @type Object
         */
        axes: {
            valueFn: "_getDefaultAxes",

            setter: function(val)
            {
                _yuitest_coverfunc("/build/charts-base/charts-base.js", "setter", 15488);
_yuitest_coverline("/build/charts-base/charts-base.js", 15490);
if(this.get("dataProvider"))
                {
                    _yuitest_coverline("/build/charts-base/charts-base.js", 15492);
val = this._setAxes(val);
                }
                _yuitest_coverline("/build/charts-base/charts-base.js", 15494);
return val;
            }
        },

        /**
         * Collection of series to appear on the chart. This can be an array of Series instances or object literals
         * used to construct the appropriate series.
         *
         * @attribute seriesCollection
         * @type Array
         */
        seriesCollection: {
            valueFn: "_getDefaultSeriesCollection",
            
            setter: function(val)
            {
                _yuitest_coverfunc("/build/charts-base/charts-base.js", "setter", 15508);
_yuitest_coverline("/build/charts-base/charts-base.js", 15510);
if(this.get("dataProvider"))
                {
                    _yuitest_coverline("/build/charts-base/charts-base.js", 15512);
val = this._parseSeriesCollection(val);
                }
                _yuitest_coverline("/build/charts-base/charts-base.js", 15514);
return val;
            }
        },

        /**
         * Reference to the left-aligned axes for the chart.
         *
         * @attribute leftAxesCollection
         * @type Array
         * @private
         */
        leftAxesCollection: {},

        /**
         * Reference to the bottom-aligned axes for the chart.
         *
         * @attribute bottomAxesCollection
         * @type Array
         * @private
         */
        bottomAxesCollection: {},

        /**
         * Reference to the right-aligned axes for the chart.
         *
         * @attribute rightAxesCollection
         * @type Array
         * @private
         */
        rightAxesCollection: {},

        /**
         * Reference to the top-aligned axes for the chart.
         *
         * @attribute topAxesCollection
         * @type Array
         * @private
         */
        topAxesCollection: {},
        
        /**
         * Indicates whether or not the chart is stacked.
         *
         * @attribute stacked
         * @type Boolean
         */
        stacked: {
            value: false
        },

        /**
         * Direction of chart's category axis when there is no series collection specified. Charts can
         * be horizontal or vertical. When the chart type is column, the chart is horizontal.
         * When the chart type is bar, the chart is vertical. 
         *
         * @attribute direction
         * @type String
         */
        direction: {
            getter: function()
            {
                _yuitest_coverfunc("/build/charts-base/charts-base.js", "getter", 15573);
_yuitest_coverline("/build/charts-base/charts-base.js", 15575);
var type = this.get("type");
                _yuitest_coverline("/build/charts-base/charts-base.js", 15576);
if(type == "bar")
                {   
                    _yuitest_coverline("/build/charts-base/charts-base.js", 15578);
return "vertical";
                }
                else {_yuitest_coverline("/build/charts-base/charts-base.js", 15580);
if(type == "column")
                {
                    _yuitest_coverline("/build/charts-base/charts-base.js", 15582);
return "horizontal";
                }}
                _yuitest_coverline("/build/charts-base/charts-base.js", 15584);
return this._direction;
            },

            setter: function(val)
            {
                _yuitest_coverfunc("/build/charts-base/charts-base.js", "setter", 15587);
_yuitest_coverline("/build/charts-base/charts-base.js", 15589);
this._direction = val;
                _yuitest_coverline("/build/charts-base/charts-base.js", 15590);
return this._direction;
            }
        },

        /**
         * Indicates whether or not an area is filled in a combo chart.
         * 
         * @attribute showAreaFill
         * @type Boolean
         */
        showAreaFill: {},

        /**
         * Indicates whether to display markers in a combo chart.
         *
         * @attribute showMarkers
         * @type Boolean
         */
        showMarkers:{},

        /**
         * Indicates whether to display lines in a combo chart.
         *
         * @attribute showLines
         * @type Boolean
         */
        showLines:{},

        /**
         * Indicates the key value used to identify a category axis in the `axes` hash. If
         * not specified, the categoryKey attribute value will be used.
         * 
         * @attribute categoryAxisName
         * @type String
         */
        categoryAxisName: {
        },

        /**
         * Indicates the key value used to identify a the series axis when an axis not generated.
         *
         * @attribute valueAxisName
         * @type String
         */
        valueAxisName: {
            value: "values"
        },

        /**
         * Reference to the horizontalGridlines for the chart.
         *
         * @attribute horizontalGridlines
         * @type Gridlines
         */
        horizontalGridlines: {
            getter: function()
            {
                _yuitest_coverfunc("/build/charts-base/charts-base.js", "getter", 15645);
_yuitest_coverline("/build/charts-base/charts-base.js", 15647);
var graph = this.get("graph");
                _yuitest_coverline("/build/charts-base/charts-base.js", 15648);
if(graph)
                {
                    _yuitest_coverline("/build/charts-base/charts-base.js", 15650);
return graph.get("horizontalGridlines");
                }
                _yuitest_coverline("/build/charts-base/charts-base.js", 15652);
return this._horizontalGridlines;
            },
            setter: function(val)
            {
                _yuitest_coverfunc("/build/charts-base/charts-base.js", "setter", 15654);
_yuitest_coverline("/build/charts-base/charts-base.js", 15656);
var graph = this.get("graph");
                _yuitest_coverline("/build/charts-base/charts-base.js", 15657);
if(val && !Y_Lang.isObject(val))
                {
                    _yuitest_coverline("/build/charts-base/charts-base.js", 15659);
val = {};
                }
                _yuitest_coverline("/build/charts-base/charts-base.js", 15661);
if(graph)
                {
                    _yuitest_coverline("/build/charts-base/charts-base.js", 15663);
graph.set("horizontalGridlines", val);
                }
                else
                {
                    _yuitest_coverline("/build/charts-base/charts-base.js", 15667);
this._horizontalGridlines = val;
                }
            }
        },

        /**
         * Reference to the verticalGridlines for the chart.
         *
         * @attribute verticalGridlines
         * @type Gridlines
         */
        verticalGridlines: {
            getter: function()
            {
                _yuitest_coverfunc("/build/charts-base/charts-base.js", "getter", 15679);
_yuitest_coverline("/build/charts-base/charts-base.js", 15681);
var graph = this.get("graph");
                _yuitest_coverline("/build/charts-base/charts-base.js", 15682);
if(graph)
                {
                    _yuitest_coverline("/build/charts-base/charts-base.js", 15684);
return graph.get("verticalGridlines");
                }
                _yuitest_coverline("/build/charts-base/charts-base.js", 15686);
return this._verticalGridlines;
            },
            setter: function(val)
            {
                _yuitest_coverfunc("/build/charts-base/charts-base.js", "setter", 15688);
_yuitest_coverline("/build/charts-base/charts-base.js", 15690);
var graph = this.get("graph");
                _yuitest_coverline("/build/charts-base/charts-base.js", 15691);
if(val && !Y_Lang.isObject(val))
                {
                    _yuitest_coverline("/build/charts-base/charts-base.js", 15693);
val = {};
                }
                _yuitest_coverline("/build/charts-base/charts-base.js", 15695);
if(graph)
                {
                    _yuitest_coverline("/build/charts-base/charts-base.js", 15697);
graph.set("verticalGridlines", val);
                }
                else
                {
                    _yuitest_coverline("/build/charts-base/charts-base.js", 15701);
this._verticalGridlines = val;
                }
            }
        },
        
        /**
         * Type of chart when there is no series collection specified.
         *
         * @attribute type
         * @type String 
         */
        type: {
            getter: function()
            {
                _yuitest_coverfunc("/build/charts-base/charts-base.js", "getter", 15713);
_yuitest_coverline("/build/charts-base/charts-base.js", 15715);
if(this.get("stacked"))
                {
                    _yuitest_coverline("/build/charts-base/charts-base.js", 15717);
return "stacked" + this._type;
                }
                _yuitest_coverline("/build/charts-base/charts-base.js", 15719);
return this._type;
            },

            setter: function(val)
            {
                _yuitest_coverfunc("/build/charts-base/charts-base.js", "setter", 15722);
_yuitest_coverline("/build/charts-base/charts-base.js", 15724);
if(this._type == "bar")
                {
                    _yuitest_coverline("/build/charts-base/charts-base.js", 15726);
if(val != "bar")
                    {
                        _yuitest_coverline("/build/charts-base/charts-base.js", 15728);
this.set("direction", "horizontal");
                    }
                }
                else
                {
                    _yuitest_coverline("/build/charts-base/charts-base.js", 15733);
if(val == "bar")
                    {
                        _yuitest_coverline("/build/charts-base/charts-base.js", 15735);
this.set("direction", "vertical");
                    }
                }
                _yuitest_coverline("/build/charts-base/charts-base.js", 15738);
this._type = val;
                _yuitest_coverline("/build/charts-base/charts-base.js", 15739);
return this._type;
            }
        },
        
        /**
         * Reference to the category axis used by the chart.
         *
         * @attribute categoryAxis
         * @type Axis
         */
        categoryAxis:{}
    }
});
/**
 * The PieChart class creates a pie chart
 *
 * @module charts
 * @submodule charts-base
 * @class PieChart
 * @extends ChartBase
 * @constructor
 */
_yuitest_coverline("/build/charts-base/charts-base.js", 15761);
Y.PieChart = Y.Base.create("pieChart", Y.Widget, [Y.ChartBase], {
    /**
     * Calculates and returns a `seriesCollection`.
     *
     * @method _getSeriesCollection
     * @return Array
     * @private
     */
    _getSeriesCollection: function()
    {
        _yuitest_coverfunc("/build/charts-base/charts-base.js", "_getSeriesCollection", 15769);
_yuitest_coverline("/build/charts-base/charts-base.js", 15771);
if(this._seriesCollection)
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 15773);
return this._seriesCollection;
        }
        _yuitest_coverline("/build/charts-base/charts-base.js", 15775);
var axes = this.get("axes"),
            sc = [], 
            seriesKeys,
            i = 0,
            l,
            type = this.get("type"),
            key,
            catAxis = "categoryAxis",
            catKey = "categoryKey",
            valAxis = "valueAxis",
            seriesKey = "valueKey";
        _yuitest_coverline("/build/charts-base/charts-base.js", 15786);
if(axes)
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 15788);
seriesKeys = axes.values.get("keyCollection");
            _yuitest_coverline("/build/charts-base/charts-base.js", 15789);
key = axes.category.get("keyCollection")[0];
            _yuitest_coverline("/build/charts-base/charts-base.js", 15790);
l = seriesKeys.length;
            _yuitest_coverline("/build/charts-base/charts-base.js", 15791);
for(; i < l; ++i)
            {
                _yuitest_coverline("/build/charts-base/charts-base.js", 15793);
sc[i] = {type:type};
                _yuitest_coverline("/build/charts-base/charts-base.js", 15794);
sc[i][catAxis] = "category";
                _yuitest_coverline("/build/charts-base/charts-base.js", 15795);
sc[i][valAxis] = "values";
                _yuitest_coverline("/build/charts-base/charts-base.js", 15796);
sc[i][catKey] = key;
                _yuitest_coverline("/build/charts-base/charts-base.js", 15797);
sc[i][seriesKey] = seriesKeys[i];
            }
        }
        _yuitest_coverline("/build/charts-base/charts-base.js", 15800);
this._seriesCollection = sc;
        _yuitest_coverline("/build/charts-base/charts-base.js", 15801);
return sc;
    },

    /**
     * Creates `Axis` instances.
     *
     * @method _parseAxes
     * @param {Object} val Object containing `Axis` instances or objects in which to construct `Axis` instances.
     * @return Object
     * @private
     */
    _parseAxes: function(hash)
    {
        _yuitest_coverfunc("/build/charts-base/charts-base.js", "_parseAxes", 15812);
_yuitest_coverline("/build/charts-base/charts-base.js", 15814);
if(!this._axes)
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 15816);
this._axes = {};
        }
        _yuitest_coverline("/build/charts-base/charts-base.js", 15818);
var i, pos, axis, dh, config, axisClass,
            type = this.get("type"),
            w = this.get("width"),
            h = this.get("height"),
            node = Y.Node.one(this._parentNode);
        _yuitest_coverline("/build/charts-base/charts-base.js", 15823);
if(!w)
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 15825);
this.set("width", node.get("offsetWidth"));
            _yuitest_coverline("/build/charts-base/charts-base.js", 15826);
w = this.get("width");
        }
        _yuitest_coverline("/build/charts-base/charts-base.js", 15828);
if(!h)
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 15830);
this.set("height", node.get("offsetHeight"));
            _yuitest_coverline("/build/charts-base/charts-base.js", 15831);
h = this.get("height");
        }
        _yuitest_coverline("/build/charts-base/charts-base.js", 15833);
for(i in hash)
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 15835);
if(hash.hasOwnProperty(i))
            {
                _yuitest_coverline("/build/charts-base/charts-base.js", 15837);
dh = hash[i];
                _yuitest_coverline("/build/charts-base/charts-base.js", 15838);
pos = type == "pie" ? "none" : dh.position;
                _yuitest_coverline("/build/charts-base/charts-base.js", 15839);
axisClass = this._getAxisClass(dh.type);
                _yuitest_coverline("/build/charts-base/charts-base.js", 15840);
config = {dataProvider:this.get("dataProvider")};
                _yuitest_coverline("/build/charts-base/charts-base.js", 15841);
if(dh.hasOwnProperty("roundingUnit"))
                {
                    _yuitest_coverline("/build/charts-base/charts-base.js", 15843);
config.roundingUnit = dh.roundingUnit;
                }
                _yuitest_coverline("/build/charts-base/charts-base.js", 15845);
config.keys = dh.keys;
                _yuitest_coverline("/build/charts-base/charts-base.js", 15846);
config.width = w;
                _yuitest_coverline("/build/charts-base/charts-base.js", 15847);
config.height = h;
                _yuitest_coverline("/build/charts-base/charts-base.js", 15848);
config.position = pos;
                _yuitest_coverline("/build/charts-base/charts-base.js", 15849);
config.styles = dh.styles;
                _yuitest_coverline("/build/charts-base/charts-base.js", 15850);
axis = new axisClass(config);
                _yuitest_coverline("/build/charts-base/charts-base.js", 15851);
axis.on("axisRendered", Y.bind(this._itemRendered, this));
                _yuitest_coverline("/build/charts-base/charts-base.js", 15852);
this._axes[i] = axis;
            }
        }
    },

    /**
     * Adds axes to the chart.
     *
     * @method _addAxes
     * @private
     */
    _addAxes: function()
    {
        _yuitest_coverfunc("/build/charts-base/charts-base.js", "_addAxes", 15863);
_yuitest_coverline("/build/charts-base/charts-base.js", 15865);
var axes = this.get("axes"),
            i, 
            axis, 
            p;
        _yuitest_coverline("/build/charts-base/charts-base.js", 15869);
if(!axes)
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 15871);
this.set("axes", this._getDefaultAxes());
            _yuitest_coverline("/build/charts-base/charts-base.js", 15872);
axes = this.get("axes");
        }
        _yuitest_coverline("/build/charts-base/charts-base.js", 15874);
if(!this._axesCollection)
        {   
            _yuitest_coverline("/build/charts-base/charts-base.js", 15876);
this._axesCollection = [];
        }
        _yuitest_coverline("/build/charts-base/charts-base.js", 15878);
for(i in axes)
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 15880);
if(axes.hasOwnProperty(i))
            {
                _yuitest_coverline("/build/charts-base/charts-base.js", 15882);
axis = axes[i];
                _yuitest_coverline("/build/charts-base/charts-base.js", 15883);
p = axis.get("position");
                _yuitest_coverline("/build/charts-base/charts-base.js", 15884);
if(!this.get(p + "AxesCollection"))
                {
                    _yuitest_coverline("/build/charts-base/charts-base.js", 15886);
this.set(p + "AxesCollection", [axis]);
                }
                else
                {
                    _yuitest_coverline("/build/charts-base/charts-base.js", 15890);
this.get(p + "AxesCollection").push(axis);
                }
                _yuitest_coverline("/build/charts-base/charts-base.js", 15892);
this._axesCollection.push(axis);
            }
        }
    },

    /**
     * Renders the Graph.
     *
     * @method _addSeries
     * @private
     */
    _addSeries: function()
    {
        _yuitest_coverfunc("/build/charts-base/charts-base.js", "_addSeries", 15903);
_yuitest_coverline("/build/charts-base/charts-base.js", 15905);
var graph = this.get("graph"),
            seriesCollection = this.get("seriesCollection");
        _yuitest_coverline("/build/charts-base/charts-base.js", 15907);
this._parseSeriesAxes(seriesCollection);
        _yuitest_coverline("/build/charts-base/charts-base.js", 15908);
graph.set("showBackground", false);
        _yuitest_coverline("/build/charts-base/charts-base.js", 15909);
graph.set("width", this.get("width"));
        _yuitest_coverline("/build/charts-base/charts-base.js", 15910);
graph.set("height", this.get("height"));
        _yuitest_coverline("/build/charts-base/charts-base.js", 15911);
graph.set("seriesCollection", seriesCollection);
        _yuitest_coverline("/build/charts-base/charts-base.js", 15912);
this._seriesCollection = graph.get("seriesCollection");
        _yuitest_coverline("/build/charts-base/charts-base.js", 15913);
graph.render(this.get("contentBox"));
    },

    /**
     * Parse and sets the axes for the chart.
     *
     * @method _parseSeriesAxes
     * @param {Array} c A collection `PieSeries` instance.
     * @private
     */
    _parseSeriesAxes: function(c)
    {
        _yuitest_coverfunc("/build/charts-base/charts-base.js", "_parseSeriesAxes", 15923);
_yuitest_coverline("/build/charts-base/charts-base.js", 15925);
var i = 0, 
            len = c.length, 
            s,
            axes = this.get("axes"),
            axis;
        _yuitest_coverline("/build/charts-base/charts-base.js", 15930);
for(; i < len; ++i)
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 15932);
s = c[i];
            _yuitest_coverline("/build/charts-base/charts-base.js", 15933);
if(s)
            {
                //If series is an actual series instance, 
                //replace axes attribute string ids with axes
                _yuitest_coverline("/build/charts-base/charts-base.js", 15937);
if(s instanceof Y.PieSeries)
                {
                    _yuitest_coverline("/build/charts-base/charts-base.js", 15939);
axis = s.get("categoryAxis");
                    _yuitest_coverline("/build/charts-base/charts-base.js", 15940);
if(axis && !(axis instanceof Y.Axis))
                    {
                        _yuitest_coverline("/build/charts-base/charts-base.js", 15942);
s.set("categoryAxis", axes[axis]);
                    }
                    _yuitest_coverline("/build/charts-base/charts-base.js", 15944);
axis = s.get("valueAxis");
                    _yuitest_coverline("/build/charts-base/charts-base.js", 15945);
if(axis && !(axis instanceof Y.Axis))
                    {
                        _yuitest_coverline("/build/charts-base/charts-base.js", 15947);
s.set("valueAxis", axes[axis]);
                    }
                    _yuitest_coverline("/build/charts-base/charts-base.js", 15949);
continue;
                }
                _yuitest_coverline("/build/charts-base/charts-base.js", 15951);
s.categoryAxis = axes.category;
                _yuitest_coverline("/build/charts-base/charts-base.js", 15952);
s.valueAxis = axes.values;
                _yuitest_coverline("/build/charts-base/charts-base.js", 15953);
if(!s.type)
                {
                    _yuitest_coverline("/build/charts-base/charts-base.js", 15955);
s.type = this.get("type");
                }
            }
        }
    },

    /**
     * Generates and returns a key-indexed object containing `Axis` instances or objects used to create `Axis` instances.
     *
     * @method _getDefaultAxes
     * @return Object
     * @private
     */
    _getDefaultAxes: function()
    {
        _yuitest_coverfunc("/build/charts-base/charts-base.js", "_getDefaultAxes", 15968);
_yuitest_coverline("/build/charts-base/charts-base.js", 15970);
var catKey = this.get("categoryKey"),
            seriesKeys = this.get("seriesKeys").concat(), 
            seriesAxis = "numeric";
        _yuitest_coverline("/build/charts-base/charts-base.js", 15973);
return {
            values:{
                keys:seriesKeys,
                type:seriesAxis
            },
            category:{
                keys:[catKey],
                type:this.get("categoryType")
            }
        };
    },
        
    /**
     * Returns an object literal containing a categoryItem and a valueItem for a given series index.
     *
     * @method getSeriesItem
     * @param series Reference to a series.
     * @param index Index of the specified item within a series.
     * @return Object
     */
    getSeriesItems: function(series, index)
    {
        _yuitest_coverfunc("/build/charts-base/charts-base.js", "getSeriesItems", 15993);
_yuitest_coverline("/build/charts-base/charts-base.js", 15995);
var categoryItem = {
                axis: series.get("categoryAxis"),
                key: series.get("categoryKey"),
                displayName: series.get("categoryDisplayName")
            },
            valueItem = {
                axis: series.get("valueAxis"),
                key: series.get("valueKey"),
                displayName: series.get("valueDisplayName")
            };
        _yuitest_coverline("/build/charts-base/charts-base.js", 16005);
categoryItem.value = categoryItem.axis.getKeyValueAt(categoryItem.key, index);
        _yuitest_coverline("/build/charts-base/charts-base.js", 16006);
valueItem.value = valueItem.axis.getKeyValueAt(valueItem.key, index);
        _yuitest_coverline("/build/charts-base/charts-base.js", 16007);
return {category:categoryItem, value:valueItem};
    },

    /**
     * Handler for sizeChanged event.
     *
     * @method _sizeChanged
     * @param {Object} e Event object.
     * @private
     */
    _sizeChanged: function(e)
    {
        _yuitest_coverfunc("/build/charts-base/charts-base.js", "_sizeChanged", 16017);
_yuitest_coverline("/build/charts-base/charts-base.js", 16019);
this._redraw();
    },

    /**
     * Redraws the chart instance.
     *
     * @method _redraw
     * @private
     */
    _redraw: function()
    {
        _yuitest_coverfunc("/build/charts-base/charts-base.js", "_redraw", 16028);
_yuitest_coverline("/build/charts-base/charts-base.js", 16030);
var graph = this.get("graph"),
            w = this.get("width"),
            h = this.get("height"),
            dimension;
        _yuitest_coverline("/build/charts-base/charts-base.js", 16034);
if(graph)
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 16036);
dimension = Math.min(w, h);
            _yuitest_coverline("/build/charts-base/charts-base.js", 16037);
graph.set("width", dimension);
            _yuitest_coverline("/build/charts-base/charts-base.js", 16038);
graph.set("height", dimension);
        }
    },
    
    /**
     * Formats tooltip text for a pie chart.
     *
     * @method _tooltipLabelFunction
     * @param {Object} categoryItem An object containing the following:
     *  <dl>
     *      <dt>axis</dt><dd>The axis to which the category is bound.</dd>
     *      <dt>displayName</dt><dd>The display name set to the category (defaults to key if not provided)</dd>
     *      <dt>key</dt><dd>The key of the category.</dd>
     *      <dt>value</dt><dd>The value of the category</dd>
     *  </dl>
     * @param {Object} valueItem An object containing the following:
     *  <dl>
     *      <dt>axis</dt><dd>The axis to which the item's series is bound.</dd>
     *      <dt>displayName</dt><dd>The display name of the series. (defaults to key if not provided)</dd>
     *      <dt>key</dt><dd>The key for the series.</dd>
     *      <dt>value</dt><dd>The value for the series item.</dd> 
     *  </dl>
     * @param {Number} itemIndex The index of the item within the series.
     * @param {CartesianSeries} series The `PieSeries` instance of the item.
     * @param {Number} seriesIndex The index of the series in the `seriesCollection`.
     * @return {HTML}
     * @private
     */
    _tooltipLabelFunction: function(categoryItem, valueItem, itemIndex, series, seriesIndex)
    {
        _yuitest_coverfunc("/build/charts-base/charts-base.js", "_tooltipLabelFunction", 16066);
_yuitest_coverline("/build/charts-base/charts-base.js", 16068);
var msg = DOCUMENT.createElement("div"),
            total = series.getTotalValues(),
            pct = Math.round((valueItem.value / total) * 10000)/100;
        _yuitest_coverline("/build/charts-base/charts-base.js", 16071);
msg.appendChild(DOCUMENT.createTextNode(categoryItem.displayName +
        ": " + categoryItem.axis.get("labelFunction").apply(this, [categoryItem.value, categoryItem.axis.get("labelFormat")]))); 
        _yuitest_coverline("/build/charts-base/charts-base.js", 16073);
msg.appendChild(DOCUMENT.createElement("br"));
        _yuitest_coverline("/build/charts-base/charts-base.js", 16074);
msg.appendChild(DOCUMENT.createTextNode(valueItem.displayName + 
        ": " + valueItem.axis.get("labelFunction").apply(this, [valueItem.value, valueItem.axis.get("labelFormat")])));
        _yuitest_coverline("/build/charts-base/charts-base.js", 16076);
msg.appendChild(DOCUMENT.createElement("br"));
        _yuitest_coverline("/build/charts-base/charts-base.js", 16077);
msg.appendChild(DOCUMENT.createTextNode(pct + "%")); 
        _yuitest_coverline("/build/charts-base/charts-base.js", 16078);
return msg; 
    },

    /**
     * Returns the appropriate message based on the key press.
     *
     * @method _getAriaMessage
     * @param {Number} key The keycode that was pressed.
     * @return String
     */
    _getAriaMessage: function(key)
    {
        _yuitest_coverfunc("/build/charts-base/charts-base.js", "_getAriaMessage", 16088);
_yuitest_coverline("/build/charts-base/charts-base.js", 16090);
var msg = "",
            categoryItem,
            items,
            series,
            valueItem,
            seriesIndex = 0,
            itemIndex = this._itemIndex,
            seriesCollection = this.get("seriesCollection"),
            len,
            total,
            pct,
            markers;
        _yuitest_coverline("/build/charts-base/charts-base.js", 16102);
series = this.getSeries(parseInt(seriesIndex, 10));
        _yuitest_coverline("/build/charts-base/charts-base.js", 16103);
markers = series.get("markers");
        _yuitest_coverline("/build/charts-base/charts-base.js", 16104);
len = markers && markers.length ? markers.length : 0;
        _yuitest_coverline("/build/charts-base/charts-base.js", 16105);
if(key === 37)
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 16107);
itemIndex = itemIndex > 0 ? itemIndex - 1 : len - 1;
        }
        else {_yuitest_coverline("/build/charts-base/charts-base.js", 16109);
if(key === 39)
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 16111);
itemIndex = itemIndex >= len - 1 ? 0 : itemIndex + 1;
        }}
        _yuitest_coverline("/build/charts-base/charts-base.js", 16113);
this._itemIndex = itemIndex;
        _yuitest_coverline("/build/charts-base/charts-base.js", 16114);
items = this.getSeriesItems(series, itemIndex);
        _yuitest_coverline("/build/charts-base/charts-base.js", 16115);
categoryItem = items.category;
        _yuitest_coverline("/build/charts-base/charts-base.js", 16116);
valueItem = items.value;
        _yuitest_coverline("/build/charts-base/charts-base.js", 16117);
total = series.getTotalValues();
        _yuitest_coverline("/build/charts-base/charts-base.js", 16118);
pct = Math.round((valueItem.value / total) * 10000)/100;
        _yuitest_coverline("/build/charts-base/charts-base.js", 16119);
if(categoryItem && valueItem)
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 16121);
msg += categoryItem.displayName + ": " + categoryItem.axis.formatLabel.apply(this, [categoryItem.value, categoryItem.axis.get("labelFormat")]) + ", ";
            _yuitest_coverline("/build/charts-base/charts-base.js", 16122);
msg += valueItem.displayName + ": " + valueItem.axis.formatLabel.apply(this, [valueItem.value, valueItem.axis.get("labelFormat")]) + ", "; 
            _yuitest_coverline("/build/charts-base/charts-base.js", 16123);
msg += "Percent of total " + valueItem.displayName + ": " + pct + "%,"; 
        }
        else
        {
            _yuitest_coverline("/build/charts-base/charts-base.js", 16127);
msg += "No data available,";
        }
        _yuitest_coverline("/build/charts-base/charts-base.js", 16129);
msg += (itemIndex + 1) + " of " + len + ". ";
        _yuitest_coverline("/build/charts-base/charts-base.js", 16130);
return msg;
    }
}, {
    ATTRS: {
        /**
         * Sets the aria description for the chart.
         *
         * @attribute ariaDescription
         * @type String
         */
        ariaDescription: {
            value: "Use the left and right keys to navigate through items.",

            setter: function(val)
            {
                _yuitest_coverfunc("/build/charts-base/charts-base.js", "setter", 16143);
_yuitest_coverline("/build/charts-base/charts-base.js", 16145);
if(this._description)
                {
                    _yuitest_coverline("/build/charts-base/charts-base.js", 16147);
this._description.setContent("");
                    _yuitest_coverline("/build/charts-base/charts-base.js", 16148);
this._description.appendChild(DOCUMENT.createTextNode(val));
                }
                _yuitest_coverline("/build/charts-base/charts-base.js", 16150);
return val;
            }
        },
        
        /**
         * Axes to appear in the chart. 
         *
         * @attribute axes
         * @type Object
         */
        axes: {
            getter: function()
            {
                _yuitest_coverfunc("/build/charts-base/charts-base.js", "getter", 16161);
_yuitest_coverline("/build/charts-base/charts-base.js", 16163);
return this._axes;
            },

            setter: function(val)
            {
                _yuitest_coverfunc("/build/charts-base/charts-base.js", "setter", 16166);
_yuitest_coverline("/build/charts-base/charts-base.js", 16168);
this._parseAxes(val);
            }
        },

        /**
         * Collection of series to appear on the chart. This can be an array of Series instances or object literals
         * used to describe a Series instance.
         *
         * @attribute seriesCollection
         * @type Array
         */
        seriesCollection: {
            getter: function()
            {
                _yuitest_coverfunc("/build/charts-base/charts-base.js", "getter", 16180);
_yuitest_coverline("/build/charts-base/charts-base.js", 16182);
return this._getSeriesCollection();
            },
            
            setter: function(val)
            {
                _yuitest_coverfunc("/build/charts-base/charts-base.js", "setter", 16185);
_yuitest_coverline("/build/charts-base/charts-base.js", 16187);
return this._setSeriesCollection(val);
            }
        },
        
        /**
         * Type of chart when there is no series collection specified.
         *
         * @attribute type
         * @type String 
         */
        type: {
            value: "pie"
        }
    }
});


}, '@VERSION@' ,{requires:['dom', 'datatype-number', 'datatype-date', 'event-custom', 'event-mouseenter', 'event-touch', 'widget', 'widget-position', 'widget-stack', 'graphics']});
