/**
 * Provides browser history management functionality using a simple
 * add/replace/get paradigm. This can be used to ensure that the browser's back
 * and forward buttons work as the user expects and to provide bookmarkable URLs
 * that return the user to the current application state, even in an Ajax
 * application that doesn't perform full-page refreshes.
 *
 * @module history
 * @since 3.2.0
 */

/**
 * The history-base module uses a simple object to store state. To integrate
 * state management with browser history and allow the back/forward buttons to
 * navigate between states, use history-hash.
 *
 * @module history
 * @submodule history-base
 */

/**
 * The HistoryBase class provides basic state management functionality backed by
 * an object. History state is shared globally among all instances and
 * subclass instances of HistoryBase.
 *
 * @class HistoryBase
 * @uses EventTarget
 * @constructor
 * @param {Object} config (optional) configuration object, which may contain
 *   zero or more of the following properties:
 *
 * <dl>
 *   <dt>initialState (Object)</dt>
 *   <dd>
 *     Initial state to set, as an object hash of key/value pairs. This will be
 *     merged into the current global state.
 *   </dd>
 * </dl>
 */

var Lang        = Y.Lang,
    Obj         = Y.Object,
    GlobalEnv   = YUI.namespace('Env.History'),

    EVT_CHANGE  = 'change',
    NAME        = 'historyBase',
    SRC_ADD     = 'add',
    SRC_REPLACE = 'replace',

HistoryBase = function () {
    this._init.apply(this, arguments);
};

Y.augment(HistoryBase, Y.EventTarget, null, null, {
    emitFacade : true,
    prefix     : 'history',
    preventable: false,
    queueable  : true
});

if (!GlobalEnv._state) {
    GlobalEnv._state = {};
}

// -- Public Static Properties -------------------------------------------------

/**
 * Name of this component.
 *
 * @property NAME
 * @type String
 * @static
 */
HistoryBase.NAME = NAME;

/**
 * Constant used to identify state changes originating from the
 * <code>add()</code> method.
 *
 * @property SRC_ADD
 * @type String
 * @static
 * @final
 */
HistoryBase.SRC_ADD = SRC_ADD;

/**
 * Constant used to identify state changes originating from the
 * <code>replace()</code> method.
 *
 * @property SRC_REPLACE
 * @type String
 * @static
 * @final
 */
HistoryBase.SRC_REPLACE = SRC_REPLACE;

Y.mix(HistoryBase.prototype, {
    // -- Initialization -------------------------------------------------------

    /**
     * Initializes this HistoryBase instance. This method is called by the
     * constructor.
     *
     * @method _init
     * @param {Object} config configuration object
     * @protected
     */
    _init: function (config) {
        var initialState = config && config.initialState;

        /**
         * Fired when the state changes. To be notified of all state changes
         * regardless of the History or YUI instance that generated them,
         * subscribe to this event on <code>Y.Global</code>. If you would rather
         * be notified only about changes generated by this specific History
         * instance, subscribe to this event on the instance.
         *
         * @event history:change
         * @param {EventFacade} e Event facade with the following additional
         *   properties:
         *
         * <dl>
         *   <dt>changed</dt>
         *   <dd>
         *     Object hash of state items that have been added or changed. The
         *     key is the item key, and the value is an object containing
         *     <code>newVal</code> and <code>prevVal</code> properties
         *     representing the values of the item both before and after the
         *     change. If the item was newly added, <code>prevVal</code> will be
         *     <code>undefined</code>.
         *   </dd>
         *
         *   <dt>newVal</dt>
         *   <dd>
         *     Object hash of key/value pairs of all state items after the
         *     change.
         *   </dd>
         *
         *   <dt>prevVal</dt>
         *   <dd>
         *     Object hash of key/value pairs of all state items before the
         *     change.
         *   </dd>
         *
         *   <dt>removed</dt>
         *   <dd>
         *     Object hash of key/value pairs of state items that have been
         *     removed. Values are the old values prior to removal.
         *   </dd>
         *
         *   <dt>src</dt>
         *   <dd>
         *     The source of the event. This can be used to selectively ignore
         *     events generated by certain sources.
         *   </dd>
         * </dl>
         */
        this.publish(EVT_CHANGE, {
            broadcast: 2,
            defaultFn: this._defChangeFn
        });

        // If initialState was provided and is a simple object, merge it into
        // the current state.
        if (Lang.isObject(initialState) && !Lang.isFunction(initialState) &&
                !Lang.isArray(initialState)) {
            this.add(Y.merge(GlobalEnv._state, initialState));
        }
    },

    // -- Public Methods -------------------------------------------------------

    /**
     * Adds a state entry with new values for the specified key or keys. Any key
     * with a <code>null</code> or <code>undefined</code> value will be removed
     * from the current state; all others will be merged into it.
     *
     * @method add
     * @param {Object|String} state|key object hash of key/value string pairs,
     *   or the name of a single key
     * @param {String|null} value (optional) if <i>state</i> is the name of a
     *   single key, <i>value</i> will become its new value
     * @chainable
     */
    add: function (state, value) {
        return this._change(SRC_ADD, state, value);
    },

    /**
     * Returns the current value of the state parameter specified by <i>key</i>,
     * or an object hash of key/value pairs for all current state parameters if
     * no key is specified.
     *
     * @method get
     * @param {String} key (optional) state parameter key
     * @return {Object|mixed} value of the specified state parameter, or an
     *   object hash of key/value pairs for all current state parameters
     */
    get: function (key) {
        var state = GlobalEnv._state;

        if (key) {
            return Obj.owns(state, key) ? state[key] : undefined;
        } else {
            return Y.mix({}, state, true); // Fast shallow clone.
        }
    },

    /**
     * Replaces the current state entry with new values for the specified
     * parameters, just as with <code>add()</code>, except that no change events
     * are generated.
     *
     * @method replace
     * @param {Object|String} state|key object hash of key/value string pairs,
     *   or the name of a single key
     * @param {String|null} value (optional) if <i>state</i> is the name of a
     *   single key, <i>value</i> will become its new value
     * @chainable
     */
    replace: function (state, value) {
        return this._change(SRC_REPLACE, state, value);
    },

    // -- Protected Methods ----------------------------------------------------

    /**
     * Changes the state. This method provides a common implementation shared by
     * add() and replace().
     *
     * @method _change
     * @param {String} src source of the change, for inclusion in event facades
     *   to facilitate filtering
     * @param {Object|String} state|key object hash of key/value string pairs,
     *   or the name of a single key
     * @param {String|null} value (optional) if <i>state</i> is the name of a
     *   single key, <i>value</i> will become its new value
     * @protected
     * @chainable
     */
    _change: function (src, state, value) {
        var key;

        if (Lang.isString(state)) {
            key        = state;
            state      = {};
            state[key] = value;
        }

        this._resolveChanges(src, Y.merge(GlobalEnv._state, state));
        return this;
    },

    /**
     * Called by _resolveChanges() when the state has changed. This method takes
     * care of actually firing the necessary events.
     *
     * @method _fireEvents
     * @param {String} src source of the changes, for inclusion in event facades
     *   to facilitate filtering
     * @param {Object} changes resolved changes
     * @protected
     */
    _fireEvents: function (src, changes) {
        // Fire the global change event.
        this.fire(EVT_CHANGE, {
            changed: changes.changed,
            newVal : changes.newState,
            prevVal: changes.prevState,
            removed: changes.removed,
            src    : src
        });

        // Fire change/remove events for individual items.
        Obj.each(changes.changed, function (value, key) {
            this._fireChangeEvent(src, key, value);
        }, this);

        Obj.each(changes.removed, function (value, key) {
            this._fireRemoveEvent(src, key, value);
        }, this);
    },

    /**
     * Fires a dynamic "[key]Change" event.
     *
     * @method _fireChangeEvent
     * @param {String} src source of the change, for inclusion in event facades
     *   to facilitate filtering
     * @param {String} key key of the item that was changed
     * @param {Object} value object hash containing <i>newVal</i> and
     *   <i>prevVal</i> properties for the changed item
     * @protected
     */
    _fireChangeEvent: function (src, key, value) {
        /**
         * <p>
         * Dynamic event fired when an individual history item is added or
         * changed. The name of this event depends on the name of the key that
         * changed. To listen to change events for a key named "foo", subscribe
         * to the <code>fooChange</code> event; for a key named "bar", subscribe
         * to <code>barChange</code>, etc.
         * </p>
         *
         * <p>
         * Key-specific events are only fired for instance-level changes; that
         * is, changes that were made via the same History instance on which the
         * event is subscribed. To be notified of changes made by other History
         * instances, subscribe to the global <code>history:change</code> event.
         * </p>
         *
         * @event [key]Change
         * @param {EventFacade} e Event facade with the following additional
         *   properties:
         *
         * <dl>
         *   <dt>newVal</dt>
         *   <dd>
         *     The new value of the item after the change.
         *   </dd>
         *
         *   <dt>prevVal</dt>
         *   <dd>
         *     The previous value of the item before the change, or
         *     <code>undefined</code> if the item was just added and has no
         *     previous value.
         *   </dd>
         *
         *   <dt>src</dt>
         *   <dd>
         *     The source of the event. This can be used to selectively ignore
         *     events generated by certain sources.
         *   </dd>
         * </dl>
         */
        this.fire(key + 'Change', {
            newVal : value.newVal,
            prevVal: value.prevVal,
            src    : src
        });
    },

    /**
     * Fires a dynamic "[key]Remove" event.
     *
     * @method _fireRemoveEvent
     * @param {String} src source of the change, for inclusion in event facades
     *   to facilitate filtering
     * @param {String} key key of the item that was removed
     * @param {mixed} value value of the item prior to its removal
     * @protected
     */
    _fireRemoveEvent: function (src, key, value) {
        /**
         * <p>
         * Dynamic event fired when an individual history item is removed. The
         * name of this event depends on the name of the key that was removed.
         * To listen to remove events for a key named "foo", subscribe to the
         * <code>fooRemove</code> event; for a key named "bar", subscribe to
         * <code>barRemove</code>, etc.
         * </p>
         *
         * <p>
         * Key-specific events are only fired for instance-level changes; that
         * is, changes that were made via the same History instance on which the
         * event is subscribed. To be notified of changes made by other History
         * instances, subscribe to the global <code>history:change</code> event.
         * </p>
         *
         * @event [key]Remove
         * @param {EventFacade} e Event facade with the following additional
         *   properties:
         *
         * <dl>
         *   <dt>prevVal</dt>
         *   <dd>
         *     The value of the item before it was removed.
         *   </dd>
         *
         *   <dt>src</dt>
         *   <dd>
         *     The source of the event. This can be used to selectively ignore
         *     events generated by certain sources.
         *   </dd>
         * </dl>
         */
        this.fire(key + 'Remove', {
            prevVal: value,
            src    : src
        });
    },

    /**
     * Resolves the changes (if any) between <i>newState</i> and the current
     * state and fires appropriate events if things have changed.
     *
     * @method _resolveChanges
     * @param {String} src source of the changes, for inclusion in event facades
     *   to facilitate filtering
     * @param {Object} newState object hash of key/value pairs representing the
     *   new state
     * @protected
     */
    _resolveChanges: function (src, newState) {
        var changed   = {},
            isChanged,
            prevState = GlobalEnv._state,
            removed   = {};

        newState = newState || {};

        // Figure out what was added or changed.
        Obj.each(newState, function (newVal, key) {
            var prevVal = prevState[key];

            if (newVal !== prevVal) {
                changed[key] = {
                    newVal : newVal,
                    prevVal: prevVal
                };

                isChanged = true;
            }
        }, this);

        // Figure out what was removed.
        // TODO: Could possibly improve performance slightly by not checking
        // keys that have been added/changed, since they obviously haven't been
        // removed. Need to profile to see if it's actually worth it.
        Obj.each(prevState, function (prevVal, key) {
            if (!Obj.owns(newState, key) || newState[key] === null) {
                delete newState[key];
                removed[key] = prevVal;
                isChanged = true;
            }
        }, this);

        if (isChanged) {
            this._fireEvents(src, {
                changed  : changed,
                newState : newState,
                prevState: prevState,
                removed  : removed
            });
        }
    },

    /**
     * Stores the specified state. Don't call this method directly; go through
     * _resolveChanges() to ensure that changes are resolved and all events are
     * fired properly.
     *
     * @method _storeState
     * @param {String} src source of the changes, for inclusion in event facades
     *   to facilitate filtering
     * @param {Object} newState new state to store
     * @protected
     */
    _storeState: function (src, newState) {
        // Note: the src param isn't used here, but it is used by subclasses.
        GlobalEnv._state = newState || {};
    },

    // -- Protected Event Handlers ---------------------------------------------

    /**
     * Default <code>history:change</code> event handler.
     *
     * @method _defChangeFn
     * @param {EventFacade} e state change event facade
     * @protected
     */
    _defChangeFn: function (e) {
        this._storeState(e.src, e.newVal);
    }
}, true);

Y.HistoryBase = HistoryBase;
