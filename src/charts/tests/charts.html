<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
    <head>
        <meta http-equiv="content-type" content="text/html; charset=utf-8">
        <style>
            /*Supplemental: CSS for the YUI distribution*/
            #custom-doc { width: 95%; min-width: 950px; }
            #pagetitle {background-image: url(../../assets/bg_hd.gif);}
            #mychart {
                padding:10px 10px 10px 10px;
            }
        </style>
        <link rel="stylesheet" type="text/css" href="../../../build/cssfonts/fonts-min.css">
    </head>		
<body class="yui3-skin-sam">
<h3>Unit Tests</h3>
<div id="mychart"></div>
<script type="text/javascript" src="../../../build/yui/yui-min.js"></script>
<script>            
YUI({
    allowRollup: false,
    filter: (window.location.search.match(/[?&]filter=([^&]+)/) || [])[1] || 'min'
}).use('charts', 'test', 'console', function (Y) 
{ 
    Y.namespace("example.test");
    
    var ENGINE = "VML",
    DOCUMENT = Y.config.doc,
    canvas = DOCUMENT && DOCUMENT.createElement("canvas"),
    TestSVGNodes = function(lineStyles, tickStyles, valueLinePath, valueTickPath, catLinePath, catTickPath)
    {
            var lineColor = lineStyles.color,
                lineWeight = lineStyles.weight,
                lineOpacity = lineStyles.alpha,
                tickColor = tickStyles.color,
                tickWeight = tickStyles.weight,
                tickOpacity = tickStyles.alpha;
            valueLineNode = valueLinePath.get("node");
            valueTickNode = valueTickPath.get("node");
            catLineNode = catLinePath.get("node");
            catTickNode = catTickPath.get("node");

            return  ( lineColor == valueLineNode.getAttribute("stroke") &&
                    parseFloat(lineWeight) === parseFloat(valueLineNode.getAttribute("stroke-width")) &&
                    parseFloat(lineOpacity) === parseFloat(valueLineNode.getAttribute("stroke-opacity")) &&
                    lineColor == catLineNode.getAttribute("stroke") &&
                    parseFloat(lineWeight) === parseFloat(catLineNode.getAttribute("stroke-width")) &&
                    parseFloat(lineOpacity) === parseFloat(catLineNode.getAttribute("stroke-opacity")) &&
                    tickColor == valueTickNode.getAttribute("stroke") &&
                    parseFloat(tickWeight) === parseFloat(valueTickNode.getAttribute("stroke-width")) &&
                    parseFloat(tickOpacity) === parseFloat(valueTickNode.getAttribute("stroke-opacity")) &&
                    tickColor == catTickNode.getAttribute("stroke") &&
                    parseFloat(tickWeight) === parseFloat(catTickNode.getAttribute("stroke-width")) &&
                    parseFloat(tickOpacity) === parseFloat(catTickNode.getAttribute("stroke-opacity")));
    },

    compareVMLColors = function(color, strokeNode, node)
    {
        var toHex = Y.Color.toHex,
            color = toHex(color);
        
        return (color == toHex(strokeNode.color) || color == toHex(strokeNode.color.value)) ||
        (color == toHex(node.strokecolor) || color == toHex(node.strokecolor.value));
    },

    compareVMLStrokeWeight = function(weight, strokeNode, node)
    {
        weight = parseFloat(weight);
        alert(weight + ", " + node.strokeWeight);
        alert(weight + ", " + strokeNode.weight);
        return weight === parseFloat(strokeNode.weight) || weight === parseFloat(node.strokeWeight);
    },

    TestVMLNodes = function(lineStyles, tickStyles, valueLinePath, valueTickPath, catLinePath, catTickPath)
    {
            var lineColor = lineStyles.color,
                lineWeight = lineStyles.weight,
                lineOpacity = lineStyles.alpha,
                tickColor = tickStyles.color,
                tickWeight = tickStyles.weight,
                tickOpacity = tickStyles.alpha;
            valueLineStrokeNode = valueLinePath._strokeNode;
            valueTickStrokeNode = valueTickPath._strokeNode;
            valueLineNode = valueLinePath.get("stroke");
            valueTickNode = valueTickPath.get("stroke");
            catLineStrokeNode = catLinePath._strokeNode;
            catTickStrokeNode = catTickPath._strokeNode;
            catLineNode = catLinePath.get("node");
            catTickNode = catTickPath.get("node");
            return compareVMLColors(lineColor, valueLineStrokeNode, valueLineNode) &&
                    //compareVMLStrokeWeight(lineWeight, valueLineStrokeNode, valueLineNode) &&
                    parseFloat(lineOpacity) === parseFloat(valueLineStrokeNode.opacity) &&
                    compareVMLColors(lineColor, catLineStrokeNode, valueLineNode) &&
                    //compareVMLStrokeWeight(lineWeight, catLineStrokeNode, catLineNode) &&
                    parseFloat(lineOpacity) === parseFloat(catLineStrokeNode.opacity) &&
                    compareVMLColors(tickColor, valueTickStrokeNode, valueTickNode) && 
                    //compareVMLStrokeWeight(tickWeight, valueTickStrokeNode, valueTickNode) &&
                    parseFloat(tickOpacity) === parseFloat(valueTickStrokeNode.opacity) &&
                    compareVMLColors(tickColor, catTickStrokeNode, catTickNode) &&
                    //compareVMLStrokeWeight(tickWeight, catTickStrokeNode, catTickNode) &&
                    parseFloat(tickOpacity) === parseFloat(catTickStrokeNode.opacity);
    },

    toRGBA = function(val, alpha) {
        alpha = (alpha !== undefined) ? alpha : 1;
        if (!Y.Color.re_RGB.test(val)) {
            val = Y.Color.toHex(val);
        }

        if(Y.Color.re_hex.exec(val)) {
            val = 'rgba(' + [
                parseInt(RegExp.$1, 16),
                parseInt(RegExp.$2, 16),
                parseInt(RegExp.$3, 16)
            ].join(',') + ',' + alpha + ')';
        }
        return val;
    },

    TestCanvasNodes = function(lineStyles, tickStyles, valueLinePath, valueTickPath, catLinePath, catTickPath)
    {
            var toHex = Y.Color.toHex,
                lineColor = toHex(lineStyles.color),
                lineWeight = lineStyles.weight,
                lineOpacity = lineStyles.alpha,
                tickColor = toHex(tickStyles.color),
                tickWeight = tickStyles.weight,
                tickOpacity = tickStyles.alpha,
                valueLineContext = valueLinePath._context,
                valueTickContext = valueTickPath._context,
                catLineContext = catLinePath._context,
                catTickContext = catTickPath._context,
                valueLineColor = valueLineContext.strokeStyle,
                valueTickColor = valueTickContext.strokeStyle,
                catLineColor = catLineContext.strokeStyle,
                catTickColor = catTickContext.strokeStyle;

            lineOpacity = Y.Lang.isNumber(lineOpacity) ? lineOpacity : 1;
            tickOpacity = Y.Lang.isNumber(tickOpacity) ? tickOpacity : 1;
           
            //Test values line color and alpha 
            if(valueLineColor.indexOf("RGBA") > -1 || valueLineColor.indexOf("rgba") > -1)
            {
                valueLineColor = valueLineColor.toLowerCase();
                valueLineColor = valueLineColor.replace(/, /g, ",");
                if(valueLineColor != toRGBA(toHex(lineColor), lineOpacity))
                {
                    return false;
                }
            }
            else
            {
                if(toHex(valueLineColor) != lineColor)
                {
                    return false;
                }
            }

            //Test values ticks color and alpha 
            if(valueTickColor.indexOf("RGBA") > -1 || valueTickColor.indexOf("rgba") > -1)
            {
                valueTickColor = valueTickColor.toLowerCase();
                valueTickColor = valueTickColor.replace(/, /g, ",");
                if(valueTickColor != toRGBA(toHex(tickColor), tickOpacity))
                {
                    return false;
                }
            }
            else
            {
                if(toHex(valueTickColor) != tickColor)
                {
                    return false;
                }
            }
            
            
            //Test category line color and alpha 
            if(catLineColor.indexOf("RGBA") > -1 || catLineColor.indexOf("rgba") > -1)
            {
                catLineColor = catLineColor.toLowerCase();
                catLineColor = catLineColor.replace(/, /g, ",");
                if(catLineColor != toRGBA(toHex(lineColor), lineOpacity))
                {
                    return false;
                }
            }
            else
            {
                if(toHex(catLineColor) != lineColor)
                {
                    return false;
                }
            }

            //Test category ticks color and alpha 
            if(catTickColor.indexOf("RGBA") > -1 || catTickColor.indexOf("rgba") > -1)
            {
                catTickColor = catTickColor.toLowerCase();
                catTickColor = catTickColor.replace(/, /g, ",");
                if(catTickColor != toRGBA(toHex(tickColor), tickOpacity))
                {
                    return false;
                }
            }
            else
            {
                if(toHex(catTickColor) != tickColor)
                {
                    return false;
                }
            }
            return lineWeight == valueLineContext.lineWidth &&
                    lineWeight == catLineContext.lineWidth &&
                    tickWeight == valueTickContext.lineWidth &&
                    tickWeight == catTickContext.lineWidth;

    };

    if(DOCUMENT && DOCUMENT.implementation.hasFeature("http://www.w3.org/TR/SVG11/feature#BasicStructure", "1.1"))
    {
        ENGINE = "SVG";
    }
    else if(canvas && canvas.getContext && canvas.getContext("2d"))
    {
        ENGINE = "Canvas";
    }
    

    AxisTestTemplate = function(cfg, globalCfg)
    {
        var i;
        AxisTestTemplate.superclass.constructor.apply(this);
        cfg.width = cfg.width || 400;
        cfg.height = cfg.height || 300;
        this.attrCfg = cfg;
        for(i in globalCfg)
        {
            if(globalCfg.hasOwnProperty(i))
            {
                this[i] = globalCfg[i];
            }
        }
    };

    Y.extend(AxisTestTemplate, Y.Test.Case, {
        setUp: function() {
            this.chart = new Y.Chart(this.attrCfg);
        },
        
        tearDown: function() {
            this.eventListener.detach();
            this.chart.destroy();
        }
    });

    var AxisMinTestTemplate = function()
    {
        AxisMinTestTemplate.superclass.constructor.apply(this, arguments);
    };
    
    Y.extend(AxisMinTestTemplate, AxisTestTemplate, {
        //Tests a NumericAxis minimum by applying the labelFunction of the axis to the set minimum value to the innerHTML of the first label.
        //Tests a NumericAxis maximum (unset) by checking to ensure the last label has a numeric value greater than or equal to the largest value in the data set.
        testMin: function()
        {
            var chart = this.chart,
                setMin = this.setMin,
                dataMax = this.dataMax;
            this.eventListener = this.chart.on("chartRendered", function(e) {
                var axis = chart.getAxisByKey("values"),
                    majorUnit = axis.get("styles").majorUnit,
                    count = majorUnit.count - 1,
                    labels = axis.get("labels"),
                    min = parseFloat(labels[0].innerHTML),
                    max = labels[count].innerHTML,
                    roundingMethod = axis.get("roundingMethod"),
                    setIntervals = Y.Lang.isNumber(roundingMethod);
                Y.assert(min == axis.get("labelFunction").apply(axis, [setMin, axis.get("labelFormat")]));
                if(setIntervals)
                {
                    Y.assert((max - min) % roundingMethod === 0);
                }
                //if the roundingMethod is numeric the axis cannot guarantee that the maximum will be greater than the data maximum
                if(!setIntervals || (count * roundingMethod) >= dataMax - setMin)
                {
                    Y.assert(max >= dataMax); 
                }
            });
            this.chart.render("#mychart");
        }
    });

    Y.AxisMinTestTemplate = AxisMinTestTemplate;

    var AxisMaxTestTemplate = function()
    {
        AxisMaxTestTemplate.superclass.constructor.apply(this, arguments);
    };

    Y.extend(AxisMaxTestTemplate, AxisTestTemplate, {
        //Tests a NumericAxis minimum and maximum by applying the labelFunction of the axis to the set minimum and maximum values and
        //then comparing the innerHTML of the first and last labels
        testMax: function()
        {
            var chart = this.chart,
                setMax = this.setMax,
                dataMin = this.dataMin;
            this.eventListener = this.chart.on("chartRendered", function(e) {
                var axis = chart.getAxisByKey("values"),
                    majorUnit = axis.get("styles").majorUnit,
                    count = majorUnit.count - 1,
                    labels = axis.get("labels"),
                    min = parseFloat(labels[0].innerHTML),
                    max = labels[count].innerHTML,
                    roundingMethod = axis.get("roundingMethod"),
                    setIntervals = Y.Lang.isNumber(roundingMethod);
                Y.assert(max == axis.get("labelFunction").apply(axis, [setMax, axis.get("labelFormat")])); 
                if(setIntervals)
                {
                    Y.assert((max - min) % roundingMethod === 0);
                }
                //if the roundingMethod is numeric the axis cannot guarantee that the minimum will be less than the data minimum
                if(!setIntervals || (count * roundingMethod) >= setMax - dataMin)
                {
                    Y.assert(min <= dataMin); 
                }
            });
            this.chart.render("#mychart");
        }
    });

    Y.AxisMaxTestTemplate = AxisMaxTestTemplate;

    var AxisMinAndMaxTestTemplate = function()
    {
        AxisMinAndMaxTestTemplate.superclass.constructor.apply(this, arguments);
    };
    
    Y.extend(AxisMinAndMaxTestTemplate, AxisTestTemplate, {
        testMinAndMax: function()
        {
            var chart = this.chart,
                setMax = this.setMax,
                setMin = this.setMin;
            this.eventListener = this.chart.on("chartRendered", function(e) {
                var axis = chart.getAxisByKey("values"),
                    majorUnit = axis.get("styles").majorUnit,
                    count = majorUnit.count - 1,
                    labels = axis.get("labels");
                Y.assert(labels[0].innerHTML == axis.get("labelFunction").apply(axis, [setMin, axis.get("labelFormat")]));
                Y.assert(labels[count].innerHTML == axis.get("labelFunction").apply(axis, [setMax, axis.get("labelFormat")])); 
            });
            this.chart.render("#mychart");
        }
    });

    Y.AxisMinAndMaxTestTemplate = AxisMinAndMaxTestTemplate;
    
    function AxisDataProviderTemplate()
    {
        AxisDataProviderTemplate.superclass.constructor.apply(this, arguments);
    };

    Y.extend(AxisDataProviderTemplate, AxisTestTemplate, {
        testAxesMinAndMax: function()
        {
            var chart = this.chart,
                maxValues = this.maxValues,
                minValues = this.minValues;
            this.eventListener = this.chart.on("chartRendered", function(e) {
                var axes = chart.get("axes"),
                    catKey = chart.get("categoryKey"),
                    axis,
                    dataMin,
                    dataMax,
                    key,
                    seriesKey,
                    keys,
                    len,
                    seriesKey;
                for(key in axes)
                {
                    if(axes.hasOwnProperty(key) && key != catKey)
                    {
                        axis = axes[key];
                        keys = axis.get("keys");
                        for(seriesKey in keys)
                        {
                            if(keys.hasOwnProperty(seriesKey))
                            {
                                maxValue = maxValues[seriesKey];
                                minValue = minValues[seriesKey];
                                Y.assert(axis.get("maximum") >= maxValue);
                                Y.assert(axis.get("minimum") <= minValue);
                            }

                        }
                    }
                }
            });
            this.chart.render("#mychart");
        }
    });

    Y.AxisDataProviderTemplate = AxisDataProviderTemplate;

    function AxisGraphicStylesTemplate()
    {
        AxisGraphicStylesTemplate.superclass.constructor.apply(this, arguments);
        switch(ENGINE)
        {
            case "SVG" :
                this._testNodes = TestSVGNodes;
            break;
            case "Canvas" : 
                this._testNodes = TestCanvasNodes;
            break;
            case "VML" :
                this._testNodes = TestVMLNodes;
            break;
        }
    };

    Y.extend(AxisGraphicStylesTemplate, AxisTestTemplate, {
        testGraphicStyles: function()
        {
            var chart = this.chart,
                lineStyles = this.lineStyles,
                tickStyles = this.tickStyles,
                testNodes = this._testNodes;
            this.eventListener = this.chart.on("chartRendered", function(e) {
                var valueAxis = chart.getAxisByKey("values"),
                    catAxis = chart.getAxisByKey("category"),
                    valueLinePath = valueAxis.get("path"),
                    valueTickPath = valueAxis.get("tickPath"),
                    catLinePath = catAxis.get("path"),
                    catTickPath = catAxis.get("tickPath");
                    Y.Assert.isTrue(testNodes.apply(this, [lineStyles, 
                                                            tickStyles, 
                                                            valueLinePath, 
                                                            valueTickPath, 
                                                            catLinePath, 
                                                            catTickPath
                                                        ]
                                                   ));
            });
            this.chart.render("#mychart");
        }
    
    });
    
    Y.AxisGraphicStylesTemplate = AxisGraphicStylesTemplate;

    var suite = new Y.Test.Suite("Y.Charts"),
    
    ChartTests = new Y.Test.Case({
        name: "Chart Tests",

        setUp: function() {
            var myDataValues = [ 
                {category:"5/1/2010", values:2000, expenses:3700, revenue:2200}, 
                {category:"5/2/2010", values:50, expenses:9100, revenue:100}, 
                {category:"5/3/2010", values:400, expenses:1100, revenue:1500}, 
                {category:"5/4/2010", values:200, expenses:1900, revenue:2800}, 
                {category:"5/5/2010", values:5000, expenses:5000, revenue:2650}
            ];
            var mychart = new Y.Chart({width:400, height:300, dataProvider:myDataValues});
            mychart.render("#mychart");
            this.chart = mychart;
        },

        tearDown: function() {
            this.chart.destroy();
        },

        //Test to ensure that all items in the series collection are of the correct type.
        testGetSeriesByIndex: function()
        {
            var series = this.chart.getSeries(0),
                assert = Y.Assert;
                assert.isInstanceOf(Y.CartesianSeries, series);
        },
        
        //Test to ensure that all items in the series collection are of the correct type.
        testGetSeriesByKey: function()
        {
            var series = this.chart.getSeries("revenue"),
                assert = Y.Assert;
                assert.isInstanceOf(Y.CartesianSeries, series);
        },
        
        //Test to ensure the series axes are numeric and the category axis is of type category
        testGetAxesByKey: function()
        {
            var category = this.chart.getAxisByKey("category"),
                values = this.chart.getAxisByKey("values"),
                assert = Y.Assert;
            assert.isInstanceOf(Y.CategoryAxis, category);
            assert.isInstanceOf(Y.NumericAxis, values);
        },

        //Test to ensure that getCategoryAxis returns a category axis
        testGetCategoryAxis: function()
        {
            var category = this.chart.get("categoryAxis"),
                assert = Y.Assert;
            assert.isInstanceOf(Y.CategoryAxis, category);
        },
        
        //Test that the graph attribute is of type Graph
        testGetGraph: function()
        {
            Y.Assert.isInstanceOf(Y.Graph, this.chart.get("graph"));
        },
        
        //Test to ensure that the axes hash contains AxisRenderer instances
        testGetAxes: function()
        {
            var assert = Y.Assert,
                axes = this.chart.get("axes"),
                i;
            for(i in axes)
            {
                if(axes.hasOwnProperty(i))
                {
                    assert.isInstanceOf(Y.Axis, axes[i]);
                }
            }
        },

        //Test to ensure that default series keys are correct
        testGetSeriesKeys: function()
        {
            var assert = Y.Assert,
                YArray = Y.Array,
                selectedIndex,
                testKeys = ['values', 'expenses', 'revenue'],
                newArray = [],
                actualKeys = this.chart.get("seriesKeys"),
                i = 0,
                len = testKeys.length;
            assert.areEqual(actualKeys.length, testKeys.length, "Actual seriesKeys array is not the correct length.");
            for(; i < len; ++i)
            {
                selectedIndex = YArray.indexOf(actualKeys, testKeys[i]);
                assert.isNotNull(selectedIndex + 1, "The seriesKeys array should contain the following key: " + testKeys[i] + ".");
                if(selectedIndex > -1)
                {
                    newArray.push(actualKeys[selectedIndex]);
                }
                else
                {
                    throw new Error("The actual seriesKeys array should but does not contain " + testKeys[i] + ".");
                }
            }
            assert.areEqual(newArray.length, actualKeys.length, "The seriesKeys array has more keys than it should.");
        },

        //Test to ensure default attributes are correct
        testGetDefaultAttributes: function()
        {
            var assert = Y.Assert,
                attrs = {
                    direction: "horizontal",
                    type: "combo",
                    valueAxisName: "values",
                    categoryAxisName: "category",
                    categoryKey: "category"
                },
                chart = this.chart,
                i;
            for(i in attrs)
            {
                if(attrs.hasOwnProperty(i))
                {
                    assert.areEqual(chart.get(i), attrs[i], "The attribute " + i + " should equal " + attrs[i] + ".");
                }
            }

        }
    });
    
    var GraphTests = new Y.Test.Case({
        name: "Graph Tests",
        
        setUp: function() {
            var myDataValues = [ 
                {category:"5/1/2010", values:2000, expenses:3700, revenue:2200}, 
                {category:"5/2/2010", values:50, expenses:9100, revenue:100}, 
                {category:"5/3/2010", values:400, expenses:1100, revenue:1500}, 
                {category:"5/4/2010", values:200, expenses:1900, revenue:2800}, 
                {category:"5/5/2010", values:5000, expenses:5000, revenue:2650}
            ];
            var mychart = new Y.Chart({width:400, height:300, dataProvider:myDataValues, seriesKeys:["values", "revenue"]});
            mychart.render("#mychart");
            this.chart = mychart;
        },
        
        tearDown: function() {
            this.chart.destroy();
        },

        "test:graph._getSeries(line)": function()
        {
            var graph = this.chart.get("graph"),
                series = graph._getSeries("line");
            Y.Assert.areEqual(series, Y.LineSeries, "The series type should be Y.LineSeries");
        },
        
        "test:graph._getSeries(column)": function()
        {
            var graph = this.chart.get("graph"),
                series = graph._getSeries("column");
            Y.Assert.areEqual(series, Y.ColumnSeries, "The series type should be Y.ColumnSeries");
        },
        
        "test:graph._getSeries(bar)": function()
        {
            var graph = this.chart.get("graph"),
                series = graph._getSeries("bar");
            Y.Assert.areEqual(series, Y.BarSeries, "The series type should be Y.BarSeries");
        },
        
        "test:graph._getSeries(area)": function()
        {
            var graph = this.chart.get("graph"),
                series = graph._getSeries("area");
            Y.Assert.areEqual(series, Y.AreaSeries, "The series type should be Y.AreaSeries");
        },
        
        "test:graph._getSeries(stackedarea)": function()
        {
            var graph = this.chart.get("graph"),
                series = graph._getSeries("stackedarea");
            Y.Assert.areEqual(series, Y.StackedAreaSeries, "The series type should be Y.StackedAreaSeries");
        },
        
        "test:graph._getSeries(stackedcolumn)": function()
        {
            var graph = this.chart.get("graph"),
                series = graph._getSeries("stackedcolumn");
            Y.Assert.areEqual(series, Y.StackedColumnSeries, "The series type should be Y.StackedColumnSeries");
        },
        
        "test:graph._getSeries(stackedbar)": function()
        {
            var graph = this.chart.get("graph"),
                series = graph._getSeries("stackedbar");
            Y.Assert.areEqual(series, Y.StackedBarSeries, "The series type should be Y.StackedBarSeries");
        },
        
        "test:graph._getSeries(stackedline)": function()
        {
            var graph = this.chart.get("graph"),
                series = graph._getSeries("stackedline");
            Y.Assert.areEqual(series, Y.StackedLineSeries, "The series type should be Y.StackedLineSeries");
        },
        
        "test:graph._getSeries(markerseries)": function()
        {
            var graph = this.chart.get("graph"),
                series = graph._getSeries("markerseries");
            Y.Assert.areEqual(series, Y.MarkerSeries, "The series type should be Y.MarkerSeries");
        },
        
        "test:graph._getSeries(stackedmarkerseries)": function()
        {
            var graph = this.chart.get("graph"),
                series = graph._getSeries("stackedmarkerseries");
            Y.Assert.areEqual(series, Y.StackedMarkerSeries, "The series type should be Y.StackedMarkerSeries");
        },
        
        "test:graph._getSeries(spline)": function()
        {
            var graph = this.chart.get("graph"),
                series = graph._getSeries("spline");
            Y.Assert.areEqual(series, Y.SplineSeries, "The series type should be Y.SplineSeries");
        },
        
        "test:graph._getSeries(areaspline)": function()
        {
            var graph = this.chart.get("graph"),
                series = graph._getSeries("areaspline");
            Y.Assert.areEqual(series, Y.AreaSplineSeries, "The series type should be Y.AreaSplineSeries");
        },
        
        "test:graph._getSeries(stackedspline)": function()
        {
            var graph = this.chart.get("graph"),
                series = graph._getSeries("stackedspline");
            Y.Assert.areEqual(series, Y.StackedSplineSeries, "The series type should be Y.StackedSplineSeries");
        },
        
        "test:graph._getSeries(stackedareapline)": function()
        {
            var graph = this.chart.get("graph"),
                series = graph._getSeries("stackedareaspline");
            Y.Assert.areEqual(series, Y.StackedAreaSplineSeries, "The series type should be Y.StackedAreaSplineSeries");
        },
        
        "test:graph._getSeries(pie)": function()
        {
            var graph = this.chart.get("graph"),
                series = graph._getSeries("pie");
            Y.Assert.areEqual(series, Y.PieSeries, "The series type should be Y.PieSeries");
        },
        
        "test:graph._getSeries(combo)": function()
        {
            var graph = this.chart.get("graph"),
                series = graph._getSeries("combo");
            Y.Assert.areEqual(series, Y.ComboSeries, "The series type should be Y.ComboSeries");
        },
        
        "test:graph._getSeries(stackedcombo)": function()
        {
            var graph = this.chart.get("graph"),
                series = graph._getSeries("stackedcombo");
            Y.Assert.areEqual(series, Y.StackedComboSeries, "The series type should be Y.StackedComboSeries");
        },
        "test:graph._getSeries(combospline)": function()
        {
            var graph = this.chart.get("graph"),
                series = graph._getSeries("combospline");
            Y.Assert.areEqual(series, Y.ComboSplineSeries, "The series type should be Y.ComboSplineSeries");
        },
        
        "test:graph._getSeries(stackedcombospline)": function()
        {
            var graph = this.chart.get("graph"),
                series = graph._getSeries("stackedcombospline");
            Y.Assert.areEqual(series, Y.StackedComboSplineSeries, "The series type should be Y.StackedComboSplineSeries");
        },

        "test:graph._getSeries(customclass)" : function()
        {
            var graph = this.chart.get("graph"),
                series;

            Y.CustomLineSeries = Y.Base.create("customLineSeries", Y.LineSeries, [], {
                mycustomprop: null,

                mycustommethod: function()
                {
                    var yaypie = "mmmm";
                    yaypie += "Pie";
                }
            });

            series = graph._getSeries(Y.CustomLineSeries);
            Y.Assert.areEqual(series, Y.CustomLineSeries, "The series type should be Y.CustomLineSeries");
        }
    }),
    
    AxesTests = new Y.Test.Case({
        name: "Axes Tests",
        
        setUp: function() {
            var myDataValues = [ 
                {category:"5/1/2010", values:2000, expenses:3700, revenue:2200}, 
                {category:"5/2/2010", values:50, expenses:9100, revenue:100}, 
                {category:"5/3/2010", values:400, expenses:1100, revenue:1500}, 
                {category:"5/4/2010", values:200, expenses:1900, revenue:2800}, 
                {category:"5/5/2010", values:5000, expenses:5000, revenue:2650}
            ];
            var mychart = new Y.Chart({width:400, height:300, dataProvider:myDataValues, seriesKeys:["values", "revenue"]});
            mychart.render("#mychart");
            this.chart = mychart;
        },

        tearDown: function() {
            this.chart.destroy();
        },

        //Test axes data classes
        testRemoveKey: function()
        {
            var assert = Y.Assert,
                xAxis = this.chart.getCategoryAxis(),
                yAxis = this.chart.getAxisByKey("values"),
                keys,
                l,
                i;
            this.xHandle = xAxis.on("dataUpdate", Y.bind(function(e) {
                l = xAxis.get("keyCollection").length || 0;
                assert.areEqual(0, 0, "The value should be zero");
            }, this));
            this.yHandle = yAxis.on("dataUpdate", Y.bind(function(e) {
                keys = yAxis.get("keyCollection");
                assert.areEqual(1, keys.length, "The length should be 1");
                assert.areEqual(Y.Array.indexOf(keys, "revenue"), -1, "The key revenue should be removed");
            }));
            xAxis.removeKey("category");
            yAxis.removeKey("revenue");
            this.xHandle.detach();
            this.yHandle.detach();
        },
        
        testAddKey: function()
        {       
            var assert = Y.Assert,
                yAxis = this.chart.getAxisByKey("values"),
                keys,
                pattern = [3700, 9100, 1100, 1900],
                testarray,
                i = 0;
                l = 4;
            this.yHandle = yAxis.on("dataUpdate", Y.bind(function(e) {
                keys = yAxis.get("keyCollection");
                testarray = yAxis.getDataByKey("expenses");
                assert.areEqual(3, keys.length);
                assert.areEqual(Y.Array.indexOf(keys, "expenses"), 2);
                for(; i < l; ++i)
                {
                    assert.areEqual(pattern[i], testarray[i]);
                }
            }, this));
            yAxis.addKey("expenses");
            this.yHandle.detach();
        }
    }), 

    AxisAlwaysShowZero = new Y.Test.Case({
        name: "Axis alwaysShowZero Test",
        
        setUp: function() 
        {
            var myDataValues = [ 
                {category:"5/1/2010", values:2000, expenses:3700, revenue:2200}, 
                {category:"5/2/2010", values:50, expenses:9100, revenue:-100}, 
                {category:"5/3/2010", values:-400, expenses:-1100, revenue:1500}, 
                {category:"5/4/2010", values:200, expenses:1900, revenue:-2800}, 
                {category:"5/5/2010", values:5000, expenses:-5000, revenue:2650}
            ];
            this.chart = new Y.Chart({
                width:400, 
                height:300, 
                dataProvider:myDataValues
            });
        },

        tearDown: function() {
            this.eventListener.detach();
            this.chart.destroy();
        },

        testAlwaysShowZero: function()
        {
            var chart = this.chart;
            this.eventListener = this.chart.on("chartRendered", function(e) {
                var i = 0,
                    yAxis = chart.getAxisByKey("values"),
                    majorUnit = yAxis.get("styles").majorUnit,
                    count = majorUnit.count,
                    labels = yAxis.get("labels"),
                    label;
                for(; i < count; ++i)
                {
                    label = parseFloat(labels[i].innerHTML);
                    if(label === 0)
                    {
                        break;
                    }
                }
                Y.assert(label === 0);
            });
            this.chart.render("#mychart");
        }
    }),
    
    AxisAlwaysShowZeroFalse = new Y.Test.Case({
        name: "Axis alwaysShowZero = false Test",
        
        setUp: function() 
        {
            var myDataValues = [ 
                {category:"5/1/2010", values:2000, expenses:3700, revenue:2200}, 
                {category:"5/2/2010", values:50, expenses:9100, revenue:-100}, 
                {category:"5/3/2010", values:-400, expenses:-1100, revenue:1500}, 
                {category:"5/4/2010", values:200, expenses:1900, revenue:-2800}, 
                {category:"5/5/2010", values:5000, expenses:-5000, revenue:2650}
            ];
            this.chart = new Y.Chart({
                width:400, 
                height:300, 
                axes: {
                    values: {
                        alwaysShowZero: false
                    }
                },
                dataProvider:myDataValues
            });
        },

        tearDown: function() {
            this.eventListener.detach();
            this.chart.destroy();
        },
        
        testAlwaysShowZeroEqualsFalse: function()
        {
            var chart = this.chart;
            this.eventListener = this.chart.on("chartRendered", function(e) {
                var i = 0,
                    yAxis = chart.getAxisByKey("values"),
                    majorUnit = yAxis.get("styles").majorUnit,
                    count = majorUnit.count,
                    labels = yAxis.get("labels"),
                    label;
                for(; i < count; ++i)
                {
                    label = parseFloat(labels[i].innerHTML);
                    if(label === 0)
                    {
                        break;
                    }
                }
                Y.assert(label !== 0);
            });
            this.chart.render("#mychart");
        }
    }),
    
    //test to ensure that pie charts are drawn from center
    //pie charts need to have the same width/height
    PieCenterTest = new Y.Test.Case({
        name: "PieChartCenterTest",
        setUp: function() {
            var myDataValues = [ 
                {day:"Monday", taxes:2000}, 
                {day:"Tuesday", taxes:50}, 
                {day:"Wednesday", taxes:4000}, 
                {day:"Thursday", taxes:200}, 
                {day:"Friday", taxes:2000}
            ];
            var mychart = new Y.Chart({type: "pie", width:400, height:400, dataProvider:myDataValues});
            mychart.render("#mychart");
            this.chart = mychart;
        },

        tearDown: function() {
            this.chart.destroy();
        },

        testWidthAndHeightEqual: function()
        {
            var graphic = this.chart.get("graph").get("graphic"),
                shapes = graphic.get("shapes"),
                i,
                shape;
            for(i in shapes)
            {
                if(shapes.hasOwnProperty(i))
                {
                    shape = shapes[i];
                    Y.assert(shape.get("width") === shape.get("height"));
                }
            }
        },

        testWidthGreaterThanHeight: function()
        {
            var graphic = this.chart.get("graph").get("graphic"),
                shapes,
                i,
                shape;
            this.chart.set("width", 500);
            shapes = graphic.get("shapes");
            for(i in shapes)
            {
                if(shapes.hasOwnProperty(i))
                {
                    shape = shapes[i];
                    Y.assert(shape.get("width") === shape.get("height"));
                }
            }
        },

        testHeightGreaterThanWidth: function()
        {
            var graphic = this.chart.get("graph").get("graphic"),
                shapes,
                i,
                shape;
            this.chart.set("height", 600);
            shapes = graphic.get("shapes");
            for(i in shapes)
            {
                if(shapes.hasOwnProperty(i))
                {
                    shape = shapes[i];
                    Y.assert(shape.get("width") === shape.get("height"));
                }
            }
        }
    }),

    allPositiveDataProvider =  [ 
        {category:"5/1/2010", values:2000, expenses:3700, revenue:2200}, 
        {category:"5/2/2010", values:50, expenses:9100, revenue:100}, 
        {category:"5/3/2010", values:400, expenses:1100, revenue:1500}, 
        {category:"5/4/2010", values:200, expenses:1900, revenue:2800}, 
        {category:"5/5/2010", values:5000, expenses:5000, revenue:2650}
    ],

    allPositiveDataProviderDataMax = 9100,

    allPositiveDataProviderDataMin = 50,

    positiveAndNegativeDataProvider = [ 
        {category:"5/1/2010", values:2000, expenses:3700, revenue:2200}, 
        {category:"5/2/2010", values:50, expenses:9100, revenue:-100}, 
        {category:"5/3/2010", values:-400, expenses:-1100, revenue:1500}, 
        {category:"5/4/2010", values:200, expenses:1900, revenue:-2800}, 
        {category:"5/5/2010", values:5000, expenses:-5000, revenue:2650}
    ],

    positiveAndNegativeDataProviderDataMax = 9100,

    positiveAndNegativeDataProviderDataMin = -5000,

    allNegativeDataProvider = [ 
        {category:"5/1/2010", values:-2000, expenses:-3700, revenue:-2200}, 
        {category:"5/2/2010", values:-50, expenses:-9100, revenue:-100}, 
        {category:"5/3/2010", values:-400, expenses:-1100, revenue:-1500}, 
        {category:"5/4/2010", values:-200, expenses:-1900, revenue:-2800}, 
        {category:"5/5/2010", values:-5000, expenses:-5000, revenue:-2650}
    ],

    allNegativeDataProviderDataMax = -50,

    allNegativeDataProviderDataMin = -9100,

    decimalDataProvider = [ 
        {category:"5/1/2010", values:2.45, expenses:3.71, revenue:2.2}, 
        {category:"5/2/2010", values:0.5, expenses:9.1, revenue:0.16}, 
        {category:"5/3/2010", values:1.4, expenses:1.14, revenue:1.25}, 
        {category:"5/4/2010", values:0.05, expenses:1.9, revenue:2.8}, 
        {category:"5/5/2010", values:5.53, expenses:5.21, revenue:2.65}
    ],

    decimalDataProviderDataMax = 9.1,

    decimalDataProviderDataMin = 0.05,
    
    missingDataSmallDataProvider = [
        {date: "1/1/2010", expenses: 3700},
        {date: "1/2/2010", revenue: 2200},
        {date: "2/1/2010", expenses: 9100},
        {date: "2/2/2010", revenue: 100}
    ],

    missingDataLargeDataProvider = [
        {date: "1/1/2010", expenses: 3700},
        {date: "1/2/2010", revenue: 2200},
        {date: "1/3/2010", expenses: 3000},
        {date: "1/4/2010", revenue: 400},
        {date: "2/1/2010", expenses: 9100},
        {date: "2/2/2010", revenue: 100},
        {date: "2/3/2010", expenses: 3300},
        {date: "2/4/2010", revenue: 1500}
    ],
    
    AxisMinTest = new Y.AxisMinTestTemplate({
        axes: {
            values: {
                minimum: 7
            }
        },
        dataProvider: allPositiveDataProvider    
    },
    {
        name: "Axes Min Test",
        setMin: 7,
        dataMax: allPositiveDataProviderDataMax
    }),

    //Tests setting a NumericAxis minimum with alwaysShowZero as false
    AxisMinAlwaysShowZeroFalseTest = new Y.AxisMinTestTemplate({
        axes: {
            values: {
                minimum: 7,
                alwaysShowZero: false
            }
        },
        dataProvider: allPositiveDataProvider    
    },
    {
        name: "Axes Min Test",
        setMin: 7,
        dataMax: allPositiveDataProviderDataMax
    }),
 
    //Tests setting a NumericAxis' minimum to a negative value
    AxisNegativeMinTest = new Y.AxisMinTestTemplate({
        axes: {
            values: {
                minimum: -1721
            }
        },
        dataProvider: positiveAndNegativeDataProvider
    },
    {    
        name: "Axes Negative Min Test",
        setMin: -1721,
        dataMax: positiveAndNegativeDataProviderDataMax
    }),

    //Tests setting a NumericAxis' minimum to a negative values with all negative values in it's dataProvider
    AxisNegativeMinWithAllNegativeDataTest = new Y.AxisMinTestTemplate({
        axes: {
            values: {
                minimum: -1721
            }
        },
        dataProvider: allNegativeDataProvider
    },
    {
        name: "Axes Negative Min with All Negative Data Test",
        setMin: -1721,
        dataMax: allNegativeDataProviderDataMax 
    }),

    //Tests setting a NumericAxis' minimum to a value with decimals
    AxisMinWithDecimalsTest = new Y.AxisMinTestTemplate({
        axes: {
            values: {
                minimum: 1.5
            }
        },
        dataProvider: decimalDataProvider
    },
    {
        name: "Axes Min with Decimals Test",
        dataMax: decimalDataProviderDataMax,
        setMin: 1.5
    }),

    //Tests setting a NumericAxis' minimum to an integer value with a data set that contains decimal values
    AxisMinIntegerDecimalDataTest = new Y.AxisMinTestTemplate({
        axes: {
            values: {
                minimum: 1
            }
        },
        dataProvider: decimalDataProvider
    },
    {
        name: "Axes Integer Min with Decimal Data Test",
        dataMax: decimalDataProviderDataMax,
        setMin: 1
    }),
    
    //Tests setting a NumericAxis' minimum to a negative value with a data set of all positive values
    AxisNegativeMinPositiveDataTest =  new Y.AxisMinTestTemplate({
        axes: {
            values: {
                minimum: -100
            }
        },
        dataProvider: allPositiveDataProvider    
    },
    {
        name: "Axes Negative Min with Positive Data Test",
        setMin: -100,
        dataMax: allPositiveDataProviderDataMax
    }),

    AxisMaxTest = new Y.AxisMaxTestTemplate({
        axes: {
            values: {
                maximum: 1492
            }
        },
        dataProvider: allPositiveDataProvider    
    },
    {
        name: "Axes Max Test",
        setMax: 1492,
        dataMin: allPositiveDataProviderDataMin
    }),
    
    //tests negative maximum value 
    AxisNegativeMaxTest = new Y.AxisMaxTestTemplate({
        axes: {
            values: {
                maximum: -500
            }
        },
        dataProvider: allNegativeDataProvider
    },
    {    
        name: "Axes Negative Max Test",
        setMax: -500,
        dataMin: allNegativeDataProviderDataMin
    }),
    
    AxisMaxWithDecimalsTest = new Y.AxisMaxTestTemplate({
        axes: {
            values: {
                maximum: 7.5
            }
        },
        dataProvider: decimalDataProvider
    },
    {
        name: "Axes Max with Decimals Test",
        dataMin: decimalDataProviderDataMin,
        setMax: 7.5
    }),
 
    AxisMaxIntegerDecimalDataTest= new Y.AxisMaxTestTemplate({
        axes: {
            values: {
                maximum: 8 
            }
        },
        dataProvider: decimalDataProvider
    },
    {
        name: "Axes Integer Max with Decimal Data Test",
        dataMin: decimalDataProviderDataMin,
        setMax: 8
    }),
    
    AxisMaxWithPositiveAndNegativeDataTest = new Y.AxisMaxTestTemplate({
        axes: {
            values: {
                maximum: 1492
            }
        },
        dataProvider: positiveAndNegativeDataProvider   
    },
    {
        name: "Axes Max Test",
        setMax: 1492,
        dataMin: positiveAndNegativeDataProviderDataMin
    }),
    
    AxisMinAndMaxTest = new Y.AxisMinAndMaxTestTemplate({
        axes: {
            values: {
                minimum: 10,
                maximum: 8000
            }
        },
        dataProvider: allPositiveDataProvider    
    },
    {
        name: "Axes Min and Max Test",
        setMin: 10,
        setMax: 8000
    }),

    AxisNegativeMinAndPositiveMaxTest = new Y.AxisMinAndMaxTestTemplate({
        axes: {
            values: {
                minimum: -500,
                maximum: 8000
            }
        },
        dataProvider: allPositiveDataProvider    
    },
    {
        name: "Axes Negative Min and Positive Max Test",
        setMin: -500,
        setMax: 8000
    }),

    AxisMinAndMaxWithDecimalsTest = new Y.AxisMinAndMaxTestTemplate({
        axes: {
            values: {
                maximum: 7.5,
                minimum: 2.5
            }
        },
        dataProvider: decimalDataProvider
    },
    {
        name: "Axes Min and Max with Decimals Test",
        setMin: 2.5,
        setMax: 7.5
    });
    
    AxisNegativeMinAndMaxTest = new Y.AxisMinAndMaxTestTemplate({
        axes: {
            values: {
                minimum: -5000,
                maximum: -500
            }
        },
        dataProvider: allNegativeDataProvider
    },
    {
        name: "Axes Negative Min an Max Test",
        setMin: -5000,
        setMax: -500
    }),

    AxisMinRoundingAutoTest = new Y.AxisMinTestTemplate({
        axes: {
            values: {
                minimum: 7,
                roundingMethod: "auto"
            }
        },
        dataProvider: allPositiveDataProvider    
    },
    {
        name: "Axes Min Test",
        setMin: 7,
        dataMax: allPositiveDataProviderDataMax
    }),

    //Tests setting a NumericAxis minimum with alwaysShowZero as false
    AxisMinAlwaysShowZeroFalseRoundingMethodAutoTest = new Y.AxisMinTestTemplate({
        axes: {
            values: {
                minimum: 7,
                roundingMethod: "auto",
                alwaysShowZero: false
            }
        },
        dataProvider: allPositiveDataProvider    
    },
    {
        name: "Axes Min Test with roundingMethod=auto",
        setMin: 7,
        dataMax: allPositiveDataProviderDataMax
    }),
 
    //Tests setting a NumericAxis' minimum to a negative value
    AxisNegativeMinRoundingMethodAutoTest = new Y.AxisMinTestTemplate({
        axes: {
            values: {
                minimum: -1721,
                roundingMethod: "auto"
            }
        },
        dataProvider: positiveAndNegativeDataProvider
    },
    {    
        name: "Axes Negative Min Test with roundingMethod=auto",
        setMin: -1721,
        dataMax: positiveAndNegativeDataProviderDataMax
    }),

    //Tests setting a NumericAxis' minimum to a negative values with all negative values in it's dataProvider
    AxisNegativeMinWithAllNegativeDataRoundingMethodAutoTest = new Y.AxisMinTestTemplate({
        axes: {
            values: {
                minimum: -1721,
                roundingMethod: "auto"
            }
        },
        dataProvider: allNegativeDataProvider
    },
    {
        name: "Axes Negative Min with All Negative Data Test with roundingMethod=auto",
        setMin: -1721,
        dataMax: allNegativeDataProviderDataMax 
    }),

    //Tests setting a NumericAxis' minimum to a value with decimals
    AxisMinWithDecimalsRoundingMethodAutoTest = new Y.AxisMinTestTemplate({
        axes: {
            values: {
                minimum: 1.5,
                roundingMethod: "auto"
            }
        },
        dataProvider: decimalDataProvider
    },
    {
        name: "Axes Min with Decimals Test with roundingMethod=auto",
        dataMax: decimalDataProviderDataMax,
        setMin: 1.5
    }),

    //Tests setting a NumericAxis' minimum to an integer value with a data set that contains decimal values
    AxisMinIntegerDecimalDataRoundingMethodAutoTest = new Y.AxisMinTestTemplate({
        axes: {
            values: {
                minimum: 1,
                roundingMethod: "auto"
            }
        },
        dataProvider: decimalDataProvider
    },
    {
        name: "Axes Integer Min with Decimal Data Test with roundingMethod=auto",
        dataMax: decimalDataProviderDataMax,
        setMin: 1
    }),
    
    //Tests setting a NumericAxis' minimum to a negative value with a data set of all positive values
    AxisNegativeMinPositiveDataRoundingMethodAutoTest =  new Y.AxisMinTestTemplate({
        axes: {
            values: {
                minimum: -100,
                roundingMethod: "auto"
            }
        },
        dataProvider: allPositiveDataProvider    
    },
    {
        name: "Axes Negative Min with Positive Data Test with roundingMethod=auto",
        setMin: -100,
        dataMax: allPositiveDataProviderDataMax
    }),
    
    AxisMinRoundingNullTest = new Y.AxisMinTestTemplate({
        axes: {
            values: {
                minimum: 7,
                roundingMethod: null
            }
        },
        dataProvider: allPositiveDataProvider    
    },
    {
        name: "Axes Min Test with roundingMethod=null",
        setMin: 7,
        dataMax: allPositiveDataProviderDataMax
    }),

    //Tests setting a NumericAxis minimum with alwaysShowZero as false
    AxisMinAlwaysShowZeroFalseRoundingMethodNullTest = new Y.AxisMinTestTemplate({
        axes: {
            values: {
                minimum: 7,
                roundingMethod: null,
                alwaysShowZero: false
            }
        },
        dataProvider: allPositiveDataProvider    
    },
    {
        name: "Axes Min Test with roundingMethod=null",
        setMin: 7,
        dataMax: allPositiveDataProviderDataMax
    }),
 
    //Tests setting a NumericAxis' minimum to a negative value
    AxisNegativeMinRoundingMethodNullTest = new Y.AxisMinTestTemplate({
        axes: {
            values: {
                minimum: -1721,
                roundingMethod: null
            }
        },
        dataProvider: positiveAndNegativeDataProvider
    },
    {    
        name: "Axes Negative Min Test with roundingMethod=null",
        setMin: -1721,
        dataMax: positiveAndNegativeDataProviderDataMax
    }),

    //Tests setting a NumericAxis' minimum to a negative values with all negative values in it's dataProvider
    AxisNegativeMinWithAllNegativeDataRoundingMethodNullTest = new Y.AxisMinTestTemplate({
        axes: {
            values: {
                minimum: -1721,
                roundingMethod: null
            }
        },
        dataProvider: allNegativeDataProvider
    },
    {
        name: "Axes Negative Min with All Negative Data Test with roundingMethod=null",
        setMin: -1721,
        dataMax: allNegativeDataProviderDataMax 
    }),

    //Tests setting a NumericAxis' minimum to a value with decimals
    AxisMinWithDecimalsRoundingMethodNullTest = new Y.AxisMinTestTemplate({
        axes: {
            values: {
                minimum: 1.5,
                roundingMethod: null
            }
        },
        dataProvider: decimalDataProvider
    },
    {
        name: "Axes Min with Decimals Test with roundingMethod=null",
        dataMax: decimalDataProviderDataMax,
        setMin: 1.5
    }),

    //Tests setting a NumericAxis' minimum to an integer value with a data set that contains decimal values
    AxisMinIntegerDecimalDataRoundingMethodNullTest = new Y.AxisMinTestTemplate({
        axes: {
            values: {
                minimum: 1,
                roundingMethod: null
            }
        },
        dataProvider: decimalDataProvider
    },
    {
        name: "Axes Integer Min with Decimal Data Test with roundingMethod=null",
        dataMax: decimalDataProviderDataMax,
        setMin: 1
    }),
    
    //Tests setting a NumericAxis' minimum to a negative value with a data set of all positive values
    AxisNegativeMinPositiveDataRoundingMethodNullTest =  new Y.AxisMinTestTemplate({
        axes: {
            values: {
                minimum: -100,
                roundingMethod: null
            }
        },
        dataProvider: allPositiveDataProvider    
    },
    {
        name: "Axes Negative Min with Positive Data Test with roundingMethod=null",
        setMin: -100,
        dataMax: allPositiveDataProviderDataMax
    }),
    
    AxisMinRoundingNumericTest = new Y.AxisMinTestTemplate({
        axes: {
            values: {
                minimum: 7,
                roundingMethod: 1000
            }
        },
        dataProvider: allPositiveDataProvider    
    },
    {
        name: "Axes Min Test with roundingMethod=1000",
        setMin: 7,
        dataMax: allPositiveDataProviderDataMax
    }),

    //Tests setting a NumericAxis minimum with alwaysShowZero as false
    AxisMinAlwaysShowZeroFalseRoundingMethodNumericTest = new Y.AxisMinTestTemplate({
        axes: {
            values: {
                minimum: 7,
                roundingMethod: 1000,
                alwaysShowZero: false
            }
        },
        dataProvider: allPositiveDataProvider    
    },
    {
        name: "Axes Min Test with roundingMethod=1000",
        setMin: 7,
        dataMax: allPositiveDataProviderDataMax
    }),
 
    //Tests setting a NumericAxis' minimum to a negative value
    AxisNegativeMinRoundingMethodNumericTest = new Y.AxisMinTestTemplate({
        axes: {
            values: {
                minimum: -1721,
                roundingMethod: 1000
            }
        },
        dataProvider: positiveAndNegativeDataProvider
    },
    {    
        name: "Axes Negative Min Test with roundingMethod=1000",
        setMin: -1721,
        dataMax: positiveAndNegativeDataProviderDataMax
    }),

    //Tests setting a NumericAxis' minimum to a negative values with all negative values in it's dataProvider
    AxisNegativeMinWithAllNegativeDataRoundingMethodNumericTest = new Y.AxisMinTestTemplate({
        axes: {
            values: {
                minimum: -1721,
                roundingMethod: 1000
            }
        },
        dataProvider: allNegativeDataProvider
    },
    {
        name: "Axes Negative Min with All Negative Data Test with roundingMethod=1000",
        setMin: -1721,
        dataMax: allNegativeDataProviderDataMax 
    }),

    //Tests setting a NumericAxis' minimum to a value with decimals
    AxisMinWithDecimalsRoundingMethodNumericTest = new Y.AxisMinTestTemplate({
        axes: {
            values: {
                minimum: 1.5,
                roundingMethod: 2
            }
        },
        dataProvider: decimalDataProvider
    },
    {
        name: "Axes Min with Decimals Test with roundingMethod=2",
        dataMax: decimalDataProviderDataMax,
        setMin: 1.5
    }),

    //Tests setting a NumericAxis' minimum to an integer value with a data set that contains decimal values
    AxisMinIntegerDecimalDataRoundingMethodNumericTest = new Y.AxisMinTestTemplate({
        axes: {
            values: {
                minimum: 1,
                roundingMethod: 2
            }
        },
        dataProvider: decimalDataProvider
    },
    {
        name: "Axes Integer Min with Decimal Data Test with roundingMethod=2",
        dataMax: decimalDataProviderDataMax,
        setMin: 1
    }),
    
    //Tests setting a NumericAxis' minimum to a negative value with a data set of all positive values
    AxisNegativeMinPositiveDataRoundingMethodNumericTest =  new Y.AxisMinTestTemplate({
        axes: {
            values: {
                minimum: -100,
                roundingMethod: 1000 
            }
        },
        dataProvider: allPositiveDataProvider    
    },
    {
        name: "Axes Negative Min with Positive Data Test with roundingMethod=1000",
        setMin: -100,
        dataMax: allPositiveDataProviderDataMax
    });
    
    AxisMaxRoundingMethodAutoTest = new Y.AxisMaxTestTemplate({
        axes: {
            values: {
                roundingMethod: "auto",
                maximum: 1492
            }
        },
        dataProvider: allPositiveDataProvider    
    },
    {
        name: "Axes Max Test with roundingMethod=auto",
        setMax: 1492,
        dataMin: allPositiveDataProviderDataMin
    }),
    
    //tests negative maximum value 
    AxisNegativeMaxRoundingMethodAutoTest = new Y.AxisMaxTestTemplate({
        axes: {
            values: {
                roundingMethod: "auto",
                maximum: -500
            }
        },
        dataProvider: allNegativeDataProvider
    },
    {    
        name: "Axes Negative Max Test with roundingMethod=auto",
        setMax: -500,
        dataMin: allNegativeDataProviderDataMin
    }),
    
    AxisMaxWithDecimalsRoundingMethodAutoTest = new Y.AxisMaxTestTemplate({
        axes: {
            values: {
                roundingMethod: "auto",
                maximum: 7.5
            }
        },
        dataProvider: decimalDataProvider
    },
    {
        name: "Axes Max with Decimals Test with roundingMethod=auto",
        dataMin: decimalDataProviderDataMin,
        setMax: 7.5
    }),
 
    AxisMaxIntegerDecimalDataRoundingMethodAutoTest= new Y.AxisMaxTestTemplate({
        axes: {
            values: {
                roundingMethod: "auto",
                maximum: 8 
            }
        },
        dataProvider: decimalDataProvider
    },
    {
        name: "Axes Integer Max with Decimal Data Test with roundingMethod=auto",
        dataMin: decimalDataProviderDataMin,
        setMax: 8
    }),

    AxisMaxWithPositiveAndNegativeDataRoundingMethodAutoTest = new Y.AxisMaxTestTemplate({
        axes: {
            values: {
                roundingMethod: "auto",
                maximum: 1492
            }
        },
        dataProvider: positiveAndNegativeDataProvider   
    },
    {
        name: "Axes Max Test with roundingMethod=auto",
        setMax: 1492,
        dataMin: positiveAndNegativeDataProviderDataMin
    }),
    
    AxisMaxRoundingMethodNullTest = new Y.AxisMaxTestTemplate({
        axes: {
            values: {
                roundingMethod: null,
                maximum: 1492
            }
        },
        dataProvider: allPositiveDataProvider    
    },
    {
        name: "Axes Max Test with roundingMethod=null",
        setMax: 1492,
        dataMin: allPositiveDataProviderDataMin
    }),
    
    //tests negative maximum value 
    AxisNegativeMaxRoundingMethodNullTest = new Y.AxisMaxTestTemplate({
        axes: {
            values: {
                roundingMethod: null,
                maximum: -500
            }
        },
        dataProvider: allNegativeDataProvider
    },
    {    
        name: "Axes Negative Max Test with roundingMethod=null",
        setMax: -500,
        dataMin: allNegativeDataProviderDataMin
    }),
    
    AxisMaxWithDecimalsRoundingMethodNullTest = new Y.AxisMaxTestTemplate({
        axes: {
            values: {
                roundingMethod: null,
                maximum: 7.5
            }
        },
        dataProvider: decimalDataProvider
    },
    {
        name: "Axes Max with Decimals Test with roundingMethod=null",
        dataMin: decimalDataProviderDataMin,
        setMax: 7.5
    }),
 
    AxisMaxIntegerDecimalDataRoundingMethodNullTest= new Y.AxisMaxTestTemplate({
        axes: {
            values: {
                roundingMethod: null,
                maximum: 8 
            }
        },
        dataProvider: decimalDataProvider
    },
    {
        name: "Axes Integer Max with Decimal Data Test with roundingMethod=null",
        dataMin: decimalDataProviderDataMin,
        setMax: 8
    }),

    AxisMaxWithPositiveAndNegativeDataRoundingMethodNullTest = new Y.AxisMaxTestTemplate({
        axes: {
            values: {
                roundingMethod: null,
                maximum: 1492
            }
        },
        dataProvider: positiveAndNegativeDataProvider   
    },
    {
        name: "Axes Max Test with roundingMethod=null",
        setMax: 1492,
        dataMin: positiveAndNegativeDataProviderDataMin
    }),
    
    AxisMaxRoundingMethodNumericTest = new Y.AxisMaxTestTemplate({
        axes: {
            values: {
                roundingMethod: 1000,
                maximum: 1492
            }
        },
        dataProvider: allPositiveDataProvider    
    },
    {
        name: "Axes Max Test with roundingMethod=1000",
        setMax: 1492,
        dataMin: allPositiveDataProviderDataMin
    }),
    
    //tests negative maximum value 
    AxisNegativeMaxRoundingMethodNumericTest = new Y.AxisMaxTestTemplate({
        axes: {
            values: {
                roundingMethod: 1000,
                maximum: -500
            }
        },
        dataProvider: allNegativeDataProvider
    },
    {    
        name: "Axes Negative Max Test with roundingMethod=1000",
        setMax: -500,
        dataMin: allNegativeDataProviderDataMin
    }),
    
    AxisMaxWithDecimalsRoundingMethodNumericTest = new Y.AxisMaxTestTemplate({
        axes: {
            values: {
                roundingMethod: 2,
                maximum: 7.5
            }
        },
        dataProvider: decimalDataProvider
    },
    {
        name: "Axes Max with Decimals Test with roundingMethod=2",
        dataMin: decimalDataProviderDataMin,
        setMax: 7.5
    }),
 
    AxisMaxIntegerDecimalDataRoundingMethodNumericTest= new Y.AxisMaxTestTemplate({
        axes: {
            values: {
                roundingMethod: 2,
                maximum: 8 
            }
        },
        dataProvider: decimalDataProvider
    },
    {
        name: "Axes Integer Max with Decimal Data Test with roundingMethod=2",
        dataMin: decimalDataProviderDataMin,
        setMax: 8
    }),

    AxisMaxWithPositiveAndNegativeDataRoundingMethodNumericTest = new Y.AxisMaxTestTemplate({
        axes: {
            values: {
                maximum: 1492,
                roundingMethod: 1000
            }
        },
        dataProvider: positiveAndNegativeDataProvider   
    },
    {
        name: "Axes Max with Positive and Negative Data Test with roundingMethod=1000",
        setMax: 1492,
        dataMin: positiveAndNegativeDataProviderDataMin
    }),

    DualAxesMissingDataSmallTest = new Y.AxisDataProviderTemplate({
        axes: {
            leftAxis: {
                keys: ["expenses"],
                type: "numeric",
                position: "left"
            },
            rightAxis: {
                keys: ["revenue"],
                type: "numeric",
                position: "right"
            }
        },
        categoryKey: "date",
        dataProvider: missingDataSmallDataProvider
    },
    {
        name: "Dual Axes Missing Data (small dataProvider) Test",
        maxValues: {
            expenses: 9100,
            revenue: 2200
        },
        minValues: {
            expenses: 3700,
            revenue: 100
        },
        seriesKeys: ["expenses", "revenue"]
    });
    
    DualAxesMissingDataLargeTest = new Y.AxisDataProviderTemplate({
        axes: {
            leftAxis: {
                keys: ["expenses"],
                type: "numeric",
                position: "left"
            },
            rightAxis: {
                keys: ["revenue"],
                type: "numeric",
                position: "right"
            }
        },
        categoryKey: "date",
        dataProvider: missingDataLargeDataProvider
    },
    {
        name: "Dual Axes Missing Data (large dataProvider) Test",
        maxValues: {
            expenses: 9100,
            revenue: 2200
        },
        minValues: {
            expenses: 3700,
            revenue: 100
        },
        seriesKeys: ["expenses", "revenue"]
    });
    
    DualAxesMissingDataSmallAlwaysShowZeroFalseTest = new Y.AxisDataProviderTemplate({
        axes: {
            leftAxis: {
                keys: ["expenses"],
                type: "numeric",
                position: "left",
                alwaysShowZero: false
            },
            rightAxis: {
                keys: ["revenue"],
                type: "numeric",
                position: "right",
                alwaysShowZero: false
            }
        },
        categoryKey: "date",
        dataProvider: missingDataSmallDataProvider
    },
    {
        name: "Dual Axes Missing Data (small dataProvider) Test with alwaysShowZero=false",
        maxValues: {
            expenses: 9100,
            revenue: 2200
        },
        minValues: {
            expenses: 3700,
            revenue: 100
        },
        seriesKeys: ["expenses", "revenue"]
    });
    
    DualAxesMissingDataLargeAlwaysShowZeroFalseTest = new Y.AxisDataProviderTemplate({
        axes: {
            leftAxis: {
                keys: ["expenses"],
                type: "numeric",
                position: "left",
                alwaysShowZero: false
            },
            rightAxis: {
                keys: ["revenue"],
                type: "numeric",
                position: "right",
                alwaysShowZero: false
            }
        },
        categoryKey: "date",
        dataProvider: missingDataLargeDataProvider
    },
    {
        name: "Dual Axes Missing Data (large dataProvider) Test with alwaysShowZero=false",
        maxValues: {
            expenses: 9100,
            revenue: 2200
        },
        minValues: {
            expenses: 3700,
            revenue: 100
        },
        seriesKeys: ["expenses", "revenue"]
    }),
    
    LeftAndBottomAxisCustomTickAndLinesInsideTicks = new Y.AxisGraphicStylesTemplate({
        axes: {
            category: {
                position: "bottom",
                type: "category",
                keys: ["category"],
                styles: {
                    line: {
                        weight: 2,
                        color: "#ff0000",
                        alpha: 1
                    },
                    majorTicks: {
                        weight: 1,
                        color: "#0000ff",
                        alpha: 0.5,
                        display: "inside"
                    }
                }
            },
            values: {
                position: "left",
                type: "numeric",
                keys: ["expenses", "revenue"],
                styles: {
                    line: {
                        weight: 2,
                        color: "#ff0000",
                        alpha: 1
                    },
                    majorTicks: {
                        weight: 1,
                        color: "#0000ff",
                        alpha: 0.5,
                        display: "inside"
                    }
                }
            }
        },
        dataProvider: allPositiveDataProvider
    },
    {
        name: "Custom Left and Bottom Axes with inside ticks",

        lineStyles: {
            weight: 2,
            color: "#ff0000",
            alpha: 1
        },
        tickStyles: {
            weight: 1,
            color: "#0000ff",
            alpha: 0.5,
            display: "inside"
        }
    }),

    LeftAndBottomAxisCustomTickAndLinesOutsideTicks = new Y.AxisGraphicStylesTemplate({
        axes: {
            category: {
                position: "bottom",
                type: "category",
                keys: ["category"],
                styles: {
                    line: {
                        weight: 2,
                        color: "#ff0000",
                        alpha: 1
                    },
                    majorTicks: {
                        weight: 1,
                        color: "#0000ff",
                        alpha: 0.5,
                        display: "outside"
                    }
                }
            },
            values: {
                position: "left",
                type: "numeric",
                keys: ["expenses", "revenue"],
                styles: {
                    line: {
                        weight: 2,
                        color: "#ff0000",
                        alpha: 1
                    },
                    majorTicks: {
                        weight: 1,
                        color: "#0000ff",
                        alpha: 0.5,
                        display: "outside"
                    }
                }
            }
        },
        dataProvider: allPositiveDataProvider
    },
    {
        name: "Custom Left and Bottom Axes with outside ticks",

        lineStyles: {
            weight: 2,
            color: "#ff0000",
            alpha: 1
        },
        tickStyles: {
            weight: 1,
            color: "#0000ff",
            alpha: 0.5,
            display: "outside"
        }
    }),

    LeftAndBottomAxisCustomTickAndLinesCrossTicks = new Y.AxisGraphicStylesTemplate({
        axes: {
            category: {
                position: "bottom",
                type: "category",
                keys: ["category"],
                styles: {
                    line: {
                        weight: 2,
                        color: "#ff0000",
                        alpha: 1
                    },
                    majorTicks: {
                        weight: 1,
                        color: "#0000ff",
                        alpha: 0.5,
                        display: "cross"
                    }
                }
            },
            values: {
                position: "left",
                type: "numeric",
                keys: ["expenses", "revenue"],
                styles: {
                    line: {
                        weight: 2,
                        color: "#ff0000",
                        alpha: 1
                    },
                    majorTicks: {
                        weight: 1,
                        color: "#0000ff",
                        alpha: 0.5,
                        display: "cross"
                    }
                }
            }
        },
        dataProvider: allPositiveDataProvider
    },
    {
        name: "Custom Left and Bottom Axes with cross ticks",

        lineStyles: {
            weight: 2,
            color: "#ff0000",
            alpha: 1
        },
        tickStyles: {
            weight: 1,
            color: "#0000ff",
            alpha: 0.5,
            display: "cross"
        }
    }),

    RightAndBottomAxisCustomTickAndLinesInsideTicks = new Y.AxisGraphicStylesTemplate({
        axes: {
            category: {
                position: "bottom",
                type: "category",
                keys: ["category"],
                styles: {
                    line: {
                        weight: 2,
                        color: "#ff0000",
                        alpha: 1
                    },
                    majorTicks: {
                        weight: 1,
                        color: "#0000ff",
                        alpha: 0.5,
                        display: "inside"
                    }
                }
            },
            values: {
                position: "right",
                type: "numeric",
                keys: ["expenses", "revenue"],
                styles: {
                    line: {
                        weight: 2,
                        color: "#ff0000",
                        alpha: 1
                    },
                    majorTicks: {
                        weight: 1,
                        color: "#0000ff",
                        alpha: 0.5,
                        display: "inside"
                    }
                }
            }
        },
        dataProvider: allPositiveDataProvider
    },
    {
        name: "Custom Right and Bottom Axes with inside ticks",

        lineStyles: {
            weight: 2,
            color: "#ff0000",
            alpha: 1
        },
        tickStyles: {
            weight: 1,
            color: "#0000ff",
            alpha: 0.5,
            display: "inside"
        }
    }),

    RightAndBottomAxisCustomTickAndLinesOutsideTicks = new Y.AxisGraphicStylesTemplate({
        axes: {
            category: {
                position: "bottom",
                type: "category",
                keys: ["category"],
                styles: {
                    line: {
                        weight: 2,
                        color: "#ff0000",
                        alpha: 1
                    },
                    majorTicks: {
                        weight: 1,
                        color: "#0000ff",
                        alpha: 0.5,
                        display: "outside"
                    }
                }
            },
            values: {
                position: "right",
                type: "numeric",
                keys: ["expenses", "revenue"],
                styles: {
                    line: {
                        weight: 2,
                        color: "#ff0000",
                        alpha: 1
                    },
                    majorTicks: {
                        weight: 1,
                        color: "#0000ff",
                        alpha: 0.5,
                        display: "outside"
                    }
                }
            }
        },
        dataProvider: allPositiveDataProvider
    },
    {
        name: "Custom Right and Bottom Axes with outside ticks",

        lineStyles: {
            weight: 2,
            color: "#ff0000",
            alpha: 1
        },
        tickStyles: {
            weight: 1,
            color: "#0000ff",
            alpha: 0.5,
            display: "outside"
        }
    }),

    RightAndBottomAxisCustomTickAndLinesCrossTicks = new Y.AxisGraphicStylesTemplate({
        axes: {
            category: {
                position: "bottom",
                type: "category",
                keys: ["category"],
                styles: {
                    line: {
                        weight: 2,
                        color: "#ff0000",
                        alpha: 1
                    },
                    majorTicks: {
                        weight: 1,
                        color: "#0000ff",
                        alpha: 0.5,
                        display: "cross"
                    }
                }
            },
            values: {
                position: "left",
                type: "numeric",
                keys: ["expenses", "revenue"],
                styles: {
                    line: {
                        weight: 2,
                        color: "#ff0000",
                        alpha: 1
                    },
                    majorTicks: {
                        weight: 1,
                        color: "#0000ff",
                        alpha: 0.5,
                        display: "cross"
                    }
                }
            }
        },
        dataProvider: allPositiveDataProvider
    },
    {
        name: "Custom Right and Bottom Axes with cross ticks",

        lineStyles: {
            weight: 2,
            color: "#ff0000",
            alpha: 1
        },
        tickStyles: {
            weight: 1,
            color: "#0000ff",
            alpha: 0.5,
            display: "inside"
        }
    }),

    LeftAndTopAxisCustomTickAndLinesInsideTicks = new Y.AxisGraphicStylesTemplate({
        axes: {
            category: {
                position: "top",
                type: "category",
                keys: ["category"],
                styles: {
                    line: {
                        weight: 2,
                        color: "#ff0000",
                        alpha: 1
                    },
                    majorTicks: {
                        weight: 1,
                        color: "#0000ff",
                        alpha: 0.5,
                        display: "inside"
                    }
                }
            },
            values: {
                position: "left",
                type: "numeric",
                keys: ["expenses", "revenue"],
                styles: {
                    line: {
                        weight: 2,
                        color: "#ff0000",
                        alpha: 1
                    },
                    majorTicks: {
                        weight: 1,
                        color: "#0000ff",
                        alpha: 0.5,
                        display: "inside"
                    }
                }
            }
        },
        dataProvider: allPositiveDataProvider
    },
    {
        name: "Custom Left and Top Axes with inside ticks",

        lineStyles: {
            weight: 2,
            color: "#ff0000",
            alpha: 1
        },
        tickStyles: {
            weight: 1,
            color: "#0000ff",
            alpha: 0.5,
            display: "inside"
        }
    }),

    LeftAndTopAxisCustomTickAndLinesOutsideTicks = new Y.AxisGraphicStylesTemplate({
        axes: {
            category: {
                position: "top",
                type: "category",
                keys: ["category"],
                styles: {
                    line: {
                        weight: 2,
                        color: "#ff0000",
                        alpha: 1
                    },
                    majorTicks: {
                        weight: 1,
                        color: "#0000ff",
                        alpha: 0.5,
                        display: "outside"
                    }
                }
            },
            values: {
                position: "left",
                type: "numeric",
                keys: ["expenses", "revenue"],
                styles: {
                    line: {
                        weight: 2,
                        color: "#ff0000",
                        alpha: 1
                    },
                    majorTicks: {
                        weight: 1,
                        color: "#0000ff",
                        alpha: 0.5,
                        display: "outside"
                    }
                }
            }
        },
        dataProvider: allPositiveDataProvider
    },
    {
        name: "Custom Left and Top Axes with outside ticks",

        lineStyles: {
            weight: 2,
            color: "#ff0000",
            alpha: 1
        },
        tickStyles: {
            weight: 1,
            color: "#0000ff",
            alpha: 0.5,
            display: "outside"
        }
    }),

    LeftAndTopAxisCustomTickAndLinesCrossTicks = new Y.AxisGraphicStylesTemplate({
        axes: {
            category: {
                position: "top",
                type: "category",
                keys: ["category"],
                styles: {
                    line: {
                        weight: 2,
                        color: "#ff0000",
                        alpha: 1
                    },
                    majorTicks: {
                        weight: 1,
                        color: "#0000ff",
                        alpha: 0.5,
                        display: "cross"
                    }
                }
            },
            values: {
                position: "left",
                type: "numeric",
                keys: ["expenses", "revenue"],
                styles: {
                    line: {
                        weight: 2,
                        color: "#ff0000",
                        alpha: 1
                    },
                    majorTicks: {
                        weight: 1,
                        color: "#0000ff",
                        alpha: 0.5,
                        display: "cross"
                    }
                }
            }
        },
        dataProvider: allPositiveDataProvider
    },
    {
        name: "Custom Left and Top Axes with cross ticks",

        lineStyles: {
            weight: 2,
            color: "#ff0000",
            alpha: 1
        },
        tickStyles: {
            weight: 1,
            color: "#0000ff",
            alpha: 0.5,
            display: "cross"
        }
    }),

    RightAndTopAxisCustomTickAndLinesInsideTicks = new Y.AxisGraphicStylesTemplate({
        axes: {
            category: {
                position: "top",
                type: "category",
                keys: ["category"],
                styles: {
                    line: {
                        weight: 2,
                        color: "#ff0000",
                        alpha: 1
                    },
                    majorTicks: {
                        weight: 1,
                        color: "#0000ff",
                        alpha: 0.5,
                        display: "inside"
                    }
                }
            },
            values: {
                position: "right",
                type: "numeric",
                keys: ["expenses", "revenue"],
                styles: {
                    line: {
                        weight: 2,
                        color: "#ff0000",
                        alpha: 1
                    },
                    majorTicks: {
                        weight: 1,
                        color: "#0000ff",
                        alpha: 0.5,
                        display: "inside"
                    }
                }
            }
        },
        dataProvider: allPositiveDataProvider
    },
    {
        name: "Custom Right and Top Axes with inside ticks",

        lineStyles: {
            weight: 2,
            color: "#ff0000",
            alpha: 1
        },
        tickStyles: {
            weight: 1,
            color: "#0000ff",
            alpha: 0.5,
            display: "inside"
        }
    }),

    RightAndTopAxisCustomTickAndLinesOutsideTicks = new Y.AxisGraphicStylesTemplate({
        axes: {
            category: {
                position: "top",
                type: "category",
                keys: ["category"],
                styles: {
                    line: {
                        weight: 2,
                        color: "#ff0000",
                        alpha: 1
                    },
                    majorTicks: {
                        weight: 1,
                        color: "#0000ff",
                        alpha: 0.5,
                        display: "outside"
                    }
                }
            },
            values: {
                position: "right",
                type: "numeric",
                keys: ["expenses", "revenue"],
                styles: {
                    line: {
                        weight: 2,
                        color: "#ff0000",
                        alpha: 1
                    },
                    majorTicks: {
                        weight: 1,
                        color: "#0000ff",
                        alpha: 0.5,
                        display: "outside"
                    }
                }
            }
        },
        dataProvider: allPositiveDataProvider
    },
    {
        name: "Custom Right and Top Axes with outside ticks",

        lineStyles: {
            weight: 2,
            color: "#ff0000",
            alpha: 1
        },
        tickStyles: {
            weight: 1,
            color: "#0000ff",
            alpha: 0.5,
            display: "outside"
        }
    }),

    RightAndTopAxisCustomTickAndLinesCrossTicks = new Y.AxisGraphicStylesTemplate({
        axes: {
            category: {
                position: "top",
                type: "category",
                keys: ["category"],
                styles: {
                    line: {
                        weight: 2,
                        color: "#ff0000",
                        alpha: 1
                    },
                    majorTicks: {
                        weight: 1,
                        color: "#0000ff",
                        alpha: 0.5,
                        display: "cross"
                    }
                }
            },
            values: {
                position: "left",
                type: "numeric",
                keys: ["expenses", "revenue"],
                styles: {
                    line: {
                        weight: 2,
                        color: "#ff0000",
                        alpha: 1
                    },
                    majorTicks: {
                        weight: 1,
                        color: "#0000ff",
                        alpha: 0.5,
                        display: "cross"
                    }
                }
            }
        },
        dataProvider: allPositiveDataProvider
    },
    {
        name: "Custom Right and Top Axes with cross ticks",

        lineStyles: {
            weight: 2,
            color: "#ff0000",
            alpha: 1
        },
        tickStyles: {
            weight: 1,
            color: "#0000ff",
            alpha: 0.5,
            display: "inside"
        }
    });
    
    suite.add(ChartTests);
    suite.add(GraphTests);
    suite.add(AxesTests);
    suite.add(AxisMinTest);
    suite.add(AxisMinAlwaysShowZeroFalseTest);
    suite.add(AxisNegativeMinTest);
    suite.add(AxisNegativeMinWithAllNegativeDataTest);
    suite.add(AxisMinWithDecimalsTest);
    suite.add(AxisMinIntegerDecimalDataTest);
    suite.add(AxisNegativeMinPositiveDataTest);
    suite.add(AxisMaxTest);
    suite.add(AxisNegativeMaxTest);
    suite.add(AxisMaxWithDecimalsTest);
    suite.add(AxisMaxIntegerDecimalDataTest);
    suite.add(AxisMaxWithPositiveAndNegativeDataTest);
    suite.add(AxisMinAndMaxTest);
    suite.add(AxisNegativeMinAndPositiveMaxTest);
    suite.add(AxisNegativeMinAndMaxTest);
    suite.add(AxisMinAndMaxWithDecimalsTest);
    suite.add(AxisMinRoundingAutoTest);
    suite.add(AxisMinAlwaysShowZeroFalseRoundingMethodAutoTest);
    suite.add(AxisNegativeMinRoundingMethodAutoTest);
    suite.add(AxisNegativeMinWithAllNegativeDataRoundingMethodAutoTest);
    suite.add(AxisMinWithDecimalsRoundingMethodAutoTest);
    suite.add(AxisMinIntegerDecimalDataRoundingMethodAutoTest);
    suite.add(AxisNegativeMinPositiveDataRoundingMethodAutoTest);
    suite.add(AxisMinRoundingNullTest);
    suite.add(AxisMinAlwaysShowZeroFalseRoundingMethodNullTest);
    suite.add(AxisNegativeMinRoundingMethodNullTest);
    suite.add(AxisNegativeMinWithAllNegativeDataRoundingMethodNullTest);
    suite.add(AxisMinWithDecimalsRoundingMethodNullTest);
    suite.add(AxisMinIntegerDecimalDataRoundingMethodNullTest);
    suite.add(AxisNegativeMinPositiveDataRoundingMethodNullTest);
    suite.add(AxisMinRoundingNumericTest);
    suite.add(AxisMinAlwaysShowZeroFalseRoundingMethodNumericTest);
    suite.add(AxisNegativeMinRoundingMethodNumericTest);
    suite.add(AxisNegativeMinWithAllNegativeDataRoundingMethodNumericTest);
    suite.add(AxisMinWithDecimalsRoundingMethodNumericTest);
    suite.add(AxisMinIntegerDecimalDataRoundingMethodNumericTest);
    suite.add(AxisNegativeMinPositiveDataRoundingMethodNumericTest);
    suite.add(AxisMaxRoundingMethodAutoTest);
    suite.add(AxisNegativeMaxRoundingMethodAutoTest);
    suite.add(AxisMaxWithDecimalsRoundingMethodAutoTest);
    suite.add(AxisMaxIntegerDecimalDataRoundingMethodAutoTest);
    suite.add(AxisMaxWithPositiveAndNegativeDataRoundingMethodAutoTest);
    suite.add(AxisMaxRoundingMethodNullTest);
    suite.add(AxisNegativeMaxRoundingMethodNullTest);
    suite.add(AxisMaxWithDecimalsRoundingMethodNullTest);
    suite.add(AxisMaxIntegerDecimalDataRoundingMethodNullTest);
    suite.add(AxisMaxWithPositiveAndNegativeDataRoundingMethodNullTest);
    suite.add(AxisMaxRoundingMethodNumericTest);
    suite.add(AxisNegativeMaxRoundingMethodNumericTest);
    suite.add(AxisMaxWithDecimalsRoundingMethodNumericTest);
    suite.add(AxisMaxIntegerDecimalDataRoundingMethodNumericTest);
    suite.add(AxisMaxWithPositiveAndNegativeDataRoundingMethodNumericTest);
    suite.add(AxisAlwaysShowZero);
    suite.add(AxisAlwaysShowZeroFalse);
    suite.add(DualAxesMissingDataSmallTest);
    suite.add(DualAxesMissingDataLargeTest);
    suite.add(DualAxesMissingDataSmallAlwaysShowZeroFalseTest);
    suite.add(DualAxesMissingDataLargeAlwaysShowZeroFalseTest);
    suite.add(LeftAndBottomAxisCustomTickAndLinesInsideTicks);
    suite.add(LeftAndBottomAxisCustomTickAndLinesOutsideTicks);
    suite.add(LeftAndBottomAxisCustomTickAndLinesCrossTicks);
    suite.add(RightAndBottomAxisCustomTickAndLinesInsideTicks);
    suite.add(RightAndBottomAxisCustomTickAndLinesOutsideTicks);
    suite.add(RightAndBottomAxisCustomTickAndLinesCrossTicks);
    suite.add(LeftAndTopAxisCustomTickAndLinesInsideTicks);
    suite.add(LeftAndTopAxisCustomTickAndLinesOutsideTicks);
    suite.add(LeftAndTopAxisCustomTickAndLinesCrossTicks);
    suite.add(RightAndTopAxisCustomTickAndLinesInsideTicks);
    suite.add(RightAndTopAxisCustomTickAndLinesOutsideTicks);
    suite.add(RightAndTopAxisCustomTickAndLinesCrossTicks);
    suite.add(PieCenterTest);
    
    //create the console
    var r = new Y.Console({
        newestOnTop : false,
        style: 'block' // to anchor in the example content
    });
    
    r.render('#testLogger');

    //run the tests
    Y.Test.Runner.setName("Y.Charts");
    Y.Test.Runner.add(suite);
    Y.Test.Runner.run();
});
</script>
</body>
</html>
