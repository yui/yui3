<div class="intro">
<p>
Model is a lightweight <a href="../attribute/index.html">Attribute</a>-based data model with methods for getting, setting, validating, and syncing attribute values to a persistence layer or server, as well as events for notifying listeners of model changes.
</p>

<p>
The `Y.Model` class is intended to be extended by a custom class that defines
custom model attributes, validators, and behaviors.
</p>
</div>

{{>getting-started}}

<h2>What is a Model?</h2>

<p>
A model is a class that manages data, state, and behavior associated with an application or a part of an application.
</p>

<p>
For example, in a photo gallery, you might use a model to represent each photo. The model would contain information about the image file, a caption, tags, etc., along with methods for working with this data. The model would also be responsible for validating any new data before accepting it.
</p>

<p>
While Model may be used as a standalone component, it's common to associate a Model instance with a <a href="../view/index.html">View</a> instance, which is responsible for rendering the visual representation of the data contained in the model and updating that representation when the model changes.
</p>

<h2>Using Model</h2>

<h3>Quick Start</h3>

<p>
The quickest way to get up and running with Model is to create a new instance of the `Y.Model` class and pass in an object of key/value pairs representing attributes to set (note: creating ad-hoc attributes like this requires YUI 3.5.0 or higher).
</p>

<p>
Here's how you might create a simple model representing a delicious pie (imagine you're building an online ordering system for a bakery):
</p>

```
var applePie = new Y.Model({
  slices: 6,       // number of slices in this pie
  type  : 'apple'  // what type of pie this is
});
```

<p>
This creates a new `Y.Model` instance named `applePie`, with two attributes: `slices` and `type`, in addition to the [[#built-in attributes]] `id` and `clientId`, which are available on all models.
</p>

<p>
Pass the name of an attribute to the model's `get()` function to get that attribute's value.
</p>

```
applePie.get('slices'); // => 6
applePie.get('type'); // => "apple"
```

<p>
To change the value of an attribute, pass its name and new value to `set()`.
</p>

```
applePie.set('slices', 5); // someone ate a slice!
```

<p>
Read on to learn how to create custom model subclasses for representing more complex data and logic, or skip ahead to [[#Model Events]] or [[#Getting and Setting Attribute Values]] to learn more about how to take advantage of the useful state management functionality Model provides.
</p>

<h3>Extending `Y.Model`</h3>

<p>
The ability to create ad-hoc models by instantiating `Y.Model` is convenient, but sometimes it can be useful to create a custom Model subclass by <em>extending</em> `Y.Model`. This allows you to declare the data attributes your Model class will manage up front, as well as specify default attribute values, helper methods, validators, and (optionally) a sync layer to help your Model class communicate with a storage API or a remote server.
</p>

<p>
In this example, we'll create a `Y.PieModel` class. Each instance of this class will represent a delicious pie, fresh from the oven.
</p>

```
// Create a new Y.PieModel class that extends Y.Model.
Y.PieModel = Y.Base.create('pieModel', Y.Model, [], {
  // Add prototype methods for your Model here if desired. These methods will be
  // available to all instances of your Model.

  // Returns true if all the slices of the pie have been eaten.
  allGone: function () {
    return this.get('slices') === 0;
  },

  // Consumes a slice of pie, or fires an `error` event if there are no slices
  // left.
  eatSlice: function () {
    if (this.allGone()) {
      this.fire('error', {
        type : 'eat',
        error: "Oh snap! There isn't any pie left."
      });
    } else {
      this.set('slices', this.get('slices') - 1);
      Y.log('You just ate a slice of delicious ' + this.get('type') + ' pie!');
    }
  }
}, {
  ATTRS: {
    // Add custom model attributes here. These attributes will contain your
    // model's data. See the docs for Y.Attribute to learn more about defining
    // attributes.

    slices: {
      value: 6 // default value
    },

    type: {
      value: 'apple'
    }
  }
});
```

<p>
Now we can create instances of `Y.PieModel` to represent delicious pies.
</p>

<p>
Each instance will have a `type` attribute containing the type of the pie and a `slices` attribute containing the number of slices remaining. We can call the `allGone()` method to check whether there are any slices left, and the `eatSlice()` method to eat a slice.
</p>

```
// Bake a delicious new pecan pie.
var pecanPie = new Y.PieModel({type: 'pecan'});

pecanPie.on('error', function (e) {
  Y.log(e.error);
});

pecanPie.eatSlice(); // => "You just ate a slice of delicious pecan pie!"
Y.log(pecanPie.get('slices')); // => 5
```

<p>
Five slices later, our pie will be all gone. If we try to eat another slice, we'll get an `error` event.
</p>

```
// 5 slices later...
pecanPie.eatSlice(); // => "Oh snap! There isn't any pie left."
```

<h3>Model Attributes</h3>

<p>
A Model's data is represented by <a href="../attribute/index.html">attributes</a>. The Model class provides two built-in attributes, `clientId` and `id`. The rest are up to you to define when you extend `Y.Model`.
</p>

<h4>Built-in Attributes</h4>

<table>
  <thead>
    <tr>
      <th>Attribute</th>
      <th>Default Value</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>`clientId`</td>
      <td><em>generated id</em></td>
      <td>
        <p>
        An automatically generated client-side only unique ID for identifying model instances that don't yet have an `id`. The client id is guaranteed to be unique among all models on the current page, but is not unique across pageviews. Client ids are never included in `toJSON()` output.
        </p>
      </td>
    </tr>

    <tr>
      <td>`id`</td>
      <td>`null`</td>
      <td>
        <p>
        A globally unique identifier for the model instance. If this is `null`, then the model instance is assumed to be "new" (meaning it hasn't yet been saved to a persistence layer). If the model represents data that's stored in a database of some kind, it usually makes sense to use the database's primary key here.
        </p>

        <p>
        If your persistence layer uses a primary key with a name other than `id`, you can override the `idAttribute` property and set it to the name of your custom id attribute when extending `Y.Model` (be sure to define a corresponding attribute as well). The `id` attribute will then act as an alias for your custom id attribute.
        </p>
      </td>
    </tr>
  </tbody>
</table>

<h4>Custom Attributes</h4>

<p>
Custom attributes are where all your model's data should live. You define these attributes when you first extend `Y.Model`. You can set their values by passing a config object into the model's constructor, or by calling the model's `set()` or `setAttrs()` methods..
</p>

<p>
Attributes can specify default values, getters and setters, validators, and more. For details, see the documentation for the <a href="../attribute/index.html">Attribute</a> component.
</p>

<h3>Model Properties</h3>

<p>
The following properties are available on Model instances. The `idAttribute` property may be overridden when extending `Y.Model`; the others are intended to be read-only.
</p>

<table>
  <thead>
    <tr>
      <th>Property</th>
      <th>Type</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>`changed`</td>
      <td>Object</td>
      <td>
        <p>
        Hash of attributes that have changed since the last time the model was saved.
        </p>
      </td>
    </tr>

    <tr>
      <td>`idAttribute`</td>
      <td>String</td>
      <td>
        <p>
        Name of the attribute to use as the unique id for the model. Defaults to "id", but you may override this property when extending `Y.Model` if you want to specify a custom id attribute.
        </p>
      </td>
    </tr>

    <tr>
      <td>`lastChange`</td>
      <td>Object</td>
      <td>
        <p>
        Hash of attributes that were changed in the most recent `change` event. Each item in this hash is an object with the following properties:
        </p>

        <dl style="margin-top: 1em;">
          <dt><strong>`newVal`</strong></dt>
          <dd>
            <p>
            The new value of the attribute after it changed.
            </p>
          </dd>

          <dt><strong>`prevVal`</strong></dt>
          <dd>
            <p>
            The old value of the attribute before it changed.
            </p>
          </dd>

          <dt><strong>`src`</strong></dt>
          <dd>
            <p>
            The source of the change, or `null` if no source was specified when the change was made.
            </p>

            <p>
            This can be set to any string you want by passing an options object like `{src: 'foo'}` to the `set()` or `setAttrs()` methods when changing attribute values. Its purpose is to allow you to identify the source of the change later by inspecting the `src` property associated with an event, so choose a string that has meaning for your particular use case.
            </p>
          </dd>
        </dl>
      </td>
    </tr>

    <tr>
      <td>`lists`</td>
      <td>Array</td>
      <td>
        <p>
        Array of <a href="../model-list/index.html">ModelList</a> instances that contain this model.
        </p>

        <p>
        This property is updated automatically when the model is added to or removed from a ModelList instance. You shouldn't alter it manually. When working with models in a list, you should always add and remove models using the list's `add()` and `remove()` methods.
        </p>
      </td>
    </tr>
  </tbody>
</table>

<h3>Model Events</h3>

<p>
Model instances provide the following events:
</p>

<table>
  <thead>
    <tr>
      <th>Event</th>
      <th>When</th>
      <th>Payload</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>`change`</td>
      <td>
        <p>
        One or more attributes on the model are changed.
        </p>
      </td>
      <td>
        <dl>
          <dt>`changed` (<em>Object</em>)</dt>
          <dd>
            <p>
            Hash of change information for each attribute that changed. Keys are attribute names, values are objects with the following properties:
            </p>

            <dl style="margin-top: 1em;">
              <dt>`newVal`</dt>
              <dd>
                <p>
                The new value of the attribute after it changed.
                </p>
              </dd>

              <dt>`prevVal`</dt>
              <dd>
                <p>
                The old value of the attribute before it changed.
                </p>
              </dd>

              <dt>`src`</dt>
              <dd>
                <p>
                The source of the change, or `null` if no source was specified when the change was made.
                </p>

                <p>
                This can be set to any string you want by passing an options object like `{src: 'foo'}` to the `set()` or `setAttrs()` methods when changing attribute values. Its purpose is to allow you to identify the source of the change later by inspecting the `src` property associated with an event, so choose a string that has meaning for your particular use case.
                </p>
              </dd>
            </dl>
          </dd>
        </dl>
      </td>
    </tr>

    <tr>
      <td>`error`</td>
      <td>
        <p>
        An error occurs, such as when the model fails validation or a sync layer response can't be parsed.
        </p>
      </td>
      <td>
        <dl>
          <dt>`error`</dt>
          <dd>
            <p>
              Error message, object, or exception generated by the error. Calling `toString()` on this should result in a meaningful error message.
            </p>
          </dd>

          <dt>`src`</dt>
          <dd>
            <p>
            Source of the error. May be one of the following default sources, or any custom error source used by your Model subclass):
            </p>

            <dl style="margin-top: 1em;">
              <dt>`load`</dt>
              <dd>
                <p>
                An error loading the model from a sync layer. The sync layer's response (if any) will be provided as the `response` property on the event facade.
                </p>
              </dd>

              <dt>`parse`</dt>
              <dd>
                <p>
                An error parsing a response from a sync layer.
                </p>
              </dd>

              <dt>`save`</dt>
              <dd>
                <p>
                An error saving the model to a sync layer. The sync layer's response (if any) will be provided as the `response` property on the event facade.
                </p>
              </dd>

              <dt>`validate`</dt>
              <dd>
                <p>
                The model failed to validate.
                </p>
              </dd>
            </dl>
          </dd>
        </dl>
      </td>
    </tr>

    <tr>
      <td>`load`</td>
      <td>
        <p>
        After model attributes are loaded from a sync layer.
        </p>
      </td>
      <td>
        <dl>
          <dt>`parsed`</dt>
          <dd>
            <p>
            The parsed version of the sync layer's response to the load request.
            </p>
          </dd>

          <dt>`response`</dt>
          <dd>
            <p>
            The sync layer's raw, unparsed response to the load request.
            </p>
          </dd>
        </dl>
      </td>
    </tr>

    <tr>
      <td>`save`</td>
      <td>
        <p>
        After model attributes are saved to a sync layer.
        </p>
      </td>
      <td>
        <dl>
          <dt>`parsed`</dt>
          <dd>
            <p>
            The parsed version of the sync layer's response to the save request.
            </p>
          </dd>

          <dt>`response`</dt>
          <dd>
            <p>
            The sync layer's raw, unparsed response to the save request.
            </p>
          </dd>
        </dl>
      </td>
    </tr>
  </tbody>
</table>

<p>
A model's events bubble up to any <a href="../model-list/index.html">model lists</a> that the model belongs to. This enables you to use the model list as a central point for handling model value changes and errors.
</p>

<h4>Change Events</h4>

<p>
In addition to the master `change` event, which is fired whenever one or more attributes are changed, there are also change events for each individual attribute.
</p>

<p>
Attribute-level change events follow the naming scheme <code><em>name</em>Change</code>, where <em>name</em> is the name of an attribute.
</p>

```
// Bake a new pie model.
var pie = new Y.PieModel();

// Listen for all attribute changes.
pie.on('change', function (e) {
  Y.log('change fired: ' + Y.Object.keys(e.changed).join(', '));
});

// Listen for changes to the `slices` attribute.
pie.on('slicesChange', function (e) {
  Y.log('slicesChange fired');
});

// Listen for changes to the `type` attribute.
pie.on('typeChange', function (e) {
  Y.log('typeChange fired');
});

// Change multiple attributes at once.
pie.setAttrs({
  slices: 3,
  type  : 'maple custard'
});

// => "slicesChange fired"
// => "typeChange fired"
// => "change fired: slices, type"
```

<h4>Firing Your Own Error Events</h4>

<p>
In your custom model class, there may be situations beyond just parsing and validating in which an `error` event would be useful. For example, in the `Y.PieModel` class, we fire an error when someone tries to eat a slice of pie and there are no slices left.
</p>

```
// Consumes a slice of pie, or fires an `error` event if there are no slices
// left.
eatSlice: function () {
  if (this.allGone()) {
    this.fire('error', {
      type : 'eat',
      error: "Oh snap! There isn't any pie left."
    });
  } else {
    this.set('slices', this.get('slices') - 1);
    Y.log('You just ate a slice of delicious ' + this.get('type') + ' pie!');
  }
}
```

<p>
When firing an error event, set the `type` property to something that users of your class can use to identify the type of error that has occurred. In the example above, we set it to "eat", because it occurred when the caller tried to eat a slice of pie.
</p>

<p>
The `error` property should be set to an error message, an Error object, or anything else that provides information about the error and has a `toString()` method that returns an error message string.
</p>

<h3>Working with Model Data</h3>

<h4>Getting and Setting Attribute Values</h4>

<p>
Model's `get()` and `set()` methods are the main ways of interacting with model attributes. Unsurprisingly, they allow you to get and set the value of a single attribute.
</p>

```
var pie = new Y.PieModel();

// Set the value of the `type` attribute.
pie.set('type', 'banana cream');

// Get the value of the `type` attribute.
pie.get('type'); // => "banana cream"
```

<p>
Model also provides two convenience methods for getting and escaping an attribute value in a single step. The `getAsHTML()` method returns an HTML-escaped value, and the `getAsURL()` method returns a URL-encoded value.
</p>

```
pie.set('type', 'strawberries & cream');

pie.getAsHTML('type'); // => "strawberries &amp; cream"
pie.getAsURL('type');  // => "strawberries%20%26%20cream"
```

<p>
The `getAttrs()` and `setAttrs()` methods may be used to get and set multiple attributes at once. `getAttrs()` returns a hash of all attribute values, while `setAttrs()` accepts a hash of attribute values. When you set multiple attributes with `setAttrs()`, it fires only a single change event that contains all the affected attributes..
</p>

```
pie.setAttrs({
  slices: 6,
  type  : 'marionberry'
});

pie.getAttrs();
// => {
//   clientId: "pieModel_1",
//   destroyed: false,
//   id: null,
//   initialized: true,
//   slices: 6,
//   type: "marionberry"
// }
```

<p>
The `destroyed` and `initialized` attributes you see in the sample output above are lifecycle attributes provided by `Y.Base`, and aren't actually model data.
</p>

<p>
To get a slightly more useful representation of model data, use the `toJSON()` method. The `toJSON()` method excludes the `clientId`, `destroyed`, and `initialized` attributes, making the resulting object more suitable for serialization and for storing in a persistence layer.
</p>

```
pie.toJSON();
// => {
//   id: null,
//   slices: 6,
//   type: "marionberry"
// }
```

<p>
If a custom `idAttribute` is in use, the `toJSON()` output will include that id attribute instead of `id`.
</p>

```
// toJSON() output with a custom id attribute.
pie.toJSON();
// => {
//   customId: null,
//   slices: 6,
//   type: "marionberry"
// }
```

<p>
If you'd like to customize the serialized representation of your models, you may override the `toJSON()` method.
</p>

<p>
When using the `set()` and `setAttrs()` methods, you may pass an optional `options` argument. If `options.silent` is `true`, no `change` event will be fired.
</p>

```
// Set attributes without firing a `change` event.
pie.set('slices', 0, {silent: true});

pie.setAttrs({
  slices: 0,
  type  : 'chocolate cream'
}, {silent: true});
```

<p>
After making changes to a model's attributes, you may call the `undo()` method to undo the previous change.
</p>

```
var pie = new Y.PieModel({slices: 6});

pie.set('slices', 5);
pie.undo();
pie.get('slices'); // => 6
```

<p>
Note that there's only a single level of undo, so it's not possible to revert past the most recent change.
</p>

<h4>Validating Changes</h4>

<p>
Validating model changes as they occur is a good way to ensure that the data in your models isn't nonsense, especially when dealing with user input.
</p>

<p>
There are two ways to validate model attributes. One way is to define an attribute validator function for an individual attribute when you extend `Y.Model`.
</p>

```
// Defining an individual attribute validator.
Y.PieModel = Y.Base.create('pieModel', Y.Model, [], {
  // ... prototype methods and properties ...
}, {
  ATTRS: {
    slices: {
      value: 6,
      validator: function (value) {
        return typeof value === 'number' && value >= 0 && value <= 10;
      }
    },

    // ...
  }
});
```

<p>
An attribute validator will be called whenever that attribute changes, and can prevent the change from taking effect by returning `false`. Model `error` events are not fired when attribute validators fail. For more details on attribute validators, see the <a href="../attribute/index.html">Attribute User Guide</a>.
</p>

<p>
The second way to validate changes is to provide a custom `validate()` method when extending `Y.Model`. The `validate()` method will be called automatically when `save()` is called, and will receive a hash of all the attributes in the model. Validation can be an asyncronous process, and the `validation()` method takes a `callback()` function. If your `validate()` method calls the `callback()` with an argument other than `null`, or `undefined`, it will be considered a validation failure, an `error` event will be fired with the returned value as the error message, and the `save()` action will be aborted.
</p>

<p>
To indicate success, call the provided `callback()` function with no arguments from your validation method. To indicate failure, call the provided `callback()` function with a single argument, which may contain an error message, an array of error messages, or any other value. On validation failure an `error` event will be fired with the passed argument as the error message.
</p>

```
// Defining a model-wide `validator()` method.
Y.PieModel = Y.Base.create('pieModel', Y.Model, [], {
  // ... prototype methods and properties ...

  validate: function (attributes, callback) {
    var slices;

    switch (attributes.type) {
    case 'rhubarb':
      callback('Eww. No. Not allowed.');
      return;

    case 'maple custard':
      slices = Y.Lang.isValue(attributes.slices) ?
          attributes.slices : this.get('slices');

      if (slices < 10) {
        callback("Making fewer than 10 slices of maple custard pie would be " +
            "silly, because I'm just going to eat 8 of them as soon as it's " +
            "out of the oven.");
        return;
      }
    }

    // Success!
    callback();
  }
}, {
  // ... attributes ...
});
```

<h4>Loading and Saving Model Data</h4>

<p>
Calling a model's `load()` and `save()` methods will result in a behind-the-scenes call to the model's `sync()` method specifying the appropriate action.
</p>

<p>
The default `sync()` method does nothing, but by overriding it and providing your own sync layer, you can make it possible to create, read, update, and delete models from a persistence layer or a server. See [[#Implementing a Model Sync Layer]] for more details.
</p>

<p>
The `load()` and `save()` methods each accept two optional parameters: an options object and a callback function. If provided, the options object will be passed to the sync layer, and the callback will be called after the load or save operation is finished. You may provide neither parameter, or just an options object, or just a callback, although if you provide both an options object and a callback, they need to be in that order.
</p>

<p>
The callback function will receive two parameters: an error (this parameter will be `null` or `undefined` if the operation was successful) and a response (which is the result of calling the model's `parse()` method with whatever response the sync layer returned).
</p>

<p>
The `load()` method calls `sync()` with the `read` action, and automatically updates the model with the response data (by passing it to `parse()` and then updating attributes based on the hash that `parse()` returns) before calling the callback.
</p>

```
var pie = new Y.PieModel({id: 'pie123'});

// Load a pie model, passing a callback that will run when the model has
// been loaded.
pie.load(function (err, response) {
  if (!err) {
    // Success! The model now contains the loaded data.
  }
});
```

<p>
The `save()` method will do one of two things: if the model is new (meaning it doesn't yet have an `id` value), it will call `sync()` with the "create" action. If the model is not new, then it will call `sync()` with the "update" action.
</p>

<p>
If the sync layer returns a response, then `save()` will update the model's attributes with the response data before calling the callback function.
</p>

```
// Save a pie model, passing a callback that will run when the model has
// been saved.
pie.save(function (err, response) {
  if (!err) {
    // Success! The model has been saved. If the sync layer returned a response,
    // then the model has also been updated with any new data in the response.
  }
});
```

<p>
In addition to calling the specified callback (if any), the `load()` and `save()` methods will fire a `load` event and a `save` event respectively on success, or an `error` event on failure. See [[#Model Events]] for more details on these events.
</p>

<p>
Always use the `load()` or `save()` methods rather than calling `sync()` directly, since this ensures that the sync layer's response is passed through the `parse()` method and that the model's data is updated if necessary.
</p>

<h2>The Model Lifecycle</h2>

<p>
When a model is first created and doesn't yet have an `id` value, it's considered "new". The `isNew()` method will tell you whether or not a model is new.
</p>

<p>
Once a model has an `id` value, either because one was manually set or because the model received one when it was loaded or saved, the model is no longer considered new, since it is assumed to exist in a persistence layer or on a server somewhere.
</p>

<p>
If a model is new or if any of its attributes have changed since the model was last loaded or saved, the model is considered "modified". The `isModified()` method will tell you whether or not a model is modified. A successful call to `load()` or `save()` will reset a model's "modified" flag.
</p>

<p>
Finally, a model's `destroy()` method can be used to destroy the model instance. Calling `destroy()` with no arguments will destroy only the local model instance, while calling `destroy({remove: true})` will both destroy the local model instance and call the sync layer with the "delete" action to delete the model from a persistence layer or server.
</p>

<p>
It's not necessary for a model to support all possible sync actions. A model that's used to represent read-only data might use a sync layer that only implements the `read` action, for instance. In this case, the other actions should simply be no-ops that either call the sync callback immediately, or pass an error to the sync callback indicating that the action isn't supported (depending on your personal preference).
</p>

<h2>Model Sync Layers</h2>

<p>
A model's `save()`, `load()`, and `destroy()` methods all internally call the model's `sync()` method to carry out an action. The default `sync()` method doesn't actually do anything, but you can mix one of the following sync layers into your `Y.Model`/`Y.ModelList` subclass or implement a custom sync layer.
</p>

<h3>RESTful XHR</h3>

<p>
`Y.ModelSync.REST` is an extension which provides a RESTful XHR `sync()` implementation that can be mixed into a Model or ModelList subclass.
</p>

<p>
This makes it trivial for your Model or ModelList subclasses communicate and transmit their data via RESTful XHR. In most cases you'll only need to provide a value for `root` when sub-classing `Y.Model`.
</p>

```javascript
// Create `Y.User`, a `Y.Model` subclass and mix-in the RESTful XHR sync layer.
Y.User = Y.Base.create('user', Y.Model, [Y.ModelSync.REST], {
    // The root or collection path segment for the server's Users resource.
    root: '/users'
});

var existingUser = new Y.User({id: '1'}),
    oldUser      = new Y.User({id: '2'}),
    newUser      = new Y.User({name: 'Eric Ferraiuolo'});

// GET the existing user data from: "/users/1"
existingUser.load(function () {
    Y.log(existingUser.get('name')); // => "Ron Swannson"

    // Correct the user's `name` and PUT the updated user at: "/users/1"
    existingUser.set('name', 'Ron Swanson').save();
});

// DELETE the old user data at: "/users/2"
oldUser.destroy({remove: true});

// POST the new user data to: "/users"
newUser.save(function () {
    // The server can return the user data with an `id` assigned.
    Y.log(newUser.get('id')); // => "3"
});
```

<p>
The following sections provide details on how to use and configure the `Y.ModelSync.REST` extension. You can also refer to the <a href="{{apiDocs}}/classes/ModelSync.REST.html">API docs</a> for more information.
</p>

<h4 class="no-toc">Configuring URLs</h4>

<p>
In order for this sync layer to make requests to a server it needs a URL. Some useful conventions have been put in place to generate these URLs, thus reducing the amount of configuration required to use this sync layer.
</p>

<p>
The `url` property works in conjunction with the `root` property to generate the URLs needed to make the XHRs. By simply configuring a `root` on the prototype of your Model subclass to the URL of collection resource on the server, your model's and model lists' URLs can be automatically generated. The following example sets up a Model and ModelList subclass and configures them to work with this sync layer:
</p>

```
Y.User = Y.Base.create('user', Y.Model, [Y.ModelSync.REST], {
    root: '/users'
});

Y.Users = Y.Base.create('users', Y.ModelList, [Y.ModelSync.REST], {
    // By convention `Y.User`'s `root` will be used for the lists' URL.
    model: Y.User
});

var users = new Y.Users();

// GET users list from: "/users"
users.load(function () {
    var firstUser = users.item(0);

    Y.log(firstUser.get('id')); // => "1"

    // PUT updated user data at: "/users/1"
    firstUser.set('name', 'Eric').save();
});
```

<p>
By convention, the URL generated for a model when preforming a read, update, or delete action will combine with the configured `root` with the model's `id`. When creating the model resource on the server, just the `root` will be used as the URL.
</p>

<p>
<strong>Note:</strong> If the `root` string ends in trailing-slash, the generated URLs will also end with a "/", and if the `root` does not end with a slash, neither will the generated URLs.
</p>

<p>
If a `url` is specified, it will be processed by `Y.Lang.sub()`, which is useful when the URLs for a Model/ModelList subclass match a specific pattern and can use simple replacement tokens; e.g.:
</p>

```
Y.User = Y.Base.create('user', Y.Model, [Y.ModelSync.REST], {
    root: '/users',
    url : '/users/{username}'
});
```

<p>
<strong>Note:</strong> String subsitituion of the `url` only use string an number values provided by this object's attribute and/or the `options` passed to the `getURL()` method. Do not expect something fancy to happen with Object, Array, or Boolean values, they will simply be ignored.
</p>

<p>
For more details, refer to the API docs for the <a href="{{apiDocs}}/classes/ModelSync.REST.html#property_root">`root`</a> and <a href="{{apiDocs}}/classes/ModelSync.REST.html#property_url">`url`</a> properties, and the <a href="{{apiDocs}}/classes/ModelSync.REST.html#method_getURL">`getURL()`</a> method.
</p>

<h4 class="no-toc">Authentic Requests</h4>

<p>
Anytime a server accepts requests from clients which result in state being changed, the server is susceptible to <a href="https://en.wikipedia.org/wiki/Cross-site_request_forgery">Cross-Site Request Forgery (CSRF)</a> attacks. This extension has build in support for authenticity tokens to help prevent these CSRF attacks.
</p>

<p>
A CSRF token provided by the server can be embedded in the HTML document and assigned to `YUI.Env.CSRF_TOKEN` like this:
</p>

```html
<script>
    YUI.Env.CSRF_TOKEN = \{{session.authenticityToken}};
</script>
```

<p>
The above should come after YUI seed file so that `YUI.Env` will be defined.
</p>

<p>
<strong>Note:</strong> This can be overridden on a per-request basis. See `sync()` method.
</p>

<p>
When a value for the CSRF token is provided, either statically or via `options` passed to the `save()` and `destroy()` methods, the applicable HTTP requests will have a `X-CSRF-Token` header added with the token value.
</p>

<h4 class="no-toc">Overriding HTTP Defaults</h4>

<p>
If the server-side HTTP framework isn't RESTful, setting the static `Y.ModelSync.REST.EMULATE_HTTP` flag to `true`
will cause all PUT and DELETE requests to instead use the POST HTTP method, and add a `X-HTTP-Method-Override` HTTP header with the value of the method type which was overridden.
</p>

<p>
Additionally, the mapping of CRUD actions to HTTP methods can be changed. By default, the static mapping provided by `Y.ModelSync.REST.HTTP_METHODS` is:
</p>

<table>
  <thead>
    <tr>
      <th>CRUD Action</th>
      <th>HTTP Method</th>
      <th>Description</th>
    </tr>
  </thead>

  <tbody>
    <tr>
      <td>`create`</td>
      <td>POST</td>
      <td>
        <p>
        Creates a new resource on the server for the model.
        </p>
      </td>
    </tr>

    <tr>
      <td>`read`</td>
      <td>GET</td>
      <td>
        <p>
        Loads the data for a model from its resource on the server.
        </p>
      </td>
    </tr>

    <tr>
      <td>`update`</td>
      <td>PUT</td>
      <td>
        <p>
        Updates the resource on the server with the new model data.
        </p>
      </td>
    </tr>

    <tr>
      <td>`delete`</td>
      <td>DELETE</td>
      <td>
        <p>
        Removes the resource for the model from the server.
        </p>
      </td>
    </tr>
  </tbody>
</table>

<h4 class="no-toc">Content-Types Other Than JSON</h4>

<p>
By default, this extension will communicate with the server using JSON, by setting the `Accept` and `Content-Type` HTTP headers for all XHRs to "application/json", it signals the server to process the request bodies as JSON and send JSON responses.
</p>

<p>
If you're sending and receiving content other than JSON, you can override these default headers on the static `Y.ModelSync.REST.HTTP_HEADERS` object. Additionally, you'll want to provide custom implementations of your Model subclass' `parse()` and `serialize()` methods. The <a href="{{apiDocs}}/classes/ModelSync.REST.html#method_serialize">`serialize()`</a> method is added by this extension, by default it JSON-stringifies to result of calling the model's `toJSON()` method.
</p>

<p>
For more information on the `Y.ModelSync.REST` extension, refer to its <a href="{{apiDocs}}/classes/ModelSync.REST.html">API docs</a>.
</p>

<h3>Local Storage Synchronization</h3>

<p>
`Y.ModelSync.Local` is an extension which provides a sync implementation through locally stored key value pairs, either through the HTML localStorage API or falling back onto an in-memory cache, that can be mixed into a Model or ModelList subclass.
</p>

<p>
This follows a similar API as `Y.ModelSync.REST`, so in most cases, you'll again only need to provide a value for `root` when sub-classing `Y.Model`.
</p>

```javascript
// Create `Y.User`, a `Y.Model` subclass and mix-in the Local Storage sync layer
Y.User = Y.Base.create('user', Y.Model, [Y.ModelSync.Local], {
    // The root key for local storage or the in-memory cache
    root: 'users'
});

var existingUser = new Y.User({id: 'users-1'}),
    oldUser      = new Y.User({id: 'users-2'}),
    newUser      = new Y.User({name: 'Eric Ferraiuolo'});

// Get the existing user data from: "{'users': 'users-1': { /* data */ }}"
existingUser.load(function () {
    Y.log(existingUser.get('name')); // => "Ron Swannson"

    // Correct the user's `name` and update the set of key-value pairs
    existingUser.set('name', 'Ron Swanson').save();
});

// Destroy the old user data at: "{'users': 'users-2': { /* data */ }}"
oldUser.destroy({remove: true});

// Set the new user data to "{'users'}"
newUser.save(function () {
    // The sync layer can return the user data with an `id` assigned.
    // By default, this uses the root and Y.guid() internally
    Y.log(newUser.get('id')); 
    // => "users_yui_3_8_0_1_1357185522298_106"
});
```

<p>
As mentioned in the example, the IDs that are automatically generated and used inside of either Local Storage or the in-memory cache are provided by Y.guid() internally.  If you would like to use your own method of generating unique IDs with this sync layer, you can override the `generateID` method to do so.
</p>

<p>
For Model Lists, the `root` property is by convention inherited from the `root` property found in the default Model class that can be provided as a configuration parameter.  Otherwise, it defaults to an empty string.
</p>

```
Y.User = Y.Base.create('user', Y.Model, [Y.ModelSync.Local], {
    root: 'users'
});

Y.Users = Y.Base.create('users', Y.ModelList, [Y.ModelSync.Local], {
    // By convention `Y.User`'s `root` will be used for `Y.Users` as well.
    model: Y.User
});

var users = new Y.Users();

// Get users list from: {"users": /* data */ }
users.load(function () {
    var firstUser = users.item(0);

    Y.log(firstUser.get('id')); 
    // => "users-1"

    // Update user data at "users-1"
    firstUser.set('name', 'Eric').save();
});
```

<h3>Implementing a Model Sync Layer</h3>

<p>
A sync layer might make Ajax requests to a remote server, or it might act as a wrapper around local storage, or any number of other things. By overriding the `sync()` method, you can provide a custom sync layer.
</p>

<h4>The `sync()` Method</h4>

<p>
When the `sync()` method is called, it receives three arguments:
</p>

<dl>
  <dt><strong>`action` (<em>String</em>)</strong></dt>
  <dd>
    <p>
    A string that indicates the intended sync action. May be one of the following values:
    </p>

    <dl>
      <dt><strong>`create`</strong></dt>
      <dd>
        <p>
        Create a new model record. The "create" action occurs when a model is saved and doesn't yet have an `id` value.
        </p>
      </dd>

      <dt><strong>`read`</strong></dt>
      <dd>
        <p>
        Read an existing model record. The record should be identified based on the `id` attribute of the model.
        </p>
      </dd>

      <dt><strong>`update`</strong></dt>
      <dd>
        <p>
        Update an existing model record. The "update" action occurs when a model is saved and already has an `id` value. The record to be updated should be identified based on the `id` attribute of the model.
        </p>
      </dd>

      <dt><strong>`delete`</strong></dt>
      <dd>
        <p>
        Delete an existing model record. The record to be deleted should be identified based on the `id` attribute of the model.
        </p>
      </dd>
    </dl>
  </dd>

  <dt><strong>`options` (<em>Object</em>)</strong></dt>
  <dd>
    <p>
    A hash containing any options that were passed to the `save()`, `load()` or `destroy()` method. This may be used to pass custom options to a sync layer.
    </p>
  </dd>

  <dt><strong>`callback` (<em>Function</em>)</strong></dt>
  <dd>
    <p>
    A callback function that should be called when the sync operation is complete. The callback expects to receive the following arguments:
    </p>

    <dl>
      <dt><strong>`err`</strong></dt>
      <dd>
        <p>
        Error message or object if an error occured, `null` or `undefined` if the operation was successful.
        </p>
      </dd>

      <dt><strong>`response`</strong></dt>
      <dd>
        <p>
        Response from the persistence layer, if any. This will be passed to the `parse()` method to be parsed.
        </p>
      </dd>
    </dl>
  </dd>
</dl>

<p>
Implementing a sync layer is as simple as handling the requested sync action and then calling the callback function. Here's a sample sync layer that stores records in local storage (note: this example requires the `json-stringify` module):
</p>

```
Y.PieModel = Y.Base.create('pieModel', Y.Model, [], {
  // ... prototype methods and properties ...

  // Custom sync layer.
  sync: function (action, options, callback) {
    var data;

    switch (action) {
      case 'create':
        data = this.toJSON();

        // Use the current timestamp as an id just to simplify the example. In a
        // real sync layer, you'd want to generate an id that's more likely to
        // be globally unique.
        data.id = Y.Lang.now();

        // Store the new record in localStorage, then call the callback.
        localStorage.setItem(data.id, Y.JSON.stringify(data));
        callback(null, data);
        return;

      case 'read':
        // Look for an item in localStorage with this model's id.
        data = localStorage.getItem(this.get('id'));

        if (data) {
          callback(null, data);
        } else {
          callback('Model not found.');
        }

        return;

      case 'update':
        data = this.toJSON();

        // Update the record in localStorage, then call the callback.
        localStorage.setItem(this.get('id'), Y.JSON.stringify(data));
        callback(null, data);
        return;

      case 'delete':
        localStorage.removeItem(this.get('id'));
        callback();
        return;

      default:
        callback('Invalid action');
    }
  }
}, {
  // ... attributes ...
});
```

<h4>The `parse()` Method</h4>

<p>
Depending on the kind of response your sync layer returns, you may need to override the `parse()` method as well. The default `parse()` implementation knows how to parse JavaScript objects and JSON strings that can be parsed into JavaScript objects representing a hash of attributes. If your response data is in another format, such as a nested JSON response or XML, override the `parse()` method to provide a custom parser implementation.
</p>

<p>
If an error occurs while parsing a response, fire an `error` event with `type` "parse".
</p>

<p>
This sample demonstrates a custom parser for responses in which the model data is contained in a `data` property of the response object.
</p>

```
// Custom response parser.
parse: function (response) {
  if (response.data) {
    return response.data;
  }

  this.fire('error', {
    type : 'parse',
    error: 'No data in the response.'
  });
}
```
