
var BaseObservable = Y.BaseObservable,
    Lang           = Y.Lang,
    ModelBase      = Y.Model.Base,
    ModelBaseProto = ModelBase.prototype,
    YObject        = Y.Object,

    /**
    Fired when one or more attributes on this model are changed.

    @event change
    @param {Object} changed Hash of change information for each attribute that
        changed. Each item in the hash has the following properties:
      @param {Any} changed.newVal New value of the attribute.
      @param {Any} changed.prevVal Previous value of the attribute.
      @param {String|null} changed.src Source of the change event, if any.
    **/
    EVT_CHANGE = 'change',

    /**
    Fired when an error occurs, such as when the model doesn't validate or when
    a sync layer response can't be parsed.

    @event error
    @param {Any} error Error message, object, or exception generated by the
      error. Calling `toString()` on this should result in a meaningful error
      message.
    @param {String} src Source of the error. May be one of the following (or any
      custom error source defined by a Model subclass):

      * `load`: An error loading the model from a sync layer. The sync layer's
        response (if any) will be provided as the `response` property on the
        event facade.

      * `parse`: An error parsing a JSON response. The response in question will
        be provided as the `response` property on the event facade.

      * `save`: An error saving the model to a sync layer. The sync layer's
        response (if any) will be provided as the `response` property on the
        event facade.

      * `validate`: The model failed to validate. The attributes being validated
        will be provided as the `attributes` property on the event facade.
    **/
    EVT_ERROR = 'error',

    /**
    Fired after model attributes are loaded from a sync layer.

    @event load
    @param {Object} parsed The parsed version of the sync layer's response to
        the load request.
    @param {any} response The sync layer's raw, unparsed response to the load
        request.
    @since 3.5.0
    **/
    EVT_LOAD = 'load',

    /**
    Fired after model attributes are saved to a sync layer.

    @event save
    @param {Object} [parsed] The parsed version of the sync layer's response to
        the save request, if there was a response.
    @param {any} [response] The sync layer's raw, unparsed response to the save
        request, if there was one.
    @since 3.5.0
    **/
    EVT_SAVE = 'save';

function ModelObservable() {
    BaseObservable.apply(this, arguments);
}

ModelObservable.prototype = {
    // -- HACKS!!! -------------------------------------------------------------

    // These references to `Y.Model.Base.prototype` are to preserve these
    // Attribute method overrides. Model.Observable uses AttributeObservable,
    // so when used as a class extension, AttributeObservable's implementations
    // of these methods will overwrite Model.Base's explicit overrides.
    //
    // The plain is to remove the need for Model.Base to have these overrides of
    // Attribute methods, and instead move features down into Attribute and/or
    // use difference implementations of these features such that they do not
    // require overriding these three methods.
    addAttr : ModelBaseProto.addAttr,
    set     : ModelBaseProto.set,
    setAttrs: ModelBaseProto.setAttrs,

    // -- Public Methods -------------------------------------------------------

    /**
    Destroys this model instance and removes it from its containing lists, if
    any.

    The _callback_, if one is provided, will be called after the model is
    destroyed.

    If `options.remove` is `true`, then this method delegates to the `sync()`
    method to delete the model from the persistence layer, which is an
    asynchronous action. In this case, the _callback_ (if provided) will be
    called after the sync layer indicates success or failure of the delete
    operation.

    @method destroy
    @param {Object} [options] Sync options. It's up to the custom sync
        implementation to determine what options it supports or requires, if
        any.
      @param {Boolean} [options.remove=false] If `true`, the model will be
        deleted via the sync layer in addition to the instance being destroyed.
    @param {callback} [callback] Called after the model has been destroyed (and
        deleted via the sync layer if `options.remove` is `true`).
      @param {Error|null} callback.err If an error occurred, this parameter will
        contain the error. Otherwise _err_ will be `null`.
    @chainable
    **/
    destroy: function (options, callback) {
        this.onceAfter('destroy', function () {
            this._destroy(options, callback);
        });

        return BaseObservable.prototype.destroy.apply(this, arguments);
    },

    /**
    Called to parse the _response_ when the model is loaded from the server.
    This method receives a server _response_ and is expected to return an
    attribute hash.

    The default implementation assumes that _response_ is either an attribute
    hash or a JSON string that can be parsed into an attribute hash. If
    _response_ is a JSON string and either `Y.JSON` or the native `JSON` object
    are available, it will be parsed automatically. If a parse error occurs, an
    `error` event will be fired and the model will not be updated.

    You may override this method to implement custom parsing logic if necessary.

    @method parse
    @param {Any} response Server response.
    @return {Object} Attribute hash.
    **/
    parse: function (response) {
        if (typeof response === 'string') {
            try {
                return Y.JSON.parse(response);
            } catch (ex) {
                this.fire(EVT_ERROR, {
                    error   : ex,
                    response: response,
                    src     : 'parse'
                });

                return null;
            }
        }

        return response;
    },

    // -- Protected Event Handlers ---------------------------------------------

    /**
    Duckpunches the `_defAttrChangeFn()` provided by `Y.Attribute` so we can
    have a single global notification when a change event occurs.

    @method _defAttrChangeFn
    @param {EventFacade} e
    @protected
    **/
    _defAttrChangeFn: function (e) {
        var attrName = e.attrName;

        if (!this._setAttrVal(attrName, e.subAttrName, e.prevVal, e.newVal)) {
            Y.log('State not updated and stopImmediatePropagation called for attribute: ' + attrName + ' , value:' + e.newVal, 'warn', 'attribute');
            // Prevent "after" listeners from being invoked since nothing changed.
            e.stopImmediatePropagation();
        } else {
            e.newVal = this.get(attrName);

            if (e._transaction) {
                e._transaction[attrName] = e;
            }
        }
    },

    // TODO: Document method.
    _handleRead: function (err, response, options, callback) {
        var facade, parsed;

        facade = {
            options : options,
            response: response
        };

        if (err) {
            facade.error = err;
            facade.src   = 'load';

            this.fire(EVT_ERROR, facade);
        } else {
            // Lazy publish.
            if (!this._loadEvent) {
                this._loadEvent = this.publish(EVT_LOAD, {
                    preventable: false
                });
            }

            parsed = facade.parsed = this._parse(response);

            this.setAttrs(parsed, options);
            this.changed = {};

            this.fire(EVT_LOAD, facade);
        }

        if (callback) {
            callback(err, response);
        }
    },

    // TODO: Document method.
    _handleSave: function (err, response, options, callback) {
        var facade, parsed;

        facade = {
            options : options,
            response: response
        };

        if (err) {
            facade.error = err;
            facade.src   = 'save';

            this.fire(EVT_ERROR, facade);
        } else {
            // Lazy publish.
            if (!this._saveEvent) {
                this._saveEvent = this.publish(EVT_SAVE, {
                    preventable: false
                });
            }

            if (response) {
                parsed = facade.parsed = this._parse(response);
                this.setAttrs(parsed, options);
            }

            this.changed = {};
            this.fire(EVT_SAVE, facade);
        }

        if (callback) {
            callback(err, response);
        }
    },

    // TODO: Document method.
    _processAttrsTransaction: function (transaction, options) {
        if (YObject.isEmpty(transaction)) {
            return;
        }

        ModelBase.prototype._processAttrsTransaction.apply(this, arguments);

        if (!options.silent) {
            // Lazy publish for the change event.
            if (!this._changeEvent) {
                this._changeEvent = this.publish(EVT_CHANGE, {
                    preventable: false
                });
            }

            this.fire(EVT_CHANGE, Y.merge(options, {
                changed: this.lastChange
            }));
        }
    },

    /**
    Calls the public, overridable `validate()` method and fires an `error` event
    if validation fails.

    @method _validate
    @param {Object} attributes Attribute hash.
    @param {Function} callback Validation callback.
        @param {Any} [callback.err] Value on failure, non-value on success.
    @protected
    **/
    _validate: function (attributes, callback) {
        var self = this;

        this.validate(attributes, function (err) {
            if (Lang.isValue(err)) {
                // Validation failed. Fire an error.
                self.fire(EVT_ERROR, {
                    attributes: attributes,
                    error     : err,
                    src       : 'validate'
                });

                callback(err);
                return;
            }

            callback();
        });
    }
};

// Mix statics.
ModelObservable._ATTR_CFG = BaseObservable._ATTR_CFG.concat();

// Mix prototype.
Y.mix(ModelObservable, BaseObservable, false, null, 1);

// -- Namespace ----------------------------------------------------------------
Y.Model.Observable = ModelObservable;
