/**
DataBind provides the `Y.DataBind` class to bind attributes to form elements.

The class may be used standalone, or as a class extension.

The three required configurations of DataBind are:

1. `container` - The DOM element that contains the bound inputs. Defaulted from
    Widget's boundingBox if used as an extension for a Widget.
1. `model` - The Attribute source. Defaulted from `this.get('model') || this`
    when used as an extension for a class with Attribute.
1. `fields` - An object map of HTML form field names (the value of the `name`
    attribute) to the attribute. Defaults to a map generated by querying the
    containers subtree for elements with a "data-bind-attr" attribute.

Additional configurations are supported in the `fields` map values when an
object is used as the value, including:
```
fields: {
    fieldNameA: 'attributeNameA',
    fieldNameB: {
        attr: 'attributeNameB',
        getter: function (node) { <code to get a value from node> },
        setter: function (node, value) { <... to set a value in node> },
        formatter: function (value) { <massage value for display in DOM> },
        parser: function (value) { <extract raw value from DOM value> }
    }
}
```

`getter` and `setter` are not commonly needed, as DataBind can get and set
values to common form elements already. `formatter` and `parser` are useful
to translate things like raw floats to formatted currency strings for the UI,
and likewise to extract raw data from formatted strings. They should be used as
a pair.

@module data-bind
@class DataBind
@param {Object} config Configuration object for this instance
    @param {String|Node} [config.container] Node or selector for node that
                        contains the bound elements.
    @param {Base} [config.model] Attribute host for the data.
    @param {Object} [config.fields] Map of element `name`s to attributes or
                        bind configurations (see above).
@since 3.9.0
**/
Y.DataBind = function (config) {
    if (!Y.Base || !(this instanceof Y.Base)) {
        // Being used as a standalone class
        this.initializer(config);
        // alias instance.destroy() to destructor for convenience
        this.destroy = this.destructor;
    }
};

/**
Map of user events to subscribe to for specific types of inputs. If not in this
map, the 'change' event will be used.

@property FIELD_EVENTS
@type {Object}
@static
**/
Y.DataBind.FIELD_EVENTS = {
    radio: 'click',
    checkbox: 'click'
};

/**
Build configuration to migrate the FIELD_EVENTS static property to the host
class when used as a class extension.

@property _buildCfg
@type {Object}
@protected
@static
**/
Y.DataBind._buildCfg = { statics: ['FIELD_EVENTS'] };

Y.mix(Y.DataBind.prototype, {
    /**
    Gets the value from the DOM element representing the provided attribute. If
    the binding is configured with a `parser`, the value returned will be the
    parsed value.

    @method getUIValue
    @param {String} attrName Attribute name corresponding to the DOM element
    @return {Any} Usually a string, but parsers can return anything
    **/
    getUIValue: function (attrName) {
        var fieldConfig = this._attrMap[attrName],
            type, field, method, value;

        if (fieldConfig) {
            type   = fieldConfig.type,
            field  = fieldConfig.field;
            method = fieldConfig.getter ||
                        this['_get' + type.charAt(0).toUpperCase() +
                                      type.slice(1) +
                                      'Value'] ||
                        this._getSimpleValue;

            // e.g. this._getRadioValue(field)
            value = method.call(this, field);

            return (fieldConfig.parser) ?
                fieldConfig.parser.call(this, value) :
                value;
        }

        // TODO: Better default return value?
        return null;
    },

    /**
    Sets the value in the DOM element for the provided attribute. *This does
    not update the attribute value*. If the binding is configured with a
    formatter, the value assigned to the DOM element will be the formatted
    value.

    @method setUIValue
    @param {String} attrName Attribute name corresponding to the DOM element
    @param {Any} value The value to assign to the DOM element
    @return {DataBind} this instance
    @chainable
    **/
    setUIValue: function (attrName, value) {
        var fieldConfig = this._attrMap[attrName],
            type, field, method;

        if (fieldConfig) {
            type   = fieldConfig.type,
            field  = fieldConfig.field;
            method = fieldConfig.setter ||
                        this['_set' + type.charAt(0).toUpperCase() +
                                      type.slice(1) +
                                      'Value'] ||
                        this._setSimpleValue;

            if (fieldConfig.formatter) {
                value = fieldConfig.formatter.call(this, value);
            }

            // e.g. this._setRadioValue(field, value)
            method.call(this, field, value);
        }

        return this;
    },

    /**
    Pushes current Attribute values to the UI.

    @method syncToUI
    @return {DataBind} this instance
    @chainable
    **/
    syncToUI: function () {
        var model  = this._dataModel,
            values, attr;

        if (model) {
            values = model.getAttrs();

            for (attr in this._attrMap) {
                this.setUIValue(attr, values[attr]);
            }
        }

        return this;
    },

    /**
    Pushes current DOM element values to the bound attributes.

    @method syncToModel
    @return {DataBind} this instance
    @chainable
    **/
    syncToModel: function () {
        var values = {},
            model  = this._dataModel,
            attr;

        if (model) {
            for (attr in this._attrMap) {
                values[attr] = this.getUIValue(attr);
            }

            model.setAttrs(values, { src: 'UI' });
        }

        return this;
    },

    /**
    Stores the instances data model (attribute host), and initializes the data
    bindings if possible. Note: Widgets, or other classes that don't render on
    instantiation must call (at least) `this._initDataBinding(config)` once the
    bindable DOM is in place.

    @method initializer
    @param {Object} [config] Configuration object passed to the constructor
    @protected
    **/
    initializer: function (config) {
        this._initDataModel(config);
        this._initDataBinding(config);
    },

    /**
    Stores the attribute host object. When used as a class extension, it looks
    for a 'model' attribute, then falls back to assuming the instance itself
    (`this`) is the model. Otherwise, it uses the object stored in the
    `config.model` property.

    @method _initDataModel
    @param {Object} [config] Configuration object with 'model' property if
        needed.
    **/
    _initDataModel: function (config) {
        /**
        A reference to the attribute host object.

        @property _dataModel
        @type {Base}
        @protected
        **/
        this._dataModel = this.get ?
            (this.get('model') || this) :
            config.model;
    },

    /**
    Stores the DOM element containing the bound elements, then calls
    `_initBindMaps` and `_bindEvents`.

    When used as a class extension, it looks for the existence of a
    'contentBox' attribute (not necessarily the assignment of it), then falls
    back to a 'container' attribute. Otherwise, it uses the Node or selector
    stored in the `config.container` property.

    @method _iniDataBinding
    @param {Object} [config] Configuration object with 'container'
    @protected
    **/
    _initDataBinding: function (config) {
        /**
        A reference to the DOM element that contains the bound elements.

        @property _bindContainer
        @type {Node}
        @protected
        **/
        if (this.get) {
            this._bindContainer = this.attrAdded('contentBox') ?
                this.get('contentBox') :
                this.get('container');

        } else {
            this._bindContainer = Y.one(config.container);
        }

        if (this._bindContainer) {
            this._initBindMaps(config);
            this._bindEvents(config);
        }
    },

    /**
    Builds the `_fieldMap` and `_attrMap` properties from the config's 'fields'
    property, or by inspecting the DOM subtree of the configured 'container'
    for elements with the 'data-bind-attr' attribute.

    @method _initBindMaps
    @param {Object} [config] Configuration object with a `fields` property
    @protected
    **/
    _initBindMaps: function (config) {
        var fields    = config && Y.merge(config.fields),
            container = this._bindContainer,
            name, allFields, field, nodes, type, i, len, fieldConfig;

        /**
        A map of DOM field names to bind configurations. A bind configuration
        is an object in the following form:

        ```
        {
            attr: (string),
            field: (Node or NodeList),
            type: (string),
            getter: (function) - optional,
            setter: (function) - optional,
            parser: (function) - optional,
            formatter: (function) - optional
        }
        ```

        @property _fieldMap
        @type {Object}
        @protected
        **/
        this._fieldMap = {};

        /**
        A map of attribute names to bind configurations. A bind configuration
        is an object in the following form:

        ```
        {
            attr: (string),
            field: (Node or NodeList),
            type: (string),
            getter: (function) - optional,
            setter: (function) - optional,
            parser: (function) - optional,
            formatter: (function) - optional
        }
        ```

        @property _fieldMap
        @type {Object}
        @protected
        **/
        this._attrMap  = {};

        if (container) {
            if (!fields) {
                fields = {};

                allFields = container.all('[data-bind-attr]');
                if (!allFields.size()) {
                    allFields = container.all('input,select,textarea');
                }

                allFields = allFields.getDOMNodes();
                for (i = 0, len = allFields.length; i < len; ++i) {
                    field = allFields[i];
                    fields[field.name] = {
                        attr: field.getAttribute('data-bind-attr') ||
                              field.name
                    };
                }
            }

            for (name in fields) {
                fieldConfig = typeof fields[name] === 'string' ?
                                { attr: fields[name] } :
                                Y.merge(fields[name]);

                nodes = container.all('[name=' + name + ']');
                field = nodes.item(0);
                type  = field.get('nodeName').toLowerCase();

                if (type === 'input') {
                    type = field.get('type').toLowerCase();
                }

                fieldConfig.type = type;
                fieldConfig.field = (type === 'radio') ? nodes : nodes.item(0);

                this._fieldMap[name] = // chained assignment
                this._attrMap[fieldConfig.attr] = fieldConfig;
            }
        }
    },

    /**
    Binds the DOM events for the elements and the change events for the
    attributes to keep everything sync'd up.

    @method _bindEvents
    @protected
    **/
    _bindEvents: function () {
        var eventMap   = this.constructor.FIELD_EVENTS ||
                         Y.DataBind.FIELD_EVENTS,
            model      = this._dataModel,
            eventNames = [],
            name, fieldConfig, field, event;

        this._dataBindEvents = [];

        for (name in this._fieldMap) {
            if (this._fieldMap.hasOwnProperty(name)) {
                fieldConfig = this._fieldMap[name];
                field = fieldConfig.field;
                event = eventMap[fieldConfig.type] || 'change';

                eventNames.push(fieldConfig.attr + 'Change');

                // Subscribing to the individual nodes rather than delegating
                // on purpose to avoid cross browser issues with events. This
                // might be a mistake.
                this._dataBindEvents.push(
                    field.on(event, this._onUIChange, this, fieldConfig.attr));
            }
        }

        if (model) {
            // Not binding to 'change' to support Widget extension case where
            // there's no rollup change event (yet?)
            this._dataBindEvents.push(
                model.after(eventNames, this._afterAttrChange, this));
        }
    },

    /**
    Detaches the events binding the attributes and DOM elements.

    @method destructor
    @protected
    **/
    destructor: function () {
        if (this._dataBindEvents.length && Y.EventHandle) {
            new Y.EventHandle(this._dataBindEvents).detach();
        }
    },

    /**
    Relays new attribute values to the appropriate DOM element setter.

    @method _afterAttrChange
    @param {EventFacade} e Attribute change event
    @protected
    **/
    _afterAttrChange: function (e) {
        if (!e.src) {
            this.setUIValue(e.attrName, e.newVal);
        }
    },

    /**
    Relays field changes from user input to the bound attribute.

    @method _onUIChange
    @param {DOMEventFacade} e DOM event originating the change
    @param {String} the name of the bound attribute for this field
    @protected
    **/
    _onUIChange: function (e, attr) {
        if (this._dataModel) {
            this._dataModel.set(attr, this.getUIValue(attr), { src: 'UI' });
        }
    },

    /**
    Setter for radio input values. Assigns the 'checked' property of the radio
    in the radio group with the corresponding value. If the provided value
    doesn't match any of the DOM values, the current DOM value is not changed.

    @method _setRadioValue
    @param {NodeList} radioGroup The radio input nodes in the radio group
    @param {Any} value The value to set in the UI
    @protected
    **/
    _setRadioValue: function (radioGroup, value) {
        var radios = radioGroup.getDOMNodes(),
            i, len;

        for (i = 0, len = radios.length; i < len; ++i) {
            // allowing for type coercion on purpose
            if (radios[i].value == value) {
                break;
            }
        }

        if (i < len) {
            radios[i].checked = true;
        }
    },

    /**
    Setter for checkbox input values. Assigns the 'checked' property of the
    input if the provided value is `true` or is equal to the 'value' property
    of the checkbox element. Otherwise, it unchecks it.

    @method _setCheckboxValue
    @param {Node} checkbox The checkbox input Node
    @param {Any} value The value to trigger checking or unchecking the box
    @protected
    **/
    _setCheckboxValue: function (checkbox, value) {
        checkbox.set('checked',
            (value === true || value === checkbox.get('value')));
    },

    /**
    Setter for select fields. Assigns the 'selected' property of the option
    in the select with the corresponding value. If the provided value
    doesn't match any of the DOM values, the current DOM value is not changed.

    @method _setSelectValue
    @param {Node} select The select Node
    @param {Any} value The value to set in the UI
    @protected
    **/
    _setSelectValue: function (select, value) {
        var options = select.getDOMNode().options,
            i, len;

        for (i = 0, len = options.length; i < len; ++i) {
            // allowing for type coercion on purpose
            if (options[i].value == value) {
                break;
            }
        }

        if (i < len) {
            options[i].selected = true;
        }
    },

    /**
    The default value setter for elements. Assigns the 'value' property of the
    provided Node.

    @method _setSimpleValue
    @param {Node} field The bound Node
    @param {Any} value The value to set in the UI
    @protected
    **/
    _setSimpleValue: function (field, value) {
        field.set('value', value);
    },

    /**
    Gets the value of the currently checked radio button in the group.

    @method _getRadioValue
    @param {NodeList} radioGroup The input Nodes in the radio group
    @return {String|null} The value of the checked radio or null if none
    @protected
    **/
    _getRadioValue: function (radioGroup) {
        var radios = radioGroup.getDOMNodes(),
            i, len, radio;

        for (i = 0, len = radios.length; i < len; ++i) {
            radio = radios[i];
            if (radio.checked) {
                return radio.value;
            }
        }

        // TODO: better default return value?
        return null;
    },

    /**
    Returns the value of the checkbox if its checked, or `null` otherwise.

    @method _getCheckboxValue
    @param {Node} checkbox The checkbox input Node
    @return {String|null} The value of the checkbox or null if unchecked
    @protected
    **/
    _getCheckboxValue: function (checkbox) {
        // TODO: better default value for unchecked box?
        return checkbox.get('checked') ? checkbox.get('value') : null;
    },

    /**
    Gets the value of the currently selected option in the select.

    @method _getSelectValue
    @param {Node} select The select Node
    @return {String|null} The value of the selected option or null if none
    @protected
    **/
    _getSelectValue: function (select) {
        select = select.getDOMNode();
        return (select.selectedIndex >= 0) ?
            select.options[select.selectedIndex].value :
            null;
    },

    /**
    Default value getter. Returns the value of the Node's 'value' property.

    @method _getSimpleValue
    @param {Node} field The bound Node
    @return {String} The value of the field's 'value' property
    @protected
    **/
    _getSimpleValue: function (field) {
        return field.get('value');
    }
}, true);
