<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
<title>DataSource Tests</title>
</head>

<body class="yui-skin-sam">
<h1>DataSource Tests</h1>
<p><input type="button" value="Run Tests" id="btnRun" disabled="true" /></p>

<script type="text/javascript" src="../../../build/yui/yui.js"></script>
<script type="text/javascript" src="../../../build/cache/cache.js"></script>
<script type="text/javascript" src="../../../build/dataparser/dataparser.js"></script>
<script type="text/javascript" src="../../../build/datasource/datasource.js" id="src_ds"></script>
<script type="text/javascript">

(function() {
    YUI({
        base: "../../../build/",
        filter: "debug",
        useConsole: true,
        insertBefore: "src_ds"
    }).use("dump", "test", "console", "io-base", "cache", "base", "plugin", "json", "dataparser", "datasource", function(Y) {

        var ASSERT = Y.Assert,
            ARRAYASSERT = Y.ArrayAssert,
            OBJECTASSERT = Y.ObjectAssert,
            BTNRUN = Y.get("#btnRun"),
            WAITTIMEOUT = 1000; // On a slow connection set to 5000

        // Set up the page
        
        BTNRUN.set("disabled", false);
        Y.on("click", function() {
            Y.Test.Runner.run();
        }, BTNRUN);
        var myConsole = new Y.Console().render();
 
        var testClass = new Y.Test.Case({
            name: "Class Tests",
        
            testConstructor: function() {
                var ds = new Y.DataSource.Local();
                ASSERT.areSame((ds instanceof Y.Base), true, "Expected Base instance.");
                ASSERT.areSame((ds instanceof Y.DataSource.Local), true, "Expected Local instance.");
            },

            testConstructorXHR: function() {
                var ds = new Y.DataSource.XHR();
                ASSERT.areSame((ds instanceof Y.Base), true, "Expected Base instance.");
                ASSERT.areSame((ds instanceof Y.DataSource.Local), true, "Expected Local instance.");
                ASSERT.areSame((ds instanceof Y.DataSource.XHR), true, "Expected XHR instance.");
            }
        });
        
        var testLocal = new Y.Test.Case({
            name: "DataSource.Local Tests",

            testLocalDefaults: function() {
                var ds = new Y.DataSource.Local({
                    source: ["a","b","c","d"]
                });

                var handler = Y.Mock();
                Y.Mock.expect(handler,{
                    method: "handleSuccess",
                    args: [Y.Mock.Value(function(e){
                        ARRAYASSERT.itemsAreSame(["a","b","c","d"], e.response.results, "Expected live array.");
                    })]
                });

                ds.sendRequest(null, {
                    success: handler.handleSuccess,
                    failure: function(e) {
                        ASSERT.fail("XHR failure case.");
                    }
                });
                
                Y.Mock.verify(handler);
            },

            testLocalEvents: function() {
                var ds = new Y.DataSource.Local({
                    source: ["a","b","c","d"]
                });
                
                var handler = Y.Mock();
                Y.Mock.expect(handler,{
                    method: "handleRequest",
                    args: [Y.Mock.Value(function(e){
                        ASSERT.isNumber(e.tId, "request: Expected transaction ID.");
                        ASSERT.areSame("a", e.request, "request: Expected request.");
                        ASSERT.areSame("callback", e.callback, "request: Expected callback.");
                    })]
                });
                ds.subscribe("request", handler.handleRequest);

                Y.Mock.expect(handler,{
                    method: "handleData",
                    args: [Y.Mock.Value(function(e){
                        ASSERT.isNumber(e.tId, "data: Expected transaction ID.");
                        ASSERT.areSame("a", e.request, "data: Expected request.");
                        ASSERT.areSame("callback", e.callback, "data: Expected callback.");
                        ASSERT.isArray(e.data, "data: Expected raw data.");
                    })]
                });
                ds.subscribe("data", handler.handleData);
                
                Y.Mock.expect(handler,{
                    method: "handleResponse",
                    args: [Y.Mock.Value(function(e){
                        ASSERT.isNumber(e.tId, "response: Expected transaction ID.");
                        ASSERT.areSame("a", e.request, "response: Expected request.");
                        ASSERT.areSame("callback", e.callback, "response: Expected callback.");
                        ASSERT.isArray(e.data, "response: Expected raw data.");
                        ASSERT.isObject(e.response, "response: Expected normalized response object.");
                        ASSERT.isArray(e.response.results, "response: Expected parsed results.");
                        ASSERT.isObject(e.response.meta, "response: Expected parsed meta data.");
                    })]
                });
                ds.subscribe("response", handler.handleResponse);

                ds.sendRequest("a", "callback");
                Y.Mock.verify(handler);
            },

            testLocalError: function() {
                var ds = new Y.DataSource.Local({
                    source: ["a","b","c","d"]
                });

                var handler = Y.Mock();
                Y.Mock.expect(handler,{
                    method: "handleError",
                    args: [Y.Mock.Value(function(e){
                        ASSERT.isNumber(e.tId, "error: Expected transaction ID.");
                        ASSERT.areSame("a", e.request, "error: Expected request.");
                        ASSERT.areSame("callback", e.callback, "error: Expected callback.");
                        ASSERT.isUndefined(e.response, "error: Expected undefined response.");
                        ASSERT.isObject(e.error, "error: Expected error.");
                    })]
                });
                ds.subscribe("error", handler.handleError);

                ds.set("source", undefined);
                ds.sendRequest("a", "callback");
                this.wait(function(){Y.Mock.verify(handler);}, WAITTIMEOUT);
            }
        });

        var testXHR = new Y.Test.Case({
            name: "DataSource.XHR Tests",

            testXHRDefaults: function() {
                var ds = new Y.DataSource.XHR({
                    source: "./php/ysearch_json_madonna.php"
                });
                
                var handler = Y.Mock();
                Y.Mock.expect(handler,{
                    method: "handleSuccess",
                    args: [Y.Mock.Value(function(e){
                        ASSERT.isNull(e.request, "Expected null request.");
                        ASSERT.isObject(e.response, "Expected response object.");
                        OBJECTASSERT.ownsAll({tId:null,request:null,data:null,response:null,callback:null}, e, "Expected all properties.");
                    })]
                });

                ds.sendRequest(null, {
                    success: handler.handleSuccess,
                    failure: function(e) {
                        ASSERT.fail("XHR failure case.");
                    }
                });                

                this.wait(function(){Y.Mock.verify(handler);}, WAITTIMEOUT);
            },

            testXHREvents: function() {
                var ds = new Y.DataSource.XHR({
                    source: "./php/ysearch_json_madonna.php"
                });
                ds.plug({fn: Y.plugin.DataSourceJSONParser, cfg: {
                    schema: {
                        resultsLocator: "ResultSet.Result",
                        resultsFields: ["Title"]
                    }
                }});

                var handler = Y.Mock();
                Y.Mock.expect(handler,{
                    method: "handleRequest",
                    args: [Y.Mock.Value(function(e){
                        ASSERT.isNumber(e.tId, "request: Expected transaction ID.");
                        ASSERT.areSame(null, e.request, "request: Expected request.");
                        ASSERT.areSame("callback", e.callback, "request: Expected callback.");
                    })]
                });
                ds.subscribe("request", handler.handleRequest);

                Y.Mock.expect(handler,{
                    method: "handleData",
                    args: [Y.Mock.Value(function(e){
                        ASSERT.isNumber(e.tId, "data: Expected transaction ID.");
                        ASSERT.areSame(null, e.request, "data: Expected request.");
                        ASSERT.areSame("callback", e.callback, "data: Expected callback.");
                        ASSERT.isObject(e.data, "data: Expected raw data.");
                    })]
                });
                ds.subscribe("data", handler.handleData);

                Y.Mock.expect(handler,{
                    method: "handleResponse",
                    args: [Y.Mock.Value(function(e){
                        ASSERT.isNumber(e.tId, "response: Expected transaction ID.");
                        ASSERT.areSame("a", e.request, "response: Expected request.");
                        ASSERT.areSame("callback", e.callback, "response: Expected callback.");
                        ASSERT.isObject(e.data, "response: Expected raw data.");
                        ASSERT.isObject(e.response, "response: Expected normalized response object.");
                        ASSERT.isArray(e.response.results, "response: Expected parsed results.");
                        ASSERT.isObject(e.response.meta, "response: Expected parsed meta data.");
                    })]
                });
                ds.subscribe("response", handler.handleResponse);

                ds.sendRequest(null, "callback");
                this.wait(function(){Y.Mock.verify(handler);}, WAITTIMEOUT);
            },

            testXHRError: function() {
                var ds = new Y.DataSource.XHR({
                    source: "./php/ysearch_json_madonna.php",
                });
                ds.plug({fn: Y.plugin.DataSourceJSONParser, cfg: {
                    schema: {
                        resultsLocator: "ResultSet.Result",
                        resultsFields: ["Title"]
                    }
                }});

                var handler = Y.Mock();
                Y.Mock.expect(handler,{
                    method: "handleError",
                    args: [Y.Mock.Value(function(e){
                        ASSERT.isNumber(e.tId, "error: Expected transaction ID.");
                        ASSERT.areSame("a", e.request, "error: Expected request.");
                        ASSERT.areSame("callback", e.callback, "error: Expected callback.");
                        ASSERT.isObject(e.data, "error: Expected raw data.");
                        ASSERT.isObject(e.error, "error: Expected error.");
                    })]
                });
                ds.subscribe("error", handler.handleError);

                ds.set("source", "foo");
                ds.sendRequest("a", "callback");
                this.wait(function(){Y.Mock.verify(handler);}, WAITTIMEOUT);
            }
        });

        var testJSONParser = new Y.Test.Case({
            name: "DataSource.XHR JSONParser Tests",

            testXHRPlug: function() {
                var ds = new Y.DataSource.XHR({
                    source: "./php/ysearch_json_madonna.php"
                });
                ds.plug({fn: Y.plugin.DataSourceJSONParser, cfg: {
                    schema: {
                        resultsLocator: "ResultSet.Result",
                        resultsFields: ["Title"]
                    }
                }});

                var handler = Y.Mock();
                Y.Mock.expect(handler,{
                    method: "handleSuccess",
                    args: [Y.Mock.Value(function(e){
                        ASSERT.isNull(e.request, "Expected null request.");
                        ASSERT.isObject(e.response, "Expected normalized response object.");
                        ASSERT.isArray(e.response.results, "Expected results array.");
                        ASSERT.areSame(10, e.response.results.length, "Expected 10 results.")
                        ASSERT.isNotUndefined(e.response.results[0].Title, "Expected Title property")
                    })]
                });

                ds.sendRequest(null, {
                    success: handler.handleSuccess,
                    failure: function(e) {
                        ASSERT.fail("XHR failure case.");
                    },
                    scope: this
                });

                this.wait(function(){Y.Mock.verify(handler);}, WAITTIMEOUT);
            }
        });

        var testCaching = new Y.Test.Case({
            name: "DataSource Caching Tests",

            testCacheDefaultMax: function() {
                var ds = new Y.DataSource.Local();
                ds.plug(Y.plugin.DataSourceCache);
                ASSERT.areSame((ds.cache instanceof Y.Cache), true, "Expected Cache instance.");
                ASSERT.areSame(ds.cache.get("max"), 0, "Expected 0 max in Cache.");
            },

            testCacheInitMax: function() {
                var ds = new Y.DataSource.Local();
                ds.plug({fn:Y.plugin.DataSourceCache, cfg:{max:3}});
                ASSERT.areSame((ds.cache instanceof Y.Cache), true, "Expected Cache instance.");
                ASSERT.areSame(ds.cache.get("max"), 3, "Expected 3 max in Cache.");
            },

            testCacheSetMax: function() {
                var ds = new Y.DataSource.Local();
                ds.plug({fn:Y.plugin.DataSourceCache});
                ds.cache.set("max", 5);
                ASSERT.areSame((ds.cache instanceof Y.Cache), true, "Expected Cache instance.");
                ASSERT.areSame(ds.cache.get("max"), 5, "Expected 5 max in Cache.");
            },
            
            testLocalCache: function() {
                var ds = new Y.DataSource.Local({
                        source: ["a","b","c","d"]
                    });
                ds.plug({fn:Y.plugin.DataSourceCache, cfg:{max:3}});

                ds.sendRequest("a");

                ds.subscribe("data", function(e) {
                    ASSERT.fail("Entry should be cached -- 'data' event is unexpected");
                });

                ds.sendRequest("a");
            },

            testLocalCacheUnplug: function() {
                var ds = new Y.DataSource.Local({
                        source: ["a","b","c","d"]
                    });
                ds.plug({fn:Y.plugin.DataSourceCache, cfg:{max:3}});

                ds.sendRequest("a");

                ds.cache.subscribe("retrieve", function(e) {
                    ASSERT.fail("Cache is unset -- 'retrieve' event is unexpected");
                });

                ds.unplug("cache");
                ds.sendRequest("a");
            }
        });

        var testPolling = new Y.Test.Case({
            name: "DataSource Polling Tests",

            testClass: function() {
                var ds = new Y.DataSource.Local();
                ASSERT.isNotUndefined((ds.setInterval), "Expected setInterval() method on Local.");
                ASSERT.isNotUndefined((ds.clearInterval), "Expected clearInterval() method on Local.");

                ds = new Y.DataSource.XHR();
                ASSERT.isNotUndefined((ds.setInterval), "Expected setInterval() method on XHR.");
                ASSERT.isNotUndefined((ds.clearInterval), "Expected clearInterval() method on XHR.");
            },

            testSetAndClear: function() {
                var ds = new Y.DataSource.Local();
                
                var handler = Y.Mock();
                Y.Mock.expect(handler,{
                    method: "handleSuccess",
                    args: [Y.Mock.Value.Any],
                    callCount: 3
                });

                var id = ds.setInterval(500, null, {
                    success: handler.handleSuccess,
                    failure: function(e) {
                        ASSERT.fail("XHR failure case.");
                    }
                });
                
                ASSERT.isNumber(id, "Expected interval id.");

                this.wait(function(){
                    ds.clearInterval(id);
                    this.wait(function(){
                        Y.Mock.verify(handler);
                    }, 1000);
                }, 2000);
            },

            testClearAll: function() {
                var ds = new Y.DataSource.Local();

                var handler = Y.Mock();
                Y.Mock.expect(handler,{
                    method: "handleSuccess",
                    args: [Y.Mock.Value.Any],
                    callCount: 3
                });

                ds.setInterval(500, null, {
                    success: handler.handleSuccess,
                    failure: function(e) {
                        ASSERT.fail("XHR failure case.");
                    }
                });
                ds.setInterval(500, null, {
                    success: handler.handleSuccess,
                    failure: function(e) {
                        ASSERT.fail("XHR failure case.");
                    }
                });
                ds.setInterval(500, null, {
                    success: handler.handleSuccess,
                    failure: function(e) {
                        ASSERT.fail("XHR failure case.");
                    }
                });

                this.wait(function(){
                    ds.clearAllIntervals();
                    this.wait(function(){
                        Y.Mock.verify(handler);
                    }, 500);
                }, 1000);
            },
        });

        Y.Test.Runner.add(testClass);
        Y.Test.Runner.add(testLocal);
        Y.Test.Runner.add(testXHR);
        Y.Test.Runner.add(testJSONParser);
        Y.Test.Runner.add(testCaching);
        Y.Test.Runner.add(testPolling);
        Y.Test.Runner.run();
    });
})();
</script>
</body>
</html>
